/*
  Human
  homepage: <https://github.com/vladmandic/human>
  author: <https://github.com/vladmandic>'
*/

var Human=(()=>{var nle=Object.create;var N1=Object.defineProperty;var rle=Object.getOwnPropertyDescriptor;var sle=Object.getOwnPropertyNames;var ole=Object.getPrototypeOf,ale=Object.prototype.hasOwnProperty;var ile=(e,t,n)=>t in e?N1(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var aP=e=>N1(e,"__esModule",{value:!0});var _c=(e=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(e,{get:(t,n)=>(typeof require!="undefined"?require:t)[n]}):e)(function(e){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var Gr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),dn=(e,t)=>{aP(e);for(var n in t)N1(e,n,{get:t[n],enumerable:!0})},lle=(e,t,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of sle(t))!ale.call(e,r)&&r!=="default"&&N1(e,r,{get:()=>t[r],enumerable:!(n=rle(t,r))||n.enumerable});return e},T1=e=>lle(aP(N1(e!=null?nle(ole(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var nt=(e,t,n)=>(ile(e,typeof t!="symbol"?t+"":t,n),n),iP=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)};var _1=(e,t,n)=>(iP(e,t,"read from private field"),n?n.call(e):t.get(e)),E1=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n)},R1=(e,t,n,r)=>(iP(e,t,"write to private field"),r?r.call(e,n):t.set(e,n),n);var jj=Gr((ltt,Uj)=>{Uj.exports=jn;var Ga=null;try{Ga=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function jn(e,t,n){this.low=e|0,this.high=t|0,this.unsigned=!!n}jn.prototype.__isLong__;Object.defineProperty(jn.prototype,"__isLong__",{value:!0});function Qo(e){return(e&&e.__isLong__)===!0}jn.isLong=Qo;var Oj={},Pj={};function Ph(e,t){var n,r,s;return t?(e>>>=0,(s=0<=e&&e<256)&&(r=Pj[e],r)?r:(n=Hn(e,(e|0)<0?-1:0,!0),s&&(Pj[e]=n),n)):(e|=0,(s=-128<=e&&e<128)&&(r=Oj[e],r)?r:(n=Hn(e,e<0?-1:0,!1),s&&(Oj[e]=n),n))}jn.fromInt=Ph;function Ua(e,t){if(isNaN(e))return t?Mh:ja;if(t){if(e<0)return Mh;if(e>=zj)return Gj}else{if(e<=-Lj)return ea;if(e+1>=Lj)return Wj}return e<0?Ua(-e,t).neg():Hn(e%fy|0,e/fy|0,t)}jn.fromNumber=Ua;function Hn(e,t,n){return new jn(e,t,n)}jn.fromBits=Hn;var x3=Math.pow;function z7(e,t,n){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return ja;if(typeof t=="number"?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return z7(e.substring(1),t,n).neg();for(var s=Ua(x3(n,8)),o=ja,a=0;a<e.length;a+=8){var i=Math.min(8,e.length-a),l=parseInt(e.substring(a,a+i),n);if(i<8){var u=Ua(x3(n,i));o=o.mul(u).add(Ua(l))}else o=o.mul(s),o=o.add(Ua(l))}return o.unsigned=t,o}jn.fromString=z7;function Di(e,t){return typeof e=="number"?Ua(e,t):typeof e=="string"?z7(e,t):Hn(e.low,e.high,typeof t=="boolean"?t:e.unsigned)}jn.fromValue=Di;var Mj=1<<16,tMe=1<<24,fy=Mj*Mj,zj=fy*fy,Lj=zj/2,Bj=Ph(tMe),ja=Ph(0);jn.ZERO=ja;var Mh=Ph(0,!0);jn.UZERO=Mh;var hy=Ph(1);jn.ONE=hy;var Vj=Ph(1,!0);jn.UONE=Vj;var L7=Ph(-1);jn.NEG_ONE=L7;var Wj=Hn(4294967295|0,2147483647|0,!1);jn.MAX_VALUE=Wj;var Gj=Hn(4294967295|0,4294967295|0,!0);jn.MAX_UNSIGNED_VALUE=Gj;var ea=Hn(0,2147483648|0,!1);jn.MIN_VALUE=ea;var Ue=jn.prototype;Ue.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ue.toNumber=function(){return this.unsigned?(this.high>>>0)*fy+(this.low>>>0):this.high*fy+(this.low>>>0)};Ue.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ea)){var n=Ua(t),r=this.div(n),s=r.mul(n).sub(this);return r.toString(t)+s.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var o=Ua(x3(t,6),this.unsigned),a=this,i="";;){var l=a.div(o),u=a.sub(l.mul(o)).toInt()>>>0,c=u.toString(t);if(a=l,a.isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}};Ue.getHighBits=function(){return this.high};Ue.getHighBitsUnsigned=function(){return this.high>>>0};Ue.getLowBits=function(){return this.low};Ue.getLowBitsUnsigned=function(){return this.low>>>0};Ue.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ea)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,n=31;n>0&&(t&1<<n)==0;n--);return this.high!=0?n+33:n+1};Ue.isZero=function(){return this.high===0&&this.low===0};Ue.eqz=Ue.isZero;Ue.isNegative=function(){return!this.unsigned&&this.high<0};Ue.isPositive=function(){return this.unsigned||this.high>=0};Ue.isOdd=function(){return(this.low&1)==1};Ue.isEven=function(){return(this.low&1)==0};Ue.equals=function(t){return Qo(t)||(t=Di(t)),this.unsigned!==t.unsigned&&this.high>>>31==1&&t.high>>>31==1?!1:this.high===t.high&&this.low===t.low};Ue.eq=Ue.equals;Ue.notEquals=function(t){return!this.eq(t)};Ue.neq=Ue.notEquals;Ue.ne=Ue.notEquals;Ue.lessThan=function(t){return this.comp(t)<0};Ue.lt=Ue.lessThan;Ue.lessThanOrEqual=function(t){return this.comp(t)<=0};Ue.lte=Ue.lessThanOrEqual;Ue.le=Ue.lessThanOrEqual;Ue.greaterThan=function(t){return this.comp(t)>0};Ue.gt=Ue.greaterThan;Ue.greaterThanOrEqual=function(t){return this.comp(t)>=0};Ue.gte=Ue.greaterThanOrEqual;Ue.ge=Ue.greaterThanOrEqual;Ue.compare=function(t){if(Qo(t)||(t=Di(t)),this.eq(t))return 0;var n=this.isNegative(),r=t.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};Ue.comp=Ue.compare;Ue.negate=function(){return!this.unsigned&&this.eq(ea)?ea:this.not().add(hy)};Ue.neg=Ue.negate;Ue.add=function(t){Qo(t)||(t=Di(t));var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,o=this.low&65535,a=t.high>>>16,i=t.high&65535,l=t.low>>>16,u=t.low&65535,c=0,p=0,d=0,f=0;return f+=o+u,d+=f>>>16,f&=65535,d+=s+l,p+=d>>>16,d&=65535,p+=r+i,c+=p>>>16,p&=65535,c+=n+a,c&=65535,Hn(d<<16|f,c<<16|p,this.unsigned)};Ue.subtract=function(t){return Qo(t)||(t=Di(t)),this.add(t.neg())};Ue.sub=Ue.subtract;Ue.multiply=function(t){if(this.isZero())return ja;if(Qo(t)||(t=Di(t)),Ga){var n=Ga.mul(this.low,this.high,t.low,t.high);return Hn(n,Ga.get_high(),this.unsigned)}if(t.isZero())return ja;if(this.eq(ea))return t.isOdd()?ea:ja;if(t.eq(ea))return this.isOdd()?ea:ja;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(Bj)&&t.lt(Bj))return Ua(this.toNumber()*t.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,o=this.low>>>16,a=this.low&65535,i=t.high>>>16,l=t.high&65535,u=t.low>>>16,c=t.low&65535,p=0,d=0,f=0,h=0;return h+=a*c,f+=h>>>16,h&=65535,f+=o*c,d+=f>>>16,f&=65535,f+=a*u,d+=f>>>16,f&=65535,d+=s*c,p+=d>>>16,d&=65535,d+=o*u,p+=d>>>16,d&=65535,d+=a*l,p+=d>>>16,d&=65535,p+=r*c+s*u+o*l+a*i,p&=65535,Hn(f<<16|h,p<<16|d,this.unsigned)};Ue.mul=Ue.multiply;Ue.divide=function(t){if(Qo(t)||(t=Di(t)),t.isZero())throw Error("division by zero");if(Ga){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var n=(this.unsigned?Ga.div_u:Ga.div_s)(this.low,this.high,t.low,t.high);return Hn(n,Ga.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Mh:ja;var r,s,o;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return Mh;if(t.gt(this.shru(1)))return Vj;o=Mh}else{if(this.eq(ea)){if(t.eq(hy)||t.eq(L7))return ea;if(t.eq(ea))return hy;var a=this.shr(1);return r=a.div(t).shl(1),r.eq(ja)?t.isNegative()?hy:L7:(s=this.sub(t.mul(r)),o=r.add(s.div(t)),o)}else if(t.eq(ea))return this.unsigned?Mh:ja;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();o=ja}for(s=this;s.gte(t);){r=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var i=Math.ceil(Math.log(r)/Math.LN2),l=i<=48?1:x3(2,i-48),u=Ua(r),c=u.mul(t);c.isNegative()||c.gt(s);)r-=l,u=Ua(r,this.unsigned),c=u.mul(t);u.isZero()&&(u=hy),o=o.add(u),s=s.sub(c)}return o};Ue.div=Ue.divide;Ue.modulo=function(t){if(Qo(t)||(t=Di(t)),Ga){var n=(this.unsigned?Ga.rem_u:Ga.rem_s)(this.low,this.high,t.low,t.high);return Hn(n,Ga.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};Ue.mod=Ue.modulo;Ue.rem=Ue.modulo;Ue.not=function(){return Hn(~this.low,~this.high,this.unsigned)};Ue.and=function(t){return Qo(t)||(t=Di(t)),Hn(this.low&t.low,this.high&t.high,this.unsigned)};Ue.or=function(t){return Qo(t)||(t=Di(t)),Hn(this.low|t.low,this.high|t.high,this.unsigned)};Ue.xor=function(t){return Qo(t)||(t=Di(t)),Hn(this.low^t.low,this.high^t.high,this.unsigned)};Ue.shiftLeft=function(t){return Qo(t)&&(t=t.toInt()),(t&=63)==0?this:t<32?Hn(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Hn(0,this.low<<t-32,this.unsigned)};Ue.shl=Ue.shiftLeft;Ue.shiftRight=function(t){return Qo(t)&&(t=t.toInt()),(t&=63)==0?this:t<32?Hn(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Hn(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};Ue.shr=Ue.shiftRight;Ue.shiftRightUnsigned=function(t){if(Qo(t)&&(t=t.toInt()),t&=63,t===0)return this;var n=this.high;if(t<32){var r=this.low;return Hn(r>>>t|n<<32-t,n>>>t,this.unsigned)}else return t===32?Hn(n,0,this.unsigned):Hn(n>>>t-32,0,this.unsigned)};Ue.shru=Ue.shiftRightUnsigned;Ue.shr_u=Ue.shiftRightUnsigned;Ue.toSigned=function(){return this.unsigned?Hn(this.low,this.high,!1):this};Ue.toUnsigned=function(){return this.unsigned?this:Hn(this.low,this.high,!0)};Ue.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};Ue.toBytesLE=function(){var t=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};Ue.toBytesBE=function(){var t=this.high,n=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};jn.fromBytes=function(t,n,r){return r?jn.fromBytesLE(t,n):jn.fromBytesBE(t,n)};jn.fromBytesLE=function(t,n){return new jn(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,n)};jn.fromBytesBE=function(t,n){return new jn(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],n)}});var TH=Gr(()=>{});var iq=Gr((aq,PD)=>{(function(e,t,n){function r(i){var l=this,u=a();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(i),l.s0<0&&(l.s0+=1),l.s1-=u(i),l.s1<0&&(l.s1+=1),l.s2-=u(i),l.s2<0&&(l.s2+=1),u=null}function s(i,l){return l.c=i.c,l.s0=i.s0,l.s1=i.s1,l.s2=i.s2,l}function o(i,l){var u=new r(i),c=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&s(c,u),p.state=function(){return s(u,{})}),p}function a(){var i=4022871197,l=function(u){u=u.toString();for(var c=0;c<u.length;c++){i+=u.charCodeAt(c);var p=.02519603282416938*i;i=p>>>0,p-=i,p*=i,i=p>>>0,p-=i,i+=p*4294967296}return(i>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.alea=o})(aq,typeof PD=="object"&&PD,typeof define=="function"&&define)});var uq=Gr((lq,MD)=>{(function(e,t,n){function r(a){var i=this,l="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var c=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^c^c>>>8},a===(a|0)?i.x=a:l+=a;for(var u=0;u<l.length+64;u++)i.x^=l.charCodeAt(u)|0,i.next()}function s(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function o(a,i){var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor128=o})(lq,typeof MD=="object"&&MD,typeof define=="function"&&define)});var pq=Gr((cq,zD)=>{(function(e,t,n){function r(a){var i=this,l="";i.next=function(){var c=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(c^c<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:l+=a;for(var u=0;u<l.length+64;u++)i.x^=l.charCodeAt(u)|0,u==l.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function s(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function o(a,i){var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorwow=o})(cq,typeof zD=="object"&&zD,typeof define=="function"&&define)});var fq=Gr((dq,LD)=>{(function(e,t,n){function r(a){var i=this;i.next=function(){var u=i.x,c=i.i,p,d,f;return p=u[c],p^=p>>>7,d=p^p<<24,p=u[c+1&7],d^=p^p>>>10,p=u[c+3&7],d^=p^p>>>3,p=u[c+4&7],d^=p^p<<7,p=u[c+7&7],p=p^p<<13,d^=p^p<<9,u[c]=d,i.i=c+1&7,d};function l(u,c){var p,d,f=[];if(c===(c|0))d=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?d=f[7]=-1:d=f[p],u.x=f,u.i=0,p=256;p>0;--p)u.next()}l(i,a)}function s(a,i){return i.x=a.x.slice(),i.i=a.i,i}function o(a,i){a==null&&(a=+new Date);var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.x&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorshift7=o})(dq,typeof LD=="object"&&LD,typeof define=="function"&&define)});var mq=Gr((hq,BD)=>{(function(e,t,n){function r(a){var i=this;i.next=function(){var u=i.w,c=i.X,p=i.i,d,f;return i.w=u=u+1640531527|0,f=c[p+34&127],d=c[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,f=c[p]=f^d,i.i=p,f+(u^u>>>16)|0};function l(u,c){var p,d,f,h,m,g=[],x=128;for(c===(c|0)?(d=c,c=null):(c=c+"\0",d=0,x=Math.max(x,c.length)),f=0,h=-32;h<x;++h)c&&(d^=c.charCodeAt((h+32)%c.length)),h===0&&(m=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,h>=0&&(m=m+1640531527|0,p=g[h&127]^=d+m,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,h=4*128;h>0;--h)d=g[f+34&127],p=g[f=f+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,g[f]=d^p;u.w=m,u.X=g,u.i=f}l(i,a)}function s(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function o(a,i){a==null&&(a=+new Date);var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.X&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor4096=o})(hq,typeof BD=="object"&&BD,typeof define=="function"&&define)});var xq=Gr((gq,VD)=>{(function(e,t,n){function r(a){var i=this,l="";i.next=function(){var c=i.b,p=i.c,d=i.d,f=i.a;return c=c<<25^c>>>7^p,p=p-d|0,d=d<<24^d>>>8^f,f=f-c|0,i.b=c=c<<20^c>>>12^p,i.c=p=p-d|0,i.d=d<<16^p>>>16^f,i.a=f-c|0},i.a=0,i.b=0,i.c=2654435769|0,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):l+=a;for(var u=0;u<l.length+20;u++)i.b^=l.charCodeAt(u)|0,i.next()}function s(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function o(a,i){var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.tychei=o})(gq,typeof VD=="object"&&VD,typeof define=="function"&&define)});var WD=Gr(()=>{});var yq=Gr((t0t,F3)=>{(function(e,t){var n=this,r=256,s=6,o=52,a="random",i=t.pow(r,s),l=t.pow(2,o),u=l*2,c=r-1,p;function d(b,A,v){var w=[];A=A==!0?{entropy:!0}:A||{};var k=g(m(A.entropy?[b,y(e)]:b==null?x():b,3),w),I=new f(w),N=function(){for(var T=I.g(s),_=i,R=0;T<l;)T=(T+R)*r,_*=r,R=I.g(1);for(;T>=u;)T/=2,_/=2,R>>>=1;return(T+R)/_};return N.int32=function(){return I.g(4)|0},N.quick=function(){return I.g(4)/4294967296},N.double=N,g(y(I.S),e),(A.pass||v||function(T,_,R,S){return S&&(S.S&&h(S,I),T.state=function(){return h(I,{})}),R?(t[a]=T,_):T})(N,k,"global"in A?A.global:this==t,A.state)}t["seed"+a]=d;function f(b){var A,v=b.length,w=this,k=0,I=w.i=w.j=0,N=w.S=[];for(v||(b=[v++]);k<r;)N[k]=k++;for(k=0;k<r;k++)N[k]=N[I=c&I+b[k%v]+(A=N[k])],N[I]=A;(w.g=function(T){for(var _,R=0,S=w.i,F=w.j,B=w.S;T--;)_=B[S=c&S+1],R=R*r+B[c&(B[S]=B[F=c&F+_])+(B[F]=_)];return w.i=S,w.j=F,R})(r)}function h(b,A){return A.i=b.i,A.j=b.j,A.S=b.S.slice(),A}function m(b,A){var v=[],w=typeof b,k;if(A&&w=="object")for(k in b)try{v.push(m(b[k],A-1))}catch(I){}return v.length?v:w=="string"?b:b+"\0"}function g(b,A){for(var v=b+"",w,k=0;k<v.length;)A[c&k]=c&(w^=A[c&k]*19)+v.charCodeAt(k++);return y(A)}function x(){try{var b;return p&&(b=p.randomBytes)?b=b(r):(b=new Uint8Array(r),(n.crypto||n.msCrypto).getRandomValues(b)),y(b)}catch(w){var A=n.navigator,v=A&&A.plugins;return[+new Date,n,v,n.screen,y(e)]}}function y(b){return String.fromCharCode.apply(0,b)}if(g(t.random(),e),typeof F3=="object"&&F3.exports){F3.exports=d;try{p=WD()}catch(b){}}else typeof define=="function"&&define.amd&&define(function(){return d})})([],Math)});var GD=Gr((n0t,bq)=>{var bBe=iq(),ABe=uq(),vBe=pq(),wBe=fq(),kBe=mq(),IBe=xq(),am=yq();am.alea=bBe;am.xor128=ABe;am.xorwow=vBe;am.xorshift7=wBe;am.xor4096=kBe;am.tychei=IBe;bq.exports=am});var CY=Gr((IY,N6)=>{(function(e,t,n){function r(i){var l=this,u=a();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(i),l.s0<0&&(l.s0+=1),l.s1-=u(i),l.s1<0&&(l.s1+=1),l.s2-=u(i),l.s2<0&&(l.s2+=1),u=null}function s(i,l){return l.c=i.c,l.s0=i.s0,l.s1=i.s1,l.s2=i.s2,l}function o(i,l){var u=new r(i),c=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&s(c,u),p.state=function(){return s(u,{})}),p}function a(){var i=4022871197,l=function(u){u=String(u);for(var c=0;c<u.length;c++){i+=u.charCodeAt(c);var p=.02519603282416938*i;i=p>>>0,p-=i,p*=i,i=p>>>0,p-=i,i+=p*4294967296}return(i>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.alea=o})(IY,typeof N6=="object"&&N6,typeof define=="function"&&define)});var NY=Gr((SY,T6)=>{(function(e,t,n){function r(a){var i=this,l="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var c=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^c^c>>>8},a===(a|0)?i.x=a:l+=a;for(var u=0;u<l.length+64;u++)i.x^=l.charCodeAt(u)|0,i.next()}function s(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function o(a,i){var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor128=o})(SY,typeof T6=="object"&&T6,typeof define=="function"&&define)});var _Y=Gr((TY,_6)=>{(function(e,t,n){function r(a){var i=this,l="";i.next=function(){var c=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(c^c<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:l+=a;for(var u=0;u<l.length+64;u++)i.x^=l.charCodeAt(u)|0,u==l.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function s(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function o(a,i){var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorwow=o})(TY,typeof _6=="object"&&_6,typeof define=="function"&&define)});var RY=Gr((EY,E6)=>{(function(e,t,n){function r(a){var i=this;i.next=function(){var u=i.x,c=i.i,p,d,f;return p=u[c],p^=p>>>7,d=p^p<<24,p=u[c+1&7],d^=p^p>>>10,p=u[c+3&7],d^=p^p>>>3,p=u[c+4&7],d^=p^p<<7,p=u[c+7&7],p=p^p<<13,d^=p^p<<9,u[c]=d,i.i=c+1&7,d};function l(u,c){var p,d,f=[];if(c===(c|0))d=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?d=f[7]=-1:d=f[p],u.x=f,u.i=0,p=256;p>0;--p)u.next()}l(i,a)}function s(a,i){return i.x=a.x.slice(),i.i=a.i,i}function o(a,i){a==null&&(a=+new Date);var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.x&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorshift7=o})(EY,typeof E6=="object"&&E6,typeof define=="function"&&define)});var $Y=Gr((DY,R6)=>{(function(e,t,n){function r(a){var i=this;i.next=function(){var u=i.w,c=i.X,p=i.i,d,f;return i.w=u=u+1640531527|0,f=c[p+34&127],d=c[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,f=c[p]=f^d,i.i=p,f+(u^u>>>16)|0};function l(u,c){var p,d,f,h,m,g=[],x=128;for(c===(c|0)?(d=c,c=null):(c=c+"\0",d=0,x=Math.max(x,c.length)),f=0,h=-32;h<x;++h)c&&(d^=c.charCodeAt((h+32)%c.length)),h===0&&(m=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,h>=0&&(m=m+1640531527|0,p=g[h&127]^=d+m,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,h=4*128;h>0;--h)d=g[f+34&127],p=g[f=f+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,g[f]=d^p;u.w=m,u.X=g,u.i=f}l(i,a)}function s(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function o(a,i){a==null&&(a=+new Date);var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.X&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor4096=o})(DY,typeof R6=="object"&&R6,typeof define=="function"&&define)});var OY=Gr((FY,D6)=>{(function(e,t,n){function r(a){var i=this,l="";i.next=function(){var c=i.b,p=i.c,d=i.d,f=i.a;return c=c<<25^c>>>7^p,p=p-d|0,d=d<<24^d>>>8^f,f=f-c|0,i.b=c=c<<20^c>>>12^p,i.c=p=p-d|0,i.d=d<<16^p>>>16^f,i.a=f-c|0},i.a=0,i.b=0,i.c=2654435769|0,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):l+=a;for(var u=0;u<l.length+20;u++)i.b^=l.charCodeAt(u)|0,i.next()}function s(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function o(a,i){var l=new r(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&s(u,l),c.state=function(){return s(l,{})}),c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.tychei=o})(FY,typeof D6=="object"&&D6,typeof define=="function"&&define)});var MY=Gr((PY,XC)=>{(function(e,t,n){var r=256,s=6,o=52,a="random",i=n.pow(r,s),l=n.pow(2,o),u=l*2,c=r-1,p;function d(b,A,v){var w=[];A=A==!0?{entropy:!0}:A||{};var k=g(m(A.entropy?[b,y(t)]:b==null?x():b,3),w),I=new f(w),N=function(){for(var T=I.g(s),_=i,R=0;T<l;)T=(T+R)*r,_*=r,R=I.g(1);for(;T>=u;)T/=2,_/=2,R>>>=1;return(T+R)/_};return N.int32=function(){return I.g(4)|0},N.quick=function(){return I.g(4)/4294967296},N.double=N,g(y(I.S),t),(A.pass||v||function(T,_,R,S){return S&&(S.S&&h(S,I),T.state=function(){return h(I,{})}),R?(n[a]=T,_):T})(N,k,"global"in A?A.global:this==n,A.state)}function f(b){var A,v=b.length,w=this,k=0,I=w.i=w.j=0,N=w.S=[];for(v||(b=[v++]);k<r;)N[k]=k++;for(k=0;k<r;k++)N[k]=N[I=c&I+b[k%v]+(A=N[k])],N[I]=A;(w.g=function(T){for(var _,R=0,S=w.i,F=w.j,B=w.S;T--;)_=B[S=c&S+1],R=R*r+B[c&(B[S]=B[F=c&F+_])+(B[F]=_)];return w.i=S,w.j=F,R})(r)}function h(b,A){return A.i=b.i,A.j=b.j,A.S=b.S.slice(),A}function m(b,A){var v=[],w=typeof b,k;if(A&&w=="object")for(k in b)try{v.push(m(b[k],A-1))}catch(I){}return v.length?v:w=="string"?b:b+"\0"}function g(b,A){for(var v=b+"",w,k=0;k<v.length;)A[c&k]=c&(w^=A[c&k]*19)+v.charCodeAt(k++);return y(A)}function x(){try{var b;return p&&(b=p.randomBytes)?b=b(r):(b=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(b)),y(b)}catch(w){var A=e.navigator,v=A&&A.plugins;return[+new Date,e,v,e.screen,y(t)]}}function y(b){return String.fromCharCode.apply(0,b)}if(g(n.random(),t),typeof XC=="object"&&XC.exports){XC.exports=d;try{p=WD()}catch(b){}}else typeof define=="function"&&define.amd?define(function(){return d}):n["seed"+a]=d})(typeof self!="undefined"?self:PY,[],Math)});var $6=Gr((Sen,zY)=>{var EUe=CY(),RUe=NY(),DUe=_Y(),$Ue=RY(),FUe=$Y(),OUe=OY(),Fm=MY();Fm.alea=EUe;Fm.xor128=RUe;Fm.xorwow=DUe;Fm.xorshift7=$Ue;Fm.xor4096=FUe;Fm.tychei=OUe;zY.exports=Fm});var LY=Gr(()=>{});var uQe={};dn(uQe,{Human:()=>fie,Models:()=>wv,default:()=>fie,defaults:()=>Ec,env:()=>Ee});function an(e,t){let n=e.endsWith("/")?"":"/",s=t.startsWith(".")||t.startsWith("/")||t.startsWith("http:")||t.startsWith("https:")||t.startsWith("file:")?`${t}`:`${e}${n}${t}`;if(!s.toLocaleLowerCase().includes(".json"))throw new Error(`modelpath error: ${s} expecting json file`);return s}function Ce(...e){let t=new Date,n=`${t.getHours().toString().padStart(2,"0")}:${t.getMinutes().toString().padStart(2,"0")}:${t.getSeconds().toString().padStart(2,"0")}.${t.getMilliseconds().toString().padStart(3,"0")}`;e&&console.log(n,"Human:",...e)}var en=()=>typeof performance!="undefined"?performance.now():parseInt((Number(process.hrtime.bigint())/1e3/1e3).toString());function kT(e,t,n="config",r=[]){for(let s of Object.keys(t))if(typeof t[s]=="object")kT(e[s],t[s],s,r);else{let o=e&&typeof e[s]!="undefined";o||r.push({reason:"unknown property",where:`${n}.${s} = ${t[s]}`});let a=e&&typeof e[s]==typeof t[s];o&&!a&&r.push({reason:"property type mismatch",where:`${n}.${s} = ${t[s]}`,expected:typeof e[s]})}return t.debug&&n==="config"&&r.length>0&&Ce("invalid configuration",r),r}function os(...e){let t=n=>n&&typeof n=="object";return e.reduce((n,r)=>(Object.keys(r||{}).forEach(s=>{let o=n[s],a=r[s];Array.isArray(o)&&Array.isArray(a)?n[s]=o.concat(...a):t(o)&&t(a)?n[s]=os(o,a):n[s]=a}),n),{})}var Ec={backend:"",modelBasePath:"",wasmPath:"",debug:!0,async:!0,warmup:"full",cacheSensitivity:.75,skipFrame:!1,filter:{enabled:!0,width:0,height:0,flip:!1,return:!0,brightness:0,contrast:0,sharpness:0,blur:0,saturation:0,hue:0,negative:!1,sepia:!1,vintage:!1,kodachrome:!1,technicolor:!1,polaroid:!1,pixelate:0},gesture:{enabled:!0},face:{enabled:!0,detector:{modelPath:"blazeface.json",rotation:!0,maxDetected:1,skipFrames:11,minConfidence:.2,iouThreshold:.1,return:!1},mesh:{enabled:!0,modelPath:"facemesh.json"},iris:{enabled:!0,modelPath:"iris.json"},emotion:{enabled:!0,minConfidence:.1,skipFrames:12,modelPath:"emotion.json"},description:{enabled:!0,modelPath:"faceres.json",skipFrames:13,minConfidence:.1}},body:{enabled:!0,modelPath:"movenet-lightning.json",detector:{modelPath:""},maxDetected:-1,minConfidence:.2,skipFrames:5},hand:{enabled:!0,rotation:!0,skipFrames:14,minConfidence:.5,iouThreshold:.2,maxDetected:-1,landmarks:!0,detector:{modelPath:"handtrack.json"},skeleton:{modelPath:"handskeleton.json"}},object:{enabled:!1,modelPath:"mb3-centernet.json",minConfidence:.2,iouThreshold:.4,maxDetected:10,skipFrames:15},segmentation:{enabled:!1,modelPath:"selfie.json",blur:8}};var bh={};dn(bh,{Abs:()=>cg,Acos:()=>pg,Acosh:()=>dg,AdadeltaOptimizer:()=>_k,AdagradOptimizer:()=>Ek,AdamOptimizer:()=>Rk,AdamaxOptimizer:()=>Dk,Add:()=>$c,AddN:()=>Ld,All:()=>fg,Any:()=>hg,ArgMax:()=>Bd,ArgMin:()=>P1,Asin:()=>mg,Asinh:()=>gg,Atan:()=>xg,Atan2:()=>bg,Atanh:()=>yg,AvgPool:()=>Vd,AvgPool3D:()=>M1,AvgPool3DGrad:()=>tw,AvgPoolGrad:()=>ew,BackendWasm:()=>xU,BatchMatMul:()=>Wd,BatchToSpaceND:()=>Ag,Bincount:()=>nw,BroadcastArgs:()=>ET,BroadcastTo:()=>SP,Callback:()=>hL,CallbackList:()=>az,Cast:()=>Gd,Ceil:()=>Ud,ClipByValue:()=>Fc,Complex:()=>rw,ComplexAbs:()=>z1,Concat:()=>vg,Conv2D:()=>jd,Conv2DBackpropFilter:()=>sw,Conv2DBackpropInput:()=>Hd,Conv3D:()=>L1,Conv3DBackpropFilterV2:()=>ow,Conv3DBackpropInputV2:()=>aw,Cos:()=>qd,Cosh:()=>Kd,CropAndResize:()=>wg,Cumsum:()=>Xd,CustomCallback:()=>lz,DataStorage:()=>Xv,DenseBincount:()=>iw,DepthToSpace:()=>kg,DepthwiseConv2dNative:()=>Zd,DepthwiseConv2dNativeBackpropFilter:()=>lw,DepthwiseConv2dNativeBackpropInput:()=>uw,Diag:()=>cw,Dilation2D:()=>B1,Dilation2DBackpropFilter:()=>dw,Dilation2DBackpropInput:()=>pw,ENV:()=>Da,EarlyStopping:()=>gL,Einsum:()=>fw,Elu:()=>Jd,EluGrad:()=>hw,Environment:()=>IP,Equal:()=>Cg,Erf:()=>Ig,Exp:()=>Qd,ExpandDims:()=>Sg,Expm1:()=>Ng,FFT:()=>mw,Fill:()=>V1,FlipLeftRight:()=>Tg,Floor:()=>ef,FloorDiv:()=>tf,FromPixels:()=>Pw,FusedBatchNorm:()=>nf,FusedConv2D:()=>Mf,FusedDepthwiseConv2D:()=>zf,GPGPUContext:()=>$5,GatherNd:()=>Eg,GatherV2:()=>_g,GraphModel:()=>KL,Greater:()=>Rg,GreaterEqual:()=>rf,History:()=>iz,IFFT:()=>gw,Identity:()=>sf,Imag:()=>xw,InputSpec:()=>Rr,IsFinite:()=>Dg,IsInf:()=>$g,IsNan:()=>Fg,KernelBackend:()=>$1,LRN:()=>U1,LRNGrad:()=>bw,LayerVariable:()=>tz,LayersModel:()=>ql,LeakyRelu:()=>of,Less:()=>Og,LessEqual:()=>Pg,LinSpace:()=>yw,Log:()=>af,Log1p:()=>Mg,LogSoftmax:()=>NP,LogicalAnd:()=>zg,LogicalNot:()=>W1,LogicalOr:()=>G1,MathBackendWebGL:()=>Y0,Max:()=>lf,MaxPool:()=>cf,MaxPool3D:()=>j1,MaxPool3DGrad:()=>vw,MaxPoolGrad:()=>Aw,MaxPoolWithArgmax:()=>ww,Maximum:()=>uf,Mean:()=>pf,Min:()=>df,Minimum:()=>ff,MirrorPad:()=>hf,Mod:()=>Lg,MomentumOptimizer:()=>$k,Multinomial:()=>kw,Multiply:()=>mf,Neg:()=>Bg,NonMaxSuppressionV3:()=>Wg,NonMaxSuppressionV4:()=>Gg,NonMaxSuppressionV5:()=>Ug,NotEqual:()=>Vg,OP_SCOPE_SUFFIX:()=>WP,OneHot:()=>gf,OnesLike:()=>jg,Optimizer:()=>Ul,Pack:()=>Hg,PadV2:()=>xf,Pool:()=>sue,Pow:()=>yf,Prelu:()=>bf,Prod:()=>qg,RMSPropOptimizer:()=>Fk,RNN:()=>fl,Range:()=>H1,Rank:()=>OT,Real:()=>Iw,RealDiv:()=>Yd,Reciprocal:()=>Kg,Reduction:()=>Ws,Relu:()=>Af,Relu6:()=>wf,Reshape:()=>Xg,ResizeBilinear:()=>vf,ResizeBilinearGrad:()=>Sw,ResizeNearestNeighbor:()=>q1,ResizeNearestNeighborGrad:()=>Cw,Reverse:()=>kf,RotateWithOffset:()=>c0,Round:()=>If,Rsqrt:()=>Cf,SGDOptimizer:()=>Cb,ScatterNd:()=>Zg,Select:()=>Yg,Selu:()=>Jg,Sequential:()=>M0,Sigmoid:()=>Nf,Sign:()=>t0,Sin:()=>Sf,Sinh:()=>e0,Slice:()=>Qg,Softmax:()=>Ef,Softplus:()=>n0,SpaceToBatchND:()=>r0,SparseFillEmptyRows:()=>Nw,SparseReshape:()=>Tw,SparseSegmentMean:()=>_w,SparseSegmentSum:()=>Ew,SparseToDense:()=>Rw,SplitV:()=>s0,Sqrt:()=>Tf,Square:()=>K1,SquaredDifference:()=>Rf,Step:()=>Pc,StridedSlice:()=>o0,StringNGrams:()=>Dw,StringSplit:()=>$w,StringToHashBucketFast:()=>Fw,Sub:()=>Df,Sum:()=>_f,SymbolicTensor:()=>Ii,Tan:()=>$f,Tanh:()=>Ff,Tensor:()=>Vt,TensorBuffer:()=>Ur,Tile:()=>Oc,TopK:()=>a0,Transform:()=>i0,Transpose:()=>Of,Unique:()=>Ow,Unpack:()=>l0,UnsortedSegmentSum:()=>X1,Variable:()=>rb,ZerosLike:()=>u0,_FusedMatMul:()=>Pf,abs:()=>Tr,acos:()=>u_,acosh:()=>c_,add:()=>Re,addN:()=>Yw,all:()=>Jw,any:()=>lb,argMax:()=>xi,argMin:()=>p_,asin:()=>d_,asinh:()=>f_,atan:()=>h_,atan2:()=>m_,atanh:()=>g_,avgPool:()=>cb,avgPool3d:()=>b_,backend:()=>sl,backend_util:()=>G,basicLSTMCell:()=>Mpe,batchNorm:()=>qf,batchNorm2d:()=>E9,batchNorm3d:()=>R9,batchNorm4d:()=>D9,batchToSpaceND:()=>pb,bincount:()=>A_,booleanMaskAsync:()=>Uhe,broadcastArgs:()=>$9,broadcastTo:()=>A0,browser:()=>Mo,buffer:()=>Wt,callbacks:()=>s2e,cast:()=>Fe,ceil:()=>v_,clipByValue:()=>yo,clone:()=>mi,complex:()=>Lc,concat:()=>En,concat1d:()=>F9,concat2d:()=>v0,concat3d:()=>O9,concat4d:()=>P9,constraints:()=>FM,conv1d:()=>ek,conv2d:()=>Bl,conv2dTranspose:()=>tk,conv3d:()=>k_,conv3dTranspose:()=>z9,copyRegisteredKernels:()=>iue,cos:()=>db,cosh:()=>nk,cosineWindow:()=>Z_,cumsum:()=>rk,customGrad:()=>al,data:()=>XL,denseBincount:()=>L9,deprecationWarn:()=>i_,depthToSpace:()=>I_,depthwiseConv2d:()=>w0,deregisterOp:()=>a2e,device_util:()=>ob,diag:()=>fde,dilation2d:()=>C_,disableDeprecationWarnings:()=>Qce,dispose:()=>ye,disposeVariables:()=>epe,div:()=>Me,divNoNan:()=>S_,dot:()=>B9,dropout:()=>iM,einsum:()=>V9,elu:()=>k0,enableDebugMode:()=>Jce,enableProdMode:()=>C9,enclosingPowerOfTwo:()=>lM,engine:()=>zo,env:()=>be,equal:()=>Lo,erf:()=>N_,exp:()=>Bo,expandDims:()=>kr,expm1:()=>T_,eye:()=>__,fft:()=>wb,fill:()=>I0,findBackend:()=>l_,findBackendFactory:()=>spe,floor:()=>C0,floorDiv:()=>Zw,forceHalfFloat:()=>wW,fused:()=>Hc,gather:()=>Kf,gatherND:()=>aM,gather_util:()=>e_,getBackend:()=>gi,getGradient:()=>RT,getKernel:()=>Mw,getKernelsForBackend:()=>zl,gpgpu_util:()=>ZV,grad:()=>Gde,grads:()=>Ude,greater:()=>bo,greaterEqual:()=>Uc,ifft:()=>_0,imag:()=>sk,image:()=>ht,inTopKAsync:()=>tme,initializers:()=>VM,input:()=>Rz,io:()=>go,irfft:()=>bk,isFinite:()=>W9,isInf:()=>G9,isNaN:()=>E_,keep:()=>us,kernel_impls:()=>ll,layers:()=>JM,leakyRelu:()=>fb,less:()=>ok,lessEqual:()=>jc,linalg:()=>AM,linspace:()=>U9,loadGraphModel:()=>yn,loadLayersModel:()=>hbe,localResponseNormalization:()=>R_,log:()=>Vo,log1p:()=>hb,logSigmoid:()=>H9,logSoftmax:()=>ik,logSumExp:()=>F_,logicalAnd:()=>Fa,logicalNot:()=>mb,logicalOr:()=>lk,logicalXor:()=>Z9,losses:()=>Mge,matMul:()=>Lt,math:()=>a9,max:()=>Wo,maxPool:()=>gb,maxPool3d:()=>O_,maxPoolWithArgmax:()=>Y9,maximum:()=>il,mean:()=>cr,memory:()=>Kw,meshgrid:()=>dfe,metrics:()=>pL,min:()=>xb,minimum:()=>S0,mirrorPad:()=>P_,mod:()=>M_,model:()=>dbe,models:()=>dL,moments:()=>uk,movingAverage:()=>qhe,mul:()=>te,multiRNNCell:()=>Afe,multinomial:()=>J9,neg:()=>er,nextFrame:()=>Ok,norm:()=>kk,notEqual:()=>Yf,oneHot:()=>g0,ones:()=>Go,onesLike:()=>Uo,op:()=>ae,outerProduct:()=>Cfe,pad:()=>Vl,pad1d:()=>Tfe,pad2d:()=>Efe,pad3d:()=>Dfe,pad4d:()=>Ffe,pool:()=>Q9,pow:()=>Wl,prelu:()=>bb,print:()=>e9,prod:()=>ck,profile:()=>tpe,rand:()=>Gfe,randomGamma:()=>qfe,randomNormal:()=>eM,randomUniform:()=>N0,range:()=>T0,ready:()=>Xw,real:()=>Ab,reciprocal:()=>B_,registerBackend:()=>y0,registerCallbackConstructor:()=>mbe,registerGradient:()=>TP,registerKernel:()=>Mc,registerOp:()=>o2e,regularizers:()=>fL,relu:()=>yi,relu6:()=>pk,removeBackend:()=>rpe,reshape:()=>ie,reverse:()=>jo,reverse1d:()=>nhe,reverse2d:()=>she,reverse3d:()=>ahe,reverse4d:()=>lhe,rfft:()=>kb,round:()=>dk,rsqrt:()=>fk,scalar:()=>at,scatterND:()=>oM,scatter_util:()=>t_,selu:()=>hk,separableConv2d:()=>V_,sequential:()=>fbe,serialization:()=>De,setBackend:()=>S9,setPlatform:()=>ope,setWasmPath:()=>zPe,setWasmPaths:()=>bU,setWebGLContext:()=>I5,setdiff1dAsync:()=>tM,sigmoid:()=>xo,sign:()=>W_,signal:()=>Pge,sin:()=>mk,sinh:()=>gk,slice:()=>gt,slice1d:()=>xk,slice2d:()=>G_,slice3d:()=>yk,slice4d:()=>vb,slice_util:()=>Bs,softmax:()=>Jf,softplus:()=>Xf,spaceToBatchND:()=>yb,sparse:()=>Ib,sparseToDense:()=>X_,spectral:()=>Oge,split:()=>_r,sqrt:()=>As,square:()=>Tn,squaredDifference:()=>Ak,squeeze:()=>ln,stack:()=>vs,step:()=>E0,stridedSlice:()=>U_,string:()=>Tk,sub:()=>Ge,sum:()=>Je,sumOutType:()=>Ww,tan:()=>j_,tanh:()=>Hf,tensor:()=>ls,tensor1d:()=>Er,tensor2d:()=>bi,tensor3d:()=>jw,tensor4d:()=>Fhe,tensor5d:()=>Ohe,tensor6d:()=>Phe,tensor_util:()=>fi,test_util:()=>w9,tidy:()=>ce,tile:()=>da,time:()=>npe,topk:()=>H_,train:()=>eh,transpose:()=>Kt,truncatedNormal:()=>vk,unique:()=>wk,unregisterGradient:()=>aue,unregisterKernel:()=>oue,unsortedSegmentSum:()=>q_,unstack:()=>Vs,upcastType:()=>$a,util:()=>E,valueAndGrad:()=>jde,valueAndGrads:()=>Hde,variable:()=>nM,variableGrads:()=>j9,version:()=>XPe,version_converter:()=>uve,version_core:()=>qw,version_layers:()=>RE,version_wasm:()=>LPe,version_webgl:()=>vTe,webgl:()=>wTe,webgl_util:()=>AV,where:()=>$s,whereAsync:()=>K_,zeros:()=>xr,zerosLike:()=>Xt});var ule=Object.create,Kv=Object.defineProperty,cle=Object.getOwnPropertyDescriptor,ple=Object.getOwnPropertyNames,dle=Object.getPrototypeOf,fle=Object.prototype.hasOwnProperty,lP=e=>Kv(e,"__esModule",{value:!0}),ig=(e=>typeof _c!="undefined"?_c:typeof Proxy!="undefined"?new Proxy(e,{get:(t,n)=>(typeof _c!="undefined"?_c:t)[n]}):e)(function(e){if(typeof _c!="undefined")return _c.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')}),Qn=(e,t)=>function(){return t||(0,e[Object.keys(e)[0]])((t={exports:{}}).exports,t),t.exports},Rt=(e,t)=>{lP(e);for(var n in t)Kv(e,n,{get:t[n],enumerable:!0})},hle=(e,t,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of ple(t))!fle.call(e,r)&&r!=="default"&&Kv(e,r,{get:()=>t[r],enumerable:!(n=cle(t,r))||n.enumerable});return e},Pd=e=>hle(lP(Kv(e!=null?ule(dle(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e),mle=Qn({"node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js"(e,t){t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(R){}function r(R,S,F){this.low=R|0,this.high=S|0,this.unsigned=!!F}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function s(R){return(R&&R.__isLong__)===!0}r.isLong=s;var o={},a={};function i(R,S){var F,B,W;return S?(R>>>=0,(W=0<=R&&R<256)&&(B=a[R],B)?B:(F=u(R,(R|0)<0?-1:0,!0),W&&(a[R]=F),F)):(R|=0,(W=-128<=R&&R<128)&&(B=o[R],B)?B:(F=u(R,R<0?-1:0,!1),W&&(o[R]=F),F))}r.fromInt=i;function l(R,S){if(isNaN(R))return S?A:b;if(S){if(R<0)return A;if(R>=g)return N}else{if(R<=-x)return T;if(R+1>=x)return I}return R<0?l(-R,S).neg():u(R%m|0,R/m|0,S)}r.fromNumber=l;function u(R,S,F){return new r(R,S,F)}r.fromBits=u;var c=Math.pow;function p(R,S,F){if(R.length===0)throw Error("empty string");if(R==="NaN"||R==="Infinity"||R==="+Infinity"||R==="-Infinity")return b;if(typeof S=="number"?(F=S,S=!1):S=!!S,F=F||10,F<2||36<F)throw RangeError("radix");var B;if((B=R.indexOf("-"))>0)throw Error("interior hyphen");if(B===0)return p(R.substring(1),S,F).neg();for(var W=l(c(F,8)),q=b,K=0;K<R.length;K+=8){var J=Math.min(8,R.length-K),Q=parseInt(R.substring(K,K+J),F);if(J<8){var ee=l(c(F,J));q=q.mul(ee).add(l(Q))}else q=q.mul(W),q=q.add(l(Q))}return q.unsigned=S,q}r.fromString=p;function d(R,S){return typeof R=="number"?l(R,S):typeof R=="string"?p(R,S):u(R.low,R.high,typeof S=="boolean"?S:R.unsigned)}r.fromValue=d;var f=1<<16,h=1<<24,m=f*f,g=m*m,x=g/2,y=i(h),b=i(0);r.ZERO=b;var A=i(0,!0);r.UZERO=A;var v=i(1);r.ONE=v;var w=i(1,!0);r.UONE=w;var k=i(-1);r.NEG_ONE=k;var I=u(4294967295|0,2147483647|0,!1);r.MAX_VALUE=I;var N=u(4294967295|0,4294967295|0,!0);r.MAX_UNSIGNED_VALUE=N;var T=u(0,2147483648|0,!1);r.MIN_VALUE=T;var _=r.prototype;_.toInt=function(){return this.unsigned?this.low>>>0:this.low},_.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},_.toString=function(S){if(S=S||10,S<2||36<S)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(T)){var F=l(S),B=this.div(F),W=B.mul(F).sub(this);return B.toString(S)+W.toInt().toString(S)}else return"-"+this.neg().toString(S);for(var q=l(c(S,6),this.unsigned),K=this,J="";;){var Q=K.div(q),ee=K.sub(Q.mul(q)).toInt()>>>0,ue=ee.toString(S);if(K=Q,K.isZero())return ue+J;for(;ue.length<6;)ue="0"+ue;J=""+ue+J}},_.getHighBits=function(){return this.high},_.getHighBitsUnsigned=function(){return this.high>>>0},_.getLowBits=function(){return this.low},_.getLowBitsUnsigned=function(){return this.low>>>0},_.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var S=this.high!=0?this.high:this.low,F=31;F>0&&(S&1<<F)==0;F--);return this.high!=0?F+33:F+1},_.isZero=function(){return this.high===0&&this.low===0},_.eqz=_.isZero,_.isNegative=function(){return!this.unsigned&&this.high<0},_.isPositive=function(){return this.unsigned||this.high>=0},_.isOdd=function(){return(this.low&1)==1},_.isEven=function(){return(this.low&1)==0},_.equals=function(S){return s(S)||(S=d(S)),this.unsigned!==S.unsigned&&this.high>>>31==1&&S.high>>>31==1?!1:this.high===S.high&&this.low===S.low},_.eq=_.equals,_.notEquals=function(S){return!this.eq(S)},_.neq=_.notEquals,_.ne=_.notEquals,_.lessThan=function(S){return this.comp(S)<0},_.lt=_.lessThan,_.lessThanOrEqual=function(S){return this.comp(S)<=0},_.lte=_.lessThanOrEqual,_.le=_.lessThanOrEqual,_.greaterThan=function(S){return this.comp(S)>0},_.gt=_.greaterThan,_.greaterThanOrEqual=function(S){return this.comp(S)>=0},_.gte=_.greaterThanOrEqual,_.ge=_.greaterThanOrEqual,_.compare=function(S){if(s(S)||(S=d(S)),this.eq(S))return 0;var F=this.isNegative(),B=S.isNegative();return F&&!B?-1:!F&&B?1:this.unsigned?S.high>>>0>this.high>>>0||S.high===this.high&&S.low>>>0>this.low>>>0?-1:1:this.sub(S).isNegative()?-1:1},_.comp=_.compare,_.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(v)},_.neg=_.negate,_.add=function(S){s(S)||(S=d(S));var F=this.high>>>16,B=this.high&65535,W=this.low>>>16,q=this.low&65535,K=S.high>>>16,J=S.high&65535,Q=S.low>>>16,ee=S.low&65535,ue=0,re=0,de=0,fe=0;return fe+=q+ee,de+=fe>>>16,fe&=65535,de+=W+Q,re+=de>>>16,de&=65535,re+=B+J,ue+=re>>>16,re&=65535,ue+=F+K,ue&=65535,u(de<<16|fe,ue<<16|re,this.unsigned)},_.subtract=function(S){return s(S)||(S=d(S)),this.add(S.neg())},_.sub=_.subtract,_.multiply=function(S){if(this.isZero())return b;if(s(S)||(S=d(S)),n){var F=n.mul(this.low,this.high,S.low,S.high);return u(F,n.get_high(),this.unsigned)}if(S.isZero())return b;if(this.eq(T))return S.isOdd()?T:b;if(S.eq(T))return this.isOdd()?T:b;if(this.isNegative())return S.isNegative()?this.neg().mul(S.neg()):this.neg().mul(S).neg();if(S.isNegative())return this.mul(S.neg()).neg();if(this.lt(y)&&S.lt(y))return l(this.toNumber()*S.toNumber(),this.unsigned);var B=this.high>>>16,W=this.high&65535,q=this.low>>>16,K=this.low&65535,J=S.high>>>16,Q=S.high&65535,ee=S.low>>>16,ue=S.low&65535,re=0,de=0,fe=0,me=0;return me+=K*ue,fe+=me>>>16,me&=65535,fe+=q*ue,de+=fe>>>16,fe&=65535,fe+=K*ee,de+=fe>>>16,fe&=65535,de+=W*ue,re+=de>>>16,de&=65535,de+=q*ee,re+=de>>>16,de&=65535,de+=K*Q,re+=de>>>16,de&=65535,re+=B*ue+W*ee+q*Q+K*J,re&=65535,u(fe<<16|me,re<<16|de,this.unsigned)},_.mul=_.multiply,_.divide=function(S){if(s(S)||(S=d(S)),S.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&S.low===-1&&S.high===-1)return this;var F=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,S.low,S.high);return u(F,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?A:b;var B,W,q;if(this.unsigned){if(S.unsigned||(S=S.toUnsigned()),S.gt(this))return A;if(S.gt(this.shru(1)))return w;q=A}else{if(this.eq(T)){if(S.eq(v)||S.eq(k))return T;if(S.eq(T))return v;var K=this.shr(1);return B=K.div(S).shl(1),B.eq(b)?S.isNegative()?v:k:(W=this.sub(S.mul(B)),q=B.add(W.div(S)),q)}else if(S.eq(T))return this.unsigned?A:b;if(this.isNegative())return S.isNegative()?this.neg().div(S.neg()):this.neg().div(S).neg();if(S.isNegative())return this.div(S.neg()).neg();q=b}for(W=this;W.gte(S);){B=Math.max(1,Math.floor(W.toNumber()/S.toNumber()));for(var J=Math.ceil(Math.log(B)/Math.LN2),Q=J<=48?1:c(2,J-48),ee=l(B),ue=ee.mul(S);ue.isNegative()||ue.gt(W);)B-=Q,ee=l(B,this.unsigned),ue=ee.mul(S);ee.isZero()&&(ee=v),q=q.add(ee),W=W.sub(ue)}return q},_.div=_.divide,_.modulo=function(S){if(s(S)||(S=d(S)),n){var F=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,S.low,S.high);return u(F,n.get_high(),this.unsigned)}return this.sub(this.div(S).mul(S))},_.mod=_.modulo,_.rem=_.modulo,_.not=function(){return u(~this.low,~this.high,this.unsigned)},_.and=function(S){return s(S)||(S=d(S)),u(this.low&S.low,this.high&S.high,this.unsigned)},_.or=function(S){return s(S)||(S=d(S)),u(this.low|S.low,this.high|S.high,this.unsigned)},_.xor=function(S){return s(S)||(S=d(S)),u(this.low^S.low,this.high^S.high,this.unsigned)},_.shiftLeft=function(S){return s(S)&&(S=S.toInt()),(S&=63)==0?this:S<32?u(this.low<<S,this.high<<S|this.low>>>32-S,this.unsigned):u(0,this.low<<S-32,this.unsigned)},_.shl=_.shiftLeft,_.shiftRight=function(S){return s(S)&&(S=S.toInt()),(S&=63)==0?this:S<32?u(this.low>>>S|this.high<<32-S,this.high>>S,this.unsigned):u(this.high>>S-32,this.high>=0?0:-1,this.unsigned)},_.shr=_.shiftRight,_.shiftRightUnsigned=function(S){if(s(S)&&(S=S.toInt()),S&=63,S===0)return this;var F=this.high;if(S<32){var B=this.low;return u(B>>>S|F<<32-S,F>>>S,this.unsigned)}else return S===32?u(F,0,this.unsigned):u(F>>>S-32,0,this.unsigned)},_.shru=_.shiftRightUnsigned,_.shr_u=_.shiftRightUnsigned,_.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},_.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},_.toBytes=function(S){return S?this.toBytesLE():this.toBytesBE()},_.toBytesLE=function(){var S=this.high,F=this.low;return[F&255,F>>>8&255,F>>>16&255,F>>>24,S&255,S>>>8&255,S>>>16&255,S>>>24]},_.toBytesBE=function(){var S=this.high,F=this.low;return[S>>>24,S>>>16&255,S>>>8&255,S&255,F>>>24,F>>>16&255,F>>>8&255,F&255]},r.fromBytes=function(S,F,B){return B?r.fromBytesLE(S,F):r.fromBytesBE(S,F)},r.fromBytesLE=function(S,F){return new r(S[0]|S[1]<<8|S[2]<<16|S[3]<<24,S[4]|S[5]<<8|S[6]<<16|S[7]<<24,F)},r.fromBytesBE=function(S,F){return new r(S[4]<<24|S[5]<<16|S[6]<<8|S[7],S[0]<<24|S[1]<<16|S[2]<<8|S[3],F)}}}),gle=Qn({"(disabled):node_modules/.pnpm/node-fetch@2.6.5/node_modules/node-fetch/browser.js"(){}}),xle=Qn({"node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/alea.js"(e,t){(function(n,r,s){function o(u){var c=this,p=l();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=p(" "),c.s1=p(" "),c.s2=p(" "),c.s0-=p(u),c.s0<0&&(c.s0+=1),c.s1-=p(u),c.s1<0&&(c.s1+=1),c.s2-=p(u),c.s2<0&&(c.s2+=1),p=null}function a(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function i(u,c){var p=new o(u),d=c&&c.state,f=p.next;return f.int32=function(){return p.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,d&&(typeof d=="object"&&a(d,p),f.state=function(){return a(p,{})}),f}function l(){var u=4022871197,c=function(p){p=p.toString();for(var d=0;d<p.length;d++){u+=p.charCodeAt(d);var f=.02519603282416938*u;u=f>>>0,f-=u,f*=u,u=f>>>0,f-=u,u+=f*4294967296}return(u>>>0)*23283064365386963e-26};return c}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.alea=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),yle=Qn({"node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/xor128.js"(e,t){(function(n,r,s){function o(l){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},l===(l|0)?u.x=l:c+=l;for(var p=0;p<c.length+64;p++)u.x^=c.charCodeAt(p)|0,u.next()}function a(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function i(l,u){var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(typeof p=="object"&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xor128=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),ble=Qn({"node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/xorwow.js"(e,t){(function(n,r,s){function o(l){var u=this,c="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(d^d<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:c+=l;for(var p=0;p<c.length+64;p++)u.x^=c.charCodeAt(p)|0,p==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function i(l,u){var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(typeof p=="object"&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xorwow=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),Ale=Qn({"node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/xorshift7.js"(e,t){(function(n,r,s){function o(l){var u=this;u.next=function(){var p=u.x,d=u.i,f,h,m;return f=p[d],f^=f>>>7,h=f^f<<24,f=p[d+1&7],h^=f^f>>>10,f=p[d+3&7],h^=f^f>>>3,f=p[d+4&7],h^=f^f<<7,f=p[d+7&7],f=f^f<<13,h^=f^f<<9,p[d]=h,u.i=d+1&7,h};function c(p,d){var f,h,m=[];if(d===(d|0))h=m[0]=d;else for(d=""+d,f=0;f<d.length;++f)m[f&7]=m[f&7]<<15^d.charCodeAt(f)+m[f+1&7]<<13;for(;m.length<8;)m.push(0);for(f=0;f<8&&m[f]===0;++f);for(f==8?h=m[7]=-1:h=m[f],p.x=m,p.i=0,f=256;f>0;--f)p.next()}c(u,l)}function a(l,u){return u.x=l.x.slice(),u.i=l.i,u}function i(l,u){l==null&&(l=+new Date);var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(p.x&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xorshift7=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),vle=Qn({"node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/xor4096.js"(e,t){(function(n,r,s){function o(l){var u=this;u.next=function(){var p=u.w,d=u.X,f=u.i,h,m;return u.w=p=p+1640531527|0,m=d[f+34&127],h=d[f=f+1&127],m^=m<<13,h^=h<<17,m^=m>>>15,h^=h>>>12,m=d[f]=m^h,u.i=f,m+(p^p>>>16)|0};function c(p,d){var f,h,m,g,x,y=[],b=128;for(d===(d|0)?(h=d,d=null):(d=d+"\0",h=0,b=Math.max(b,d.length)),m=0,g=-32;g<b;++g)d&&(h^=d.charCodeAt((g+32)%d.length)),g===0&&(x=h),h^=h<<10,h^=h>>>15,h^=h<<4,h^=h>>>13,g>=0&&(x=x+1640531527|0,f=y[g&127]^=h+x,m=f==0?m+1:0);for(m>=128&&(y[(d&&d.length||0)&127]=-1),m=127,g=4*128;g>0;--g)h=y[m+34&127],f=y[m=m+1&127],h^=h<<13,f^=f<<17,h^=h>>>15,f^=f>>>12,y[m]=h^f;p.w=x,p.X=y,p.i=m}c(u,l)}function a(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function i(l,u){l==null&&(l=+new Date);var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(p.X&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xor4096=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),wle=Qn({"node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/lib/tychei.js"(e,t){(function(n,r,s){function o(l){var u=this,c="";u.next=function(){var d=u.b,f=u.c,h=u.d,m=u.a;return d=d<<25^d>>>7^f,f=f-h|0,h=h<<24^h>>>8^m,m=m-d|0,u.b=d=d<<20^d>>>12^f,u.c=f=f-h|0,u.d=h<<16^f>>>16^m,u.a=m-d|0},u.a=0,u.b=0,u.c=2654435769|0,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):c+=l;for(var p=0;p<c.length+20;p++)u.b^=c.charCodeAt(p)|0,u.next()}function a(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function i(l,u){var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(typeof p=="object"&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.tychei=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),uP=Qn({"(disabled):crypto"(){}}),kle=Qn({"node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/seedrandom.js"(e,t){(function(n,r){var s=this,o=256,a=6,i=52,l="random",u=r.pow(o,a),c=r.pow(2,i),p=c*2,d=o-1,f;function h(v,w,k){var I=[];w=w==!0?{entropy:!0}:w||{};var N=y(x(w.entropy?[v,A(n)]:v==null?b():v,3),I),T=new m(I),_=function(){for(var R=T.g(a),S=u,F=0;R<c;)R=(R+F)*o,S*=o,F=T.g(1);for(;R>=p;)R/=2,S/=2,F>>>=1;return(R+F)/S};return _.int32=function(){return T.g(4)|0},_.quick=function(){return T.g(4)/4294967296},_.double=_,y(A(T.S),n),(w.pass||k||function(R,S,F,B){return B&&(B.S&&g(B,T),R.state=function(){return g(T,{})}),F?(r[l]=R,S):R})(_,N,"global"in w?w.global:this==r,w.state)}r["seed"+l]=h;function m(v){var w,k=v.length,I=this,N=0,T=I.i=I.j=0,_=I.S=[];for(k||(v=[k++]);N<o;)_[N]=N++;for(N=0;N<o;N++)_[N]=_[T=d&T+v[N%k]+(w=_[N])],_[T]=w;(I.g=function(R){for(var S,F=0,B=I.i,W=I.j,q=I.S;R--;)S=q[B=d&B+1],F=F*o+q[d&(q[B]=q[W=d&W+S])+(q[W]=S)];return I.i=B,I.j=W,F})(o)}function g(v,w){return w.i=v.i,w.j=v.j,w.S=v.S.slice(),w}function x(v,w){var k=[],I=typeof v,N;if(w&&I=="object")for(N in v)try{k.push(x(v[N],w-1))}catch(T){}return k.length?k:I=="string"?v:v+"\0"}function y(v,w){for(var k=v+"",I,N=0;N<k.length;)w[d&N]=d&(I^=w[d&N]*19)+k.charCodeAt(N++);return A(w)}function b(){try{var v;return f&&(v=f.randomBytes)?v=v(o):(v=new Uint8Array(o),(s.crypto||s.msCrypto).getRandomValues(v)),A(v)}catch(I){var w=s.navigator,k=w&&w.plugins;return[+new Date,s,k,s.screen,A(n)]}}function A(v){return String.fromCharCode.apply(0,v)}if(y(r.random(),n),typeof t=="object"&&t.exports){t.exports=h;try{f=uP()}catch(v){}}else typeof define=="function"&&define.amd&&define(function(){return h})})([],Math)}}),cP=Qn({"node_modules/.pnpm/seedrandom@2.4.3/node_modules/seedrandom/index.js"(e,t){var n=xle(),r=yle(),s=ble(),o=Ale(),a=vle(),i=wle(),l=kle();l.alea=n,l.xor128=r,l.xorwow=s,l.xorshift7=o,l.xor4096=a,l.tychei=i,t.exports=l}}),Ile=Qn({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/alea.js"(e,t){(function(n,r,s){function o(u){var c=this,p=l();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=p(" "),c.s1=p(" "),c.s2=p(" "),c.s0-=p(u),c.s0<0&&(c.s0+=1),c.s1-=p(u),c.s1<0&&(c.s1+=1),c.s2-=p(u),c.s2<0&&(c.s2+=1),p=null}function a(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function i(u,c){var p=new o(u),d=c&&c.state,f=p.next;return f.int32=function(){return p.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,d&&(typeof d=="object"&&a(d,p),f.state=function(){return a(p,{})}),f}function l(){var u=4022871197,c=function(p){p=String(p);for(var d=0;d<p.length;d++){u+=p.charCodeAt(d);var f=.02519603282416938*u;u=f>>>0,f-=u,f*=u,u=f>>>0,f-=u,u+=f*4294967296}return(u>>>0)*23283064365386963e-26};return c}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.alea=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),Cle=Qn({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor128.js"(e,t){(function(n,r,s){function o(l){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},l===(l|0)?u.x=l:c+=l;for(var p=0;p<c.length+64;p++)u.x^=c.charCodeAt(p)|0,u.next()}function a(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function i(l,u){var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(typeof p=="object"&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xor128=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),Sle=Qn({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorwow.js"(e,t){(function(n,r,s){function o(l){var u=this,c="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(d^d<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:c+=l;for(var p=0;p<c.length+64;p++)u.x^=c.charCodeAt(p)|0,p==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function i(l,u){var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(typeof p=="object"&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xorwow=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),Nle=Qn({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorshift7.js"(e,t){(function(n,r,s){function o(l){var u=this;u.next=function(){var p=u.x,d=u.i,f,h,m;return f=p[d],f^=f>>>7,h=f^f<<24,f=p[d+1&7],h^=f^f>>>10,f=p[d+3&7],h^=f^f>>>3,f=p[d+4&7],h^=f^f<<7,f=p[d+7&7],f=f^f<<13,h^=f^f<<9,p[d]=h,u.i=d+1&7,h};function c(p,d){var f,h,m=[];if(d===(d|0))h=m[0]=d;else for(d=""+d,f=0;f<d.length;++f)m[f&7]=m[f&7]<<15^d.charCodeAt(f)+m[f+1&7]<<13;for(;m.length<8;)m.push(0);for(f=0;f<8&&m[f]===0;++f);for(f==8?h=m[7]=-1:h=m[f],p.x=m,p.i=0,f=256;f>0;--f)p.next()}c(u,l)}function a(l,u){return u.x=l.x.slice(),u.i=l.i,u}function i(l,u){l==null&&(l=+new Date);var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(p.x&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xorshift7=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),Tle=Qn({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor4096.js"(e,t){(function(n,r,s){function o(l){var u=this;u.next=function(){var p=u.w,d=u.X,f=u.i,h,m;return u.w=p=p+1640531527|0,m=d[f+34&127],h=d[f=f+1&127],m^=m<<13,h^=h<<17,m^=m>>>15,h^=h>>>12,m=d[f]=m^h,u.i=f,m+(p^p>>>16)|0};function c(p,d){var f,h,m,g,x,y=[],b=128;for(d===(d|0)?(h=d,d=null):(d=d+"\0",h=0,b=Math.max(b,d.length)),m=0,g=-32;g<b;++g)d&&(h^=d.charCodeAt((g+32)%d.length)),g===0&&(x=h),h^=h<<10,h^=h>>>15,h^=h<<4,h^=h>>>13,g>=0&&(x=x+1640531527|0,f=y[g&127]^=h+x,m=f==0?m+1:0);for(m>=128&&(y[(d&&d.length||0)&127]=-1),m=127,g=4*128;g>0;--g)h=y[m+34&127],f=y[m=m+1&127],h^=h<<13,f^=f<<17,h^=h>>>15,f^=f>>>12,y[m]=h^f;p.w=x,p.X=y,p.i=m}c(u,l)}function a(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function i(l,u){l==null&&(l=+new Date);var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(p.X&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.xor4096=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),_le=Qn({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/tychei.js"(e,t){(function(n,r,s){function o(l){var u=this,c="";u.next=function(){var d=u.b,f=u.c,h=u.d,m=u.a;return d=d<<25^d>>>7^f,f=f-h|0,h=h<<24^h>>>8^m,m=m-d|0,u.b=d=d<<20^d>>>12^f,u.c=f=f-h|0,u.d=h<<16^f>>>16^m,u.a=m-d|0},u.a=0,u.b=0,u.c=2654435769|0,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):c+=l;for(var p=0;p<c.length+20;p++)u.b^=c.charCodeAt(p)|0,u.next()}function a(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function i(l,u){var c=new o(l),p=u&&u.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,m=(f+h)/(1<<21);while(m===0);return m},d.int32=c.next,d.quick=d,p&&(typeof p=="object"&&a(p,c),d.state=function(){return a(c,{})}),d}r&&r.exports?r.exports=i:s&&s.amd?s(function(){return i}):this.tychei=i})(e,typeof t=="object"&&t,typeof define=="function"&&define)}}),Ele=Qn({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/seedrandom.js"(e,t){(function(n,r,s){var o=256,a=6,i=52,l="random",u=s.pow(o,a),c=s.pow(2,i),p=c*2,d=o-1,f;function h(v,w,k){var I=[];w=w==!0?{entropy:!0}:w||{};var N=y(x(w.entropy?[v,A(r)]:v==null?b():v,3),I),T=new m(I),_=function(){for(var R=T.g(a),S=u,F=0;R<c;)R=(R+F)*o,S*=o,F=T.g(1);for(;R>=p;)R/=2,S/=2,F>>>=1;return(R+F)/S};return _.int32=function(){return T.g(4)|0},_.quick=function(){return T.g(4)/4294967296},_.double=_,y(A(T.S),r),(w.pass||k||function(R,S,F,B){return B&&(B.S&&g(B,T),R.state=function(){return g(T,{})}),F?(s[l]=R,S):R})(_,N,"global"in w?w.global:this==s,w.state)}function m(v){var w,k=v.length,I=this,N=0,T=I.i=I.j=0,_=I.S=[];for(k||(v=[k++]);N<o;)_[N]=N++;for(N=0;N<o;N++)_[N]=_[T=d&T+v[N%k]+(w=_[N])],_[T]=w;(I.g=function(R){for(var S,F=0,B=I.i,W=I.j,q=I.S;R--;)S=q[B=d&B+1],F=F*o+q[d&(q[B]=q[W=d&W+S])+(q[W]=S)];return I.i=B,I.j=W,F})(o)}function g(v,w){return w.i=v.i,w.j=v.j,w.S=v.S.slice(),w}function x(v,w){var k=[],I=typeof v,N;if(w&&I=="object")for(N in v)try{k.push(x(v[N],w-1))}catch(T){}return k.length?k:I=="string"?v:v+"\0"}function y(v,w){for(var k=v+"",I,N=0;N<k.length;)w[d&N]=d&(I^=w[d&N]*19)+k.charCodeAt(N++);return A(w)}function b(){try{var v;return f&&(v=f.randomBytes)?v=v(o):(v=new Uint8Array(o),(n.crypto||n.msCrypto).getRandomValues(v)),A(v)}catch(I){var w=n.navigator,k=w&&w.plugins;return[+new Date,n,k,n.screen,A(r)]}}function A(v){return String.fromCharCode.apply(0,v)}if(y(s.random(),r),typeof t=="object"&&t.exports){t.exports=h;try{f=uP()}catch(v){}}else typeof define=="function"&&define.amd?define(function(){return h}):s["seed"+l]=h})(typeof self!="undefined"?self:e,[],Math)}}),pP=Qn({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/index.js"(e,t){var n=Ile(),r=Cle(),s=Sle(),o=Nle(),a=Tle(),i=_le(),l=Ele();l.alea=n,l.xor128=r,l.xorwow=s,l.xorshift7=o,l.xor4096=a,l.tychei=i,t.exports=l}}),dP=Qn({"(disabled):node_modules/.pnpm/string_decoder@1.1.1/node_modules/string_decoder/lib/string_decoder.js"(){}}),D1=Qn({"(disabled):path"(){}}),Rle=Qn({"(disabled):worker_threads"(){}}),Dle=Qn({"(disabled):perf_hooks"(){}}),$le=Qn({"node_modules/.pnpm/@tensorflow+tfjs-backend-wasm@3.9.0_@tensorflow+tfjs-core@3.9.0/node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js"(e,t){var n=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(s){s=s||{};function o(){return re.buffer!=it&&Pn(re.buffer),Zn}function a(){return re.buffer!=it&&Pn(re.buffer),Dt}function i(){return re.buffer!=it&&Pn(re.buffer),Vr}function l(){return re.buffer!=it&&Pn(re.buffer),_n}function u(){return re.buffer!=it&&Pn(re.buffer),Ar}var c=typeof s!="undefined"?s:{},p,d;c.ready=new Promise(function(P,j){p=P,d=j});var f={},h;for(h in c)c.hasOwnProperty(h)&&(f[h]=c[h]);var m=[],g="./this.program",x=function(P,j){throw j},y=!1,b=!1,A=!1,v=!1;y=typeof window=="object",b=typeof importScripts=="function",A=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=!y&&!A&&!b;var w=c.ENVIRONMENT_IS_PTHREAD||!1;w&&(it=c.buffer);var k="";function I(P){return c.locateFile?c.locateFile(P,k):k+P}var N,T,_,R,S,F;if(A){b?k=D1().dirname(k)+"/":k=__dirname+"/",N=function(j,oe){return S||(S=ig("fs")),F||(F=D1()),j=F.normalize(j),S.readFileSync(j,oe?null:"utf8")},_=function(j){var oe=N(j,!0);return oe.buffer||(oe=new Uint8Array(oe)),xe(oe.buffer),oe},process.argv.length>1&&(g=process.argv[1].replace(/\\/g,"/")),m=process.argv.slice(2),process.on("uncaughtException",function(P){if(!(P instanceof S1))throw P}),process.on("unhandledRejection",Fl),x=function(P){process.exit(P)},c.inspect=function(){return"[Emscripten Module object]"};var B;try{B=Rle()}catch(P){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),P}global.Worker=B.Worker}else v?(typeof read!="undefined"&&(N=function(j){return read(j)}),_=function(j){var oe;return typeof readbuffer=="function"?new Uint8Array(readbuffer(j)):(oe=read(j,"binary"),xe(typeof oe=="object"),oe)},typeof scriptArgs!="undefined"?m=scriptArgs:typeof arguments!="undefined"&&(m=arguments),typeof quit=="function"&&(x=function(P){quit(P)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(y||b)&&(b?k=self.location.href:typeof document!="undefined"&&document.currentScript&&(k=document.currentScript.src),typeof r!="undefined"&&r&&(k=r),k.indexOf("blob:")!==0?k=k.substr(0,k.lastIndexOf("/")+1):k="",A?(N=function(j,oe){return S||(S=ig("fs")),F||(F=D1()),j=F.normalize(j),S.readFileSync(j,oe?null:"utf8")},_=function(j){var oe=N(j,!0);return oe.buffer||(oe=new Uint8Array(oe)),xe(oe.buffer),oe}):(N=function(P){var j=new XMLHttpRequest;return j.open("GET",P,!1),j.send(null),j.responseText},b&&(_=function(P){var j=new XMLHttpRequest;return j.open("GET",P,!1),j.responseType="arraybuffer",j.send(null),new Uint8Array(j.response)}),T=function(P,j,oe){var ge=new XMLHttpRequest;ge.open("GET",P,!0),ge.responseType="arraybuffer",ge.onload=function(){if(ge.status==200||ge.status==0&&ge.response){j(ge.response);return}oe()},ge.onerror=oe,ge.send(null)}),R=function(P){document.title=P});A&&typeof performance=="undefined"&&(global.performance=Dle().performance);var W=c.print||console.log.bind(console),q=c.printErr||console.warn.bind(console);for(h in f)f.hasOwnProperty(h)&&(c[h]=f[h]);f=null,c.arguments&&(m=c.arguments),c.thisProgram&&(g=c.thisProgram),c.quit&&(x=c.quit);var K=Atomics.load,J=Atomics.store,Q=Atomics.compareExchange,ee;c.wasmBinary&&(ee=c.wasmBinary);var ue=c.noExitRuntime||!0;typeof WebAssembly!="object"&&Fl("no native wasm support detected");var re,de,fe=!1,me;function xe(P,j){P||Fl("Assertion failed: "+j)}function Ne(P){var j=c["_"+P];return xe(j,"Cannot call unknown function "+P+", make sure it is exported"),j}function _e(P,j,oe,ge,We){var Le={string:function(Ms){var ag=0;if(Ms!=null&&Ms!==0){var oP=(Ms.length<<2)+1;ag=rg(oP),ft(Ms,ag,oP)}return ag},array:function(Ms){var ag=rg(Ms.length);return ct(Ms,ag),ag}};function Be(Ms){return j==="string"?He(Ms):j==="boolean"?Boolean(Ms):Ms}var tt=Ne(P),xn=[],ss=0;if(ge)for(var Wr=0;Wr<ge.length;Wr++){var Tc=Le[oe[Wr]];Tc?(ss===0&&(ss=C1()),xn[Wr]=Tc(ge[Wr])):xn[Wr]=ge[Wr]}var og=tt.apply(null,xn);return og=Be(og),ss!==0&&ng(ss),og}function Oe(P,j,oe,ge){oe=oe||[];var We=oe.every(function(Be){return Be==="number"}),Le=j!=="string";return Le&&We&&!ge?Ne(P):function(){return _e(P,j,oe,arguments,ge)}}function Ve(P,j,oe){for(var ge=j+oe,We="";!(j>=ge);){var Le=P[j++];if(!Le)return We;if(!(Le&128)){We+=String.fromCharCode(Le);continue}var Be=P[j++]&63;if((Le&224)==192){We+=String.fromCharCode((Le&31)<<6|Be);continue}var tt=P[j++]&63;if((Le&240)==224?Le=(Le&15)<<12|Be<<6|tt:Le=(Le&7)<<18|Be<<12|tt<<6|P[j++]&63,Le<65536)We+=String.fromCharCode(Le);else{var xn=Le-65536;We+=String.fromCharCode(55296|xn>>10,56320|xn&1023)}}return We}function He(P,j){return P?Ve(a(),P,j):""}function At(P,j,oe,ge){if(!(ge>0))return 0;for(var We=oe,Le=oe+ge-1,Be=0;Be<P.length;++Be){var tt=P.charCodeAt(Be);if(tt>=55296&&tt<=57343){var xn=P.charCodeAt(++Be);tt=65536+((tt&1023)<<10)|xn&1023}if(tt<=127){if(oe>=Le)break;j[oe++]=tt}else if(tt<=2047){if(oe+1>=Le)break;j[oe++]=192|tt>>6,j[oe++]=128|tt&63}else if(tt<=65535){if(oe+2>=Le)break;j[oe++]=224|tt>>12,j[oe++]=128|tt>>6&63,j[oe++]=128|tt&63}else{if(oe+3>=Le)break;j[oe++]=240|tt>>18,j[oe++]=128|tt>>12&63,j[oe++]=128|tt>>6&63,j[oe++]=128|tt&63}}return j[oe]=0,oe-We}function ft(P,j,oe){return At(P,a(),j,oe)}function dt(P){for(var j=0,oe=0;oe<P.length;++oe){var ge=P.charCodeAt(oe);ge>=55296&&ge<=57343&&(ge=65536+((ge&1023)<<10)|P.charCodeAt(++oe)&1023),ge<=127?++j:ge<=2047?j+=2:ge<=65535?j+=3:j+=4}return j}function ct(P,j){o().set(P,j)}function mt(P,j){return P%j>0&&(P+=j-P%j),P}var it,Zn,Dt,Yn,cn,Vr,_n,hr,Ar;function Pn(P){it=P,c.HEAP8=Zn=new Int8Array(P),c.HEAP16=Yn=new Int16Array(P),c.HEAP32=Vr=new Int32Array(P),c.HEAPU8=Dt=new Uint8Array(P),c.HEAPU16=cn=new Uint16Array(P),c.HEAPU32=_n=new Uint32Array(P),c.HEAPF32=hr=new Float32Array(P),c.HEAPF64=Ar=new Float64Array(P)}var vr=c.INITIAL_MEMORY||16777216;if(w)re=c.wasmMemory,it=c.buffer;else if(c.wasmMemory)re=c.wasmMemory;else if(re=new WebAssembly.Memory({initial:vr/65536,maximum:2147483648/65536,shared:!0}),!(re.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),A&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");re&&(it=re.buffer),vr=it.byteLength,Pn(it);var rs,ys=[],Oo=[],di=[],ca=[],kc=[],_a=!1,Sv=!1;w||Oo.push({func:function(){Vv()}});function YS(){if(!w){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)Tv(c.preRun.shift());Jm(ys)}}function g1(){_a=!0,!w&&Jm(Oo)}function JS(){w||Jm(di)}function Nv(){w||(Sv=!0)}function ho(){if(!w){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)QS(c.postRun.shift());Jm(kc)}}function Tv(P){ys.unshift(P)}function QS(P){kc.unshift(P)}var $l=0,Ic=null,$d=null;function eN(P){xe(!w,"addRunDependency cannot be used in a pthread worker"),$l++,c.monitorRunDependencies&&c.monitorRunDependencies($l)}function tN(P){if($l--,c.monitorRunDependencies&&c.monitorRunDependencies($l),$l==0&&(Ic!==null&&(clearInterval(Ic),Ic=null),$d)){var j=$d;$d=null,j()}}c.preloadedImages={},c.preloadedAudios={};function Fl(P){c.onAbort&&c.onAbort(P),w&&console.error("Pthread aborting at "+new Error().stack),P+="",q(P),fe=!0,me=1,P="abort("+P+"). Build with -s ASSERTIONS=1 for more info.";var j=new WebAssembly.RuntimeError(P);throw d(j),j}function _v(P,j){return String.prototype.startsWith?P.startsWith(j):P.indexOf(j)===0}var Ym="data:application/octet-stream;base64,";function Ev(P){return _v(P,Ym)}var nN="file://";function Rv(P){return _v(P,nN)}var mo="tfjs-backend-wasm-threaded-simd.wasm";Ev(mo)||(mo=I(mo));function Dv(P){try{if(P==mo&&ee)return new Uint8Array(ee);if(_)return _(P);throw"both async and sync fetching of the wasm failed"}catch(j){Fl(j)}}function rN(){if(!ee&&(y||b)){if(typeof fetch=="function"&&!Rv(mo))return fetch(mo,{credentials:"same-origin"}).then(function(P){if(!P.ok)throw"failed to load wasm binary file at '"+mo+"'";return P.arrayBuffer()}).catch(function(){return Dv(mo)});if(T)return new Promise(function(P,j){T(mo,function(oe){P(new Uint8Array(oe))},j)})}return Promise.resolve().then(function(){return Dv(mo)})}function sN(){var P={a:KN};function j(Be,tt){var xn=Be.exports;if(c.asm=xn,rs=c.asm.F,de=tt,!w){var ss=lt.unusedWorkers.length;lt.unusedWorkers.forEach(function(Wr){lt.loadWasmModuleToWorker(Wr,function(){--ss||tN("wasm-instantiate")})})}}w||eN("wasm-instantiate");function oe(Be){j(Be.instance,Be.module)}function ge(Be){return rN().then(function(tt){return WebAssembly.instantiate(tt,P)}).then(Be,function(tt){q("failed to asynchronously prepare wasm: "+tt),Fl(tt)})}function We(){return!ee&&typeof WebAssembly.instantiateStreaming=="function"&&!Ev(mo)&&!Rv(mo)&&typeof fetch=="function"?fetch(mo,{credentials:"same-origin"}).then(function(Be){var tt=WebAssembly.instantiateStreaming(Be,P);return tt.then(oe,function(xn){return q("wasm streaming compile failed: "+xn),q("falling back to ArrayBuffer instantiation"),ge(oe)})}):ge(oe)}if(c.instantiateWasm)try{var Le=c.instantiateWasm(P,j);return Le}catch(Be){return q("Module.instantiateWasm callback failed with error: "+Be),!1}return We().catch(d),{}}var oN={10024:function(){throw"Canceled!"},10042:function(P,j){setTimeout(function(){QO(P,j)},0)}};function $v(){lt.initRuntime()}function Jm(P){for(;P.length>0;){var j=P.shift();if(typeof j=="function"){j(c);continue}var oe=j.func;typeof oe=="number"?j.arg===void 0?rs.get(oe)():rs.get(oe)(j.arg):oe(j.arg===void 0?null:j.arg)}}function x1(P,j){if(P<=0||P>o().length||P&!0||j<0)return-28;if(j==0)return 0;j>=2147483647&&(j=1/0);var oe=Atomics.load(i(),sg>>2),ge=0;if(oe==P){var We=Atomics.compareExchange(i(),sg>>2,oe,0);if(We==oe&&(--j,ge=1,j<=0))return 1}var Le=Atomics.notify(i(),P>>2,j);if(Le>=0)return Le+ge;throw"Atomics.notify returned an unexpected value "+Le}c._emscripten_futex_wake=x1;function aN(P){if(w)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!P)throw"Internal Error! Null pthread_ptr in killThread!";i()[P+12>>2]=0;var j=lt.pthreads[P];j.worker.terminate(),lt.freeThreadData(j),lt.runningWorkers.splice(lt.runningWorkers.indexOf(j.worker),1),j.worker.pthread=void 0}function iN(P){if(w)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!P)throw"Internal Error! Null pthread_ptr in cancelThread!";var j=lt.pthreads[P];j.worker.postMessage({cmd:"cancel"})}function lN(P){if(w)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!P)throw"Internal Error! Null pthread_ptr in cleanupThread!";var j=lt.pthreads[P];if(j){i()[P+12>>2]=0;var oe=j.worker;lt.returnWorkerToPool(oe)}}var lt={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var P=Math.min(4,Math.max(1,(navigator.hardwareConcurrency||1)/2)),j=0;j<P;++j)lt.allocateUnusedWorker()},initRuntime:function(){for(var P=Od(228),j=0;j<228/4;++j)l()[P/4+j]=0;i()[P+12>>2]=P;var oe=P+152;i()[oe>>2]=oe;for(var ge=Od(512),j=0;j<128;++j)l()[ge/4+j]=0;Atomics.store(l(),P+100>>2,ge),Atomics.store(l(),P+40>>2,P),vT(P,!b,1),JO(P)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;lt.threadExitHandlers.length>0;)lt.threadExitHandlers.pop()();w&&tg()&&YO()},runExitHandlersAndDeinitThread:function(P,j){Atomics.store(l(),P+56>>2,1),Atomics.store(l(),P+60>>2,0),lt.runExitHandlers(),Atomics.store(l(),P+4>>2,j),Atomics.store(l(),P+0>>2,1),x1(P+0,2147483647),vT(0,0,0)},threadExit:function(P){var j=tg();j&&(lt.runExitHandlersAndDeinitThread(j,P),w&&postMessage({cmd:"exit"}))},threadCancel:function(){lt.runExitHandlersAndDeinitThread(tg(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var P in lt.pthreads){var j=lt.pthreads[P];j&&j.worker&&lt.returnWorkerToPool(j.worker)}lt.pthreads={};for(var oe=0;oe<lt.unusedWorkers.length;++oe){var ge=lt.unusedWorkers[oe];ge.terminate()}lt.unusedWorkers=[];for(var oe=0;oe<lt.runningWorkers.length;++oe){var ge=lt.runningWorkers[oe],j=ge.pthread;lt.freeThreadData(j),ge.terminate()}lt.runningWorkers=[]},freeThreadData:function(P){if(!!P){if(P.threadInfoStruct){var j=i()[P.threadInfoStruct+100>>2];i()[P.threadInfoStruct+100>>2]=0,I1(j),I1(P.threadInfoStruct)}P.threadInfoStruct=0,P.allocatedOwnStack&&P.stackBase&&I1(P.stackBase),P.stackBase=0,P.worker&&(P.worker.pthread=null)}},returnWorkerToPool:function(P){lt.runWithoutMainThreadQueuedCalls(function(){delete lt.pthreads[P.pthread.threadInfoStruct],lt.unusedWorkers.push(P),lt.runningWorkers.splice(lt.runningWorkers.indexOf(P),1),lt.freeThreadData(P.pthread),P.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(P){i()[sP>>2]=0;try{P()}finally{i()[sP>>2]=1}},receiveObjectTransfer:function(P){},loadWasmModuleToWorker:function(P,j){P.onmessage=function(oe){var ge=oe.data,We=ge.cmd;if(P.pthread&&(lt.currentProxiedOperationCallerThread=P.pthread.threadInfoStruct),ge.targetThread&&ge.targetThread!=tg()){var Le=lt.pthreads[ge.targetThread];Le?Le.worker.postMessage(oe.data,ge.transferList):console.error('Internal error! Worker sent a message "'+We+'" to target pthread '+ge.targetThread+", but that thread no longer exists!"),lt.currentProxiedOperationCallerThread=void 0;return}if(We==="processQueuedMainThreadWork")bT();else if(We==="spawnThread")Lv(oe.data);else if(We==="cleanupThread")lN(ge.thread);else if(We==="killThread")aN(ge.thread);else if(We==="cancelThread")iN(ge.thread);else if(We==="loaded")P.loaded=!0,j&&j(P),P.runPthread&&(P.runPthread(),delete P.runPthread);else if(We==="print")W("Thread "+ge.threadId+": "+ge.text);else if(We==="printErr")q("Thread "+ge.threadId+": "+ge.text);else if(We==="alert")alert("Thread "+ge.threadId+": "+ge.text);else if(We==="exit"){var Be=P.pthread&&Atomics.load(l(),P.pthread.threadInfoStruct+64>>2);Be&&lt.returnWorkerToPool(P)}else if(We==="exitProcess")try{tle(ge.returnCode)}catch(tt){if(tt instanceof S1)return;throw tt}else We==="cancelDone"?lt.returnWorkerToPool(P):We==="objectTransfer"?lt.receiveObjectTransfer(oe.data):oe.data.target==="setimmediate"?P.postMessage(oe.data):q("worker sent an unknown command "+We);lt.currentProxiedOperationCallerThread=void 0},P.onerror=function(oe){q("pthread sent an error! "+oe.filename+":"+oe.lineno+": "+oe.message)},A&&(P.on("message",function(oe){P.onmessage({data:oe})}),P.on("error",function(oe){P.onerror(oe)}),P.on("exit",function(oe){})),P.postMessage({cmd:"load",urlOrBlob:c.mainScriptUrlOrBlob||r,wasmMemory:re,wasmModule:de})},allocateUnusedWorker:function(){var P=I("tfjs-backend-wasm-threaded-simd.worker.js");lt.unusedWorkers.push(new Worker(P))},getNewWorker:function(){return lt.unusedWorkers.length==0&&(lt.allocateUnusedWorker(),lt.loadWasmModuleToWorker(lt.unusedWorkers[0])),lt.unusedWorkers.length>0?lt.unusedWorkers.pop():null},busySpinWait:function(P){for(var j=performance.now()+P;performance.now()<j;);}};function uN(P,j){nP(P,j),ng(P)}c.establishStackSpace=uN;function cN(){return ue}c.getNoExitRuntime=cN;function pN(P,j){return rs.get(P)(j)}c.invokeEntryPoint=pN;function dN(P,j,oe,ge){Fl("Assertion failed: "+He(P)+", at: "+[j?He(j):"unknown filename",oe,ge?He(ge):"unknown function"])}function fN(P,j){var oe=_main(P,j)}var Fd;A?Fd=function(){var P=process.hrtime();return P[0]*1e3+P[1]/1e6}:w?Fd=function(){return performance.now()-c.__performance_now_clock_drift}:typeof dateNow!="undefined"?Fd=dateNow:Fd=function(){return performance.now()};function hN(P){return i()[XO()>>2]=P,P}function mN(P,j){if(w)return Cc(1,1,P,j)}function gN(P,j){if(P==j)postMessage({cmd:"processQueuedMainThreadWork"});else if(w)postMessage({targetThread:P,cmd:"processThreadQueue"});else{var oe=lt.pthreads[P],ge=oe&&oe.worker;if(!ge)return;ge.postMessage({cmd:"processThreadQueue"})}return 1}function xN(){Fl()}function yN(P,j,oe){var ge=kN(j,oe);return oN[P].apply(null,ge)}function bN(P,j){}function AN(P,j,oe){if(P<=0||P>o().length||P&!0)return-28;if(y){if(Atomics.load(i(),P>>2)!=j)return-6;for(var We=performance.now(),Le=We+oe,Be=Atomics.exchange(i(),sg>>2,P);;){if(We=performance.now(),We>Le)return Be=Atomics.exchange(i(),sg>>2,0),-73;if(Be=Atomics.exchange(i(),sg>>2,0),Be==0)break;if(bT(),Atomics.load(i(),P>>2)!=j)return-6;Be=Atomics.exchange(i(),sg>>2,P)}return 0}else{var ge=Atomics.wait(i(),P>>2,j,oe);if(ge==="timed-out")return-73;if(ge==="not-equal")return-6;if(ge==="ok")return 0;throw"Atomics.wait returned an unexpected value "+ge}}function vN(P,j,oe){a().copyWithin(P,j,j+oe)}function wN(){return A?ig("os").cpus().length:navigator.hardwareConcurrency}function Cc(P,j){for(var oe=arguments.length-2,ge=C1(),We=oe,Le=rg(We*8),Be=Le>>3,tt=0;tt<oe;tt++){var xn=arguments[2+tt];u()[Be+tt]=xn}var ss=tP(P,We,Le,j);return ng(ge),ss}var y1=[],b1=[];function kN(P,j){b1.length=0;var oe;for(j>>=2;oe=a()[P++];){var ge=oe<105;ge&&j&1&&j++,b1.push(ge?u()[j++>>1]:i()[j]),++j}return b1}function IN(P,j,oe){y1.length=j;for(var ge=oe>>3,We=0;We<j;We++)y1[We]=u()[ge+We];var Le=P<0,Be=Le?oN[-P-1]:qN[P];return Be.apply(null,y1)}function CN(){return a().length}function SN(P){try{return re.grow(P-it.byteLength+65535>>>16),Pn(re.buffer),1}catch(j){}}function NN(P){var j=CN();if(P<=j)return!1;var oe=2147483648;if(P>oe)return!1;for(var ge=1;ge<=4;ge*=2){var We=j*(1+.2/ge);We=Math.min(We,P+100663296);var Le=Math.min(oe,mt(Math.max(P,We),65536)),Be=SN(Le);if(Be)return!0}return!1}var zt={inEventHandler:0,removeAllEventListeners:function(){for(var P=zt.eventHandlers.length-1;P>=0;--P)zt._removeHandler(P);zt.eventHandlers=[],zt.deferredCalls=[]},registerRemoveEventListeners:function(){zt.removeEventListenersRegistered||(ca.push(zt.removeAllEventListeners),zt.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(P,j,oe){function ge(Be,tt){if(Be.length!=tt.length)return!1;for(var xn in Be)if(Be[xn]!=tt[xn])return!1;return!0}for(var We in zt.deferredCalls){var Le=zt.deferredCalls[We];if(Le.targetFunction==P&&ge(Le.argsList,oe))return}zt.deferredCalls.push({targetFunction:P,precedence:j,argsList:oe}),zt.deferredCalls.sort(function(Be,tt){return Be.precedence<tt.precedence})},removeDeferredCalls:function(P){for(var j=0;j<zt.deferredCalls.length;++j)zt.deferredCalls[j].targetFunction==P&&(zt.deferredCalls.splice(j,1),--j)},canPerformEventHandlerRequests:function(){return zt.inEventHandler&&zt.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!zt.canPerformEventHandlerRequests())for(var P=0;P<zt.deferredCalls.length;++P){var j=zt.deferredCalls[P];zt.deferredCalls.splice(P,1),--P,j.targetFunction.apply(null,j.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(P,j){for(var oe=0;oe<zt.eventHandlers.length;++oe)zt.eventHandlers[oe].target==P&&(!j||j==zt.eventHandlers[oe].eventTypeString)&&zt._removeHandler(oe--)},_removeHandler:function(P){var j=zt.eventHandlers[P];j.target.removeEventListener(j.eventTypeString,j.eventListenerFunc,j.useCapture),zt.eventHandlers.splice(P,1)},registerOrRemoveHandler:function(P){var j=function(We){++zt.inEventHandler,zt.currentEventHandler=P,zt.runDeferredCalls(),P.handlerFunc(We),zt.runDeferredCalls(),--zt.inEventHandler};if(P.callbackfunc)P.eventListenerFunc=j,P.target.addEventListener(P.eventTypeString,j,P.useCapture),zt.eventHandlers.push(P),zt.registerRemoveEventListeners();else for(var oe=0;oe<zt.eventHandlers.length;++oe)zt.eventHandlers[oe].target==P.target&&zt.eventHandlers[oe].eventTypeString==P.eventTypeString&&zt._removeHandler(oe--)},queueEventHandlerOnThread_iiii:function(P,j,oe,ge,We){var Le=C1(),Be=rg(12);i()[Be>>2]=oe,i()[Be+4>>2]=ge,i()[Be+8>>2]=We,AT(0,P,637534208,j,ge,Be),ng(Le)},getTargetThreadForEventCallback:function(P){switch(P){case 1:return 0;case 2:return lt.currentProxiedOperationCallerThread;default:return P}},getNodeNameForTarget:function(P){return P?P==window?"#window":P==screen?"#screen":P&&P.nodeName?P.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function TN(P){var j=dt(P)+1,oe=Od(j);return ft(P,oe,j),oe}function _N(P,j,oe,ge){var We=C1(),Le=rg(12),Be=0;j&&(Be=TN(j)),i()[Le>>2]=Be,i()[Le+4>>2]=oe,i()[Le+8>>2]=ge,AT(0,P,657457152,0,Be,Le),ng(We)}function EN(P,j,oe,ge){j=j?He(j):"",_N(P,j,oe,ge)}function RN(P){return P>2?He(P):P}var DN=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function $N(P){P=RN(P);var j=DN[P]||(typeof document!="undefined"?document.querySelector(P):void 0);return j}function A1(P){return $N(P)}function Fv(P,j,oe){var ge=A1(P);if(!ge)return-4;if(ge.canvasSharedPtr&&(i()[ge.canvasSharedPtr>>2]=j,i()[ge.canvasSharedPtr+4>>2]=oe),ge.offscreenCanvas||!ge.controlTransferredOffscreen){ge.offscreenCanvas&&(ge=ge.offscreenCanvas);var We=!1;if(ge.GLctxObject&&ge.GLctxObject.GLctx){var Le=ge.GLctxObject.GLctx.getParameter(2978);We=Le[0]===0&&Le[1]===0&&Le[2]===ge.width&&Le[3]===ge.height}ge.width=j,ge.height=oe,We&&ge.GLctxObject.GLctx.viewport(0,0,j,oe)}else if(ge.canvasSharedPtr){var Be=i()[ge.canvasSharedPtr+8>>2];return EN(Be,P,j,oe),1}else return-4;return 0}function Ov(P,j,oe){return w?Cc(2,1,P,j,oe):Fv(P,j,oe)}function FN(P,j,oe){var ge=A1(P);return ge?Fv(P,j,oe):Ov(P,j,oe)}function ON(P){}function PN(P,j){}function MN(P){var j=P.getExtension("ANGLE_instanced_arrays");if(j)return P.vertexAttribDivisor=function(oe,ge){j.vertexAttribDivisorANGLE(oe,ge)},P.drawArraysInstanced=function(oe,ge,We,Le){j.drawArraysInstancedANGLE(oe,ge,We,Le)},P.drawElementsInstanced=function(oe,ge,We,Le,Be){j.drawElementsInstancedANGLE(oe,ge,We,Le,Be)},1}function zN(P){var j=P.getExtension("OES_vertex_array_object");if(j)return P.createVertexArray=function(){return j.createVertexArrayOES()},P.deleteVertexArray=function(oe){j.deleteVertexArrayOES(oe)},P.bindVertexArray=function(oe){j.bindVertexArrayOES(oe)},P.isVertexArray=function(oe){return j.isVertexArrayOES(oe)},1}function LN(P){var j=P.getExtension("WEBGL_draw_buffers");if(j)return P.drawBuffers=function(oe,ge){j.drawBuffersWEBGL(oe,ge)},1}function BN(P){return!!(P.multiDrawWebgl=P.getExtension("WEBGL_multi_draw"))}var pn={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function(j){pn.lastError||(pn.lastError=j)},getNewId:function(P){for(var j=pn.counter++,oe=P.length;oe<j;oe++)P[oe]=null;return j},getSource:function(P,j,oe,ge){for(var We="",Le=0;Le<j;++Le){var Be=ge?i()[ge+Le*4>>2]:-1;We+=He(i()[oe+Le*4>>2],Be<0?void 0:Be)}return We},createContext:function(P,j){var oe=P.getContext("webgl",j);if(!oe)return 0;var ge=pn.registerContext(oe,j);return ge},registerContext:function(P,j){var oe=Od(8);i()[oe+4>>2]=tg();var ge={handle:oe,attributes:j,version:j.majorVersion,GLctx:P};return P.canvas&&(P.canvas.GLctxObject=ge),pn.contexts[oe]=ge,(typeof j.enableExtensionsByDefault=="undefined"||j.enableExtensionsByDefault)&&pn.initExtensions(ge),oe},makeContextCurrent:function(P){return pn.currentContext=pn.contexts[P],c.ctx=Sc=pn.currentContext&&pn.currentContext.GLctx,!(P&&!Sc)},getContext:function(P){return pn.contexts[P]},deleteContext:function(P){pn.currentContext===pn.contexts[P]&&(pn.currentContext=null),typeof zt=="object"&&zt.removeAllHandlersOnTarget(pn.contexts[P].GLctx.canvas),pn.contexts[P]&&pn.contexts[P].GLctx.canvas&&(pn.contexts[P].GLctx.canvas.GLctxObject=void 0),I1(pn.contexts[P].handle),pn.contexts[P]=null},initExtensions:function(P){if(P||(P=pn.currentContext),!P.initExtensionsDone){P.initExtensionsDone=!0;var j=P.GLctx;MN(j),zN(j),LN(j),j.disjointTimerQueryExt=j.getExtension("EXT_disjoint_timer_query"),BN(j);var oe=j.getSupportedExtensions()||[];oe.forEach(function(ge){ge.indexOf("lose_context")<0&&ge.indexOf("debug")<0&&j.getExtension(ge)})}},populateUniformTable:function(P){for(var j=pn.programs[P],oe=pn.programInfos[P]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},ge=oe.uniforms,We=Sc.getProgramParameter(j,35718),Le=0;Le<We;++Le){var Be=Sc.getActiveUniform(j,Le),tt=Be.name;oe.maxUniformLength=Math.max(oe.maxUniformLength,tt.length+1),tt.slice(-1)=="]"&&(tt=tt.slice(0,tt.lastIndexOf("[")));var xn=Sc.getUniformLocation(j,tt);if(xn){var ss=pn.getNewId(pn.uniforms);ge[tt]=[Be.size,ss],pn.uniforms[ss]=xn;for(var Wr=1;Wr<Be.size;++Wr){var Tc=tt+"["+Wr+"]";xn=Sc.getUniformLocation(j,Tc),ss=pn.getNewId(pn.uniforms),pn.uniforms[ss]=xn}}}}},VN=["default","low-power","high-performance"];function WN(P,j){var oe=j>>2,ge=i()[oe+(24>>2)],We={alpha:!!i()[oe+(0>>2)],depth:!!i()[oe+(4>>2)],stencil:!!i()[oe+(8>>2)],antialias:!!i()[oe+(12>>2)],premultipliedAlpha:!!i()[oe+(16>>2)],preserveDrawingBuffer:!!i()[oe+(20>>2)],powerPreference:VN[ge],failIfMajorPerformanceCaveat:!!i()[oe+(28>>2)],majorVersion:i()[oe+(32>>2)],minorVersion:i()[oe+(36>>2)],enableExtensionsByDefault:i()[oe+(40>>2)],explicitSwapControl:i()[oe+(44>>2)],proxyContextToMainThread:i()[oe+(48>>2)],renderViaOffscreenBackBuffer:i()[oe+(52>>2)]},Le=A1(P);if(!Le||We.explicitSwapControl)return 0;var Be=pn.createContext(Le,We);return Be}function GN(P,j){return WN(P,j)}var Qm={mappings:{},buffers:[null,[],[]],printChar:function(P,j){var oe=Qm.buffers[P];j===0||j===10?((P===1?W:q)(Ve(oe,0)),oe.length=0):oe.push(j)},varargs:void 0,get:function(){Qm.varargs+=4;var P=i()[Qm.varargs-4>>2];return P},getStr:function(P){var j=He(P);return j},get64:function(P,j){return P}};function Pv(P){return w?Cc(3,1,P):0}function Mv(P,j,oe,ge,We){if(w)return Cc(4,1,P,j,oe,ge,We)}function zv(P,j,oe,ge){if(w)return Cc(5,1,P,j,oe,ge);for(var We=0,Le=0;Le<oe;Le++){for(var Be=i()[j+Le*8>>2],tt=i()[j+(Le*8+4)>>2],xn=0;xn<tt;xn++)Qm.printChar(P,a()[Be+xn]);We+=tt}return i()[ge>>2]=We,0}function UN(P){var j=lt.threadExitHandlers.pop();P&&j()}function jN(P,j){lt.threadExitHandlers.push(function(){rs.get(P)(j)})}function Lv(P){if(w)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var j=lt.getNewWorker();if(j.pthread!==void 0)throw"Internal error!";if(!P.pthread_ptr)throw"Internal error, no pthread ptr!";lt.runningWorkers.push(j);for(var oe=Od(128*4),ge=0;ge<128;++ge)i()[oe+ge*4>>2]=0;var We=P.stackBase+P.stackSize,Le=lt.pthreads[P.pthread_ptr]={worker:j,stackBase:P.stackBase,stackSize:P.stackSize,allocatedOwnStack:P.allocatedOwnStack,threadInfoStruct:P.pthread_ptr},Be=Le.threadInfoStruct>>2;Atomics.store(l(),Be+(64>>2),P.detached),Atomics.store(l(),Be+(100>>2),oe),Atomics.store(l(),Be+(40>>2),Le.threadInfoStruct),Atomics.store(l(),Be+(80>>2),P.stackSize),Atomics.store(l(),Be+(76>>2),We),Atomics.store(l(),Be+(104>>2),P.stackSize),Atomics.store(l(),Be+(104+8>>2),We),Atomics.store(l(),Be+(104+12>>2),P.detached);var tt=ZO(),xn=tt+40;Atomics.store(l(),Be+(172>>2),xn),j.pthread=Le;var ss={cmd:"run",start_routine:P.startRoutine,arg:P.arg,threadInfoStruct:P.pthread_ptr,stackBase:P.stackBase,stackSize:P.stackSize};j.runPthread=function(){ss.time=performance.now(),j.postMessage(ss,P.transferList)},j.loaded&&(j.runPthread(),delete j.runPthread)}function HN(P,j,oe,ge){if(typeof SharedArrayBuffer=="undefined")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!P)return q("pthread_create called with a null thread pointer!"),28;var We=[],Le=0;if(w&&(We.length===0||Le))return eP(687865856,P,j,oe,ge);if(Le)return Le;var Be=0,tt=0,xn=0;j&&j!=-1?(Be=i()[j>>2],Be+=81920,tt=i()[j+8>>2],xn=i()[j+12>>2]!==0):Be=2097152;var ss=tt==0;ss?tt=rP(16,Be):(tt-=Be,xe(tt>0));for(var Wr=Od(228),Tc=0;Tc<228>>2;++Tc)l()[(Wr>>2)+Tc]=0;i()[P>>2]=Wr,i()[Wr+12>>2]=Wr;var og=Wr+152;i()[og>>2]=og;var Ms={stackBase:tt,stackSize:Be,allocatedOwnStack:ss,detached:xn,startRoutine:oe,pthread_ptr:Wr,arg:ge,transferList:We};return w?(Ms.cmd="spawnThread",postMessage(Ms,We)):Lv(Ms),0}function Bv(P){if(w)return Cc(6,1,P);switch(P){case 30:return 16384;case 85:var j=2147483648;return j/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return hN(28),-1}w||lt.initMainThreadBlock();var Sc,qN=[null,mN,Ov,Pv,Mv,zv,Bv],KN={e:dN,r:fN,x:gN,b:xN,y:yN,j:bN,c:AN,d:x1,f:Fd,p:vN,z:wN,u:IN,q:NN,v:FN,i:ON,t:PN,w:GN,m:Pv,n:Mv,g:zv,o:$v,a:re||c.wasmMemory,k:UN,l:jN,h:HN,s:Bv},KO=sN(),Vv=c.___wasm_call_ctors=function(){return(Vv=c.___wasm_call_ctors=c.asm.A).apply(null,arguments)},XN=c._init=function(){return(XN=c._init=c.asm.B).apply(null,arguments)},ZN=c._register_tensor=function(){return(ZN=c._register_tensor=c.asm.C).apply(null,arguments)},YN=c._dispose_data=function(){return(YN=c._dispose_data=c.asm.D).apply(null,arguments)},JN=c._dispose=function(){return(JN=c._dispose=c.asm.E).apply(null,arguments)},QN=c._Abs=function(){return(QN=c._Abs=c.asm.G).apply(null,arguments)},eT=c._Add=function(){return(eT=c._Add=c.asm.H).apply(null,arguments)},tT=c._AddN=function(){return(tT=c._AddN=c.asm.I).apply(null,arguments)},nT=c._All=function(){return(nT=c._All=c.asm.J).apply(null,arguments)},rT=c._Any=function(){return(rT=c._Any=c.asm.K).apply(null,arguments)},sT=c._ArgMax=function(){return(sT=c._ArgMax=c.asm.L).apply(null,arguments)},oT=c._AvgPool=function(){return(oT=c._AvgPool=c.asm.M).apply(null,arguments)},aT=c._BatchMatMul=function(){return(aT=c._BatchMatMul=c.asm.N).apply(null,arguments)},iT=c._Ceil=function(){return(iT=c._Ceil=c.asm.O).apply(null,arguments)},lT=c._ClipByValue=function(){return(lT=c._ClipByValue=c.asm.P).apply(null,arguments)},uT=c._Conv2D=function(){return(uT=c._Conv2D=c.asm.Q).apply(null,arguments)},cT=c._Conv2DBackpropInput=function(){return(cT=c._Conv2DBackpropInput=c.asm.R).apply(null,arguments)},pT=c._Cos=function(){return(pT=c._Cos=c.asm.S).apply(null,arguments)},dT=c._Cosh=function(){return(dT=c._Cosh=c.asm.T).apply(null,arguments)},fT=c._CropAndResize=function(){return(fT=c._CropAndResize=c.asm.U).apply(null,arguments)},hT=c._Cumsum=function(){return(hT=c._Cumsum=c.asm.V).apply(null,arguments)},mT=c._DepthToSpace=function(){return(mT=c._DepthToSpace=c.asm.W).apply(null,arguments)},gT=c._DepthwiseConv2dNative=function(){return(gT=c._DepthwiseConv2dNative=c.asm.X).apply(null,arguments)},xT=c._Elu=function(){return(xT=c._Elu=c.asm.Y).apply(null,arguments)},Wv=c._Equal=function(){return(Wv=c._Equal=c.asm.Z).apply(null,arguments)},Gv=c._Exp=function(){return(Gv=c._Exp=c.asm._).apply(null,arguments)},Uv=c._FlipLeftRight=function(){return(Uv=c._FlipLeftRight=c.asm.$).apply(null,arguments)},v1=c._Floor=function(){return(v1=c._Floor=c.asm.aa).apply(null,arguments)},eg=c._FloorDiv=function(){return(eg=c._FloorDiv=c.asm.ba).apply(null,arguments)},yT=c._FusedBatchNorm=function(){return(yT=c._FusedBatchNorm=c.asm.ca).apply(null,arguments)},w1=c._FusedConv2D=function(){return(w1=c._FusedConv2D=c.asm.da).apply(null,arguments)},Ae=c._FusedDepthwiseConv2D=function(){return(Ae=c._FusedDepthwiseConv2D=c.asm.ea).apply(null,arguments)},Te=c._Gather=function(){return(Te=c._Gather=c.asm.fa).apply(null,arguments)},Ze=c._GatherNd=function(){return(Ze=c._GatherNd=c.asm.ga).apply(null,arguments)},rn=c._Greater=function(){return(rn=c._Greater=c.asm.ha).apply(null,arguments)},mr=c._GreaterEqual=function(){return(mr=c._GreaterEqual=c.asm.ia).apply(null,arguments)},Jn=c._LeakyRelu=function(){return(Jn=c._LeakyRelu=c.asm.ja).apply(null,arguments)},qt=c._Less=function(){return(qt=c._Less=c.asm.ka).apply(null,arguments)},Zt=c._LessEqual=function(){return(Zt=c._LessEqual=c.asm.la).apply(null,arguments)},bs=c._Log=function(){return(bs=c._Log=c.asm.ma).apply(null,arguments)},Ol=c._LogicalAnd=function(){return(Ol=c._LogicalAnd=c.asm.na).apply(null,arguments)},Pl=c._Max=function(){return(Pl=c._Max=c.asm.oa).apply(null,arguments)},jv=c._MaxPool=function(){return(jv=c._MaxPool=c.asm.pa).apply(null,arguments)},k1=c._Maximum=function(){return(k1=c._Maximum=c.asm.qa).apply(null,arguments)},Po=c._Mean=function(){return(Po=c._Mean=c.asm.ra).apply(null,arguments)},Nc=c._Min=function(){return(Nc=c._Min=c.asm.sa).apply(null,arguments)},Hv=c._Minimum=function(){return(Hv=c._Minimum=c.asm.ta).apply(null,arguments)},hie=c._MirrorPad=function(){return(hie=c._MirrorPad=c.asm.ua).apply(null,arguments)},mie=c._Multiply=function(){return(mie=c._Multiply=c.asm.va).apply(null,arguments)},gie=c._Neg=function(){return(gie=c._Neg=c.asm.wa).apply(null,arguments)},xie=c._NonMaxSuppressionV3=function(){return(xie=c._NonMaxSuppressionV3=c.asm.xa).apply(null,arguments)},yie=c._NonMaxSuppressionV4=function(){return(yie=c._NonMaxSuppressionV4=c.asm.ya).apply(null,arguments)},bie=c._NonMaxSuppressionV5=function(){return(bie=c._NonMaxSuppressionV5=c.asm.za).apply(null,arguments)},Aie=c._NotEqual=function(){return(Aie=c._NotEqual=c.asm.Aa).apply(null,arguments)},vie=c._OneHot=function(){return(vie=c._OneHot=c.asm.Ba).apply(null,arguments)},wie=c._PadV2=function(){return(wie=c._PadV2=c.asm.Ca).apply(null,arguments)},kie=c._Pow=function(){return(kie=c._Pow=c.asm.Da).apply(null,arguments)},Iie=c._Prelu=function(){return(Iie=c._Prelu=c.asm.Ea).apply(null,arguments)},Cie=c._Prod=function(){return(Cie=c._Prod=c.asm.Fa).apply(null,arguments)},Sie=c._RealDiv=function(){return(Sie=c._RealDiv=c.asm.Ga).apply(null,arguments)},Nie=c._Relu=function(){return(Nie=c._Relu=c.asm.Ha).apply(null,arguments)},Tie=c._Relu6=function(){return(Tie=c._Relu6=c.asm.Ia).apply(null,arguments)},_ie=c._ResizeBilinear=function(){return(_ie=c._ResizeBilinear=c.asm.Ja).apply(null,arguments)},Eie=c._Reverse=function(){return(Eie=c._Reverse=c.asm.Ka).apply(null,arguments)},Rie=c._RotateWithOffset=function(){return(Rie=c._RotateWithOffset=c.asm.La).apply(null,arguments)},Die=c._Round=function(){return(Die=c._Round=c.asm.Ma).apply(null,arguments)},$ie=c._Rsqrt=function(){return($ie=c._Rsqrt=c.asm.Na).apply(null,arguments)},Fie=c._ScatterNd=function(){return(Fie=c._ScatterNd=c.asm.Oa).apply(null,arguments)},Oie=c._SelectV2=function(){return(Oie=c._SelectV2=c.asm.Pa).apply(null,arguments)},Pie=c._Sigmoid=function(){return(Pie=c._Sigmoid=c.asm.Qa).apply(null,arguments)},Mie=c._Sin=function(){return(Mie=c._Sin=c.asm.Ra).apply(null,arguments)},zie=c._Softmax=function(){return(zie=c._Softmax=c.asm.Sa).apply(null,arguments)},Lie=c._Sqrt=function(){return(Lie=c._Sqrt=c.asm.Ta).apply(null,arguments)},Bie=c._Square=function(){return(Bie=c._Square=c.asm.Ua).apply(null,arguments)},Vie=c._SquaredDifference=function(){return(Vie=c._SquaredDifference=c.asm.Va).apply(null,arguments)},Wie=c._Step=function(){return(Wie=c._Step=c.asm.Wa).apply(null,arguments)},Gie=c._StridedSlice=function(){return(Gie=c._StridedSlice=c.asm.Xa).apply(null,arguments)},Uie=c._Sub=function(){return(Uie=c._Sub=c.asm.Ya).apply(null,arguments)},jie=c._Sum=function(){return(jie=c._Sum=c.asm.Za).apply(null,arguments)},Hie=c._Tan=function(){return(Hie=c._Tan=c.asm._a).apply(null,arguments)},qie=c._Tanh=function(){return(qie=c._Tanh=c.asm.$a).apply(null,arguments)},Kie=c._Tile=function(){return(Kie=c._Tile=c.asm.ab).apply(null,arguments)},Xie=c._TopK=function(){return(Xie=c._TopK=c.asm.bb).apply(null,arguments)},Zie=c._Transform=function(){return(Zie=c._Transform=c.asm.cb).apply(null,arguments)},Yie=c._Transpose=function(){return(Yie=c._Transpose=c.asm.db).apply(null,arguments)},Jie=c.__FusedMatMul=function(){return(Jie=c.__FusedMatMul=c.asm.eb).apply(null,arguments)},Od=c._malloc=function(){return(Od=c._malloc=c.asm.fb).apply(null,arguments)},I1=c._free=function(){return(I1=c._free=c.asm.gb).apply(null,arguments)},XO=c.___errno_location=function(){return(XO=c.___errno_location=c.asm.hb).apply(null,arguments)},ZO=c._emscripten_get_global_libc=function(){return(ZO=c._emscripten_get_global_libc=c.asm.ib).apply(null,arguments)},tg=c._pthread_self=function(){return(tg=c._pthread_self=c.asm.jb).apply(null,arguments)},YO=c.___pthread_tsd_run_dtors=function(){return(YO=c.___pthread_tsd_run_dtors=c.asm.kb).apply(null,arguments)},bT=c._emscripten_main_thread_process_queued_calls=function(){return(bT=c._emscripten_main_thread_process_queued_calls=c.asm.lb).apply(null,arguments)},Qie=c._emscripten_current_thread_process_queued_calls=function(){return(Qie=c._emscripten_current_thread_process_queued_calls=c.asm.mb).apply(null,arguments)},JO=c._emscripten_register_main_browser_thread_id=function(){return(JO=c._emscripten_register_main_browser_thread_id=c.asm.nb).apply(null,arguments)},QO=c.__emscripten_do_dispatch_to_thread=function(){return(QO=c.__emscripten_do_dispatch_to_thread=c.asm.ob).apply(null,arguments)},eP=c._emscripten_sync_run_in_main_thread_4=function(){return(eP=c._emscripten_sync_run_in_main_thread_4=c.asm.pb).apply(null,arguments)},tP=c._emscripten_run_in_main_runtime_thread_js=function(){return(tP=c._emscripten_run_in_main_runtime_thread_js=c.asm.qb).apply(null,arguments)},AT=c.__emscripten_call_on_thread=function(){return(AT=c.__emscripten_call_on_thread=c.asm.rb).apply(null,arguments)},ele=c._emscripten_tls_init=function(){return(ele=c._emscripten_tls_init=c.asm.sb).apply(null,arguments)},vT=c.__emscripten_thread_init=function(){return(vT=c.__emscripten_thread_init=c.asm.tb).apply(null,arguments)},C1=c.stackSave=function(){return(C1=c.stackSave=c.asm.ub).apply(null,arguments)},ng=c.stackRestore=function(){return(ng=c.stackRestore=c.asm.vb).apply(null,arguments)},rg=c.stackAlloc=function(){return(rg=c.stackAlloc=c.asm.wb).apply(null,arguments)},nP=c._emscripten_stack_set_limits=function(){return(nP=c._emscripten_stack_set_limits=c.asm.xb).apply(null,arguments)},rP=c._memalign=function(){return(rP=c._memalign=c.asm.yb).apply(null,arguments)},sP=c.__emscripten_allow_main_runtime_queued_calls=10016,sg=c.__emscripten_main_thread_futex=11652;c.cwrap=Oe,c.PThread=lt,c.PThread=lt,c.wasmMemory=re,c.ExitStatus=S1;var qv;function S1(P){this.name="ExitStatus",this.message="Program terminated with exit("+P+")",this.status=P}$d=function P(){qv||wT(),qv||($d=P)};function wT(P){if(P=P||m,$l>0)return;if(w){p(c),g1(),postMessage({cmd:"loaded"});return}if(YS(),$l>0)return;function j(){qv||(qv=!0,c.calledRun=!0,!fe&&(g1(),JS(),p(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),ho()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),j()},1)):j()}c.run=wT;function tle(P,j){if(!(j&&ue&&P===0)){if(!j&&w)throw postMessage({cmd:"exitProcess",returnCode:P}),new S1(P);ue||(lt.terminateAllThreads(),me=P,Nv(),c.onExit&&c.onExit(P),fe=!0),x(P,new S1(P))}}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();return w&&(ue=!1,lt.initWorker()),wT(),s.ready}}();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}}),Fle=Qn({"node_modules/.pnpm/@tensorflow+tfjs-backend-wasm@3.9.0_@tensorflow+tfjs-core@3.9.0/node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js"(e,t){var n=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(s){s=s||{};var o=typeof s!="undefined"?s:{},a,i;o.ready=new Promise(function(Ae,Te){a=Ae,i=Te});var l={},u;for(u in o)o.hasOwnProperty(u)&&(l[u]=o[u]);var c=[],p="./this.program",d=function(Ae,Te){throw Te},f=!1,h=!1,m=!1,g=!1;f=typeof window=="object",h=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g=!f&&!m&&!h;var x="";function y(Ae){return o.locateFile?o.locateFile(Ae,x):x+Ae}var b,A,v,w,k,I;m?(h?x=D1().dirname(x)+"/":x=__dirname+"/",b=function(Te,Ze){return k||(k=ig("fs")),I||(I=D1()),Te=I.normalize(Te),k.readFileSync(Te,Ze?null:"utf8")},v=function(Te){var Ze=b(Te,!0);return Ze.buffer||(Ze=new Uint8Array(Ze)),W(Ze.buffer),Ze},process.argv.length>1&&(p=process.argv[1].replace(/\\/g,"/")),c=process.argv.slice(2),process.on("uncaughtException",function(Ae){if(!(Ae instanceof yT))throw Ae}),process.on("unhandledRejection",_a),d=function(Ae){process.exit(Ae)},o.inspect=function(){return"[Emscripten Module object]"}):g?(typeof read!="undefined"&&(b=function(Te){return read(Te)}),v=function(Te){var Ze;return typeof readbuffer=="function"?new Uint8Array(readbuffer(Te)):(Ze=read(Te,"binary"),W(typeof Ze=="object"),Ze)},typeof scriptArgs!="undefined"?c=scriptArgs:typeof arguments!="undefined"&&(c=arguments),typeof quit=="function"&&(d=function(Ae){quit(Ae)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(f||h)&&(h?x=self.location.href:typeof document!="undefined"&&document.currentScript&&(x=document.currentScript.src),r&&(x=r),x.indexOf("blob:")!==0?x=x.substr(0,x.lastIndexOf("/")+1):x="",b=function(Ae){var Te=new XMLHttpRequest;return Te.open("GET",Ae,!1),Te.send(null),Te.responseText},h&&(v=function(Ae){var Te=new XMLHttpRequest;return Te.open("GET",Ae,!1),Te.responseType="arraybuffer",Te.send(null),new Uint8Array(Te.response)}),A=function(Ae,Te,Ze){var rn=new XMLHttpRequest;rn.open("GET",Ae,!0),rn.responseType="arraybuffer",rn.onload=function(){if(rn.status==200||rn.status==0&&rn.response){Te(rn.response);return}Ze()},rn.onerror=Ze,rn.send(null)},w=function(Ae){document.title=Ae});var N=o.print||console.log.bind(console),T=o.printErr||console.warn.bind(console);for(u in l)l.hasOwnProperty(u)&&(o[u]=l[u]);l=null,o.arguments&&(c=o.arguments),o.thisProgram&&(p=o.thisProgram),o.quit&&(d=o.quit);var _;o.wasmBinary&&(_=o.wasmBinary);var R=o.noExitRuntime||!0;typeof WebAssembly!="object"&&_a("no native wasm support detected");var S,F=!1,B;function W(Ae,Te){Ae||_a("Assertion failed: "+Te)}function q(Ae){var Te=o["_"+Ae];return W(Te,"Cannot call unknown function "+Ae+", make sure it is exported"),Te}function K(Ae,Te,Ze,rn,mr){var Jn={string:function(Po){var Nc=0;if(Po!=null&&Po!==0){var Hv=(Po.length<<2)+1;Nc=v1(Hv),de(Po,Nc,Hv)}return Nc},array:function(Po){var Nc=v1(Po.length);return fe(Po,Nc),Nc}};function qt(Po){return Te==="string"?ue(Po):Te==="boolean"?Boolean(Po):Po}var Zt=q(Ae),bs=[],Ol=0;if(rn)for(var Pl=0;Pl<rn.length;Pl++){var jv=Jn[Ze[Pl]];jv?(Ol===0&&(Ol=Gv()),bs[Pl]=jv(rn[Pl])):bs[Pl]=rn[Pl]}var k1=Zt.apply(null,bs);return k1=qt(k1),Ol!==0&&Uv(Ol),k1}function J(Ae,Te,Ze,rn){Ze=Ze||[];var mr=Ze.every(function(qt){return qt==="number"}),Jn=Te!=="string";return Jn&&mr&&!rn?q(Ae):function(){return K(Ae,Te,Ze,arguments,rn)}}var Q=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function ee(Ae,Te,Ze){for(var rn=Te+Ze,mr=Te;Ae[mr]&&!(mr>=rn);)++mr;if(mr-Te>16&&Ae.subarray&&Q)return Q.decode(Ae.subarray(Te,mr));for(var Jn="";Te<mr;){var qt=Ae[Te++];if(!(qt&128)){Jn+=String.fromCharCode(qt);continue}var Zt=Ae[Te++]&63;if((qt&224)==192){Jn+=String.fromCharCode((qt&31)<<6|Zt);continue}var bs=Ae[Te++]&63;if((qt&240)==224?qt=(qt&15)<<12|Zt<<6|bs:qt=(qt&7)<<18|Zt<<12|bs<<6|Ae[Te++]&63,qt<65536)Jn+=String.fromCharCode(qt);else{var Ol=qt-65536;Jn+=String.fromCharCode(55296|Ol>>10,56320|Ol&1023)}}return Jn}function ue(Ae,Te){return Ae?ee(_e,Ae,Te):""}function re(Ae,Te,Ze,rn){if(!(rn>0))return 0;for(var mr=Ze,Jn=Ze+rn-1,qt=0;qt<Ae.length;++qt){var Zt=Ae.charCodeAt(qt);if(Zt>=55296&&Zt<=57343){var bs=Ae.charCodeAt(++qt);Zt=65536+((Zt&1023)<<10)|bs&1023}if(Zt<=127){if(Ze>=Jn)break;Te[Ze++]=Zt}else if(Zt<=2047){if(Ze+1>=Jn)break;Te[Ze++]=192|Zt>>6,Te[Ze++]=128|Zt&63}else if(Zt<=65535){if(Ze+2>=Jn)break;Te[Ze++]=224|Zt>>12,Te[Ze++]=128|Zt>>6&63,Te[Ze++]=128|Zt&63}else{if(Ze+3>=Jn)break;Te[Ze++]=240|Zt>>18,Te[Ze++]=128|Zt>>12&63,Te[Ze++]=128|Zt>>6&63,Te[Ze++]=128|Zt&63}}return Te[Ze]=0,Ze-mr}function de(Ae,Te,Ze){return re(Ae,_e,Te,Ze)}function fe(Ae,Te){Ne.set(Ae,Te)}function me(Ae,Te){return Ae%Te>0&&(Ae+=Te-Ae%Te),Ae}var xe,Ne,_e,Oe,Ve,He,At,ft,dt;function ct(Ae){xe=Ae,o.HEAP8=Ne=new Int8Array(Ae),o.HEAP16=Oe=new Int16Array(Ae),o.HEAP32=He=new Int32Array(Ae),o.HEAPU8=_e=new Uint8Array(Ae),o.HEAPU16=Ve=new Uint16Array(Ae),o.HEAPU32=At=new Uint32Array(Ae),o.HEAPF32=ft=new Float32Array(Ae),o.HEAPF64=dt=new Float64Array(Ae)}var mt=o.INITIAL_MEMORY||16777216,it,Zn=[],Dt=[],Yn=[],cn=[],Vr=!1;Dt.push({func:function(){$v()}});function _n(){if(o.preRun)for(typeof o.preRun=="function"&&(o.preRun=[o.preRun]);o.preRun.length;)vr(o.preRun.shift());Ic(Zn)}function hr(){Vr=!0,Ic(Dt)}function Ar(){Ic(Yn)}function Pn(){if(o.postRun)for(typeof o.postRun=="function"&&(o.postRun=[o.postRun]);o.postRun.length;)rs(o.postRun.shift());Ic(cn)}function vr(Ae){Zn.unshift(Ae)}function rs(Ae){cn.unshift(Ae)}var ys=0,Oo=null,di=null;function ca(Ae){ys++,o.monitorRunDependencies&&o.monitorRunDependencies(ys)}function kc(Ae){if(ys--,o.monitorRunDependencies&&o.monitorRunDependencies(ys),ys==0&&(Oo!==null&&(clearInterval(Oo),Oo=null),di)){var Te=di;di=null,Te()}}o.preloadedImages={},o.preloadedAudios={};function _a(Ae){o.onAbort&&o.onAbort(Ae),Ae+="",T(Ae),F=!0,B=1,Ae="abort("+Ae+"). Build with -s ASSERTIONS=1 for more info.";var Te=new WebAssembly.RuntimeError(Ae);throw i(Te),Te}function Sv(Ae,Te){return String.prototype.startsWith?Ae.startsWith(Te):Ae.indexOf(Te)===0}var YS="data:application/octet-stream;base64,";function g1(Ae){return Sv(Ae,YS)}var JS="file://";function Nv(Ae){return Sv(Ae,JS)}var ho="tfjs-backend-wasm.wasm";g1(ho)||(ho=y(ho));function Tv(Ae){try{if(Ae==ho&&_)return new Uint8Array(_);if(v)return v(Ae);throw"both async and sync fetching of the wasm failed"}catch(Te){_a(Te)}}function QS(){if(!_&&(f||h)){if(typeof fetch=="function"&&!Nv(ho))return fetch(ho,{credentials:"same-origin"}).then(function(Ae){if(!Ae.ok)throw"failed to load wasm binary file at '"+ho+"'";return Ae.arrayBuffer()}).catch(function(){return Tv(ho)});if(A)return new Promise(function(Ae,Te){A(ho,function(Ze){Ae(new Uint8Array(Ze))},Te)})}return Promise.resolve().then(function(){return Tv(ho)})}function $l(){var Ae={a:sN};function Te(qt,Zt){var bs=qt.exports;o.asm=bs,S=o.asm.i,ct(S.buffer),it=o.asm.o,kc("wasm-instantiate")}ca("wasm-instantiate");function Ze(qt){Te(qt.instance)}function rn(qt){return QS().then(function(Zt){return WebAssembly.instantiate(Zt,Ae)}).then(qt,function(Zt){T("failed to asynchronously prepare wasm: "+Zt),_a(Zt)})}function mr(){return!_&&typeof WebAssembly.instantiateStreaming=="function"&&!g1(ho)&&!Nv(ho)&&typeof fetch=="function"?fetch(ho,{credentials:"same-origin"}).then(function(qt){var Zt=WebAssembly.instantiateStreaming(qt,Ae);return Zt.then(Ze,function(bs){return T("wasm streaming compile failed: "+bs),T("falling back to ArrayBuffer instantiation"),rn(Ze)})}):rn(Ze)}if(o.instantiateWasm)try{var Jn=o.instantiateWasm(Ae,Te);return Jn}catch(qt){return T("Module.instantiateWasm callback failed with error: "+qt),!1}return mr().catch(i),{}}function Ic(Ae){for(;Ae.length>0;){var Te=Ae.shift();if(typeof Te=="function"){Te(o);continue}var Ze=Te.func;typeof Ze=="number"?Te.arg===void 0?it.get(Ze)():it.get(Ze)(Te.arg):Ze(Te.arg===void 0?null:Te.arg)}}function $d(){_a()}function eN(Ae,Te,Ze){_e.copyWithin(Ae,Te,Te+Ze)}function tN(){return _e.length}function Fl(Ae){try{return S.grow(Ae-xe.byteLength+65535>>>16),ct(S.buffer),1}catch(Te){}}function _v(Ae){var Te=tN(),Ze=2147483648;if(Ae>Ze)return!1;for(var rn=1;rn<=4;rn*=2){var mr=Te*(1+.2/rn);mr=Math.min(mr,Ae+100663296);var Jn=Math.min(Ze,me(Math.max(Ae,mr),65536)),qt=Fl(Jn);if(qt)return!0}return!1}var Ym={mappings:{},buffers:[null,[],[]],printChar:function(Ae,Te){var Ze=Ym.buffers[Ae];Te===0||Te===10?((Ae===1?N:T)(ee(Ze,0)),Ze.length=0):Ze.push(Te)},varargs:void 0,get:function(){Ym.varargs+=4;var Ae=He[Ym.varargs-4>>2];return Ae},getStr:function(Ae){var Te=ue(Ae);return Te},get64:function(Ae,Te){return Ae}};function Ev(Ae){return 0}function nN(Ae,Te,Ze,rn,mr){}function Rv(Ae,Te,Ze,rn){for(var mr=0,Jn=0;Jn<Ze;Jn++){for(var qt=He[Te+Jn*8>>2],Zt=He[Te+(Jn*8+4)>>2],bs=0;bs<Zt;bs++)Ym.printChar(Ae,_e[qt+bs]);mr+=Zt}return He[rn>>2]=mr,0}function mo(){return 6}function Dv(Ae){return He[Wv()>>2]=Ae,Ae}function rN(Ae){switch(Ae){case 30:return 16384;case 85:var Te=2147483648;return Te/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return Dv(28),-1}var sN={a:$d,d:eN,e:_v,f:Ev,c:nN,b:Rv,g:mo,h:rN},oN=$l(),$v=o.___wasm_call_ctors=function(){return($v=o.___wasm_call_ctors=o.asm.j).apply(null,arguments)},Jm=o._init=function(){return(Jm=o._init=o.asm.k).apply(null,arguments)},x1=o._register_tensor=function(){return(x1=o._register_tensor=o.asm.l).apply(null,arguments)},aN=o._dispose_data=function(){return(aN=o._dispose_data=o.asm.m).apply(null,arguments)},iN=o._dispose=function(){return(iN=o._dispose=o.asm.n).apply(null,arguments)},lN=o._Abs=function(){return(lN=o._Abs=o.asm.p).apply(null,arguments)},lt=o._Add=function(){return(lt=o._Add=o.asm.q).apply(null,arguments)},uN=o._AddN=function(){return(uN=o._AddN=o.asm.r).apply(null,arguments)},cN=o._All=function(){return(cN=o._All=o.asm.s).apply(null,arguments)},pN=o._Any=function(){return(pN=o._Any=o.asm.t).apply(null,arguments)},dN=o._ArgMax=function(){return(dN=o._ArgMax=o.asm.u).apply(null,arguments)},fN=o._AvgPool=function(){return(fN=o._AvgPool=o.asm.v).apply(null,arguments)},Fd=o._BatchMatMul=function(){return(Fd=o._BatchMatMul=o.asm.w).apply(null,arguments)},hN=o._Ceil=function(){return(hN=o._Ceil=o.asm.x).apply(null,arguments)},mN=o._ClipByValue=function(){return(mN=o._ClipByValue=o.asm.y).apply(null,arguments)},gN=o._Conv2D=function(){return(gN=o._Conv2D=o.asm.z).apply(null,arguments)},xN=o._Conv2DBackpropInput=function(){return(xN=o._Conv2DBackpropInput=o.asm.A).apply(null,arguments)},yN=o._Cos=function(){return(yN=o._Cos=o.asm.B).apply(null,arguments)},bN=o._Cosh=function(){return(bN=o._Cosh=o.asm.C).apply(null,arguments)},AN=o._CropAndResize=function(){return(AN=o._CropAndResize=o.asm.D).apply(null,arguments)},vN=o._Cumsum=function(){return(vN=o._Cumsum=o.asm.E).apply(null,arguments)},wN=o._DepthToSpace=function(){return(wN=o._DepthToSpace=o.asm.F).apply(null,arguments)},Cc=o._DepthwiseConv2dNative=function(){return(Cc=o._DepthwiseConv2dNative=o.asm.G).apply(null,arguments)},y1=o._Elu=function(){return(y1=o._Elu=o.asm.H).apply(null,arguments)},b1=o._Equal=function(){return(b1=o._Equal=o.asm.I).apply(null,arguments)},kN=o._Exp=function(){return(kN=o._Exp=o.asm.J).apply(null,arguments)},IN=o._FlipLeftRight=function(){return(IN=o._FlipLeftRight=o.asm.K).apply(null,arguments)},CN=o._Floor=function(){return(CN=o._Floor=o.asm.L).apply(null,arguments)},SN=o._FloorDiv=function(){return(SN=o._FloorDiv=o.asm.M).apply(null,arguments)},NN=o._FusedBatchNorm=function(){return(NN=o._FusedBatchNorm=o.asm.N).apply(null,arguments)},zt=o._FusedConv2D=function(){return(zt=o._FusedConv2D=o.asm.O).apply(null,arguments)},TN=o._FusedDepthwiseConv2D=function(){return(TN=o._FusedDepthwiseConv2D=o.asm.P).apply(null,arguments)},_N=o._Gather=function(){return(_N=o._Gather=o.asm.Q).apply(null,arguments)},EN=o._GatherNd=function(){return(EN=o._GatherNd=o.asm.R).apply(null,arguments)},RN=o._Greater=function(){return(RN=o._Greater=o.asm.S).apply(null,arguments)},DN=o._GreaterEqual=function(){return(DN=o._GreaterEqual=o.asm.T).apply(null,arguments)},$N=o._LeakyRelu=function(){return($N=o._LeakyRelu=o.asm.U).apply(null,arguments)},A1=o._Less=function(){return(A1=o._Less=o.asm.V).apply(null,arguments)},Fv=o._LessEqual=function(){return(Fv=o._LessEqual=o.asm.W).apply(null,arguments)},Ov=o._Log=function(){return(Ov=o._Log=o.asm.X).apply(null,arguments)},FN=o._LogicalAnd=function(){return(FN=o._LogicalAnd=o.asm.Y).apply(null,arguments)},ON=o._Max=function(){return(ON=o._Max=o.asm.Z).apply(null,arguments)},PN=o._MaxPool=function(){return(PN=o._MaxPool=o.asm._).apply(null,arguments)},MN=o._Maximum=function(){return(MN=o._Maximum=o.asm.$).apply(null,arguments)},zN=o._Mean=function(){return(zN=o._Mean=o.asm.aa).apply(null,arguments)},LN=o._Min=function(){return(LN=o._Min=o.asm.ba).apply(null,arguments)},BN=o._Minimum=function(){return(BN=o._Minimum=o.asm.ca).apply(null,arguments)},pn=o._MirrorPad=function(){return(pn=o._MirrorPad=o.asm.da).apply(null,arguments)},VN=o._Multiply=function(){return(VN=o._Multiply=o.asm.ea).apply(null,arguments)},WN=o._Neg=function(){return(WN=o._Neg=o.asm.fa).apply(null,arguments)},GN=o._NonMaxSuppressionV3=function(){return(GN=o._NonMaxSuppressionV3=o.asm.ga).apply(null,arguments)},Qm=o._NonMaxSuppressionV4=function(){return(Qm=o._NonMaxSuppressionV4=o.asm.ha).apply(null,arguments)},Pv=o._NonMaxSuppressionV5=function(){return(Pv=o._NonMaxSuppressionV5=o.asm.ia).apply(null,arguments)},Mv=o._NotEqual=function(){return(Mv=o._NotEqual=o.asm.ja).apply(null,arguments)},zv=o._OneHot=function(){return(zv=o._OneHot=o.asm.ka).apply(null,arguments)},UN=o._PadV2=function(){return(UN=o._PadV2=o.asm.la).apply(null,arguments)},jN=o._Pow=function(){return(jN=o._Pow=o.asm.ma).apply(null,arguments)},Lv=o._Prelu=function(){return(Lv=o._Prelu=o.asm.na).apply(null,arguments)},HN=o._Prod=function(){return(HN=o._Prod=o.asm.oa).apply(null,arguments)},Bv=o._RealDiv=function(){return(Bv=o._RealDiv=o.asm.pa).apply(null,arguments)},Sc=o._Relu=function(){return(Sc=o._Relu=o.asm.qa).apply(null,arguments)},qN=o._Relu6=function(){return(qN=o._Relu6=o.asm.ra).apply(null,arguments)},KN=o._ResizeBilinear=function(){return(KN=o._ResizeBilinear=o.asm.sa).apply(null,arguments)},KO=o._Reverse=function(){return(KO=o._Reverse=o.asm.ta).apply(null,arguments)},Vv=o._RotateWithOffset=function(){return(Vv=o._RotateWithOffset=o.asm.ua).apply(null,arguments)},XN=o._Round=function(){return(XN=o._Round=o.asm.va).apply(null,arguments)},ZN=o._Rsqrt=function(){return(ZN=o._Rsqrt=o.asm.wa).apply(null,arguments)},YN=o._ScatterNd=function(){return(YN=o._ScatterNd=o.asm.xa).apply(null,arguments)},JN=o._SelectV2=function(){return(JN=o._SelectV2=o.asm.ya).apply(null,arguments)},QN=o._Sigmoid=function(){return(QN=o._Sigmoid=o.asm.za).apply(null,arguments)},eT=o._Sin=function(){return(eT=o._Sin=o.asm.Aa).apply(null,arguments)},tT=o._Softmax=function(){return(tT=o._Softmax=o.asm.Ba).apply(null,arguments)},nT=o._Sqrt=function(){return(nT=o._Sqrt=o.asm.Ca).apply(null,arguments)},rT=o._Square=function(){return(rT=o._Square=o.asm.Da).apply(null,arguments)},sT=o._SquaredDifference=function(){return(sT=o._SquaredDifference=o.asm.Ea).apply(null,arguments)},oT=o._Step=function(){return(oT=o._Step=o.asm.Fa).apply(null,arguments)},aT=o._StridedSlice=function(){return(aT=o._StridedSlice=o.asm.Ga).apply(null,arguments)},iT=o._Sub=function(){return(iT=o._Sub=o.asm.Ha).apply(null,arguments)},lT=o._Sum=function(){return(lT=o._Sum=o.asm.Ia).apply(null,arguments)},uT=o._Tan=function(){return(uT=o._Tan=o.asm.Ja).apply(null,arguments)},cT=o._Tanh=function(){return(cT=o._Tanh=o.asm.Ka).apply(null,arguments)},pT=o._Tile=function(){return(pT=o._Tile=o.asm.La).apply(null,arguments)},dT=o._TopK=function(){return(dT=o._TopK=o.asm.Ma).apply(null,arguments)},fT=o._Transform=function(){return(fT=o._Transform=o.asm.Na).apply(null,arguments)},hT=o._Transpose=function(){return(hT=o._Transpose=o.asm.Oa).apply(null,arguments)},mT=o.__FusedMatMul=function(){return(mT=o.__FusedMatMul=o.asm.Pa).apply(null,arguments)},gT=o._malloc=function(){return(gT=o._malloc=o.asm.Qa).apply(null,arguments)},xT=o._free=function(){return(xT=o._free=o.asm.Ra).apply(null,arguments)},Wv=o.___errno_location=function(){return(Wv=o.___errno_location=o.asm.Sa).apply(null,arguments)},Gv=o.stackSave=function(){return(Gv=o.stackSave=o.asm.Ta).apply(null,arguments)},Uv=o.stackRestore=function(){return(Uv=o.stackRestore=o.asm.Ua).apply(null,arguments)},v1=o.stackAlloc=function(){return(v1=o.stackAlloc=o.asm.Va).apply(null,arguments)};o.cwrap=J;var eg;function yT(Ae){this.name="ExitStatus",this.message="Program terminated with exit("+Ae+")",this.status=Ae}di=function Ae(){eg||w1(),eg||(di=Ae)};function w1(Ae){if(Ae=Ae||c,ys>0||(_n(),ys>0))return;function Te(){eg||(eg=!0,o.calledRun=!0,!F&&(hr(),Ar(),a(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),Pn()))}o.setStatus?(o.setStatus("Running..."),setTimeout(function(){setTimeout(function(){o.setStatus("")},1),Te()},1)):Te()}if(o.run=w1,o.preInit)for(typeof o.preInit=="function"&&(o.preInit=[o.preInit]);o.preInit.length>0;)o.preInit.pop()();return w1(),s.ready}}();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}}),Ole=1e-7,Ple=1e-4,Xv=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},$1=class{refCount(e){return Ea("refCount")}incRef(e){return Ea("incRef")}timerAvailable(){return!0}time(e){return Ea("time")}read(e){return Ea("read")}readSync(e){return Ea("readSync")}numDataIds(){return Ea("numDataIds")}disposeData(e,t){return Ea("disposeData")}write(e,t,n){return Ea("write")}move(e,t,n,r,s){return Ea("move")}memory(){return Ea("memory")}floatPrecision(){return Ea("floatPrecision")}epsilon(){return this.floatPrecision()===32?Ole:Ple}dispose(){return Ea("dispose")}};function Ea(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function fP(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Zv(e,t,n)}function Mle(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Zv(e,n,r),Zv(t,n,r)}function F1(e,t,n){return Math.max(e,Math.min(t,n))}function zle(e){return e%2==0?e:e+1}function Zv(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function Lle(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Ble(e,t){let n=Math.random();return t*n+(1-n)*e}function Vle(e,t){let n=0;for(let r=0;r<e.length;r++){let s=Number(e[r])-Number(t[r]);n+=s*s}return n}function H(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function zs(e,t,n=""){H(Ml(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Md(e){H(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function zd(e,t=[],n=!1){if(t==null&&(t=[]),Array.isArray(e)||Ds(e)&&!n)for(let r=0;r<e.length;++r)zd(e[r],t,n);else t.push(e);return t}function wr(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Wle(e){return e.length===0}function Ml(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function as(e){return e%1==0}function Gle(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function Ule(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function jle(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return fP(t),t}function O1(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Hle(e,t=r=>0,n){return new Promise((r,s)=>{let o=0,a=()=>{if(e()){r();return}o++;let i=t(o);if(n!=null&&o>=n){s();return}setTimeout(a,i)};a()})}function qle(e,t){let n=1,r=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(e[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(e[o]<0)throw Error(`Shapes can not be < 0. Found ${e[o]} at dim ${o}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let s=e.slice();return s[r]=t/n,s}function Ra(e,t){let n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),H(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),H(e.every(r=>as(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function hP(e,t){let n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,o=t==null||s?null:Ra(t,e).sort(),a=0;for(let i=0;i<e.length;++i){if(o!=null){if(o[a]===i&&e[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(o[a]==null||o[a]>i)&&e[i]===1&&(n.push(e[i]),r.push(i)),o[a]<=i&&a++}e[i]!==1&&(n.push(e[i]),r.push(i))}return{newShape:n,keptDims:r}}function mP(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else throw new Error(`Unknown data type ${e}`);return n}function gP(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function xP(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function yP(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function Kle(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Ds(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function IT(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function bP(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Rc(e){return typeof e=="string"||e instanceof String}function AP(e){return typeof e=="boolean"}function vP(e){return typeof e=="number"}function Yv(e){return Array.isArray(e)?Yv(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":vP(e)?"float32":Rc(e)?"string":AP(e)?"bool":"float32"}function Dc(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Jv(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function lg(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function wP(e,t,n,r=!1){let s=new Array;if(t.length===1){let o=t[0]*(r?2:1);for(let a=0;a<o;a++)s[a]=n[e+a]}else{let o=t[0],a=t.slice(1),i=a.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<o;l++)s[l]=wP(e+l*i,a,n,r)}return s}function ug(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((s,o)=>s*o)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return wP(0,e,t,n)}function CT(e,t){let n=Qv(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Qv(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Xle(e,t){let n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return ug(e,new Float32Array(n));if(t==="int32")return ug(e,new Int32Array(n));if(t==="bool")return ug(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function ST(e){e.forEach(t=>{H(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Zle(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function Yle(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function NT(e){return e&&e.then&&typeof e.then=="function"}function tl(...e){be().getBool("IS_TEST")||be().getBool("PROD")||console.warn(...e)}function Jle(...e){be().getBool("IS_TEST")||be().getBool("PROD")||console.log(...e)}var kP="tfjsflags",IP=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Qle,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&tl(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];tl(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(NT(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let e=this.getQueryParams(this.global.location.search);kP in e&&e[kP].split(",").forEach(n=>{let[r,s]=n.split(":");this.urlFlags[r]=tue(r,s)})}};function Qle(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(eue(t,r[0],r[1]),r.join("="))),t}function eue(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function tue(e,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function be(){return Da}var Da=null;function nue(e){Da=e}var TT;function CP(){if(TT==null){let e;if(typeof window!="undefined")e=window;else if(typeof global!="undefined")e=global;else if(typeof process!="undefined")e=process;else if(typeof self!="undefined")e=self;else throw new Error("Could not find a global object");TT=e}return TT}function rue(){let e=CP();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function _T(e,t){let n=rue();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var cg="Abs",pg="Acos",dg="Acosh",$c="Add",Ld="AddN",fg="All",hg="Any",Bd="ArgMax",P1="ArgMin",mg="Asin",gg="Asinh",xg="Atan",yg="Atanh",bg="Atan2",Vd="AvgPool",ew="AvgPoolGrad",M1="AvgPool3D",tw="AvgPool3DGrad",Wd="BatchMatMul",Ag="BatchToSpaceND",nw="Bincount",SP="BroadcastTo",ET="BroadcastArgs",Gd="Cast",Ud="Ceil",Fc="ClipByValue",rw="Complex",z1="ComplexAbs",vg="Concat",jd="Conv2D",sw="Conv2DBackpropFilter",Hd="Conv2DBackpropInput",L1="Conv3D",ow="Conv3DBackpropFilterV2",aw="Conv3DBackpropInputV2",qd="Cos",Kd="Cosh",Xd="Cumsum",wg="CropAndResize",iw="DenseBincount",kg="DepthToSpace",Zd="DepthwiseConv2dNative",lw="DepthwiseConv2dNativeBackpropFilter",uw="DepthwiseConv2dNativeBackpropInput",cw="Diag",B1="Dilation2D",pw="Dilation2DBackpropInput",dw="Dilation2DBackpropFilter",Yd="RealDiv",fw="Einsum",Jd="Elu",hw="EluGrad",Ig="Erf",Cg="Equal",Qd="Exp",Sg="ExpandDims",Ng="Expm1",mw="FFT",V1="Fill",Tg="FlipLeftRight",ef="Floor",tf="FloorDiv",nf="FusedBatchNorm",_g="GatherV2",Eg="GatherNd",Rg="Greater",rf="GreaterEqual",sf="Identity",gw="IFFT",xw="Imag",Dg="IsFinite",$g="IsInf",Fg="IsNan",of="LeakyRelu",Og="Less",Pg="LessEqual",yw="LinSpace",af="Log",Mg="Log1p",zg="LogicalAnd",W1="LogicalNot",G1="LogicalOr",NP="LogSoftmax",U1="LRN",bw="LRNGrad",lf="Max",uf="Maximum",cf="MaxPool",Aw="MaxPoolGrad",j1="MaxPool3D",vw="MaxPool3DGrad",ww="MaxPoolWithArgmax",pf="Mean",df="Min",ff="Minimum",hf="MirrorPad",Lg="Mod",kw="Multinomial",mf="Multiply",Bg="Neg",Vg="NotEqual",Wg="NonMaxSuppressionV3",Gg="NonMaxSuppressionV4",Ug="NonMaxSuppressionV5",jg="OnesLike",gf="OneHot",Hg="Pack",xf="PadV2",sue="Pool",yf="Pow",bf="Prelu",qg="Prod",H1="Range",Iw="Real",Kg="Reciprocal",Af="Relu",Xg="Reshape",q1="ResizeNearestNeighbor",Cw="ResizeNearestNeighborGrad",vf="ResizeBilinear",Sw="ResizeBilinearGrad",wf="Relu6",kf="Reverse",If="Round",Cf="Rsqrt",Zg="ScatterNd",Yg="Select",Jg="Selu",Qg="Slice",Sf="Sin",e0="Sinh",t0="Sign",Nf="Sigmoid",n0="Softplus",Tf="Sqrt",_f="Sum",r0="SpaceToBatchND",s0="SplitV",Ef="Softmax",Nw="SparseFillEmptyRows",Tw="SparseReshape",_w="SparseSegmentMean",Ew="SparseSegmentSum",Rw="SparseToDense",Rf="SquaredDifference",K1="Square",o0="StridedSlice",Dw="StringNGrams",$w="StringSplit",Fw="StringToHashBucketFast",Df="Sub",$f="Tan",Ff="Tanh",Oc="Tile",a0="TopK",i0="Transform",Of="Transpose",Ow="Unique",l0="Unpack",X1="UnsortedSegmentSum",u0="ZerosLike",Pc="Step",Pw="FromPixels",c0="RotateWithOffset",Pf="_FusedMatMul",Mf="FusedConv2D",zf="FusedDepthwiseConv2D",p0=_T("kernelRegistry",()=>new Map),Z1=_T("gradRegistry",()=>new Map);function Mw(e,t){let n=DT(e,t);return p0.get(n)}function RT(e){return Z1.get(e)}function zl(e){let t=p0.entries(),n=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[o,a]=s,[i]=o.split("_");i===e&&n.push(a)}return n}function Mc(e){let{kernelName:t,backendName:n}=e,r=DT(t,n);p0.has(r)&&tl(`The kernel '${t}' for backend '${n}' is already registered`),p0.set(r,e)}function TP(e){let{kernelName:t}=e;Z1.has(t)&&be().getBool("DEBUG")&&tl(`Overriding the gradient for '${t}'`),Z1.set(t,e)}function oue(e,t){let n=DT(e,t);if(!p0.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);p0.delete(n)}function aue(e){if(!Z1.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Z1.delete(e)}function iue(e,t){zl(e).forEach(r=>{let s=Object.assign({},r,{backendName:t});Mc(s)})}function DT(e,t){return`${t}_${e}`}var E={};Rt(E,{arraysEqual:()=>Ml,assert:()=>H,assertNonNegativeIntegerDimensions:()=>ST,assertNonNull:()=>Md,assertShapesMatch:()=>zs,bytesFromStringArray:()=>bP,bytesPerElement:()=>IT,checkConversionForErrors:()=>xP,clamp:()=>F1,computeStrides:()=>lg,createScalarValue:()=>fue,createShuffledIndices:()=>jle,decodeString:()=>Bw,distSquared:()=>Vle,encodeString:()=>Q1,fetch:()=>mue,fingerPrint64:()=>due,flatten:()=>zd,getArrayFromDType:()=>gP,getTypedArrayFromDType:()=>mP,hasEncodingLoss:()=>Kle,hexToLong:()=>Y1,indexToLoc:()=>Yle,inferDtype:()=>Yv,inferFromImplicitShape:()=>qle,isBoolean:()=>AP,isFunction:()=>Dc,isInt:()=>as,isNumber:()=>vP,isPromise:()=>NT,isScalarShape:()=>Wle,isString:()=>Rc,isTypedArray:()=>Ds,isValidDtype:()=>yP,locToIndex:()=>Zle,makeOnesTypedArray:()=>CT,makeZerosNestedTypedArray:()=>Xle,makeZerosTypedArray:()=>Qv,nearestDivisor:()=>Jv,nearestLargerEven:()=>zle,now:()=>J1,parseAxisParam:()=>Ra,randUniform:()=>Ble,repeatedTry:()=>Hle,rightPad:()=>O1,shuffle:()=>fP,shuffleCombo:()=>Mle,sizeFromShape:()=>wr,sizeToSquarishShape:()=>Ule,squeezeShape:()=>hP,sum:()=>Lle,swap:()=>Zv,tanh:()=>Gle,toNestedArray:()=>ug,toTypedArray:()=>Lw});var _P=Pd(mle()),Lf=_P.default||_P;function Y1(e){return Lf.fromString(e,!0,16)}var EP=Y1("c3a5c85c97cb3127"),Bf=Y1("b492b66fbe98f273"),Ls=Y1("9ae16a3b2f90404f");function $T(e){return e.xor(e.shru(47))}function RP(e,t,n){let r=e.slice(t,t+n);return Lf.fromBytes(Array.from(r),!0,!0)}function Mn(e,t){return RP(e,t,8)}function DP(e,t){return RP(e,t,4)}function is(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function zc(e,t,n=Y1("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function lue(e,t,n,r,s,o){s=s.add(e),o=is(o.add(s).add(r),21);let a=s;return s=s.add(t),s=s.add(n),o=o.add(is(s,44)),[s.add(r),o.add(a)]}function zw(e,t,n,r){return lue(Mn(e,t),Mn(e,t+8),Mn(e,t+16),Mn(e,t+24),n,r)}function uue(e,t=e.length){if(t>=8){let n=Ls.add(t*2),r=Mn(e,0).add(Ls),s=Mn(e,t-8),o=is(s,37).mul(n).add(r),a=is(r,25).add(s).mul(n);return zc(o,a,n)}if(t>=4){let n=Ls.add(t*2),r=DP(e,0);return zc(r.shl(3).add(t),DP(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],s=e[t-1],o=n+(r<<8),a=t+(s<<2);return $T(Ls.mul(o).xor(EP.mul(a))).mul(Ls)}return Ls}function cue(e,t=e.length){let n=Ls.add(t*2),r=Mn(e,0).mul(Bf),s=Mn(e,8),o=Mn(e,t-8).mul(n),a=Mn(e,t-16).mul(Ls);return zc(is(r.add(s),43).add(is(o,30)).add(a),r.add(is(s.add(Ls),18)).add(o),n)}function pue(e,t=e.length){let n=Ls.add(t*2),r=Mn(e,0).mul(Ls),s=Mn(e,8),o=Mn(e,t-8).mul(n),a=Mn(e,t-16).mul(Ls),i=is(r.add(s),43).add(is(o,30)).add(a),l=zc(i,r.add(is(s.add(Ls),18)).add(o),n),u=Mn(e,16).mul(n),c=Mn(e,24),p=i.add(Mn(e,t-32)).mul(n),d=l.add(Mn(e,t-24)).mul(n);return zc(is(u.add(c),43).add(is(p,30)).add(d),u.add(is(c.add(r),18)).add(p),n)}function due(e,t=e.length){let n=Lf.fromNumber(81,!0);if(t<=32)return t<=16?uue(e,t):cue(e,t);if(t<=64)return pue(e,t);let r=n,s=n.mul(Bf).add(113),o=$T(s.mul(Ls).add(113)).mul(Ls),a=[Lf.UZERO,Lf.UZERO],i=[Lf.UZERO,Lf.UZERO];r=r.mul(Ls).add(Mn(e,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=is(r.add(s).add(a[0]).add(Mn(e,l+8)),37).mul(Bf),s=is(s.add(a[1]).add(Mn(e,l+48)),42).mul(Bf),r=r.xor(i[1]),s=s.add(a[0]).add(Mn(e,l+40)),o=is(o.add(i[0]),33).mul(Bf),a=zw(e,l,a[1].mul(Bf),r.add(i[0])),i=zw(e,l+32,o.add(i[1]),s.add(Mn(e,l+16))),[o,r]=[r,o],l+=64;while(l!==u);let p=Bf.add(o.and(255).shl(1));return l=c,i[0]=i[0].add(t-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),r=is(r.add(s).add(a[0]).add(Mn(e,l+8)),37).mul(p),s=is(s.add(a[1]).add(Mn(e,l+48)),42).mul(p),r=r.xor(i[1].mul(9)),s=s.add(a[0].mul(9).add(Mn(e,l+40))),o=is(o.add(i[0]),33).mul(p),a=zw(e,l,a[1].mul(p),r.add(i[0])),i=zw(e,l+32,o.add(i[1]),s.add(Mn(e,l+16))),[o,r]=[r,o],zc(zc(a[0],i[0],p).add($T(s).mul(EP)).add(o),zc(a[1],i[1],p).add(r),p)}function fue(e,t){return t==="string"?Q1(e):Lw([e],t)}function hue(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Lw(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=zd(e)),be().getBool("DEBUG")&&xP(e,t),hue(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function J1(){return be().platform.now()}function mue(e,t){return be().platform.fetch(e,t)}function Q1(e,t="utf-8"){return t=t||"utf-8",be().platform.encode(e,t)}function Bw(e,t="utf-8"){return t=t||"utf-8",be().platform.decode(e,t)}var gue=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new yue)}profileKernel(e,t,n){let r,s=()=>{r=n()},o,a=J1();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(let l of r)l.dataSync();o=Promise.resolve({kernelMs:J1()-a})}if(be().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<r.length;l++){let u=r[l];u.data().then(c=>{xue(c,u.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:o}=e;n.forEach(a=>{Promise.all([a.data(),r,o]).then(i=>{this.logger.logKernelProfile(t,a,i[0],i[1],s,i[2])})})}};function xue(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}var yue=class{logKernelProfile(e,t,n,r,s,o){let a=typeof r=="number"?O1(`${r}ms`,9):r.error,i=O1(e,25),l=t.rank,u=t.size,c=O1(t.shape.toString(),14),p="";for(let d in s){let f=s[d];if(f!=null){let h=f.shape||t.shape,m=h.length;p+=`${d}: ${m}D ${m>0?h:""} `}}console.log(`%c${i}	%c${a}	%c${l}D ${c}	%c${u}	%c${p}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function bue(e,t,n){let r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],c=u.inputs;for(let p in c){let d=c[p],f=!1;for(let h=0;h<t.length;h++)if(r[d.id]){u.outputs.forEach(m=>r[m.id]=!0),f=!0,s[u.id]=!0;break}if(f)break}}let o={};o[n.id]=!0;let a={};for(let l=e.length-1;l>=0;l--){let u=e[l],c=u.inputs;for(let p=0;p<u.outputs.length;p++)if(o[u.outputs[p].id]){for(let d in c)o[c[d].id]=!0,a[u.id]=!0;break}}let i=[];for(let l=0;l<e.length;l++){let u=e[l];if(s[u.id]&&a[u.id]){let c={};for(let d in u.inputs){let f=u.inputs[d];r[f.id]&&(c[d]=f)}let p=Object.assign({},u);p.inputs=c,p.outputs=u.outputs,i.push(p)}}return i}function Aue(e,t,n,r){for(let s=t.length-1;s>=0;s--){let o=t[s],a=[];if(o.outputs.forEach(l=>{let u=e[l.id];u!=null?a.push(u):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);let i=o.gradient(a);for(let l in o.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);let u=n(()=>i[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=o.inputs[l];if(!Ml(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{let p=e[c.id];e[c.id]=r(p,u),p.dispose()}}}}var $P=20,eb=3,FT=7;function vue(e,t,n,r){let s=lg(t),o=wue(e,t,n,s),a=t.length,i=Vw(e,t,n,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(i.map(u=>"    "+u).join(`
`)),l.join(`
`)}function wue(e,t,n,r){let s=wr(t),o=r[r.length-1],a=new Array(o).fill(0),i=t.length,l=n==="complex64"?nb(e):e;if(i>1)for(let u=0;u<s/o;u++){let c=u*o;for(let p=0;p<o;p++)a[p]=Math.max(a[p],tb(l[c+p],0,n).length)}return a}function tb(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(FT))} + ${parseFloat(e[1].toFixed(FT))}j`:Rc(e)?r=`'${e}'`:n==="bool"?r=FP(e):r=parseFloat(e.toFixed(FT)).toString(),O1(r,t)}function FP(e){return e===0?"false":"true"}function Vw(e,t,n,r,s,o=!0){let a=n==="complex64"?2:1,i=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=nb(e);return[tb(m[0],0,n)]}return n==="bool"?[FP(e[0])]:[e[0].toString()]}if(l===1){if(i>$P){let g=eb*a,x=Array.from(e.slice(0,g)),y=Array.from(e.slice((i-eb)*a,i*a));return n==="complex64"&&(x=nb(x),y=nb(y)),["["+x.map((b,A)=>tb(b,s[A],n)).join(", ")+", ..., "+y.map((b,A)=>tb(b,s[i-eb+A],n)).join(", ")+"]"]}let m=n==="complex64"?nb(e):Array.from(e);return["["+m.map((g,x)=>tb(g,s[x],n)).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),p=r[0]*a,d=[];if(i>$P){for(let m=0;m<eb;m++){let g=m*p,x=g+p;d.push(...Vw(e.slice(g,x),u,n,c,s,!1))}d.push("...");for(let m=i-eb;m<i;m++){let g=m*p,x=g+p;d.push(...Vw(e.slice(g,x),u,n,c,s,m===i-1))}}else for(let m=0;m<i;m++){let g=m*p,x=g+p;d.push(...Vw(e.slice(g,x),u,n,c,s,m===i-1))}let f=l===2?",":"";d[0]="["+d[0]+f;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+f;let h=`,
`;for(let m=2;m<l;m++)h+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":h),d}function nb(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Ur=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=wr(e),n!=null){let r=n.length;H(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||gP(t,this.size),this.strides=lg(e)}set(e,...t){t.length===0&&(t=[0]),H(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return nl().makeTensor(this.values,this.shape,this.dtype)}},nl=null,d0=null,kue=null;function Iue(e){nl=e}function Cue(e){d0=e}function Sue(e){kue=e}var Vt=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=wr(e),this.strides=lg(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return d0.buffer(this.shape,this.dtype,e)}bufferSync(){return d0.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return ug(this.shape,e,this.dtype==="complex64")}arraySync(){return ug(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=nl().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>Bw(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();let e=nl().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Bw(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await nl().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(nl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return d0.print(this,e)}clone(){return this.throwIfDisposed(),d0.clone(this)}toString(e=!1){let t=this.dataSync();return vue(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),d0.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),nl().makeVariable(this,e,t,n)}};Object.defineProperty(Vt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function ve(){return _T("Tensor",()=>Vt)}ve();var rb=class extends Vt{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r);this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ml(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);nl().disposeTensor(this),this.dataId=e.dataId,nl().incRef(this,null)}dispose(){nl().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(rb,Symbol.hasInstance,{value:e=>e instanceof Vt&&e.assign!=null&&e.assign instanceof Function});var fi={};Rt(fi,{assertTypesMatch:()=>OP,getTensorsInContainer:()=>BT,isTensorInList:()=>Tue,makeTypesMatch:()=>ur});var OT;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(OT||(OT={}));var PT;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(PT||(PT={}));var MT;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(MT||(MT={}));var zT;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(zT||(zT={}));var LT;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(LT||(LT={}));var Nue={float32:zT,int32:PT,bool:MT,complex64:LT};function $a(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Nue[e][t]}function Ww(e){return $a(e,"int32")}function ur(e,t){if(e.dtype===t.dtype)return[e,t];let n=$a(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function OP(e,t){H(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function Tue(e,t){return t.some(n=>n.id===e.id)}function BT(e){let t=[],n=new Set;return PP(e,t,n),t}function PP(e,t,n){if(e==null)return;if(e instanceof Vt){t.push(e);return}if(!_ue(e))return;let r=e;for(let s in r){let o=r[s];n.has(o)||(n.add(o),PP(o,t,n))}}function _ue(e){return Array.isArray(e)||typeof e=="object"}function VT(e){return e.kernelName!=null}var MP=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},sb=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new MP}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(tl(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new gue(this.backendInstance),!0}setupRegisteredKernels(){zl(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){zl(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof $1)&&typeof n.then=="function"){let r=++this.pendingBackendInitId,s=n.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,tl(`Initialization of backend ${e} failed`),tl(o.stack||o.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return tl(`Initialization of backend ${e} failed`),tl(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,n){e();try{let r=n();return t(),r}catch(r){throw t(),r}}nextTensorId(){return sb.nextTensorId++}nextVariableId(){return sb.nextVariableId++}clone(e){let t=se.runKernel(sf,{x:e}),n={x:e},r=o=>({x:()=>{let a="float32",i={x:o},l={dtype:a};return se.runKernel(Gd,i,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(Mw(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),s=0;n.forEach(i=>{s+=i.dtype==="complex64"?3:1});let o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],r=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let i,l=VT(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(VT(e)){let{kernelName:f,inputs:h,attrs:m}=e;this.backendName==null&&this.backend;let g=Mw(f,this.backendName);H(g!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{let x=this.backend.numDataIds();i=g.kernelFunc({inputs:h,attrs:m,backend:this.backend});let y=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,x,y);let b=y.map(A=>{if(A.rank!=null)return A;let{dataId:v,shape:w,dtype:k}=A;return this.makeTensorFromDataId(v,w,k)});if(r){let A=this.getTensorsForGradient(f,h,b);n=this.saveTensorsForBackwardMode(A)}return b}}else{let{forwardFunc:f}=e,h=m=>{!r||(n=m.map(g=>this.keep(this.clone(g))))};a=()=>{let m=this.backend.numDataIds();i=this.tidy(()=>f(this.backend,h));let g=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,m,g),g}}let{inputs:u,attrs:c}=e,p=VT(e)?null:e.backwardsFunc,d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(l,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),r&&this.addTapeNode(l,u,t,p,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let r=RT(e);if(r!=null){let s=r.inputsToSave||[],o=r.outputsToSave||[],a;r.saveAllInputs?(H(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(l=>t[l])):a=s.map(l=>t[l]);let i=n.filter((l,u)=>o[u]);return a.concat(i)}return[]}makeTensor(e,t,n,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;n==="string"&&Rc(e[0])&&(s=e.map(i=>Q1(i)));let o=r.write(s,t,n),a=new Vt(t,n,o,this.nextTensorId());if(this.trackTensor(a,r),n==="string"){let i=this.state.tensorInfo.get(o),l=bP(s);this.state.numBytes+=l-i.bytes,i.bytes=l}return a}makeTensorFromDataId(e,t,n,r){n=n||"float32";let s=new Vt(t,n,e,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));let s=new rb(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*IT(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof rb||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*IT(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,s,o){let a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},i=RT(e);i!=null&&(r=i.gradFunc),r!=null&&(a.gradient=l=>(l=l.map((u,c)=>{if(u==null){let p=n[c],d=Qv(p.size,p.dtype);return this.makeTensor(d,p.shape,p.dtype)}return u}),r(l.length>1?l:l[0],s,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=BT(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let o=this.state.activeScope.track[s];!o.kept&&!n.has(o.id)&&o.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(e,t,n,r=!1){if(H(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));H(s instanceof Vt,()=>"The result y returned by f() must be a tensor.");let o=bue(this.state.activeTape,t,s);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=n==null?Eue(s.shape):n,Aue(a,o,l=>this.tidy(l),Rue);let i=t.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let u of l.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:i}})}customGrad(e){return H(Dc(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{H(t.every(a=>a instanceof Vt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,r={};t.forEach((a,i)=>{r[i]=a});let s=(a,i)=>(n=e(...t,i),H(n.value instanceof Vt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),H(Dc(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),o=(a,i)=>{let l=n.gradFunc(a,i),u=Array.isArray(l)?l:[l];H(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),H(u.every(p=>p instanceof Vt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let c={};return u.forEach((p,d)=>{c[d]=()=>p}),c};return this.runKernelFunc({forwardFunc:s,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){let t=J1(),n=await this.backend.time(e);return n.wallMs=J1()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new MP;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};sb.nextTensorId=0;sb.nextVariableId=0;function Eue(e){let t=CT(wr(e),"float32");return se.makeTensor(t,e,"float32")}function zP(){let e=CP();if(e._tfengine==null){let t=new IP(e);e._tfengine=new sb(t)}return nue(e._tfengine.ENV),Iue(()=>e._tfengine),e._tfengine}var se=zP();function Rue(e,t){let n={a:e,b:t};return se.runKernel($c,n)}var ob={};Rt(ob,{isBrowser:()=>LP,isMobile:()=>$ue});function Due(){return typeof navigator!="undefined"&&navigator!=null}function $ue(e){if(e||Due()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function LP(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var hi=be();hi.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});hi.registerFlag("IS_BROWSER",()=>LP());hi.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");hi.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));hi.registerFlag("PROD",()=>!1);hi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>hi.getBool("DEBUG"));hi.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);hi.registerFlag("IS_TEST",()=>!1);hi.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);hi.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);function rl(e,t){let n=e;if(Ds(e))return t==="string"?[]:[e.length];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Ds(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&be().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&BP(e,r,[]),r}function BP(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ds(e)){H(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}H(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),H(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let s=0;s<e.length;++s)BP(e[s],r,n.concat(s))}function VP(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function U(e,t,n,r="numeric"){if(e instanceof Vt)return VP(r,e.dtype,t,n),e;let s=Yv(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),VP(r,s,t,n),e==null||!Ds(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}let o=rl(e,s);!Ds(e)&&!Array.isArray(e)&&(e=[e]);let i=s!=="string"?Lw(e,s):zd(e,[],!0);return se.makeTensor(i,o,s)}function ab(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((o,a)=>U(o,`${t}[${a}]`,n,r))}var WP="__op";function ae(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+WP;let s=(...o)=>{se.startScope(n);try{let a=r(...o);return NT(a)&&console.error("Cannot return a Promise inside of tidy."),se.endScope(a),a}catch(a){throw se.endScope(null),a}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function Fue(e,t){let n=U(e,"real","complex"),r=U(t,"imag","complex");zs(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let s={real:n,imag:r};return se.runKernel(rw,s)}var Lc=ae({complex_:Fue});function Bc(e,t,n,r){if(r==null&&(r=Yv(e)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Ds(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){ST(t);let s=wr(t),o=wr(n);H(s===o,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${o}`);for(let a=0;a<n.length;++a){let i=n[a],l=a===n.length-1?i!==wr(t.slice(a)):!0;H(n[a]===t[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Ds(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?Lw(e,r):zd(e,[],!0),se.makeTensor(e,t,r)}function ls(e,t,n){let r=rl(e,n);return Bc(e,t,r,n)}var WT={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Gw=4;async function Oue(e,t){let n=[],r=[],s=Array.isArray(e)?e.map(a=>a.name):Object.keys(e);for(let a=0;a<s.length;++a){let i=s[a],l=Array.isArray(e)?e[a].tensor:e[i];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);let u={name:i,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(async p=>{let d=await l.bytes(),f=d.reduce((g,x)=>g+x.length,0)+Gw*d.length,h=new Uint8Array(f),m=0;for(let g=0;g<d.length;g++){let x=d[g],y=new Uint8Array(new Uint32Array([x.length]).buffer);h.set(y,m),m+=Gw,h.set(x,m),m+=x.length}p(h)});r.push(c)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}let o=await Promise.all(r);return{data:Pue(o),specs:n}}function GP(e,t){let n={},r,s=0;for(let o of t){let a=o.name,i=o.dtype,l=o.shape,u=wr(l),c;if("quantization"in o){let p=o.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${o.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${o.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=WT[p.dtype],f=e.slice(s,s+u*d),h=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(i==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(h.length);for(let m=0;m<h.length;m++){let g=h[m];c[m]=g*p.scale+p.min}}else if(p.dtype==="float16")r===void 0&&(r=Wue()),c=r(h);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(i==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(h.length);for(let m=0;m<h.length;m++){let g=h[m];c[m]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);s+=u*d}else if(i==="string"){let p=wr(o.shape);c=[];for(let d=0;d<p;d++){let f=new Uint32Array(e.slice(s,s+Gw))[0];s+=Gw;let h=new Uint8Array(e.slice(s,s+f));c.push(h),s+=f}}else{let p=WT[i],d=e.slice(s,s+u*p);if(i==="float32")c=new Float32Array(d);else if(i==="int32")c=new Int32Array(d);else if(i==="bool")c=new Uint8Array(d);else if(i==="complex64"){c=new Float32Array(d);let f=new Float32Array(c.length/2),h=new Float32Array(c.length/2);for(let x=0;x<f.length;x++)f[x]=c[x*2],h[x]=c[x*2+1];let m=ls(f,l,"float32"),g=ls(h,l,"float32");n[a]=Lc(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);s+=u*p}i!=="complex64"&&(n[a]=ls(c,l,i))}return n}function Pue(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(o=>{if(t+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});let r=new Uint8Array(t),s=0;return n.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}var GT=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function UP(e){return GT?Buffer.byteLength(e):new Blob([e]).size}function Mue(e){if(GT)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function zue(e){if(GT){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function UT(e){if(e.length===1)return e[0];let t=0;e.forEach(s=>{t+=s.byteLength});let n=new Uint8Array(t),r=0;return e.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function jP(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function HP(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}async function jT(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),e.weightsManifest!=null){let[r,s]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=s}return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),n}function ib(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:UP(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:UP(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function Lue(){let e=n=>{let r=n<<13,s=0;for(;(r&8388608)==0;)s-=8388608,r<<=1;return r&=~8388608,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function Bue(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function Vue(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function Wue(){let e=Lue(),t=Bue(),n=Vue();return r=>{let s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let a=0;a<r.length;a++){let i=r[a],l=e[n[i>>10]+(i&1023)]+t[i>>10];o[a]=l}return new Float32Array(s)}}var gr=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return gr.instance==null&&(gr.instance=new gr),gr.instance}static registerSaveRouter(e){gr.getInstance().saveRouters.push(e)}static registerLoadRouter(e){gr.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return gr.getHandlers(e,"save")}static getLoadHandlers(e,t){return gr.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return(t==="load"?gr.getInstance().loadRouters:gr.getInstance().saveRouters).forEach(o=>{let a=o(e,n);a!==null&&r.push(a)}),r}},Gue=e=>gr.registerSaveRouter(e),Uue=e=>gr.registerLoadRouter(e),jue=e=>gr.getSaveHandlers(e),Hue=(e,t)=>gr.getLoadHandlers(e,t),HT="tensorflowjs",qT=1,Vf="models_store",Vc="model_info_store";function qP(){if(!be().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window=="undefined"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function KT(e){let t=e.result;t.createObjectStore(Vf,{keyPath:"modelPath"}),t.createObjectStore(Vc,{keyPath:"modelPath"})}var Wf=class{constructor(e){if(this.indexedDB=qP(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let s=this.indexedDB.open(HT,qT);s.onupgradeneeded=()=>KT(s),s.onsuccess=()=>{let o=s.result;if(t==null){let a=o.transaction(Vf,"readonly"),l=a.objectStore(Vf).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=u=>(o.close(),r(l.error)),a.oncomplete=()=>o.close()}else{let a=ib(t),i=o.transaction(Vc,"readwrite"),l=i.objectStore(Vc),u=l.put({modelPath:this.modelPath,modelArtifactsInfo:a}),c;u.onsuccess=()=>{c=o.transaction(Vf,"readwrite");let d=c.objectStore(Vf).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});d.onsuccess=()=>n({modelArtifactsInfo:a}),d.onerror=f=>{l=i.objectStore(Vc);let h=l.delete(this.modelPath);h.onsuccess=()=>(o.close(),r(d.error)),h.onerror=m=>(o.close(),r(d.error))}},u.onerror=p=>(o.close(),r(u.error)),i.oncomplete=()=>{c==null?o.close():c.oncomplete=()=>o.close()}}},s.onerror=o=>r(s.error)})}};Wf.URL_SCHEME="indexeddb://";var KP=e=>be().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Wf.URL_SCHEME)?que(e.slice(Wf.URL_SCHEME.length)):null;gr.registerSaveRouter(KP);gr.registerLoadRouter(KP);function que(e){return new Wf(e)}function Kue(e){return e.startsWith(Wf.URL_SCHEME)?e.slice(Wf.URL_SCHEME.length):e}var Xue=class{constructor(){this.indexedDB=qP()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(HT,qT);n.onupgradeneeded=()=>KT(n),n.onsuccess=()=>{let r=n.result,s=r.transaction(Vc,"readonly"),a=s.objectStore(Vc).getAll();a.onsuccess=()=>{let i={};for(let l of a.result)i[l.modelPath]=l.modelArtifactsInfo;e(i)},a.onerror=i=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=Kue(e),new Promise((t,n)=>{let r=this.indexedDB.open(HT,qT);r.onupgradeneeded=()=>KT(r),r.onsuccess=()=>{let s=r.result,o=s.transaction(Vc,"readwrite"),a=o.objectStore(Vc),i=a.get(e),l;i.onsuccess=()=>{if(i.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=a.delete(e),c=()=>{l=s.transaction(Vf,"readwrite");let d=l.objectStore(Vf).delete(e);d.onsuccess=()=>t(i.result.modelArtifactsInfo),d.onerror=f=>n(i.error)};u.onsuccess=c,u.onerror=p=>(c(),s.close(),n(i.error))}},i.onerror=u=>(s.close(),n(i.error)),o.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},r.onerror=s=>n(r.error)})}},Ll="/",f0="tensorflowjs_models",XP="info",Zue="model_topology",Yue="weight_specs",Jue="weight_data",Que="model_metadata";function ZP(e){return{info:[f0,e,XP].join(Ll),topology:[f0,e,Zue].join(Ll),weightSpecs:[f0,e,Yue].join(Ll),weightData:[f0,e,Jue].join(Ll),modelMetadata:[f0,e,Que].join(Ll)}}function YP(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function ece(e){let t=e.split(Ll);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Ll)}function tce(e){return e.startsWith(Gf.URL_SCHEME)?e.slice(Gf.URL_SCHEME.length):e}var Gf=class{constructor(e){if(!be().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ZP(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=ib(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Mue(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(s){throw YP(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}let o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=zue(o),t}};Gf.URL_SCHEME="localstorage://";var JP=e=>be().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Gf.URL_SCHEME)?nce(e.slice(Gf.URL_SCHEME.length)):null;gr.registerSaveRouter(JP);gr.registerLoadRouter(JP);function nce(e){return new Gf(e)}var rce=class{constructor(){H(be().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),H(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=f0+Ll,n=Ll+XP;for(let r=0;r<this.LS.length;++r){let s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){let o=ece(s);e[o]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=tce(e);let t=ZP(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return YP(t),n}},h0="://",pa=class{constructor(){this.managers={}}static getInstance(){return pa.instance==null&&(pa.instance=new pa),pa.instance}static registerManager(e,t){H(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(h0)&&(e=e.slice(0,e.indexOf(h0))),H(e.length>0,()=>"scheme must not be an empty string.");let n=pa.getInstance();H(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function Uw(e){if(e.indexOf(h0)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${pa.getSchemes().join(",")}`);return{scheme:e.split(h0)[0],path:e.split(h0)[1]}}async function QP(e,t,n=!1){H(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=gr.getLoadHandlers(e);H(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),H(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let s=r[0],o=gr.getSaveHandlers(t);H(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),H(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let a=o[0],i=Uw(e).scheme,l=Uw(e).path,u=i===Uw(e).scheme,c=await s.load();n&&u&&await pa.getManager(i).removeModel(l);let p=await a.save(c);return n&&!u&&await pa.getManager(i).removeModel(l),p.modelArtifactsInfo}async function sce(){let e=pa.getSchemes(),t={};for(let n of e){let r=await pa.getManager(n).listModels();for(let s in r){let o=n+h0+s;t[o]=r[s]}}return t}async function oce(e){let t=Uw(e);return pa.getManager(t.scheme).removeModel(t.path)}async function ace(e,t){return QP(e,t,!1)}async function ice(e,t){return QP(e,t,!0)}var lce=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if(be().get("IS_BROWSER")){be().setPlatform("browser",new lce);try{pa.registerManager(Gf.URL_SCHEME,new rce)}catch(e){}try{pa.registerManager(Wf.URL_SCHEME,new Xue)}catch(e){}}var uce={importFetch:()=>gle()},XT,cce=class{constructor(){this.util=ig("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return be().global.fetch!=null?be().global.fetch(e,t):(XT==null&&(XT=uce.importFetch()),XT(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};be().get("IS_NODE")&&be().setPlatform("node",new cce);function Wt(e,t="float32",n){return t=t||"float32",ST(e),new Ur(e,t,n)}function pce(e,t){let n=U(e,"x","cast");if(!yP(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},s={dtype:t};return se.runKernel(Gd,r,s)}var Fe=ae({cast_:pce});function dce(e){let n={x:U(e,"x","clone","string_or_numeric")};return se.runKernel(sf,n)}var mi=ae({clone_:dce});function e9(e,t=!1){console.log(e.toString(t))}zP();var fce={buffer:Wt,cast:Fe,clone:mi,print:e9};Cue(fce);var go={};Rt(go,{browserFiles:()=>Ace,browserHTTPRequest:()=>Cce,concatenateArrayBuffers:()=>UT,copyModel:()=>ace,decodeWeights:()=>GP,encodeWeights:()=>Oue,fromMemory:()=>Nce,getLoadHandlers:()=>Hue,getModelArtifactsForJSON:()=>jT,getModelArtifactsInfoForJSON:()=>ib,getSaveHandlers:()=>jue,http:()=>JT,isHTTPScheme:()=>YT,listModels:()=>sce,loadWeights:()=>vce,moveModel:()=>ice,registerLoadRouter:()=>Uue,registerSaveRouter:()=>Gue,removeModel:()=>oce,weightsLoaderFactory:()=>s9,withSaveHandler:()=>Tce});var hce="model",mce=".json",gce=".weights.bin";function t9(e){return new Promise(t=>setTimeout(t)).then(e)}var m0=class{constructor(e){if(!be().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(m0.URL_SCHEME)&&(e=e.slice(m0.URL_SCHEME.length)),(e==null||e.length===0)&&(e=hce),this.modelJsonFileName=e+mce,this.weightDataFileName=e+gce}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=HP(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=s,await t9(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await t9(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ib(e)}}}};m0.URL_SCHEME="downloads://";var xce=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let s=JSON.parse(r.target.result),o=s.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}let i=jT(s,l=>this.loadWeights(l));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let o of e)t.push(...o.weights),n.push(...o.paths);let r=this.checkManifestAndWeightFiles(e),s=n.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(s).then(o=>[t,UT(o)])}loadWeightsFile(e,t){return new Promise((n,r)=>{let s=new FileReader;s.onload=o=>{let a=o.target.result;n(a)},s.onerror=o=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>jP(s.name)),r={};for(let s of e)s.paths.forEach(o=>{let a=jP(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[o]=this.weightsFiles[n.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},yce=e=>be().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(m0.URL_SCHEME)?bce(e.slice(m0.URL_SCHEME.length)):null;gr.registerSaveRouter(yce);function bce(e="model"){return new m0(e)}function Ace(e){return new xce(e)}function n9(e,t,n,r){a(e),n=n==null?0:n,r=r==null?1:r,i(n,r);let s=0,o=l=>(l.then(u=>{let c=n+ ++s/e.length*(r-n);return t(c),u}),l);function a(l){H(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function i(l,u){H(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),H(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),H(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(o))}async function r9(e,t){t==null&&(t={});let n=t.fetchFunc==null?be().platform.fetch:t.fetchFunc,r=e.map(p=>n(p,t.requestInit,{isBinary:!0})),s=0,o=.5,i=(t.onProgress==null?await Promise.all(r):await n9(r,t.onProgress,s,o)).map(p=>p.arrayBuffer()),l=.5,u=1;return t.onProgress==null?await Promise.all(i):await n9(i,t.onProgress,l,u)}async function vce(e,t="",n,r){return s9(a=>r9(a,{requestInit:r}))(e,t,n)}function s9(e){return async(t,n="",r)=>{let s=t.map(()=>!1),o={},a=r!=null?r.map(()=>!1):[],i=[];if(t.forEach((f,h)=>{let m=0;f.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,y=WT[x]*wr(g.shape),b=()=>{s[h]=!0,o[h]==null&&(o[h]=[]),o[h].push({manifestEntry:g,groupOffset:m,sizeBytes:y})};r!=null?r.forEach((A,v)=>{A===g.name&&(b(),a[v]=!0)}):b(),i.push(g.name),m+=y})}),!a.every(f=>f)){let f=r.filter((h,m)=>!a[m]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let l=s.reduce((f,h,m)=>(h&&f.push(m),f),[]),u=[];l.forEach(f=>{t[f].paths.forEach(h=>{let m=n+(n.endsWith("/")?"":"/")+h;u.push(m)})});let c=await e(u),p={},d=0;return l.forEach(f=>{let h=t[f].paths.length,m=0;for(let A=0;A<h;A++)m+=c[d+A].byteLength;let g=new ArrayBuffer(m),x=new Uint8Array(g),y=0;for(let A=0;A<h;A++){let v=new Uint8Array(c[d+A]);x.set(v,y),y+=v.byteLength}o[f].forEach(A=>{let v=g.slice(A.groupOffset,A.groupOffset+A.sizeBytes),w=GP(v,[A.manifestEntry]);for(let k in w)p[k]=w[k]}),d+=h}),p}}var wce="application/octet-stream",kce="application/json",ZT=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(H(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=be().platform.fetch,H(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&H(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=HP(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:kce}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:wce}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:ib(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(s){let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return jT(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=Ice(t),s=this.weightPathPrefix||n,o=[];for(let u of e)o.push(...u.weights);let a=[],i=[];for(let u of e)for(let c of u.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(c)):a.push(s+c+r);this.weightUrlConverter&&a.push(...await Promise.all(i));let l=await r9(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,UT(l)]}};ZT.URL_SCHEME_REGEX=/^https?:\/\//;function Ice(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function YT(e){return e.match(ZT.URL_SCHEME_REGEX)!=null}var o9=(e,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>YT(r)):n=YT(e),n)return JT(e,t)}return null};gr.registerSaveRouter(o9);gr.registerLoadRouter(o9);function JT(e,t){return new ZT(e,t)}function Cce(e,t){return JT(e,t)}var QT=class{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}},Sce=class{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}};function Nce(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new QT(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new QT({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new QT({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function Tce(e){return new Sce(e)}var a9={};Rt(a9,{confusionMatrix:()=>$ce});function _ce(e,t,n=!1,r=!1){let s=U(e,"a","matMul"),o=U(t,"b","matMul");[s,o]=ur(s,o);let a={a:s,b:o},i={transposeA:n,transposeB:r};return se.runKernel(Wd,a,i)}var Lt=ae({matMul_:_ce});function Ece(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let o={indices:U(e,"indices","oneHot","int32")},a={depth:t,onValue:n,offValue:r};return se.runKernel(gf,o,a)}var g0=ae({oneHot_:Ece});function Rce(e,t){let n=U(e,"x","transpose");if(t==null&&(t=n.shape.map((o,a)=>a).reverse()),H(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(o=>{H(o>=0&&o<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let r={x:n},s={perm:t};return se.runKernel(Of,r,s)}var Kt=ae({transpose_:Rce});function Dce(e,t,n){let r=U(e,"labels","confusionMatrix"),s=U(t,"predictions","confusionMatrix");H(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),H(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),H(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),H(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),H(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let o=g0(Fe(r,"int32"),n),a=g0(Fe(s,"int32"),n),i=Kt(o),l=Lt(i,a);return Fe(l,"int32")}var $ce=ae({confusionMatrix_:Dce}),Mo={};Rt(Mo,{fromPixels:()=>Bce,fromPixelsAsync:()=>zce,toPixels:()=>Lce});function jw(e,t,n){if(Md(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=rl(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Bc(e,t,r,n)}var x0;function i9(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,a=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData!="undefined"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement!="undefined"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement)o=!0;else if(e.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(s){let h=2;if(s&&e.readyState<h)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(Mw(Pw,se.backendName)!=null){let h={pixels:e},m={numChannels:t};return se.runKernel(Pw,h,m)}let[u,c]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height],p;a?p=e.getContext("2d").getImageData(0,0,u,c).data:r||n?p=e.data:(o||s||i)&&(x0==null&&(x0=document.createElement("canvas").getContext("2d")),x0.canvas.width=u,x0.canvas.height=c,x0.drawImage(e,0,0,u,c),p=x0.getImageData(0,0,u,c).data);let d;if(t===4)d=new Int32Array(p);else{let h=u*c;d=new Int32Array(h*t);for(let m=0;m<h;m++)for(let g=0;g<t;++g)d[m*t+g]=p[m*4+g]}return jw(d,[c,u,t],"int32")}function Fce(e){return e!=null&&e.data instanceof Uint8Array}function Oce(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function Pce(e){return e!=null&&e.width!==0&&e.height!==0}function Mce(e){return Oce()&&!(e instanceof ImageBitmap)&&Pce(e)&&!Fce(e)}async function zce(e,t=3){let n=null;if(be().getBool("WRAP_TO_IMAGEBITMAP")&&Mce(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(s){r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return i9(n,t)}async function Lce(e,t){let n=U(e,"img","toPixels");if(!(e instanceof Vt)){let u=n;n=Fe(u,"int32"),u.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let[r,s]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);let a=await n.data(),i=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){let c=[0,0,0,255];for(let d=0;d<o;d++){let f=a[u*o+d];if(n.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(n.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);o===1?(c[0]=f*i,c[1]=f*i,c[2]=f*i):c[d]=f*i}let p=u*4;l[p+0]=Math.round(c[0]),l[p+1]=Math.round(c[1]),l[p+2]=Math.round(c[2]),l[p+3]=Math.round(c[3])}if(t!=null){t.width=s,t.height=r;let u=t.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return n!==e&&n.dispose(),l}var Bce=ae({fromPixels_:i9}),e_={};Rt(e_,{prepareAndValidate:()=>l9});function l9(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(wr(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=t.shape,o=s[s.length-1],a=1;for(let p=0;p<s.length-1;++p)a*=s[p];let i=e.shape,l=s.slice();l.pop();let u=1;for(let p=o;p<n;++p)u*=i[p],l.push(i[p]);let c=[...lg(e.shape).map(p=>p/u),1].slice(0,o);return[l,a,u,c]}var t_={};Rt(t_,{calculateShapes:()=>u9,validateInput:()=>r_,validateUpdateShape:()=>n_});function n_(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(o+` update.rank != ${s+e.length-r}`);for(let a=0;a<s;++a)if(n.shape[a]!==t.shape[a])throw new Error(o+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<n.rank-s;++a)if(n.shape[a+s]!==e[a+r])throw new Error(o+` updates.shape[${a+s}] (${n.shape[a+s]}) != shape[${a+s}] (${e[a+s]})`)}function r_(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}n_(n,t,e)}function u9(e,t,n){let r=t.shape.length,s=r>1?t.shape[r-1]:1,o=n.length,a=1;for(let p=s;p<o;++p)a*=n[p];let i=s<1?1:s,l=wr(t.shape)/i,u=[...lg(n.slice(0,s)),1],c=wr(n);return{sliceRank:s,numUpdates:l,sliceSize:a,strides:u,outputSize:c}}var Bs={};Rt(Bs,{assertParamsValid:()=>Vce,computeFlatOffset:()=>Gce,computeOutShape:()=>c9,getNormalizedAxes:()=>h9,isSliceContinous:()=>Wce,maskToAxes:()=>Hw,parseSliceParams:()=>A9,sliceInfo:()=>Uce,startForAxis:()=>y9,startIndicesWithElidedDims:()=>m9,stopForAxis:()=>b9,stopIndicesWithElidedDims:()=>g9,stridesForAxis:()=>x9,stridesWithElidedDims:()=>p9});function Vce(e,t,n){let r=e.shape.length;H(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),H(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)H(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function Hw(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function c9(e,t,n){let r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function p9(e,t,n,r){let s=[...e];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)o===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function d9(e,t,n){return n<=e?n:n-(t-1)}function f9(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function h9(e,t,n,r,s,o,a,i,l){let u=e.length,c=new Array(u),p=new Array(u),d=new Array(u);if(t.length&&n>0){let f=t[0],h=n+1;c=m9(a,f,h,r,e),p=g9(i,f,h,s,e),d=p9(o,f,h,e)}else for(let f=0;f<u;f++)c[f]=y9(a,r,o,e,f,l),p[f]=b9(i,s,o,e,f,l),d[f]=x9(o,f,l);return{begin:c,end:p,strides:d}}function m9(e,t,n,r,s){let o=[...s],a=f9(n,t);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{let l=d9(t,n,i),u=r[l];e&1<<l&&(u=0),o[i]=u}return o}function g9(e,t,n,r,s){let o=[...s],a=f9(n,t);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{let l=d9(t,n,i),u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[i]=u}for(let i=0;i<o.length;i++){let l=s[i];o[i]<0&&(o[i]+=l),o[i]=F1(0,o[i],s[i])}return o}function x9(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function y9(e,t,n,r,s,o){let a=t[s],i=n[s]||1;(e&1<<s||o&1<<s||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let l=r[s];return a<0&&(a+=l),a=F1(0,a,l-1),a}function b9(e,t,n,r,s,o){let a=t[s],i=n[s]||1;(e&1<<s||o&1<<s||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let l=r[s];return a<0&&(a+=l),i>0?a=F1(0,a,l):a=F1(-1,a,l-1),a}function Wce(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Gce(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function A9(e,t,n){let r,s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(a=>{H(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(s).fill(-1):typeof n=="number"?o=[n,...new Array(s-1).fill(-1)]:n.length<s?o=n.concat(new Array(s-n.length).fill(-1)):o=n,o=o.map((a,i)=>a>=0?a:(H(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),e.shape[i]-r[i])),[r,o]}function Uce(e,t,n,r,s,o,a,i,l){let u=t.slice(),c=n.slice(),p=r;r==null&&(p=new Array(u.length));let d=Hw(a);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(a!==0&&i!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(a!==0&&l!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let f=e.length-u.length,h=Hw(i),m=e.slice();h.forEach(k=>{u[k]=0,c[k]=1,m.splice(k,0,1)});let{begin:g,end:x,strides:y}=h9(m,d,f,u,c,p,s,o,a);u=g,c=x,p=y;let b=Hw(l);b.forEach(k=>{c[k]=u[k]+1,p[k]=1});let A=c9(u,c,p),v=A.filter((k,I)=>b.indexOf(I)===-1);return{nonStrided:p.every(k=>k===1),$begin:u,$end:c,$strides:p,size:A,newShape:m,outShape:v}}var De={};Rt(De,{Serializable:()=>v9,SerializationMap:()=>Uf,registerClass:()=>Wc});var v9=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Uf=class{constructor(){this.classNameMap={}}static getMap(){return Uf.instance==null&&(Uf.instance=new Uf),Uf.instance}static register(e){Uf.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function Wc(e){H(e.className!=null,()=>"Class being registered does not have the static className property defined."),H(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),H(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Uf.register(e)}var w9={};Rt(w9,{TEST_EPSILON_FLOAT16:()=>k9,encodeStrings:()=>I9,expectArrayBuffersEqual:()=>Yce,expectArraysClose:()=>Hce,expectArraysEqual:()=>Kce,expectNumbersClose:()=>Xce,expectPromiseToFail:()=>qce,expectValuesInRange:()=>Zce,testEpsilon:()=>s_});var jce=.001,k9=.1;function Hce(e,t,n){return n==null&&(n=s_()),o_(e,t,(r,s)=>a_(r,s,n))}function s_(){return se.backend.floatPrecision()===32?jce:k9}function o_(e,t,n){let r=!0;if((Ds(e)||Ds(t))&&(r=!1),Ds(e)&&Ds(t)&&(r=!0),r){let a=e.constructor.name,i=t.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(e)&&Array.isArray(t)){let a=rl(e),i=rl(t);if(!Ml(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}let s=Ds(e)?e:zd(e),o=Ds(t)?t:zd(t);if(s.length!==o.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${o.length}.
Actual:   ${s}.
Expected: ${o}.`);for(let a=0;a<o.length;++a){let i=s[a],l=o[a];if(!n(i,l))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${l}.
Actual:   ${s}.
Expected: ${o}.`)}}function qce(e,t){e().then(()=>t.fail(),()=>t())}function Kce(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Rc(e)||Rc(e[0])||Rc(t)||Rc(t[0])?o_(e,n,(r,s)=>r==s):o_(e,t,(r,s)=>a_(r,s,0))}function Xce(e,t,n){if(n==null&&(n=s_()),!a_(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function a_(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Zce(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Yce(e,t){expect(new Float32Array(e)).toEqual(new Float32Array(t))}function I9(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?I9(n):e[t]=Q1(n)}return e}var qw="3.9.0";function C9(){be().set("PROD",!0)}function Jce(){be().set("DEBUG",!0)}function Qce(){be().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function i_(e){be().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}Sue(i_);function epe(){se.disposeVariables()}function zo(){return se}function Kw(){return se.memory()}function tpe(e){return se.profile(e)}function ce(e,t){return se.tidy(e,t)}function ye(e){BT(e).forEach(n=>n.dispose())}function us(e){return se.keep(e)}function npe(e){return se.time(e)}function S9(e){return se.setBackend(e)}function Xw(){return se.ready()}function gi(){return se.backendName}function rpe(e){se.removeBackend(e)}function l_(e){return se.findBackend(e)}function spe(e){return se.findBackendFactory(e)}function y0(e,t,n=1){return se.registerBackend(e,t,n)}function sl(){return se.backend}function ope(e,t){be().setPlatform(e,t)}function ape(e,t){let n=U(e,"a","add"),r=U(t,"b","add");[n,r]=ur(n,r);let s={a:n,b:r};return se.runKernel($c,s)}var Re=ae({add_:ape});function ipe(e,t){let n=U(e,"a","floorDiv"),r=U(t,"b","floorDiv");[n,r]=ur(n,r);let s={a:n,b:r};return se.runKernel(tf,s)}var Zw=ae({floorDiv_:ipe});function lpe(e,t){let n=U(e,"a","div"),r=U(t,"b","div");if([n,r]=ur(n,r),n.dtype==="int32"&&r.dtype==="int32")return Zw(n,r);let s={a:n,b:r},o={};return se.runKernel(Yd,s,o)}var Me=ae({div_:lpe});function upe(e,t){let n=U(e,"a","mul"),r=U(t,"b","mul");[n,r]=ur(n,r);let s={a:n,b:r};return se.runKernel(mf,s)}var te=ae({mul_:upe});function cpe(e){let t=U(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return se.runKernel(z1,n)}else{let n={x:t};return se.runKernel(cg,n)}}var Tr=ae({abs_:cpe});function ppe(e){let n={x:U(e,"x","acos")};return se.runKernel(pg,n)}var u_=ae({acos_:ppe});function dpe(e){let n={x:U(e,"x","acosh")};return se.runKernel(dg,n)}var c_=ae({acosh_:dpe});function fpe(e){H(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),H(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((s,o)=>U(s,`tensors${o}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!Ml(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return se.runKernel(Ld,r)}var Yw=ae({addN_:fpe});function hpe(e,t=null,n=!1){let s={x:U(e,"x","all","bool")},o={axis:t,keepDims:n};return se.runKernel(fg,s,o)}var Jw=ae({all_:hpe});function mpe(e,t=null,n=!1){let s={x:U(e,"x","any","bool")},o={axis:t,keepDims:n};return se.runKernel(hg,s,o)}var lb=ae({any_:mpe});function gpe(e,t=0){let r={x:U(e,"x","argMax")},s={axis:t};return se.runKernel(Bd,r,s)}var xi=ae({argMax_:gpe});function xpe(e,t=0){let r={x:U(e,"x","argMin")},s={axis:t};return se.runKernel(P1,r,s)}var p_=ae({argMin_:xpe});function ype(e){let n={x:U(e,"x","asin")};return se.runKernel(mg,n)}var d_=ae({asin_:ype});function bpe(e){let n={x:U(e,"x","asinh")};return se.runKernel(gg,n)}var f_=ae({asinh_:bpe});function Ape(e){let n={x:U(e,"x","atan")};return se.runKernel(xg,n)}var h_=ae({atan_:Ape});function vpe(e,t){let n=U(e,"a","atan2"),r=U(t,"b","atan2");[n,r]=ur(n,r);let s={a:n,b:r};return se.runKernel(bg,s)}var m_=ae({atan2_:vpe});function wpe(e){let n={x:U(e,"x","atanh")};return se.runKernel(yg,n)}var g_=ae({atanh_:wpe});function kpe(e,t,n,r,s="NHWC",o){let a=e[3],i=[...t,a],l=_9(s);return ub(e,i,n,o,r,null,null,l)}function N9(e,t,n,r,s,o,a="channelsLast"){let[i,l]=Qw(t),u;if(a==="channelsLast")u=[i,l,e[3],e[3]];else if(a==="channelsFirst")u=[i,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${a}`);return ub(e,u,n,r,s,o,!1,a)}function Ipe(e,t,n,r,s,o,a="NDHWC"){let[i,l,u]=y_(t),c,p;if(a==="NDHWC")p="channelsLast",c=[i,l,u,e[4],e[4]];else if(a==="NCDHW")p="channelsFirst",c=[i,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${a}`);return T9(e,c,n,r,s,!1,p,o)}function ub(e,t,n,r,s,o,a=!1,i="channelsLast"){let[l,u,c,p]=[-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,p]=e;else if(i==="channelsFirst")[l,p,u,c]=e;else throw new Error(`Unknown dataFormat ${i}`);let[d,f,,h]=t,[m,g]=Qw(n),[x,y]=Qw(r),b=b0(d,x),A=b0(f,y),{padInfo:v,outHeight:w,outWidth:k}=Npe(s,u,c,m,g,b,A,o,i),I=a?h*p:h,N;return i==="channelsFirst"?N=[l,I,w,k]:i==="channelsLast"&&(N=[l,w,k,I]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:p,outHeight:w,outWidth:k,outChannels:I,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:f,effectiveFilterHeight:b,effectiveFilterWidth:A,dilationHeight:x,dilationWidth:y,inShape:e,outShape:N,filterShape:t}}function T9(e,t,n,r,s,o=!1,a="channelsLast",i){let[l,u,c,p,d]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,p,d]=e;else if(a==="channelsFirst")[l,d,u,c,p]=e;else throw new Error(`Unknown dataFormat ${a}`);let[f,h,m,,g]=t,[x,y,b]=y_(n),[A,v,w]=y_(r),k=b0(f,A),I=b0(h,v),N=b0(m,w),{padInfo:T,outDepth:_,outHeight:R,outWidth:S}=Tpe(s,u,c,p,x,y,b,k,I,N,i),F=o?g*d:g,B;return a==="channelsFirst"?B=[l,F,_,R,S]:a==="channelsLast"&&(B=[l,_,R,S,F]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:p,inChannels:d,outDepth:_,outHeight:R,outWidth:S,outChannels:F,padInfo:T,strideDepth:x,strideHeight:y,strideWidth:b,filterDepth:f,filterHeight:h,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:A,dilationHeight:v,dilationWidth:w,inShape:e,outShape:B,filterShape:t}}function Cpe(e,t,n,r,s){r==null&&(r=x_(e,t,n));let o=e[0],a=e[1],i=jf((o-t+2*r)/n+1,s),l=jf((a-t+2*r)/n+1,s);return[i,l]}function Spe(e,t,n,r,s,o){s==null&&(s=x_(e,t,r));let a=e[0],i=e[1],l=e[2],u=jf((a-t+2*s)/r+1,o),c=jf((i-t+2*s)/r+1,o),p=jf((l-t+2*s)/r+1,o);return[u,c,p,n]}function x_(e,t,n,r=1){let s=b0(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Qw(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function y_(e){return typeof e=="number"?[e,e,e]:e}function b0(e,t){return t<=1?e:e+(e-1)*(t-1)}function Npe(e,t,n,r,s,o,a,i,l){let u,c,p;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let f=Cpe([t,n],o,r,e,i);c=f[0],p=f[1]}else if(e==="same"){c=Math.ceil(t/r),p=Math.ceil(n/s);let d=Math.max(0,(c-1)*r+o-t),f=Math.max(0,(p-1)*s+a-n),h=Math.floor(d/2),m=d-h,g=Math.floor(f/2),x=f-g;u={top:h,bottom:m,left:g,right:x,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-o+1)/r),p=Math.ceil((n-a+1)/s);else if(typeof e=="object"){let d=l==="channelsLast"?e[1][0]:e[2][0],f=l==="channelsLast"?e[1][1]:e[2][1],h=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];u={top:d,bottom:f,left:h,right:m,type:d===0&&f===0&&h===0&&m===0?"VALID":"EXPLICIT"},c=jf((t-o+d+f)/r+1,i),p=jf((n-a+h+m)/s+1,i)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:p}}function Tpe(e,t,n,r,s,o,a,i,l,u,c){let p,d,f,h;if(typeof e=="number"){p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let g=Spe([t,n,r,1],i,1,s,e,c);d=g[0],f=g[1],h=g[2]}else if(e==="same"){d=Math.ceil(t/s),f=Math.ceil(n/o),h=Math.ceil(r/a);let m=(d-1)*s+i-t,g=(f-1)*o+l-n,x=(h-1)*a+u-r,y=Math.floor(m/2),b=m-y,A=Math.floor(g/2),v=g-A,w=Math.floor(x/2),k=x-w;p={top:A,bottom:v,left:w,right:k,front:y,back:b,type:"SAME"}}else if(e==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-i+1)/s),f=Math.ceil((n-l+1)/o),h=Math.ceil((r-u+1)/a);else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:d,outHeight:f,outWidth:h}}function jf(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Gc(e){let[t,n,r]=Qw(e);return t===1&&n===1&&r===1}function ol(e,t){return Gc(e)||Gc(t)}function _9(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function _pe(e,t){let r={x:U(e,"x","reshape","string_or_numeric")},s={shape:t};return se.runKernel(Xg,r,s)}var ie=ae({reshape_:_pe});function Epe(e,t,n,r,s){let o=U(e,"x","avgPool","float32"),a=1;H(ol(n,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let i=o,l=!1;o.rank===3&&(l=!0,i=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),H(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),s!=null&&H(as(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},p=se.runKernel(Vd,u,c);return p=Fe(p,o.dtype),l?ie(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var cb=ae({avgPool_:Epe});function Rpe(e,t,n,r,s,o="NDHWC"){let a=U(e,"x","avgPool3d","float32"),i=a,l=!1;a.rank===4&&(l=!0,i=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),H(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),H(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&H(as(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},p=se.runKernel(M1,u,c);return p=Fe(p,i.dtype),l?ie(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var b_=ae({avgPool3d_:Rpe});function Dpe(e,t=0){H(e.length>=1,()=>"Pass at least one tensor to concat");let n=ab(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return mi(n[0]);let r=n,s={axis:t};return se.runKernel(vg,r,s)}var En=ae({concat_:Dpe});function $pe(e){let n={x:U(e,"x","sigmoid")};return se.runKernel(Nf,n)}var xo=ae({sigmoid_:$pe});function Fpe(e,t,n){let r=U(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s={x:r},o={begin:t,size:n};return se.runKernel(Qg,s,o)}var gt=ae({slice_:Fpe});function Ope(e){let n={x:U(e,"x","tanh")};return se.runKernel(Ff,n)}var Hf=ae({tanh_:Ope});function Ppe(e,t,n,r,s,o){let a=U(e,"forgetBias","basicLSTMCell"),i=U(t,"lstmKernel","basicLSTMCell"),l=U(n,"lstmBias","basicLSTMCell"),u=U(r,"data","basicLSTMCell"),c=U(s,"c","basicLSTMCell"),p=U(o,"h","basicLSTMCell"),d=En([u,p],1),f=Lt(d,i),h=Re(f,l),m=h.shape[0],g=h.shape[1]/4,x=[m,g],y=gt(h,[0,0],x),b=gt(h,[0,g],x),A=gt(h,[0,g*2],x),v=gt(h,[0,g*3],x),w=Re(te(xo(y),Hf(b)),te(c,xo(Re(a,A)))),k=te(Hf(w),xo(v));return[w,k]}var Mpe=ae({basicLSTMCell_:Ppe});function zpe(e,t,n){let r=U(e,"x","batchToSpaceND"),s=t.reduce((i,l)=>i*l);H(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),H(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),H(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let o={x:r},a={blockShape:t,crops:n};return se.runKernel(Ag,o,a)}var pb=ae({batchToSpaceND_:zpe});function Lpe(e){let t;return e.rank===0||e.rank===1?t=ie(e,[1,1,1,e.size]):e.rank===2?t=ie(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function Bpe(e,t,n,r,s,o){o==null&&(o=.001);let a=U(e,"x","batchNorm"),i=U(t,"mean","batchNorm"),l=U(n,"variance","batchNorm"),u;s!=null&&(u=U(s,"scale","batchNorm"));let c;r!=null&&(c=U(r,"offset","batchNorm")),H(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),H(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),H(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:Lpe(a),scale:u,offset:c,mean:i,variance:l},f={varianceEpsilon:o},h=se.runKernel(nf,d,f);return ie(h,a.shape)}var qf=ae({batchNorm_:Bpe});function Vpe(e,t,n,r,s,o){let a=U(e,"x","batchNorm"),i=U(t,"mean","batchNorm"),l=U(n,"variance","batchNorm"),u;s!=null&&(u=U(s,"scale","batchNorm"));let c;return r!=null&&(c=U(r,"offset","batchNorm")),H(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),H(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),H(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&H(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&H(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),qf(a,i,l,c,u,o)}var E9=ae({batchNorm2d_:Vpe});function Wpe(e,t,n,r,s,o){let a=U(e,"x","batchNorm"),i=U(t,"mean","batchNorm"),l=U(n,"variance","batchNorm"),u;s!=null&&(u=U(s,"scale","batchNorm"));let c;return r!=null&&(c=U(r,"offset","batchNorm")),H(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),H(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),H(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&H(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&H(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),qf(a,i,l,c,u,o)}var R9=ae({batchNorm3d_:Wpe});function Gpe(e,t,n,r,s,o){let a=U(e,"x","batchNorm"),i=U(t,"mean","batchNorm"),l=U(n,"variance","batchNorm"),u;s!=null&&(u=U(s,"scale","batchNorm"));let c;return r!=null&&(c=U(r,"offset","batchNorm")),H(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),H(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),H(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&H(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&H(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),qf(a,i,l,c,u,o)}var D9=ae({batchNorm4d_:Gpe});function Upe(e,t,n){let r=U(e,"x","bincount"),s=U(t,"weights","bincount");H(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),H(n>=0,()=>`size must be non-negative, but got ${n}.`),H(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);let o={x:r,weights:s},a={size:n};return se.runKernel(nw,o,a)}var A_=ae({bincount_:Upe});function jpe(e,t){let n=U(e,"s0","broadcastArgs","int32"),r=U(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let s={s0:n,s1:r};return se.runKernel(ET,s)}var $9=ae({broadcastArgs_:jpe});function Hpe(e,t){let n=U(e,"broadcastTo","x"),r=n.shape;if(t.some(u=>!(u>0)||u%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=ie(n,u)}let s=n.shape,o=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])o[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return mi(n);let i={x:n},l={reps:o};return se.runKernel(Oc,i,l)}var A0=ae({broadcastTo_:Hpe});function qpe(e){let n={x:U(e,"x","ceil")};return se.runKernel(Ud,n)}var v_=ae({ceil_:qpe});function Kpe(e,t,n){let r=U(e,"x","clipByValue");H(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`);let s={x:r},o={clipValueMin:t,clipValueMax:n};return se.runKernel(Fc,s,o)}var yo=ae({clipByValue_:Kpe});function Xpe(e){return En(e,0)}var F9=ae({concat1d_:Xpe});function Zpe(e,t){return En(e,t)}var v0=ae({concat2d_:Zpe});function Ype(e,t){return En(e,t)}var O9=ae({concat3d_:Ype});function Jpe(e,t){return En(e,t)}var P9=ae({concat4d_:Jpe});function Qpe(e,t,n,r,s="NHWC",o=[1,1],a){let i=U(e,"x","conv2d"),l=U(t,"filter","conv2d"),u=i,c=!1;i.rank===3&&(c=!0,u=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),H(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),H(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),a!=null&&H(as(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);let p=s==="NHWC"?u.shape[3]:u.shape[1];H(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),H(ol(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let d={x:u,filter:l},f={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a},h=se.runKernel(jd,d,f);return c?ie(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Bl=ae({conv2d_:Qpe});function ede(e,t,n,r,s="NWC",o=1,a){let i=U(e,"x","conv1d"),l=U(t,"filter","conv1d"),u=i,c=!1;i.rank===2&&(c=!0,u=ie(i,[1,i.shape[0],i.shape[1]])),H(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),H(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),a!=null&&H(as(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),H(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),H(ol(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),H(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let p=ie(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=ie(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Bl(d,p,[1,n],r,"NHWC",[1,o],a);return c?ie(g,[g.shape[2],g.shape[3]]):ie(g,[g.shape[0],g.shape[2],g.shape[3]])}var ek=ae({conv1d_:ede});function tde(e,t,n,r,s,o="NHWC",a){H(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,l=t,u=!1;t.rank===3&&(u=!0,l=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),H(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),H(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),H(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=o==="NHWC"?i[3]:i[1],p=o==="NHWC"?l.shape[3]:l.shape[1];H(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),H(p===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`),a!=null&&H(as(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let d={dy:l,filter:n},f={strides:r,pad:s,dataFormat:o,dimRoundingMode:a,inputShape:i},h=se.runKernel(Hd,d,f);return u?ie(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var w_=ae({conv2DBackpropInput_:tde});function nde(e,t,n,r,s,o){let a=U(e,"x","conv2dTranspose"),i=U(t,"filter","conv2dTranspose");return w_(n,a,i,r,s,"NHWC",o)}var tk=ae({conv2dTranspose_:nde});function rde(e,t,n,r,s="NDHWC",o=[1,1,1]){let a=U(e,"x","conv3d"),i=U(t,"filter","conv3d"),l=a,u=!1;a.rank===4&&(u=!0,l=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),H(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),H(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),H(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),H(ol(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),H(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);let c={x:l,filter:i},p={strides:n,pad:r,dataFormat:s,dilations:o},d=se.runKernel(L1,c,p);return u?ie(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var k_=ae({conv3d_:rde});function sde(e,t,n,r,s){H(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,a=t,i=!1;t.rank===4&&(i=!0,a=ie(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);let l=o[4],u=a.shape[4];H(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),H(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),H(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),H(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),H(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let c={dy:a,filter:n},p={pad:s,strides:r,inputShape:o},d=se.runKernel(aw,c,p);return i?ie(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var M9=ae({conv3DBackpropInput_:sde});function ode(e,t,n,r,s){let o=U(e,"x","conv3dTranspose"),a=U(t,"filter","conv3dTranspose");return M9(n,o,a,r,s)}var z9=ae({conv3dTranspose_:ode});function ade(e){let n={x:U(e,"x","cos")};return se.runKernel(qd,n)}var db=ae({cos_:ade});function ide(e){let n={x:U(e,"x","cosh")};return se.runKernel(Kd,n)}var nk=ae({cosh_:ide});function lde(e,t=0,n=!1,r=!1){let o={x:U(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return se.runKernel(Xd,o,a)}var rk=ae({cumsum_:lde});function ude(e,t,n,r=!1){let s=U(e,"x","denseBincount"),o=U(t,"weights","denseBincount");H(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),H(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),H(n>=0,()=>`size must be non-negative, but got ${n}.`),H(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);let a={x:s,weights:o},i={size:n,binaryOutput:r};return se.runKernel(iw,a,i)}var L9=ae({denseBincount_:ude});function cde(e,t,n="NHWC"){let r=U(e,"x","depthToSpace"),s=n==="NHWC"?r.shape[1]:r.shape[2],o=n==="NHWC"?r.shape[2]:r.shape[3],a=n==="NHWC"?r.shape[3]:r.shape[1];H(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),H(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t} for depthToSpace with input shape
        ${r.shape}`),H(a%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${r.shape}`);let i={x:r},l={blockSize:t,dataFormat:n};return se.runKernel(kg,i,l)}var I_=ae({depthToSpace_:cde});function pde(e,t,n,r,s="NHWC",o=[1,1],a){let i=U(e,"x","depthwiseConv2d"),l=U(t,"filter","depthwiseConv2d"),u=i,c=!1;i.rank===3&&(c=!0,u=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),H(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),H(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),H(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),a!=null&&H(as(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);let p={x:u,filter:l},d={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a},f=se.runKernel(Zd,p,d);return c?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var w0=ae({depthwiseConv2d_:pde});function dde(e){let n={x:U(e,"x","diag")};return se.runKernel(cw,n)}var fde=ae({diag_:dde});function hde(e,t,n,r,s=[1,1],o="NHWC"){let a=U(e,"x","dilation2d"),i=U(t,"filter","dilation2d");H(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),H(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),H(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=a,u=!1;a.rank===3&&(l=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);let c={x:l,filter:i},p={strides:n,pad:r,dilations:s},d=se.runKernel(B1,c,p);return u?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var C_=ae({dilation2d_:hde});function mde(e,t){let n=e.length,r=[];for(let s=0;s<n;s++){let o=n-1-s,a=e[o]||1;(t[t.length-1-s]||1)>1&&a===1&&r.unshift(o)}return r}function jr(e,t){let n=[];for(let r=0;r<t.length;r++){let s=e[e.length-r-1],o=t.length-r-1,a=t[o];(s==null||s===1&&a>1)&&n.unshift(o)}return n}function Wn(e,t){let n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let o=e[e.length-s-1];o==null&&(o=1);let a=t[t.length-s-1];if(a==null&&(a=1),o===1)n.unshift(a);else if(a===1)n.unshift(o);else if(o!==a){let i=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(i)}else n.unshift(o)}return n}function gde(e,t){let n=U(e,"a","equal","string_or_numeric"),r=U(t,"b","equal","string_or_numeric");[n,r]=ur(n,r),Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Cg,s)}var Lo=ae({equal_:gde});function xde(e,t,n){let r=U(t,"a","where"),s=U(n,"b","where"),o=U(e,"condition","where","bool"),a=Wn(Wn(o.shape,r.shape),s.shape),i=A0(o,a),l=A0(r,a),u=A0(s,a),c={condition:i,t:l,e:u};return se.runKernel(Yg,c)}var $s=ae({where_:xde});function yde(e){let n={x:U(e,"x","zerosLike")};return se.runKernel(u0,n)}var Xt=ae({zerosLike_:yde});function bde(e,t){let n=U(e,"a","div"),r=U(t,"b","div");[n,r]=ur(n,r);let s=Me(n,r),o=Xt(s),a=Lo(r,o);return $s(a,o,s)}var S_=ae({divNoNan_:bde});function Ade(e,t){let n=U(e,"t1","dot"),r=U(t,"t2","dot");H((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let s=n.rank===1?n.size:n.shape[1],o=r.rank===1?r.size:r.shape[0];if(H(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),n.rank===1&&r.rank===1){let a=ie(n,[1,-1]),i=ie(r,[-1,1]),l=Lt(a,i);return ie(l,[])}else if(n.rank===1&&r.rank===2){let a=ie(n,[1,-1]),i=ie(r,[r.shape[0],r.shape[1]]),l=Lt(a,i);return ie(l,[l.size])}else if(n.rank===2&&r.rank===1){let a=ie(r,[-1,1]),i=Lt(n,a);return ie(i,[i.size])}else{let a=ie(r,[r.shape[0],r.shape[1]]);return Lt(n,a)}}var B9=ae({dot_:Ade});function vde(e,...t){let n=t.map((s,o)=>U(s,`tensors${o}`,"einsum")),r={equation:e};return se.runKernel(fw,n,r)}var V9=ae({einsum_:vde});function wde(e){let n={x:U(e,"x","elu")};return se.runKernel(Jd,n)}var k0=ae({elu_:wde});function kde(e){let t=U(e,"x","erf");H(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Fe(t,"float32"));let n={x:t};return se.runKernel(Ig,n)}var N_=ae({erf_:kde});function Ide(e){let n={x:U(e,"x","exp")};return se.runKernel(Qd,n)}var Bo=ae({exp_:Ide});function Cde(e,t=0){let n=U(e,"x","expandDims","string_or_numeric");H(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},s={dim:t};return se.runKernel(Sg,r,s)}var kr=ae({expandDims_:Cde});function Sde(e){let n={x:U(e,"x","expm1")};return se.runKernel(Ng,n)}var T_=ae({expm1_:Sde});function Nde(e,t){let n=U(e,"x","tile","string_or_numeric");H(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},s={reps:t};return se.runKernel(Oc,r,s)}var da=ae({tile_:Nde});function Tde(e,t,n,r="float32"){t==null&&(t=e);let s=Wt([e,t],r),o=e<=t?e:t;for(let i=0;i<o;++i)s.set(1,i,i);let a=ie(s.toTensor(),[e,t]);if(n==null)return a;if(n.length===1)return da(kr(a,0),[n[0],1,1]);if(n.length===2)return da(kr(kr(a,0),0),[n[0],n[1],1,1]);if(n.length===3)return da(kr(kr(kr(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var __=ae({eye_:Tde});function I0(e,t,n){let r={shape:e,value:t,dtype:n};return se.runKernel(V1,{},r)}function _de(e){let n={x:U(e,"x","floor")};return se.runKernel(ef,n)}var C0=ae({floor_:_de});function Ede(e,t,n=0,r=0){let s=U(e,"x","gather"),o=U(t,"indices","gather","int32"),a={x:s,indices:o},i={axis:n,batchDims:r};return se.runKernel(_g,a,i)}var Kf=ae({gather_:Ede});function Rde(e,t){let n=U(e,"a","greater","string_or_numeric"),r=U(t,"b","greater","string_or_numeric");[n,r]=ur(n,r),Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Rg,s)}var bo=ae({greater_:Rde});function Dde(e,t){let n=U(e,"a","greaterEqual","string_or_numeric"),r=U(t,"b","greaterEqual","string_or_numeric");[n,r]=ur(n,r),Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(rf,s)}var Uc=ae({greaterEqual_:Dde});function $de(e){let n={input:U(e,"input","imag")};return se.runKernel(xw,n)}var sk=ae({imag_:$de});function Fde(e){let n={x:U(e,"x","isFinite")};return se.runKernel(Dg,n)}var W9=ae({isFinite_:Fde});function Ode(e){let n={x:U(e,"x","isInf")};return se.runKernel($g,n)}var G9=ae({isInf_:Ode});function Pde(e){let n={x:U(e,"x","isNaN")};return se.runKernel(Fg,n)}var E_=ae({isNaN_:Pde});function Mde(e,t=.2){let r={x:U(e,"x","leakyRelu")},s={alpha:t};return se.runKernel(of,r,s)}var fb=ae({leakyRelu_:Mde});function zde(e,t){let n=U(e,"a","less","string_or_numeric"),r=U(t,"b","less","string_or_numeric");[n,r]=ur(n,r),Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Og,s)}var ok=ae({less_:zde});function Lde(e,t){let n=U(e,"a","lessEqual","string_or_numeric"),r=U(t,"b","lessEqual","string_or_numeric");[n,r]=ur(n,r),Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Pg,s)}var jc=ae({lessEqual_:Lde});function U9(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return se.runKernel(yw,{},r)}function Bde(e,t=5,n=1,r=1,s=.5){let o=U(e,"x","localResponseNormalization");H(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),H(as(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let l={x:a},u={depthRadius:t,bias:n,alpha:r,beta:s},c=se.runKernel(U1,l,u);return i?ie(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var R_=ae({localResponseNormalization_:Bde});function Vde(e){let n={x:U(e,"x","log")};return se.runKernel(af,n)}var Vo=ae({log_:Vde});function Wde(e){let n={x:U(e,"x","log1p")};return se.runKernel(Mg,n)}var hb=ae({log1p_:Wde});function Gde(e){return H(Dc(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=U(t,"x","tf.grad","string_or_numeric"),s=n!=null?U(n,"dy","tf.grad"):null;return se.tidy(()=>{let{value:o,grads:a}=se.gradients(()=>e(r),[r],s);return s!=null&&zs(o.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),ak(a),a[0]})}}function Ude(e){return H(Dc(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{H(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=ab(t,"args","tf.grads","string_or_numeric"),s=n!=null?U(n,"dy","tf.grads"):null;return se.tidy(()=>{let{value:o,grads:a}=se.gradients(()=>e(...r),r,s);return s!=null&&zs(o.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ak(a),a})}}function jde(e){return H(Dc(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{H(t instanceof Vt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),H(n==null||n instanceof Vt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:s}=se.gradients(()=>e(t),[t],n);return ak(r),{grad:r[0],value:s}}}function Hde(e){return H(Dc(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{H(Array.isArray(t)&&t.every(s=>s instanceof Vt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),H(n==null||n instanceof Vt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=se.gradients(()=>e(...t),t,n);return n!=null&&zs(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ak(r.grads),r}}function j9(e,t){H(Dc(e),()=>"The f passed in variableGrads(f) must be a function"),H(t==null||Array.isArray(t)&&t.every(u=>u instanceof rb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let u in se.registeredVariables)t.push(se.registeredVariables[u])}let r=n?t.filter(u=>!u.trainable):null,s=t.length;t=t.filter(u=>u.trainable),H(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let o=!0,{value:a,grads:i}=se.gradients(e,t,null,o);H(i.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),H(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let l={};return t.forEach((u,c)=>{i[c]!=null&&(l[u.name]=i[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:a,grads:l}}function al(e){return se.customGrad(e)}function ak(e){if(e.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function qde(e){let n={x:U(e,"x","neg")};return se.runKernel(Bg,n)}var er=ae({neg_:qde});function Kde(e){let n={x:U(e,"x","softplus")};return se.runKernel(n0,n)}var Xf=ae({softplus_:Kde});function Xde(e){let t=U(e,"x","logSigmoid");return al(r=>({value:er(Xf(er(r))),gradFunc:a=>te(a,xo(er(r)))}))(t)}var H9=ae({logSigmoid_:Xde});function Zde(e,t=null,n=!1){let s={x:U(e,"x","max")},o={reductionIndices:t,keepDims:n};return se.runKernel(lf,s,o)}var Wo=ae({max_:Zde});function Yde(e,t){let n=U(e,"a","sub"),r=U(t,"b","sub");[n,r]=ur(n,r);let s={a:n,b:r};return se.runKernel(Df,s)}var Ge=ae({sub_:Yde});function Jde(e,t=null,n=!1){let r=U(e,"x","sum");r.dtype==="bool"&&(r=Fe(r,"int32"));let s={x:r},o={axis:t,keepDims:n};return se.runKernel(_f,s,o)}var Je=ae({sum_:Jde});function Qde(e,t=-1){let n=U(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return al((s,o)=>{let a=!0,i=Wo(s,t,!0),l=Ge(s,i),u=Ge(Fe(l,"float32"),Vo(Je(Bo(l),t,a)));return o([u]),{value:u,gradFunc:(p,d)=>{let[f]=d,h=!0,m=Bo(f);return Ge(p,te(Je(p,t,h),m))}}})(n)}var ik=ae({logSoftmax_:Qde});function D_(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function q9(e,t,n){let r=e.length+t.length,s=[],o=0,a=0;for(let i=0;i<r;i++)n.indexOf(i)===-1?s.push(e[o++]):s.push(t[a++]);return s}function K9(e,t){let n=[],r=e.length;for(let o=0;o<r;o++)t.indexOf(o)===-1&&n.push(e[o]);let s=t.map(o=>e[o]);return[n,s]}function Zf(e,t){let n=t.map(r=>1);return q9(e,n,t)}function efe(e,t,n){H(D_(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function X9(e,t){if(D_(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function $_(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function tfe(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function nfe(e,t=null,n=!1){let r=U(e,"x","logSumExp"),s=Ra(t,r.shape),o=Wo(r,s,!0),a=Ge(r,o),i=Bo(a),l=Je(i,s),u=Vo(l),c=Re(ie(o,u.shape),u);if(n){let p=Zf(c.shape,s);return ie(c,p)}return c}var F_=ae({logSumExp_:nfe});function rfe(e,t){let n=U(e,"a","logicalAnd","bool"),r=U(t,"b","logicalAnd","bool");Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(zg,s)}var Fa=ae({logicalAnd_:rfe});function sfe(e){let n={x:U(e,"x","logicalNot","bool")};return se.runKernel(W1,n)}var mb=ae({logicalNot_:sfe});function ofe(e,t){let n=U(e,"a","logicalOr","bool"),r=U(t,"b","logicalOr","bool");Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(G1,s)}var lk=ae({logicalOr_:ofe});function afe(e,t){let n=U(e,"a","logicalXor","bool"),r=U(t,"b","logicalXor","bool");return Wn(n.shape,r.shape),Fa(lk(e,t),mb(Fa(e,t)))}var Z9=ae({logicalXor_:afe});function ife(e,t,n,r,s){let o=U(e,"x","maxPool"),a=1,i=o,l=!1;o.rank===3&&(l=!0,i=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),H(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),H(ol(n,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),s!=null&&H(as(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},p=se.runKernel(cf,u,c);return l?ie(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var gb=ae({maxPool_:ife});function lfe(e,t=[1,1,1],n,r,s,o="NDHWC"){let a=U(e,"x","maxPool3d"),i=a,l=!1;a.rank===4&&(l=!0,i=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),H(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),H(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&H(as(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},p=se.runKernel(j1,u,c);return l?ie(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var O_=ae({maxPool3d_:lfe});function ufe(e,t,n,r,s=!1){let a={x:U(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},l=se.runKernel(ww,a,i);return{result:l[0],indexes:l[1]}}var Y9=ae({maxPoolWithArgmax_:ufe});function cfe(e,t){let n=U(e,"a","maximum"),r=U(t,"b","maximum");[n,r]=ur(n,r),n.dtype==="bool"&&(n=Fe(n,"int32"),r=Fe(r,"int32")),Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(uf,s)}var il=ae({maximum_:cfe});function pfe(e,t=null,n=!1){let s={x:U(e,"x","mean")},o={axis:t,keepDims:n};return se.runKernel(pf,s,o)}var cr=ae({mean_:pfe});function xr(e,t="float32"){if(t==="complex64"){let r=xr(e,"float32"),s=xr(e,"float32");return Lc(r,s)}let n=Qv(wr(e),t);return se.makeTensor(n,e,t)}function Go(e,t="float32"){if(t==="complex64"){let r=Go(e,"float32"),s=xr(e,"float32");return Lc(r,s)}let n=CT(wr(e),t);return se.makeTensor(n,e,t)}function dfe(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=U(e,"x","meshgrid",e instanceof Vt?e.dtype:"float32");if(t===void 0)return[r];let s=U(t,"y","meshgrid",t instanceof Vt?t.dtype:"float32"),o=wr(r.shape),a=wr(s.shape);return n==="xy"?(r=ie(r,[1,-1]),s=ie(s,[-1,1]),[Lt(Go([a,1],r.dtype),r),Lt(s,Go([1,o],s.dtype))]):(r=ie(r,[-1,1]),s=ie(s,[1,-1]),[Lt(r,Go([1,a],r.dtype)),Lt(Go([o,1],s.dtype),s)])}function ffe(e,t=null,n=!1){let s={x:U(e,"x","min")},o={axis:t,keepDims:n};return se.runKernel(df,s,o)}var xb=ae({min_:ffe});function hfe(e,t){let n=U(e,"a","minimum"),r=U(t,"b","minimum");[n,r]=ur(n,r),n.dtype==="bool"&&(n=Fe(n,"int32"),r=Fe(r,"int32")),Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(ff,s)}var S0=ae({minimum_:hfe});function mfe(e,t,n){H(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=U(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");H(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=n==="reflect"?1:0;for(let i=0;i<r.rank;i++)H(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),H(t[i][0]>=0&&t[i][0]<=r.shape[i]-s&&t[i][1]>=0&&t[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);let o={paddings:t,mode:n},a={x:r};return se.runKernel(hf,a,o)}var P_=ae({mirrorPad_:mfe});function gfe(e,t){let n=U(e,"a","mod"),r=U(t,"b","mod");[n,r]=ur(n,r);let s={a:n,b:r};return se.runKernel(Lg,s)}var M_=ae({mod_:gfe});function xfe(e){let t=U(e,"x","square"),n={};return se.runKernel("Square",{x:t},n)}var Tn=ae({square_:xfe});function yfe(e,t=null,n=!1){e=U(e,"x","moments");let r=Ra(t,e.shape),s=cr(e,r,n),o=s.shape;n||(o=Zf(s.shape,r));let a=Tn(Ge(Fe(e,"float32"),ie(s,o))),i=cr(a,r,n);return{mean:s,variance:i}}var uk=ae({moments_:yfe});function bfe(e,t,n,r){let s=U(t,"data","multiRNNCell"),o=ab(n,"c","multiRNNCell"),a=ab(r,"h","multiRNNCell"),i=s,l=[];for(let p=0;p<e.length;p++){let d=e[p](i,o[p],a[p]);l.push(d[0]),l.push(d[1]),i=d[1]}let u=[],c=[];for(let p=0;p<l.length;p+=2)u.push(l[p]),c.push(l[p+1]);return[u,c]}var Afe=ae({multiRNNCell_:bfe});function vfe(e,t,n,r=!1){let s=U(e,"logits","multinomial"),o=s.size,a=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();let l={logits:a===1?ie(s,[1,-1]):s},u={numSamples:t,seed:n,normalized:r},c=se.runKernel(kw,l,u);return a===1?ie(c,[c.size]):c}var J9=ae({multinomial_:vfe});function wfe(e,t){let n=U(e,"a","notEqual","string_or_numeric"),r=U(t,"b","notEqual","string_or_numeric");[n,r]=ur(n,r),Wn(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Vg,s)}var Yf=ae({notEqual_:wfe});function kfe(e){let n={x:U(e,"x","onesLike")};return se.runKernel(jg,n)}var Uo=ae({onesLike_:kfe});function Ife(e,t){let n=U(e,"v1","outerProduct"),r=U(t,"v2","outerProduct");H(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let s=ie(n,[-1,1]),o=ie(r,[1,-1]);return Lt(s,o)}var Cfe=ae({outerProduct_:Ife});function Sfe(e,t,n=0){let r=U(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:n},o={x:r};return se.runKernel(xf,o,s)}var Vl=ae({pad_:Sfe});function Nfe(e,t,n=0){return H(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Vl(e,[t],n)}var Tfe=ae({pad1d_:Nfe});function _fe(e,t,n=0){return H(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vl(e,t,n)}var Efe=ae({pad2d_:_fe});function Rfe(e,t,n=0){return H(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vl(e,t,n)}var Dfe=ae({pad3d_:Rfe});function $fe(e,t,n=0){return H(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Vl(e,t,n)}var Ffe=ae({pad4d_:$fe});function Ofe(e,t,n){let r=U(e,"x","spaceToBatchND");H(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),H(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),H(r.shape.reduce((a,i,l)=>l>0&&l<=t.length?a&&(i+n[l-1][0]+n[l-1][1])%t[l-1]==0:a,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:r},o={blockShape:t,paddings:n};return se.runKernel(r0,s,o)}var yb=ae({spaceToBatchND_:Ofe});function Pfe(e,t,n,r,s,o){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");let a=U(e,"x","maxPool"),i=a,l=!1;a.rank===3&&(l=!0,i=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]])),H(ol(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);let u=N9(i.shape,t,o,s,r),c=[u.dilationHeight,u.dilationWidth],p;r==="same"?p=zfe([u.filterHeight,u.filterWidth],c):p=[[0,0],[0,0]];let d=c[0]===1&&c[1]===1,[f,h]=Mfe([u.inHeight,u.inWidth],c,p),m=d?r:"valid",g=d?i:yb(i,c,f),y=(n==="avg"?()=>cb(g,t,o,m):()=>gb(g,t,o,m))(),b=d?y:pb(y,c,h);return l?ie(b,[b.shape[1],b.shape[2],b.shape[3]]):b}function Mfe(e,t,n){let r=n.map(c=>c[0]),s=n.map(c=>c[1]),o=e.concat(r,s),a=t.map((c,p)=>(c-o[p]%c)%c),i=s.map((c,p)=>c+a[p]),l=t.map((c,p)=>[r[p],i[p]]),u=t.map((c,p)=>[0,a[p]]);return[l,u]}function zfe(e,t){let r=e.map((a,i)=>a+(a-1)*(t[i]-1)).map(a=>a-1),s=r.map(a=>Math.floor(a/2)),o=r.map((a,i)=>a-s[i]);return r.map((a,i)=>[s[i],o[i]])}var Q9=ae({pool_:Pfe});function Lfe(e,t){let n=U(e,"base","pow"),r=U(t,"exp","pow");[n,r]=ur(n,r);let s={a:n,b:r};return se.runKernel(yf,s)}var Wl=ae({pow_:Lfe});function Bfe(e,t){let n=U(e,"x","prelu"),r=U(t,"alpha","prelu"),s={x:n,alpha:r};return se.runKernel(bf,s)}var bb=ae({prelu_:Bfe});function Vfe(e,t=null,n=!1){let r=U(e,"x","prod");r.dtype==="bool"&&(r=Fe(r,"int32"));let s={x:r},o={axis:t,keepDims:n};return se.runKernel(qg,s,o)}var ck=ae({prod_:Vfe});function Wfe(e,t,n){let r=wr(e),s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<r;o++)s[o]=t();return se.makeTensor(s,e,n)}var Gfe=ae({rand_:Wfe}),z_=Pd(cP()),L_=class{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let o=s||Math.random();this.random=z_.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,s,o;do r=2*this.random()-1,s=2*this.random()-1,o=r*r+s*s;while(o>=1||o===0);let a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},Ufe=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let s=r||Math.random();this.randu=z_.alea(s.toString()),this.randn=new L_(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-o+Math.log(o)),s=this.randu(),s<t||Math.log(s)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},jfe=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=z_.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function Hfe(e,t,n=1,r="float32",s){if(n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let o=new Ufe(t,n,r,s),a=Wt(e,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}var qfe=ae({randomGamma_:Hfe});function Kfe(e,t=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let o=new L_(t,n,r,!1,s),a=Wt(e,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}var eM=ae({randomNormal_:Kfe});function Xfe(e,t=0,n=1,r="float32",s){let o=Wt(e,r),a=new jfe(t,n,null,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}var N0=ae({randomUniform_:Xfe});function T0(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let s={start:e,stop:t,step:n,dtype:r};return se.runKernel(H1,{},s)}function Zfe(e){let n={input:U(e,"input","real")};return se.runKernel(Iw,n)}var Ab=ae({real_:Zfe});function Yfe(e){let n={x:U(e,"x","reciprocal")};return se.runKernel(Kg,n)}var B_=ae({reciprocal_:Yfe});function Jfe(e){let n={x:U(e,"x","relu")};return se.runKernel(Af,n)}var yi=ae({relu_:Jfe});function Qfe(e){let n={x:U(e,"x","relu6")};return se.runKernel(wf,n)}var pk=ae({relu6_:Qfe});function ehe(e,t){let r={x:U(e,"x","reverse")},s={dims:t};return se.runKernel(kf,r,s)}var jo=ae({reverse_:ehe});function the(e){let t=U(e,"x","reverse");return H(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),jo(t,0)}var nhe=ae({reverse1d_:the});function rhe(e,t){let n=U(e,"x","reverse");return H(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),jo(n,t)}var she=ae({reverse2d_:rhe});function ohe(e,t){let n=U(e,"x","reverse");return H(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),jo(n,t)}var ahe=ae({reverse3d_:ohe});function ihe(e,t){let n=U(e,"x","reverse");return H(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),jo(n,t)}var lhe=ae({reverse4d_:ihe});function uhe(e){let n={x:U(e,"x","round")};return se.runKernel(If,n)}var dk=ae({round_:uhe});function che(e){let n={x:U(e,"x","rsqrt")};return se.runKernel(Cf,n)}var fk=ae({rsqrt_:che});function at(e,t){if((Ds(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Ds(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Bc(e,[],[],t)}function phe(e){let n={x:U(e,"x","selu")};return se.runKernel(Jg,n)}var hk=ae({selu_:phe});function dhe(e,t,n,r,s,o=[1,1],a="NHWC"){let i=U(e,"x","separableConv2d"),l=U(t,"depthwiseFilter","separableConv2d"),u=U(n,"pointwiseFilter","separableConv2d"),c=i,p=!1;if(i.rank===3&&(p=!0,c=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");H(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),H(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),H(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),H(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),H(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let d=l.shape[2],f=l.shape[3];H(u.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${u.shape[2]}.`);let h=w0(c,l,r,s,a,o),g=Bl(h,u,1,"valid",a);return p?ie(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var V_=ae({separableConv2d_:dhe});async function fhe(e,t){let n=U(e,"x","setdiff1d"),r=U(t,"y","setdiff1d");H(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),H(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),H(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await n.data(),o=await r.data(),a=new Set(o),i=0;for(let c=0;c<s.length;c++)a.has(s[c])||i++;let l=new Ur([i],n.dtype),u=new Ur([i],"int32");for(let c=0,p=0;c<s.length;c++)a.has(s[c])||(l.values[p]=s[c],u.values[p]=c,p++);return[l.toTensor(),u.toTensor()]}var tM=fhe;function hhe(e){let n={x:U(e,"x","sign")};return se.runKernel(t0,n)}var W_=ae({sign_:hhe});function mhe(e){let n={x:U(e,"x","sin")};return se.runKernel(Sf,n)}var mk=ae({sin_:mhe});function ghe(e){let n={x:U(e,"x","sinh")};return se.runKernel(e0,n)}var gk=ae({sinh_:ghe});function xhe(e,t,n){let r=U(e,"x","slice1d");return H(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),gt(r,[t],[n])}var xk=ae({slice1d_:xhe});function yhe(e,t,n){let r=U(e,"x","slice2d");return H(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),gt(r,t,n)}var G_=ae({slice2d_:yhe});function bhe(e,t,n){let r=U(e,"x","slice3d");return H(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),gt(r,t,n)}var yk=ae({slice3d_:bhe});function Ahe(e,t,n){let r=U(e,"x","slice4d");return H(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),gt(r,t,n)}var vb=ae({slice4d_:Ahe});function vhe(e,t=-1){let n=U(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},s={dim:t};return se.runKernel(Ef,r,s)}var Jf=ae({softmax_:vhe});function whe(e){H(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return se.runKernel(mw,t)}var wb=ae({fft_:whe});function khe(e){H(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return se.runKernel(gw,t)}var _0=ae({ifft_:khe});function Ihe(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let s=ie(e,[n,t]);r=_0(s)}else{let s=[n,2*(t-1)],o=ie(Ab(e),[n,t]),a=ie(sk(e),[n,t]),i=jo(gt(o,[0,1],[n,t-2]),1),l=te(jo(gt(a,[0,1],[n,t-2]),1),at(-1)),u=En([o,i],1),c=En([a,l],1),p=ie(Lc(u,c),[s[0],s[1]]);r=_0(p)}if(r=Ab(r),e.rank===3&&e.shape[0]!==0){let s=r,o=e.shape[0];r=ie(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}var bk=ae({irfft_:Ihe});function Che(e,t,n=0){let s={x:U(e,"x","split")},o={numOrSizeSplits:t,axis:n};return se.runKernel(s0,s,o)}var _r=ae({split_:Che});function She(e,t){H(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,s;if(t!=null&&t<n){let h=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=gt(e,h,m),n=t}else if(t!=null&&t>n){let h=e.shape.map(m=>m);h[e.shape.length-1]=t-n,s=En([e,xr(h)],e.shape.length-1),n=t}else s=e;let o=Xt(s),a=ie(Lc(s,o),[r,n]),i=wb(a),l=Math.floor(n/2)+1,u=Ab(i),c=sk(i),p=_r(u,[l,n-l],u.shape.length-1),d=_r(c,[l,n-l],c.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,ie(Lc(p[0],d[0]),f)}var kb=ae({rfft_:She});function Nhe(e){let n={x:U(e,"x","sqrt")};return se.runKernel(Tf,n)}var As=ae({sqrt_:Nhe});function The(e,t){let n=U(e,"a","squaredDifference"),r=U(t,"b","squaredDifference");[n,r]=ur(n,r),Wn(n.shape,r.shape);let s={a:n,b:r},o={};return se.runKernel(Rf,s,o)}var Ak=ae({squaredDifference_:The});function _he(e,t){let n=U(e,"x","squeeze");return ie(n,hP(n.shape,t).newShape)}var ln=ae({squeeze_:_he});function Ehe(e,t=0){let n=ab(e,"tensors","stack","string_or_numeric");H(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&H(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,s={axis:t};return se.runKernel(Hg,r,s)}var vs=ae({stack_:Ehe});function Rhe(e,t=0){let r={x:U(e,"x","step")},s={alpha:t};return se.runKernel(Pc,r,s)}var E0=ae({step_:Rhe});function Dhe(e,t,n,r,s=0,o=0,a=0,i=0,l=0){let c={x:U(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};return se.runKernel(o0,c,p)}var U_=ae({stridedSlice_:Dhe});function $he(e){let n={x:U(e,"x","tan")};return se.runKernel($f,n)}var j_=ae({tan_:$he});function Er(e,t){Md(e);let n=rl(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Bc(e,null,n,t)}function bi(e,t,n){if(Md(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=rl(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Bc(e,t,r,n)}function Fhe(e,t,n){if(Md(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=rl(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Bc(e,t,r,n)}function Ohe(e,t,n){if(Md(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=rl(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Bc(e,t,r,n)}function Phe(e,t,n){if(Md(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=rl(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Bc(e,t,r,n)}function Mhe(e,t=1,n=!0){let r=U(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let o={x:r},a={k:t,sorted:n},[i,l]=se.runKernel(a0,o,a);return{values:i,indices:l}}var H_=ae({topk_:Mhe});function zhe(e,t=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let o=new L_(t,n,r,!0,s),a=Wt(e,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}var vk=ae({truncatedNormal_:zhe});function Lhe(e,t=0){let n=U(e,"x","unique","string_or_numeric");H(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},s={axis:t},[o,a]=se.runKernel(Ow,r,s);return{values:o,indices:a}}var wk=ae({unique_:Lhe});function Bhe(e,t,n){let r=U(e,"x","unsortedSegmentSum"),s=U(t,"segmentIds","unsortedSegmentSum","int32");H(as(n),()=>"numSegments must be of dtype int");let o={x:r,segmentIds:s},a={numSegments:n};return se.runKernel(X1,o,a)}var q_=ae({unsortedSegmentSum_:Bhe});function Vhe(e,t=0){let n=U(e,"x","unstack","string_or_numeric");H(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},s={axis:t};return se.runKernel(l0,r,s)}var Vs=ae({unstack_:Vhe});function nM(e,t=!0,n,r){return se.makeVariable(e,t,n,r)}function rM(e,t){let n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);let r=Wt(e,"int32"),s=Wt([n.length,e.length],"int32");for(let o=0;o<n.length;o++){let a=r.indexToLoc(n[o]),i=o*e.length;s.values.set(a,i)}return s.toTensor()}async function Whe(e){let t=U(e,"condition","whereAsync","bool"),n=await t.data(),r=rM(t.shape,n);return e!==t&&t.dispose(),r}var K_=Whe;async function Ghe(e,t,n){let r=U(e,"tensor","boolMask"),s=U(t,"mask","boolMask","bool"),o=n==null?0:n,a=s.rank,i=r.shape;H(a>0,()=>"mask cannot be scalar"),zs(i.slice(o,o+a),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=o;m<o+a;m++)l*=i[m];let u=i.slice(0,o).concat([l],i.slice(o+a)),c=ie(r,u),p=ie(s,[-1]),d=await K_(p),f=ln(d,[1]),h=Kf(c,f,o);return e!==r&&r.dispose(),t!==s&&s.dispose(),f.dispose(),c.dispose(),p.dispose(),d.dispose(),h}var Uhe=Ghe;function jhe(e,t="euclidean",n=null,r=!1){e=U(e,"x","norm");let s=sM(e,t,n),o=s.shape;if(r){let a=Ra(n,e.shape);o=Zf(s.shape,a)}return ie(s,o)}function sM(e,t,n=null){if(e.rank===0)return Tr(e);if(e.rank!==1&&n===null)return sM(ie(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return Je(Tr(e),n);if(t===1/0)return Wo(Tr(e),n);if(t===-1/0)return xb(Tr(e),n);if(t==="euclidean"||t===2)return As(Je(Wl(Tr(e),at(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Wo(Je(Tr(e),n[0]),n[1]-1);if(t===1/0)return Wo(Je(Tr(e),n[1]),n[0]);if(t===-1/0)return xb(Je(Tr(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return As(Je(Tn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var kk=ae({norm_:jhe});function Hhe(e,t,n,r,s=!0){let o=U(e,"v","movingAverage"),a=U(t,"x","movingAverage"),i=U(n,"decay","movingAverage");OP(o,a),H(Ml(o.shape,a.shape),()=>"Shape mismatch in v and x");let l=at(1),u=Ge(l,i),c=te(Ge(a,o),u);if(s){H(r!=null,()=>"When using zeroDebias: true, step is required.");let p=U(r,"step","movingAverage");c=Me(c,Ge(l,Wl(i,p)))}return Re(o,c)}var qhe=ae({movingAverage_:Hhe});function Khe(e,t,n){let r=U(e,"indices","scatterND","int32"),s=U(t,"updates","scatterND");r_(s,r,n);let o={indices:r,updates:s},a={shape:n};return se.runKernel(Zg,o,a)}var oM=ae({scatterND_:Khe});function Xhe(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let s=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);let a=t.size;if(!(t.rank===0||t.rank===1&&a===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function Zhe(e,t,n,r=0){let s=U(e,"sparseIndices","sparseToDense","int32"),o=U(t,"sparseValues","sparseToDense"),a=U(r,"defaultValue","sparseToDense",o.dtype);Xhe(s,o,n,a);let i={sparseIndices:s,sparseValues:o,defaultValue:a},l={outputShape:n};return se.runKernel(Rw,i,l)}var X_=ae({sparseToDense_:Zhe});function Yhe(e,t){let n=U(t,"indices","gatherND","int32"),s={params:U(e,"x","gatherND","string_or_numeric"),indices:n};return se.runKernel(Eg,s)}var aM=ae({gatherND_:Yhe});function Jhe(e,t){if(t==null)return e.shape.slice();if(Ml(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function Qhe(e,t,n,r){let s=U(e,"x","dropout");if(H(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),H(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Vt?s.clone():s;let o=Jhe(s,n),a=1-t,i=Me(C0(Re(N0(o,0,1,"float32",r),a)),a);return te(s,i)}var iM=ae({dropout_:Qhe});function lM(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Z_(e,t,n){let r=1-e%2,s=new Float32Array(e);for(let o=0;o<e;++o){let a=2*Math.PI*o/(e+r-1);s[o]=t-n*Math.cos(a)}return Er(s,"float32")}async function eme(e,t,n=1){let r=U(e,"predictions","inTopK"),s=U(t,"targets","inTopK");H(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),H(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),zs(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let o=r.shape[r.shape.length-1];H(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);let a=await r.data(),i=await s.data(),[l,u]=[a.length/o,o],c=mP("bool",l);for(let p=0;p<l;p++){let d=p*u,f=a.subarray(d,d+u),h=[];for(let m=0;m<f.length;m++)h.push({value:f[m],index:m});h.sort((m,g)=>g.value-m.value),c[p]=0;for(let m=0;m<n;m++)if(h[m].index===i[p]){c[p]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),ls(c,s.shape,"bool")}var tme=eme,Hc={};Rt(Hc,{conv2d:()=>sme,depthwiseConv2d:()=>lme,matMul:()=>cme});function nme(e,t,n,r,s,o="NHWC",a){let i=e;e.rank===3&&(i=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]])),H(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),H(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),H(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=o==="NHWC"?i.shape[3]:i.shape[1],c=o==="NHWC"?l.shape[3]:l.shape[1];H(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),H(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),a!=null&&H(as(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let p={x:i,dy:l},d={strides:r,pad:s,dataFormat:o,dimRoundingMode:a,filterShape:n};return se.runKernel(sw,p,d)}var Y_=ae({conv2DBackpropFilter_:nme});function Ik(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return te(e,E0(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Ck(e,t){let n=t,r=jr(e.shape,t.shape);return r.length>0&&(n=Je(n,r)),ie(n,e.shape)}function Sk(e,t,n,r){if(t==="linear")return e;if(t==="relu")return yi(e);if(t==="elu")return k0(e);if(t==="relu6")return pk(e);if(t==="prelu")return bb(e,n);if(t==="leakyrelu")return fb(e,r);if(t==="sigmoid")return xo(e);throw new Error(`Unknown fused activation ${t}.`)}var Nk=(e,t)=>!(e>0)||t==="linear";function rme({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",Nk(se.state.gradientDepth,l)===!1){let v=Bl(e,t,n,r,s,o,a);return i!=null&&(v=Re(v,i)),Sk(v,l,u,c)}let p=U(e,"x","conv2d"),d=U(t,"filter","conv2d"),f=p,h=!1;p.rank===3&&(h=!0,f=ie(p,[1,p.shape[0],p.shape[1],p.shape[2]])),H(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),H(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),a!=null&&H(as(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),H(f.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${d.shape[2]}.`),H(ol(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),H(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);let m=ub(f.shape,d.shape,n,o,r,a),g;i!=null&&(g=U(i,"bias","fused conv2d"),[g]=ur(g,p),Wn(m.outShape,g.shape));let x;u!=null&&(x=U(u,"prelu weights","fused conv2d"));let y=(v,w)=>{let[k,I,N,T]=w,_=Ik(v,N,l);H(Gc(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);let R=w_(I.shape,_,k,n,r),S=Y_(I,_,k.shape,n,r),F=[R,S];if(T!=null){let B=Ck(T,_);F.push(B)}return F},b={x:f,filter:d,bias:g,preluActivationWeights:x},A={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?al((w,k,I)=>{let N=se.runKernel(Mf,b,A);return I([k,w,N]),h&&(N=ie(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:y}})(f,d):al((w,k,I,N)=>{let T=se.runKernel(Mf,b,A);return N([k,w,T,I]),h&&(T=ie(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:y}})(f,d,g)}var sme=ae({fusedConv2d_:rme});function ome(e,t,n,r,s,o=[1,1],a){let i=e;e.rank===3&&(i=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:i,dy:l},c={strides:r,pad:s,dimRoundingMode:a,dilations:o,filterShape:n};return se.runKernel(lw,u,c)}var uM=ae({depthwiseConv2dNativeBackpropFilter_:ome});function ame(e,t,n,r,s,o=[1,1],a){let i=t,l=!1;t.rank===3&&(l=!0,i=ie(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:i,filter:n},c={strides:r,pad:s,dimRoundingMode:a,dilations:o,inputShape:e},p=se.runKernel(uw,u,c);return l?ie(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var cM=ae({depthwiseConv2dNativeBackpropInput_:ame});function ime({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(Nk(se.state.gradientDepth,l)===!1){let v=w0(e,t,n,r,s,o,a);return i!=null&&(v=Re(v,i)),Sk(v,l,u,c)}let p=U(e,"x","depthwiseConv2d"),d=U(t,"filter","depthwiseConv2d"),f=p,h=!1;p.rank===3&&(h=!0,f=ie(p,[1,p.shape[0],p.shape[1],p.shape[2]])),H(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),H(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),H(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),H(ol(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),a!=null&&H(as(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`);let m=ub(f.shape,d.shape,n,o,r,a,!0),g;i!=null&&(g=U(i,"bias","fused conv2d"),[g]=ur(g,p),Wn(m.outShape,g.shape));let x;u!=null&&(x=U(u,"prelu weights","fused depthwiseConv2d"));let y=(v,w)=>{H(Gc(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[k,I,N,T]=w,_=Ik(v,N,l),R=cM(I.shape,_,k,n,r,o,a),S=uM(I,_,k.shape,n,r,o,a);if(T!=null){let F=Ck(g,_);return[R,S,F]}return[R,S]},b={x:f,filter:d,bias:g,preluActivationWeights:x},A={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?al((w,k,I)=>{let N=se.runKernel(zf,b,A);return I([k,w,N]),h&&(N=ie(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:y}})(f,d):al((w,k,I,N)=>{let T=se.runKernel(zf,b,A);return N([k,w,T,I]),h&&(T=ie(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:y}})(f,d,g)}var lme=ae({fusedDepthwiseConv2d_:ime});function ume({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i}){if(Nk(se.state.gradientDepth,o)===!1){let T=Lt(e,t,n,r);return s!=null&&(T=Re(T,s)),Sk(T,o,a,i)}let l=U(e,"a","fused matMul"),u=U(t,"b","fused matMul");[l,u]=ur(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=wr(h),x=wr(m);H(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),H(Ml(h,m),()=>`Error in fused matMul: outer dimensions (${h}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),H(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);let y=l.shape.slice(0,-2).concat([d,f]),b=n?ie(l,[g,c,d]):ie(l,[g,d,c]),A=r?ie(u,[x,f,p]):ie(u,[x,p,f]),v;s!=null&&(v=U(s,"bias","fused matMul"),[v]=ur(v,l),Wn(y,v.shape));let w;a!=null&&(w=U(a,"prelu weights","fused matMul"));let k=(T,_)=>{let[R,S,F,B]=_,W=Ik(ie(T,F.shape),F,o),q,K;if(!n&&!r?(q=Lt(W,S,!1,!0),K=Lt(R,W,!0,!1)):!n&&r?(q=Lt(W,S,!1,!1),K=Lt(W,R,!0,!1)):n&&!r?(q=Lt(S,W,!1,!0),K=Lt(R,W,!1,!1)):(q=Lt(S,W,!0,!0),K=Lt(W,R,!0,!0)),s!=null){let J=Ck(B,W);return[q,K,J]}else return[q,K]},I={a:b,b:A,bias:v,preluActivationWeights:w},N={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:i};return s==null?al((_,R,S)=>{let F=se.runKernel(Pf,I,N);return S([_,R,F]),{value:ie(F,y),gradFunc:k}})(b,A):al((_,R,S,F)=>{let B=se.runKernel(Pf,I,N);return F([_,R,B,S]),{value:ie(B,y),gradFunc:k}})(b,A,v)}var cme=ae({fusedMatMul_:ume});function pme(e){return Z_(e,.54,.46)}var dme=ae({hammingWindow_:pme});function fme(e){return Z_(e,.5,.5)}var pM=ae({hannWindow_:fme});function hme(e,t,n,r=!1,s=0){let o=0,a=[];for(;o+t<=e.size;)a.push(gt(e,o,t)),o+=n;if(r)for(;o<e.size;){let i=o+t-e.size,l=En([gt(e,o,t-i),I0([i],s)]);a.push(l),o+=n}return a.length===0?bi([],[0,t]):ie(En(a),[a.length,t])}var dM=ae({frame_:hme});function mme(e,t,n,r,s=pM){r==null&&(r=lM(t));let o=dM(e,t,n),a=te(o,s(t));return kb(a,r)}var gme=ae({stft_:mme});function xme(e,t,n,r,s="bilinear",o=0){let a=U(e,"image","cropAndResize"),i=U(t,"boxes","cropAndResize","float32"),l=U(n,"boxInd","cropAndResize","int32"),u=i.shape[0];H(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),H(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),H(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),H(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),H(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),H(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let c={image:a,boxes:i,boxInd:l},p={method:s,extrapolationValue:o,cropSize:r};return se.runKernel(wg,c,p)}var yme=ae({cropAndResize_:xme});function bme(e){let t=U(e,"image","flipLeftRight","float32");H(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return se.runKernel(Tg,n,{})}var Ame=ae({flipLeftRight_:bme});function vme(e){let t=U(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];H(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),H(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,da(t,s)}var wme=ae({grayscaleToRGB_:vme});function kme(e,t,n=0,r=.5){let s=U(e,"image","rotateWithOffset","float32");H(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let o={image:s},a={radians:t,fillValue:n,center:r};return se.runKernel(c0,o,a)}var Ime=ae({rotateWithOffset_:kme});function R0(e,t,n,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);let a=e.shape[0];return n=Math.min(n,a),H(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),H(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),H(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),H(t.rank===1,()=>"scores must be a 1D tensor"),H(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),H(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}function Cme(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let o=U(e,"boxes","nonMaxSuppression"),a=U(t,"scores","nonMaxSuppression"),i=R0(o,a,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return se.runKernel(Wg,{boxes:o,scores:a},l)}var Sme=ae({nonMaxSuppression_:Cme});function Nme(e,t,n){let r=Tme(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function Tme(e,t,n){return Eme(e,t,n||_me)}function _me(e,t){return e>t?1:e<t?-1:0}function Eme(e,t,n){let r=0,s=e.length,o=0,a=!1;for(;r<s;){o=r+(s-r>>>1);let i=n(t,e[o]);i>0?r=o+1:(s=o,a=!i)}return a?r:-r-1}function fM(e,t,n,r,s){return J_(e,t,n,r,s,0)}function hM(e,t,n,r,s,o){return J_(e,t,n,r,s,0,!1,o,!0)}function mM(e,t,n,r,s,o){return J_(e,t,n,r,s,o,!0)}function J_(e,t,n,r,s,o,a=!1,i=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(gM);let c=o>0?-.5/o:0,p=[],d=[];for(;p.length<n&&u.length>0;){let g=u.pop(),{score:x,boxIndex:y,suppressBeginIndex:b}=g;if(x<s)break;let A=!1;for(let v=p.length-1;v>=b;--v){let w=Rme(e,y,p[v]);if(w>=r){A=!0;break}if(g.score=g.score*Dme(r,c,w),g.score<=s)break}g.suppressBeginIndex=p.length,A||(g.score===x?(p.push(y),d.push(g.score)):g.score>s&&Nme(u,g,gM))}let f=p.length,h=n-f;i&&h>0&&(p.push(...new Array(h).fill(0)),d.push(...new Array(h).fill(0)));let m={selectedIndices:p};return a&&(m.selectedScores=d),l&&(m.validOutputs=f),m}function Rme(e,t,n){let r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),o=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),p=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),f=(i-o)*(l-a),h=(p-u)*(d-c);if(f<=0||h<=0)return 0;let m=Math.max(o,u),g=Math.max(a,c),x=Math.min(i,p),y=Math.min(l,d),b=Math.max(x-m,0)*Math.max(y-g,0);return b/(f+h-b)}function Dme(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function gM(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function $me(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let o=U(e,"boxes","nonMaxSuppressionAsync"),a=U(t,"scores","nonMaxSuppressionAsync"),i=R0(o,a,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;let l=await Promise.all([o.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:p}=fM(u,c,n,r,s);return o!==e&&o.dispose(),a!==t&&a.dispose(),Er(p,"int32")}var Fme=$me;function Ome(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){let a=U(e,"boxes","nonMaxSuppression"),i=U(t,"scores","nonMaxSuppression"),l=R0(a,i,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;let u={boxes:a,scores:i},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},p=se.runKernel(Ug,u,c);return{selectedIndices:p[0],selectedScores:p[1]}}var Pme=ae({nonMaxSuppressionWithScore_:Ome});async function Mme(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){let a=U(e,"boxes","nonMaxSuppressionAsync"),i=U(t,"scores","nonMaxSuppressionAsync"),l=R0(a,i,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;let u=await Promise.all([a.data(),i.data()]),c=u[0],p=u[1],{selectedIndices:d,selectedScores:f}=mM(c,p,n,r,s,o);return a!==e&&a.dispose(),i!==t&&i.dispose(),{selectedIndices:Er(d,"int32"),selectedScores:Er(f)}}var zme=Mme;function Lme(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){let a=U(e,"boxes","nonMaxSuppression"),i=U(t,"scores","nonMaxSuppression"),l=R0(a,i,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,d={boxes:a,scores:i},f={maxOutputSize:u,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:o},h=se.runKernel(Gg,d,f);return{selectedIndices:h[0],validOutputs:h[1]}}var Bme=ae({nonMaxSuppressionPadded_:Lme});async function Vme(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){let a=U(e,"boxes","nonMaxSuppressionAsync"),i=U(t,"scores","nonMaxSuppressionAsync"),l=R0(a,i,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,[d,f]=await Promise.all([a.data(),i.data()]),{selectedIndices:h,validOutputs:m}=hM(d,f,u,c,p,o);return a!==e&&a.dispose(),i!==t&&i.dispose(),{selectedIndices:Er(h,"int32"),validOutputs:at(m,"int32")}}var Wme=Vme;function Gme(e,t,n=!1,r=!1){let s=U(e,"images","resizeBilinear");H(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),H(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),H(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=ie(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,i={images:o},l={alignCorners:n,halfPixelCenters:r,size:t},u=se.runKernel(vf,i,l);return a?ie(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var xM=ae({resizeBilinear_:Gme});function Ume(e,t,n=!1,r=!1){let s=U(e,"images","resizeNearestNeighbor");H(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),H(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),H(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),H(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=ie(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,i={images:o},l={alignCorners:n,halfPixelCenters:r,size:t},u=se.runKernel(q1,i,l);return a?ie(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var yM=ae({resizeNearestNeighbor_:Ume});function jme(e,t="binary",n=!1,r=.5){let s=U(e,"image","threshold"),o=.2989,a=.587,i=.114,l=s.shape[0]*s.shape[1],u=te(Er([r]),255),c,p,d,f;if(H(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),H(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),H(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),H(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,p,d]=_r(s,[1,1,1],-1);let g=te(c,o),x=te(p,a),y=te(d,i);f=Re(Re(g,x),y)}else f=e;if(t==="otsu"){let g=A_(Fe(dk(f),"int32"),ls([]),256);u=Hme(g,l)}let h=n?jc(f,u):bo(f,u);return Fe(te(h,255),"int32")}function Hme(e,t){let n=Er([-1]),r=Er([0]),s=Er([0]),o,a,i,l,u,c;for(let p=0;p<e.size-1;p++){o=gt(e,0,p+1),a=gt(e,p+1),u=Me(Je(o),t),c=Me(Je(a),t);let d=Je(te(o,T0(0,o.size)));i=Me(d,Je(o));let f=I0(a.shape,o.size),h=Re(T0(0,a.size),f),m=te(a,h);l=Me(Je(m),Je(a));let g=Ge(i,l),x=Ge(i,l),y=te(u,c);s=te(te(y,g),x);let b=bo(s,r);r=$s(b,s,r),n=$s(b,Er([p]),n)}return n}var qme=ae({threshold_:jme});function Kme(e,t,n="nearest",r="constant",s=0,o){let a=U(e,"image","transform","float32"),i=U(t,"transforms","transform","float32");H(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),H(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),H(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);let l={image:a,transforms:i},u={interpolation:n,fillMode:r,fillValue:s,outputShape:o};return se.runKernel(i0,l,u)}var Xme=ae({transform_:Kme});function Zme(e,t,n){H(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),H(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);let r=U(e,"a","bandPart");H(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[o,a]=r.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);t<0&&(t=o),n<0&&(n=a);let i=ie(T0(0,o,1,"int32"),[-1,1]),l=T0(0,a,1,"int32"),u=Ge(i,l),c=Fa(jc(u,at(+t,"int32")),Uc(u,at(-n,"int32"))),p=xr([o,a],r.dtype);return ie(vs(Vs(ie(r,[-1,o,a])).map(d=>$s(c,d,p))),s)}var Yme=ae({bandPart_:Zme});function Jme(e){let t;if(Array.isArray(e)){t=!1,H(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=e[0].shape[0];for(let o=1;o<e.length;++o)H(e[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[o].shape[0]} vs. ${s})`)}else t=!0,e=_r(e,e.shape[0],0).map(s=>ln(s,[0]));H(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let s=0;s<e.length;++s)n.push(se.tidy(()=>{let o=r[s];if(s>0)for(let a=0;a<s;++a){let i=te(Je(te(n[a],o)),n[a]);o=Ge(o,i)}return Me(o,kk(o,"euclidean"))}));return t?vs(n,0):n}var Qme=ae({gramSchmidt_:Jme});function ege(e,t=!1){if(H(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return bM(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=Vs(ie(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],o=[];r.forEach(l=>{let[u,c]=bM(l,t);s.push(u),o.push(c)});let a=ie(vs(s,0),e.shape),i=ie(vs(o,0),e.shape);return[a,i]}}function bM(e,t=!1){return se.tidy(()=>{H(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],s=__(n),o=mi(e),a=bi([[1]],[1,1]),i=mi(a),l=n>=r?r:n;for(let u=0;u<l;++u){let c=o,p=i,d=s;[i,o,s]=se.tidy(()=>{let f=gt(o,[u,u],[n-u,1]),h=kk(f),m=gt(o,[u,u],[1,1]),g=$s(bo(m,0),bi([[-1]]),bi([[1]])),x=Ge(m,te(g,h)),y=Me(f,x);y.shape[0]===1?i=mi(a):i=En([a,gt(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);let b=er(Me(Lt(g,x),h)),A=gt(o,[u,0],[n-u,r]),v=te(b,i),w=Kt(i);if(u===0)o=Ge(A,Lt(v,Lt(w,A)));else{let N=Ge(A,Lt(v,Lt(w,A)));o=En([gt(o,[0,0],[u,r]),N],0)}let k=Kt(v),I=gt(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=Ge(I,Lt(Lt(I,i),k));else{let N=Ge(I,Lt(Lt(I,i),k));s=En([gt(s,[0,0],[n,u]),N],1)}return[i,o,s]}),ye([c,p,d])}return!t&&n>r&&(s=gt(s,[0,0],[n,r]),o=gt(o,[0,0],[r,r])),[s,o]})}var tge=ae({qr_:ege}),Ws;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ws||(Ws={}));function nge(e,t,n=Ws.SUM_BY_NONZERO_WEIGHTS){let r=U(e,"losses","computeWeightedLoss"),s=null;t!=null&&(s=U(t,"weights","computeWeightedLoss"));let o=s==null?r:te(r,s);if(n===Ws.NONE)return o;if(n===Ws.SUM)return Je(o);if(n===Ws.MEAN){if(s==null)return cr(o);{let a=r.size/s.size,i=Me(Je(o),Je(s));return a>1?Me(i,at(a)):i}}if(n===Ws.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Me(Je(o),at(r.size));{let a=te(s,Go(r.shape)),i=Fe(Je(Yf(a,at(0))),"float32");return Me(Je(o),i)}}throw Error(`Unknown reduction: ${n}`)}var Gl=ae({computeWeightedLoss_:nge});function rge(e,t,n,r=Ws.SUM_BY_NONZERO_WEIGHTS){let s=U(e,"labels","absoluteDifference"),o=U(t,"predictions","absoluteDifference"),a=null;n!=null&&(a=U(n,"weights","absoluteDifference")),zs(s.shape,o.shape,"Error in absoluteDifference: ");let i=Tr(Ge(s,o));return Gl(i,a,r)}var sge=ae({absoluteDifference_:rge});function oge(e,t,n,r,s=Ws.SUM_BY_NONZERO_WEIGHTS){let o=U(e,"labels","cosineDistance"),a=U(t,"predictions","cosineDistance"),i=null;r!=null&&(i=U(r,"weights","cosineDistance")),zs(o.shape,a.shape,"Error in cosineDistance: ");let l=at(1),u=Ge(l,Je(te(o,a),n,!0));return Gl(u,i,s)}var age=ae({cosineDistance_:oge});function ige(e,t,n,r=Ws.SUM_BY_NONZERO_WEIGHTS){let s=U(e,"labels","hingeLoss"),o=U(t,"predictions","hingeLoss"),a=null;n!=null&&(a=U(n,"weights","hingeLoss")),zs(s.shape,o.shape,"Error in hingeLoss: ");let i=at(1);s=Ge(te(at(2),s),i);let l=yi(Ge(i,te(s,o)));return Gl(l,a,r)}var lge=ae({hingeLoss_:ige});function uge(e,t,n,r=1,s=Ws.SUM_BY_NONZERO_WEIGHTS){let o=U(e,"labels","huberLoss"),a=U(t,"predictions","huberLoss"),i=null;n!=null&&(i=U(n,"weights","huberLoss")),zs(o.shape,a.shape,"Error in huberLoss: ");let l=at(r),u=Tr(Ge(a,o)),c=S0(u,l),p=Ge(u,c),d=Re(te(at(.5),Tn(c)),te(l,p));return Gl(d,i,s)}var cge=ae({huberLoss_:uge});function pge(e,t,n,r=1e-7,s=Ws.SUM_BY_NONZERO_WEIGHTS){let o=U(e,"labels","logLoss"),a=U(t,"predictions","logLoss"),i=null;n!=null&&(i=U(n,"weights","logLoss")),zs(o.shape,a.shape,"Error in logLoss: ");let l=at(1),u=at(r),c=er(te(o,Vo(Re(a,u)))),p=te(Ge(l,o),Vo(Re(Ge(l,a),u))),d=Ge(c,p);return Gl(d,i,s)}var dge=ae({logLoss_:pge});function fge(e,t,n,r=Ws.SUM_BY_NONZERO_WEIGHTS){let s=U(e,"labels","meanSquaredError"),o=U(t,"predictions","meanSquaredError"),a=null;n!=null&&(a=U(n,"weights","meanSquaredError")),zs(s.shape,o.shape,"Error in meanSquaredError: ");let i=Ak(s,o);return Gl(i,a,r)}var hge=ae({meanSquaredError_:fge});function mge(e,t){let n=U(e,"labels","sigmoidCrossEntropyWithLogits"),r=U(t,"logits","sigmoidCrossEntropyWithLogits");zs(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let s=yi(r),o=te(r,n),a=hb(Bo(er(Tr(r))));return Re(Ge(s,o),a)}function gge(e,t,n,r=0,s=Ws.SUM_BY_NONZERO_WEIGHTS){let o=U(e,"multiClassLabels","sigmoidCrossEntropy"),a=U(t,"logits","sigmoidCrossEntropy"),i=null;if(n!=null&&(i=U(n,"weights","sigmoidCrossEntropy")),zs(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=at(r),c=at(1),p=at(.5);o=Re(te(o,Ge(c,u)),te(p,u))}let l=mge(o,a);return Gl(l,i,s)}var xge=ae({sigmoidCrossEntropy_:gge});function yge(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return al((s,o,a)=>{let l=F_(o,[n],!0),u=Ge(Fe(o,"float32"),l);a([s,u]);let c=er(te(u,s));return{value:Je(c,[n]),gradFunc:(f,h)=>{let[m,g]=h,x=Zf(f.shape,[n]);return[te(ie(f,x),Ge(Fe(m,"float32"),Bo(g))),te(ie(f,x),Ge(Bo(g),Fe(m,"float32")))]}}})(e,t)}function bge(e,t,n,r=0,s=Ws.SUM_BY_NONZERO_WEIGHTS){let o=U(e,"onehotLabels","softmaxCrossEntropy"),a=U(t,"logits","softmaxCrossEntropy"),i=null;if(n!=null&&(i=U(n,"weights","softmaxCrossEntropy")),zs(o.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){let u=at(r),c=at(1),p=at(o.shape[1]);o=Re(te(o,Ge(c,u)),Me(u,p))}let l=yge(o,a);return Gl(l,i,s)}var Age=ae({softmaxCrossEntropy_:bge});function vge(e,t,n,r){let s=U(e,"indices","sparseFillEmptyRows"),o=U(t,"values","sparseFillEmptyRows"),a=U(n,"denseShape","sparseFillEmptyRows"),i=U(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let l={indices:s,values:o,denseShape:a,defaultValue:i},u=se.runKernel(Nw,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var wge=ae({sparseFillEmptyRows_:vge});function kge(e,t,n){let r=U(e,"inputIndices","sparseReshape"),s=U(t,"inputShape","sparseReshape"),o=U(n,"newShape","sparseReshape");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);let a={inputIndices:r,inputShape:s,newShape:o},i=se.runKernel(Tw,a);return{outputIndices:i[0],outputShape:i[1]}}var Ige=ae({sparseReshape_:kge});function Cge(e,t,n){let r=U(e,"data","sparseSegmentMean"),s=U(t,"indices","sparseSegmentMean"),o=U(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);let a={data:r,indices:s,segmentIds:o};return se.runKernel(_w,a)}var Sge=ae({sparseSegmentMean_:Cge});function Nge(e,t,n){let r=U(e,"data","sparseSegmentSum"),s=U(t,"indices","sparseSegmentSum"),o=U(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);let a={data:r,indices:s,segmentIds:o};return se.runKernel(Ew,a)}var Tge=ae({sparseSegmentSum_:Nge});function _ge(e,t,n,r,s,o,a,i){let l=U(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=U(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:a,preserveShortSequences:i},p={data:l,dataSplits:u},d=se.runKernel(Dw,p,c);return{nGrams:d[0],nGramsSplits:d[1]}}var Ege=ae({stringNGrams_:_ge});function Rge(e,t,n=!0){let r=U(e,"input","stringSplit","string"),s=U(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);let o={skipEmpty:n},a={input:r,delimiter:s},i=se.runKernel($w,a,o);return{indices:i[0],values:i[1],shape:i[2]}}var Dge=ae({stringSplit_:Rge});function $ge(e,t){let n=U(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let s={input:n};return se.runKernel(Fw,s,r)}var Fge=ae({stringToHashBucketFast_:$ge}),Oge={fft:wb,ifft:_0,rfft:kb,irfft:bk},Pge={hammingWindow:dme,hannWindow:pM,frame:dM,stft:gme},ht={flipLeftRight:Ame,grayscaleToRGB:wme,resizeNearestNeighbor:yM,resizeBilinear:xM,rotateWithOffset:Ime,cropAndResize:yme,nonMaxSuppression:Sme,nonMaxSuppressionAsync:Fme,nonMaxSuppressionWithScore:Pme,nonMaxSuppressionWithScoreAsync:zme,nonMaxSuppressionPadded:Bme,nonMaxSuppressionPaddedAsync:Wme,threshold:qme,transform:Xme},AM={bandPart:Yme,gramSchmidt:Qme,qr:tge},Mge={absoluteDifference:sge,computeWeightedLoss:Gl,cosineDistance:age,hingeLoss:lge,huberLoss:cge,logLoss:dge,meanSquaredError:hge,sigmoidCrossEntropy:xge,softmaxCrossEntropy:Age},Ib={sparseFillEmptyRows:wge,sparseReshape:Ige,sparseSegmentMean:Sge,sparseSegmentSum:Tge},Tk={stringNGrams:Ege,stringSplit:Dge,stringToHashBucketFast:Fge},Ul=class extends v9{minimize(e,t=!1,n){let{value:r,grads:s}=this.computeGradients(e,n);if(n!=null){let o=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(o)}else this.applyGradients(s);return ye(s),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return j9(e,t)}dispose(){this.iterations_!=null&&ye(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:at(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Ul,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var _k=class extends Ul{constructor(e,t,n=null){super();this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=se.registeredVariables[n],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accum_grad`,variable:ce(()=>Xt(s).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${n}/accum_var`,variable:ce(()=>Xt(s).variable(o))});let a=Array.isArray(e)?e[r].tensor:e[n];if(a==null)return;let i=this.accumulatedGrads[r].variable,l=this.accumulatedUpdates[r].variable;ce(()=>{let u=Re(te(i,this.rho),te(Tn(a),1-this.rho)),c=te(Me(As(Re(l,this.epsilon)),As(Re(i,this.epsilon))),a),p=Re(te(l,this.rho),te(Tn(c),1-this.rho));i.assign(u),l.assign(p);let d=Re(te(c,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ye(this.accumulatedGrads.map(e=>e.variable)),ye(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};_k.className="Adadelta";Wc(_k);var Ek=class extends Ul{constructor(e,t=.1){super();this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=se.registeredVariables[n];if(this.accumulatedGrads[r]==null){let i=!1;this.accumulatedGrads[r]={originalName:`${n}/accumulator`,variable:ce(()=>I0(s.shape,this.initialAccumulatorValue).variable(i))}}let o=Array.isArray(e)?e[r].tensor:e[n];if(o==null)return;let a=this.accumulatedGrads[r].variable;ce(()=>{let i=Re(a,Tn(o));a.assign(i);let l=Re(te(Me(o,As(Re(i,se.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ye(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};Ek.className="Adagrad";Wc(Ek);var Rk=class extends Ul{constructor(e,t,n,r=null){super();this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ce(()=>{this.accBeta1=at(t).variable(),this.accBeta2=at(n).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ce(()=>{let n=Ge(1,this.accBeta1),r=Ge(1,this.accBeta2);t.forEach((s,o)=>{let a=se.registeredVariables[s],i=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:ce(()=>Xt(a).variable(i))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${s}/v`,variable:ce(()=>Xt(a).variable(i))});let l=Array.isArray(e)?e[o].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[o].variable,c=this.accumulatedSecondMoment[o].variable,p=Re(te(u,this.beta1),te(l,1-this.beta1)),d=Re(te(c,this.beta2),te(Tn(l),1-this.beta2)),f=Me(p,n),h=Me(d,r);u.assign(p),c.assign(d);let m=Re(te(Me(f,Re(As(h),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(te(this.accBeta1,this.beta1)),this.accBeta2.assign(te(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ye(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&ye(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ce(()=>{this.accBeta1.assign(Wl(this.beta1,this.iterations_+1)),this.accBeta2.assign(Wl(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};Rk.className="Adam";Wc(Rk);var Dk=class extends Ul{constructor(e,t,n,r=null,s=0){super();this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ce(()=>{this.iteration=at(0).variable(),this.accBeta1=at(t).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ce(()=>{let n=Ge(1,this.accBeta1),r=Me(-this.learningRate,Re(te(this.iteration,this.decay),1));t.forEach((s,o)=>{let a=se.registeredVariables[s],i=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:Xt(a).variable(i)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${s}/v`,variable:Xt(a).variable(i)});let l=Array.isArray(e)?e[o].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[o].variable,c=this.accumulatedWeightedInfNorm[o].variable,p=Re(te(u,this.beta1),te(l,1-this.beta1)),d=te(c,this.beta2),f=Tr(l),h=il(d,f);u.assign(p),c.assign(h);let m=Re(te(Me(r,n),Me(p,Re(h,this.epsilon))),a);a.assign(m)}),this.iteration.assign(Re(this.iteration,1)),this.accBeta1.assign(te(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ye(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&ye(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};Dk.className="Adamax";Wc(Dk);var Cb=class extends Ul{constructor(e){super();this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=Array.isArray(e)?e[r].tensor:e[n];if(s==null)return;let o=se.registeredVariables[n];ce(()=>{let a=Re(te(this.c,s),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=us(at(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};Cb.className="SGD";Wc(Cb);var $k=class extends Cb{constructor(e,t,n=!1){super(e);this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=at(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=se.registeredVariables[n];if(this.accumulations[r]==null){let i=!1;this.accumulations[r]={originalName:`${n}/momentum`,variable:ce(()=>Xt(s).variable(i))}}let o=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[n];a!=null&&ce(()=>{let i,l=Re(te(this.m,o),a);this.useNesterov?i=Re(te(this.c,Re(a,te(l,this.m))),s):i=Re(te(this.c,l),s),o.assign(l),s.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ye(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};$k.className="Momentum";Wc($k);var Fk=class extends Ul{constructor(e,t=.9,n=0,r=null,s=!1){super();if(this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=se.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{let s=se.registeredVariables[n],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${n}/rms`,variable:ce(()=>Xt(s).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${n}/momentum`,variable:ce(()=>Xt(s).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${n}/mg`,variable:ce(()=>Xt(s).variable(o))});let a=Array.isArray(e)?e[r].tensor:e[n];if(a==null)return;let i=this.accumulatedMeanSquares[r].variable,l=this.accumulatedMoments[r].variable;ce(()=>{let u=Re(te(i,this.decay),te(Tn(a),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[r].variable,p=Re(te(c,this.decay),te(a,1-this.decay)),d=Me(te(a,this.learningRate),As(Ge(u,Re(Tn(p),this.epsilon)))),f=Re(te(l,this.momentum),d);i.assign(u),c.assign(p),l.assign(f);let h=Ge(s,f);s.assign(h)}else{let c=Re(te(i,this.decay),te(Tn(a),1-this.decay)),p=Re(te(l,this.momentum),Me(te(a,this.learningRate),As(Re(c,this.epsilon))));i.assign(c),l.assign(p);let d=Ge(s,p);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ye(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ye(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&ye(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};Fk.className="RMSProp";Wc(Fk);var Qf=class{static sgd(e){return new Cb(e)}static momentum(e,t,n=!1){return new $k(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Fk(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new Rk(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new _k(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Dk(e,t,n,r,s)}static adagrad(e,t=.1){return new Ek(e,t)}},eh={sgd:Qf.sgd,momentum:Qf.momentum,adadelta:Qf.adadelta,adagrad:Qf.adagrad,rmsprop:Qf.rmsprop,adamax:Qf.adamax,adam:Qf.adam},zge=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:e=>e())();function Ok(){return new Promise(e=>zge(()=>e()))}var G={};Rt(G,{ERF_A1:()=>Xge,ERF_A2:()=>Zge,ERF_A3:()=>Yge,ERF_A4:()=>Jge,ERF_A5:()=>Qge,ERF_P:()=>Kge,PARALLELIZE_THRESHOLD:()=>Q_,SELU_SCALE:()=>wM,SELU_SCALEALPHA:()=>vM,applyActivation:()=>Sk,assertAndGetBroadcastShape:()=>Wn,assertAxesAreInnerMostDims:()=>efe,assertParamsConsistent:()=>Lge,assignToTypedArray:()=>o0e,axesAreInnerMostDims:()=>D_,calculateShapes:()=>u9,checkEinsumDimSizes:()=>p0e,combineLocations:()=>q9,complexWithEvenIndex:()=>n0e,complexWithOddIndex:()=>r0e,computeConv2DInfo:()=>ub,computeConv3DInfo:()=>T9,computeDefaultPad:()=>x_,computeDilation2DInfo:()=>kpe,computeOptimalWindowSize:()=>Vge,computeOutAndReduceShapes:()=>K9,computeOutShape:()=>Bge,computePool2DInfo:()=>N9,computePool3DInfo:()=>Ipe,convertConv2DDataFormat:()=>_9,decodeEinsumEquation:()=>u0e,eitherStridesOrDilationsAreOne:()=>ol,expandShapeToKeepDim:()=>Zf,exponent:()=>i0e,exponents:()=>a0e,fromStringArrayToUint8:()=>A0e,fromUint8ToStringArray:()=>b0e,getAxesPermutation:()=>X9,getBroadcastDims:()=>mde,getComplexWithIndex:()=>s0e,getEinsumComputePath:()=>d0e,getEinsumPermutation:()=>c0e,getFusedBiasGradient:()=>Ck,getFusedDyActivation:()=>Ik,getImageCenter:()=>Wge,getInnerMostAxes:()=>tfe,getPermuted:()=>Uge,getReductionAxes:()=>jr,getReshaped:()=>Gge,getReshapedPermuted:()=>jge,getSliceBeginCoords:()=>Hge,getSliceSize:()=>qge,getUndoAxesPermutation:()=>$_,isIdentityPermutation:()=>f0e,log:()=>Jle,mergeRealAndImagArrays:()=>e0e,prepareAndValidate:()=>l9,prepareSplitSize:()=>m0e,segment_util:()=>CM,shouldFuse:()=>Nk,slice_util:()=>Bs,splitRealAndImagArrays:()=>t0e,tupleValuesAreOne:()=>Gc,upcastType:()=>$a,validateInput:()=>r_,validateUpdateShape:()=>n_,warn:()=>tl});function Lge(e,t){let n=e[0].length;e.forEach((s,o)=>{H(s.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),H(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((s,o)=>{for(let a=0;a<n;a++)H(a===t||s[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function Bge(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Q_=30;function Vge(e){return e<=Q_?e:Jv(e,Math.floor(Math.sqrt(e)))}function Wge(e,t,n){let r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}function Gge(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);let o=t.length;for(let a=0;a<o;++a)s=s.concat([e[a+1]/t[a],t[a]]);s=s.concat(e.slice(o+1))}return s}function Uge(e,t,n=!0){let r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],o=[];for(let a=1;a<e;++a)a>=t*2+1||a%2==1?o.push(a):s.push(a);r.push(...s),r.push(0),r.push(...o)}return r}function jge(e,t,n,r=!0){let s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?r?s.push(t[o-1]*e[o]):s.push(e[o]/t[o-1]):s.push(e[o]);return s}function Hge(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function qge(e,t,n){let r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var vM=1.7580993408473768,wM=1.0507009873554805,Kge=.3275911,Xge=.254829592,Zge=-.284496736,Yge=1.421413741,Jge=-1.453152027,Qge=1.061405429;function e0e(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function t0e(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function n0e(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function r0e(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function s0e(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function o0e(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function a0e(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){let o=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function i0e(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}var eE="->",l0e=/->/g,kM=",",IM="...";function u0e(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(l0e,"").length)/eE.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${eE}").`);let[r,s]=e.split(eE);H(r.indexOf(IM)===-1,()=>`The ellipsis notation ("${IM}") is not supported yet.`);let o=r.split(kM),a=o.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let d=0;d<s.length;++d){let f=s[d];if(!o.some(h=>h.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);i.indexOf(f)===-1&&i.push(f)}for(let d=0;d<r.length;++d){let f=r[d];i.indexOf(f)===-1&&f!==kM&&i.push(f)}let l=new Array(o.length);for(let d=0;d<a;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let f=0;f<o[d].length;++f)l[d].push(i.indexOf(o[d][f]))}let u=i.length,c=s.length,p=[];for(let d=c;d<u;++d)p.push(d);return{allDims:i,summedDims:p,idDims:l}}function c0e(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;let r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function p0e(e,t,n){let r=new Array(e);for(let s=0;s<n.length;++s){let o=n[s].shape;for(let a=0;a<t[s].length;++a)r[t[s][a]]===void 0?r[t[s][a]]=o[a]:H(r[t[s][a]]===o[a],()=>`Expected dimension ${r[t[s][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function d0e(e,t){let n=e,r=[],s=0;e.length===0&&n.push(-1),s=e.length+1;for(let a=0;a<s;++a)r.push([]);let o=[];for(let a=0;a<n.length;++a){let i=n[a],l=h0e(t,i);for(let u of l)o.indexOf(u)===-1&&(r[a].push(u),o.push(u))}return{path:n,steps:r}}function f0e(e){return e.every((t,n)=>t===n)}function h0e(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function m0e(e,t,n=0){let r=[];if(typeof t=="number")H(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let s=t.reduce((a,i)=>(i===-1&&(a+=1),a),0);H(s<=1,()=>"There should be only one negative value in split array.");let o=t.indexOf(-1);if(o!==-1){let a=t.reduce((i,l)=>l>0?i+l:i);t[o]=e.shape[n]-a}H(e.shape[n]===t.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}var CM={};Rt(CM,{collectGatherOpShapeInfo:()=>y0e,computeOutShape:()=>x0e,segOpComputeOptimalWindowSize:()=>g0e});function g0e(e,t){let n=!1,r;for(e<=Q_?(r=e,n=!0):r=Jv(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=Jv(e,r+1);return r}function x0e(e,t,n){let r=[],s=e.length;for(let o=0;o<s;o++)o!==t?r.push(e[o]):r.push(n);return r}function y0e(e,t,n,r){let s=t.shape.length,o=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let p=0;p<r;++p)if(e.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${e.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let a=e.shape[n],i=[],l=1,u=1,c=1;for(let p=0;p<r;++p)i.push(e.shape[p]),l*=e.shape[p];for(let p=r;p<n;p++)i.push(e.shape[p]),u*=e.shape[p];for(let p=r;p<s;p++)i.push(t.shape[p]);for(let p=n+1;p<o;p++)i.push(e.shape[p]),c*=e.shape[p];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:i}}function b0e(e){try{return e.map(t=>Bw(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function A0e(e){return e.map(t=>Q1(t))}var ll={};Rt(ll,{nonMaxSuppressionV3Impl:()=>fM,nonMaxSuppressionV4Impl:()=>hM,nonMaxSuppressionV5Impl:()=>mM,whereImpl:()=>rM});var SM={kernelName:cg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(e,E0(Fe(n,"float32"),-1))}}},v0e={kernelName:pg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Tn(Fe(n,"float32")),s=As(Ge(at(1),r));return er(Me(e,s))}}}},w0e={kernelName:dg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=As(Ge(Tn(Fe(n,"float32")),1));return Me(e,r)}}}},k0e={kernelName:$c,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Wn(n.shape,r.shape);return{a:()=>{let i=e,l=jr(n.shape,s);return l.length>0&&(i=Je(i,l)),ie(i,n.shape)},b:()=>{let i=e,l=jr(r.shape,s);return l.length>0&&(i=Je(i,l)),ie(i,r.shape)}}}},I0e={kernelName:Ld,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}},C0e={kernelName:Bd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Xt(n)}}},S0e={kernelName:P1,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Xt(n)}}},N0e={kernelName:mg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Me(e,As(Ge(at(1),Tn(Fe(n,"float32")))))}}},T0e={kernelName:gg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=As(Re(at(1),Tn(Fe(n,"float32"))));return Me(e,r)}}}},_0e={kernelName:bg,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Wn(n.shape,r.shape);return{a:()=>{let i=Re(Tn(n),Tn(r)),l=te(e,Me(r,i)),u=jr(n.shape,s);return u.length>0&&(l=Je(l,u)),ie(l,n.shape)},b:()=>{let i=Re(Tn(n),Tn(r)),l=er(te(e,Me(n,i))),u=jr(r.shape,s);return u.length>0&&(l=Je(l,u)),ie(l,r.shape)}}}},E0e={kernelName:xg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Me(e,Re(Tn(Fe(n,"float32")),1))}}},R0e={kernelName:yg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Me(e,Ge(at(1),Tn(Fe(n,"float32"))))}}};function D0e(e,t,n,r,s,o){let a=U(e,"dy","avgPool3dGrad"),i=U(t,"input","avgPool3dGrad"),l=a,u=i,c=!1;i.rank===4&&(c=!0,l=ie(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=ie(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),H(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),H(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),o!=null&&H(as(s),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);let p={dy:l,input:u},d={filterSize:n,strides:r,pad:s,dimRoundingMode:o},f=se.runKernel(tw,p,d);return c?ie(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var $0e=ae({avgPool3dGrad_:D0e}),F0e={kernelName:M1,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:i}=n;return{x:()=>$0e(e,r,s,o,a,i)}}};function O0e(e,t,n,r,s){let o=U(e,"dy","avgPoolGrad"),a=U(t,"input","avgPoolGrad");H(a.rank===o.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${o.rank})`);let i=a,l=o,u=!1;a.rank===3&&(u=!0,i=ie(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]])),H(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),H(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let c={dy:l,input:i},p={filterSize:n,strides:r,pad:s},d=se.runKernel(ew,c,p);return u?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var P0e=ae({avgPoolGrad_:O0e}),M0e={kernelName:Vd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:o,pad:a}=n;return{x:()=>P0e(e,r,s,o,a)}}},z0e={kernelName:Wd,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,s]=t,{transposeA:o,transposeB:a}=n;return!o&&!a?{a:()=>Lt(e,s,!1,!0),b:()=>Lt(r,e,!0,!1)}:!o&&a?{a:()=>Lt(e,s,!1,!1),b:()=>Lt(e,r,!0,!1)}:o&&!a?{a:()=>Lt(s,e,!1,!0),b:()=>Lt(r,e,!1,!1)}:{a:()=>Lt(s,e,!0,!0),b:()=>Lt(e,r,!0,!0)}}},L0e={kernelName:Ag,gradFunc:(e,t,n)=>{let{blockShape:r,crops:s}=n;return{x:()=>yb(e,r,s)}}},B0e={kernelName:SP,gradFunc:(e,t,n)=>{let r=n,s=r.inputShape,o=r.shape,a=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])a[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);let i=[];for(let l=0;l<a.length;l++)a[l]>1&&i.push(l);return{x:()=>Je(e,i,!0)}}},V0e={kernelName:Gd,gradFunc:e=>({x:()=>e.clone()})},W0e={kernelName:Ud,gradFunc:e=>({x:()=>Xt(e)})},G0e={kernelName:Fc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:s,clipValueMax:o}=n;return{x:()=>$s(Fa(Uc(r,s),jc(r,o)),e,Xt(e))}}},U0e={kernelName:z1,inputsToSave:["x"],gradFunc:SM.gradFunc},j0e={kernelName:vg,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(l=>l.shape),{axis:s}=n,o=Ra(s,t[0].shape)[0],a=r.map(l=>l[o]);return _r(e,a,o).map(l=>()=>l)}},H0e={kernelName:jd,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{dilations:o,strides:a,pad:i,dataFormat:l}=n;return H(Gc(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>w_(r.shape,e,s,a,i,l),filter:()=>Y_(r,e,s.shape,a,i,l)}}},q0e={kernelName:Hd,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{strides:o,pad:a,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>Bl(e,s,o,a,i,1,l),filter:()=>Y_(e,r,s.shape,o,a,i,l)}}};function K0e(e,t,n,r,s){let o=e;e.rank===4&&(o=ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let a=t;a.rank===4&&(a=ie(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),H(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),H(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),H(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),H(o.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${n[3]}.`),H(a.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`);let i={x:o,dy:a},l={strides:r,pad:s,filterShape:n};return se.runKernel(ow,i,l)}var X0e=ae({conv3DBackpropFilter_:K0e}),Z0e={kernelName:L1,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:o}=n;H(Gc(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[a,i]=t;return{x:()=>M9(a.shape,e,i,s,o),filter:()=>X0e(a,e,i.shape,s,o)}}},Y0e={kernelName:qd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(er(mk(Fe(n,"float32"))),e)}}},J0e={kernelName:Kd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(gk(Fe(n,"float32")),e)}}},Q0e={kernelName:Xd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s,exclusive:o,reverse:a}=n;return{x:()=>{let i=X9([s],r.rank),l=rk(e,s,o,!a);return i!=null&&(l=Kt(l,i)),l}}}},exe={kernelName:Zd,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:o,dimRoundingMode:a}=n,i=r==null?[1,1]:r;H(Gc(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[l,u]=t;return H(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),H(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),H(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),H(ol(s,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${i}'.`),a!=null&&H(as(o),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`),{x:()=>cM(l.shape,e,u,s,o,i,a),filter:()=>uM(l,e,u.shape,s,o,i,a)}}},txe={kernelName:B1,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,o={x:r,filter:s,dy:e},a={x:r,filter:s,dy:e};return{x:()=>se.runKernel(pw,o,n),filter:()=>se.runKernel(dw,a,n)}}},nxe={kernelName:Jd,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>se.runKernel(hw,r)}}},rxe={kernelName:Ig,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=te(Bo(er(Tn(n))),2/Math.sqrt(Math.PI));return{x:()=>te(e,r)}}},sxe={kernelName:Qd,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(e,n)}}},oxe={kernelName:Sg,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>ie(e,n.shape)}}},axe={kernelName:Ng,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(e,Bo(n))}}},ixe={kernelName:ef,gradFunc:e=>({x:()=>Xt(e)})},lxe={kernelName:tf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Wn(n.shape,r.shape);return{a:()=>{let i=Me(e,Fe(r,"float32")),l=jr(n.shape,s);return l.length>0?ie(Je(i,l),n.shape):i},b:()=>{let i=te(e,Fe(n,"float32")),l=jr(r.shape,s);l.length>0&&(i=ie(Je(i,l),r.shape));let u=Tn(r);return er(Me(i,Fe(u,"float32")))}}}},uxe={kernelName:nf,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[s,o,a,i]=t,l=i==null?at(1):i,u=jr(o.shape,s.shape),c=[];if(o.rank===1){for(let A=0;A<s.shape.length-1;++A)c.push(s.shape[A]);c.push(1)}let p=Ge(s,o),d=te(e,l),f=fk(Re(a,at(r))),h=te(te(te(f,f),f),at(-.5));return{x:()=>o.rank===1?ie(te(te(e,da(ie(f,[1,1,1,o.shape[0]]),c)),l),s.shape):ie(te(te(e,f),l),s.shape),mean:()=>{let A=te(te(f,at(-1)),d);return o.rank===1&&(A=Je(A,u)),ie(A,o.shape)},variance:()=>{let A=te(te(h,p),d);return o.rank===1&&(A=Je(A,u)),ie(A,o.shape)},scale:()=>{let A=te(p,f),v=te(e,A);return o.rank===1&&(v=Je(v,u)),ie(v,o.shape)},offset:()=>{let A=e;return o.rank===1&&(A=Je(A,u)),ie(A,o.shape)}}}},cxe={kernelName:_g,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,s]=t,{axis:o}=n,a=Ra(o,r.shape)[0];return{x:()=>{let l=r.shape,u=s.size,c=l.slice(0,a),p=c.length,d=l.slice(o,l.length).slice(1),f=d.length,h=NM(0,p),m=NM(p+1,p+1+f),g=TM([c,[u],d]),x=ie(e,g),y=ie(s,[u]),b=TM([[p],h,m]),A=Kt(x,b),v=q_(A,y,r.shape[a]),w=$_(b);return v=Kt(v,w),v},indices:()=>s}}};function NM(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function TM(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var pxe={kernelName:rf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Xt(n),b:()=>Xt(r)}}},dxe={kernelName:sf,gradFunc:e=>({x:()=>Fe(e,"float32")})},fxe={kernelName:Dg,gradFunc:e=>({x:()=>Xt(e)})},hxe={kernelName:$g,gradFunc:e=>({x:()=>Xt(e)})},mxe={kernelName:Fg,gradFunc:e=>({x:()=>Xt(e)})},gxe={kernelName:of,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:s}=n,o=bo(r,0);return{x:()=>$s(o,e,te(e,s))}}},xxe={kernelName:Mg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Me(e,Re(n,1))}}},yxe={kernelName:af,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Me(e,Fe(n,"float32"))}}},bxe={kernelName:NP,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n;return{logits:()=>{let o=!0,a=Bo(r);return Ge(e,te(Je(e,s,o),a))}}}};function Axe(e,t,n,r=5,s=1,o=1,a=.5){let i={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:o,beta:a};return se.runKernel(bw,i,l)}var vxe=ae({localResponseNormalizationBackprop_:Axe}),wxe={kernelName:U1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{depthRadius:o,bias:a,alpha:i,beta:l}=n;return{x:()=>vxe(r,s,e,o,a,i,l)}}};function _M(e,t,n,r){return t.rank<n.rank&&(t=ie(t,Zf(t.shape,r))),e.rank<n.rank&&(e=ie(e,Zf(e.shape,r))),{x:()=>te(e,Fe(Lo(n,t),e.dtype))}}var EM={kernelName:lf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:s}=r,o=t[0],a=t[1],i=Ra(s,o.shape),l=_M(e,a,o,i);return{x:()=>l.x()}}},kxe={kernelName:uf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>te(e,Fe(Uc(n,r),"float32")),b:()=>te(e,Fe(ok(n,r),"float32"))}}};function Ixe(e,t,n,r,s,o,a){let i=U(e,"dy","maxPool3dGrad"),l=U(t,"input","maxPool3dGrad"),u=U(n,"output","maxPool3dGrad"),c=i,p=l,d=u,f=!1;l.rank===4&&(f=!0,c=ie(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),p=ie(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=ie(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),H(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),H(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),H(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),a!=null&&H(as(o),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let h={dy:c,input:p,output:d},m={filterSize:r,strides:s,pad:o,dimRoundingMode:a},g=se.runKernel(vw,h,m);return f?ie(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var Cxe=ae({maxPool3dGrad_:Ixe}),Sxe={kernelName:j1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=n;return{x:()=>Cxe(e,r,s,o,a,i,l)}}};function Nxe(e,t,n,r,s,o,a){let i=U(e,"dy","maxPoolGrad"),l=U(t,"input","maxPoolGrad"),u=U(n,"output","maxPoolGrad");H(l.rank===i.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`),H(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),H(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),a!=null&&H(as(o),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let c={dy:i,input:l,output:u},p={filterSize:r,strides:s,pad:o,dimRoundingMode:a};return se.runKernel(Aw,c,p)}var Txe=ae({maxPoolGrad_:Nxe}),_xe={kernelName:cf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:o,strides:a,pad:i}=n;return{x:()=>Txe(e,r,s,o,a,i)}}},Exe={kernelName:pf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,o=Ra(s,r.shape),i=K9(r.shape,o)[1],l=wr(i);return{x:()=>{let c=r.shape.slice();o.forEach(f=>{c[f]=1});let p=ie(e,c);return Me(te(p,Go(r.shape,"float32")),l)}}}},Rxe={kernelName:df,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:s}=r,[o,a]=t,i=Ra(s,o.shape),l=_M(e,a,o,i);return{x:()=>l.x()}}},Dxe={kernelName:ff,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>te(e,Fe(jc(n,r),"float32")),b:()=>te(e,Fe(bo(n,r),"float32"))}}},$xe={kernelName:hf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,o=s.map(a=>a[0]);return{x:()=>gt(e,o,r.shape)}}},Fxe={kernelName:Lg,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Wn(n.shape,r.shape);return{a:()=>{let i=jr(n.shape,s);return i.length>0?ie(Je(e,i),n.shape):e},b:()=>{let i=te(e,er(C0(Me(n,r)))),l=jr(r.shape,s);return l.length>0?ie(Je(i,l),r.shape):i}}}},Oxe={kernelName:mf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Wn(n.shape,r.shape);return{a:()=>{let i=te(e,Fe(r,"float32")),l=jr(n.shape,s);return l.length>0?ie(Je(i,l),n.shape):i},b:()=>{let i=te(e,Fe(n,"float32")),l=jr(r.shape,s);return l.length>0?ie(Je(i,l),r.shape):i}}}},Pxe={kernelName:Bg,gradFunc:e=>({x:()=>er(e)})},Mxe={kernelName:gf,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>xr(n.shape,"float32")}}},zxe={kernelName:jg,gradFunc:e=>({x:()=>Xt(e)})},Lxe={kernelName:Hg,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Vs(e,r).map(o=>()=>o)}},RM={kernelName:xf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,o=s.map(a=>a[0]);return{x:()=>gt(e,o,r.shape)}}},Bxe={kernelName:yf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,s]=t,o=n,a=r,i=Wn(o.shape,a.shape);return{a:()=>{let c=Fe(a,"float32"),p=te(e,te(c,Wl(o,Ge(c,at(1))))),d=jr(o.shape,i);return d.length>0&&(p=Je(p,d)),ie(p,o.shape)},b:()=>{let c=bo(o,0),p=$s(c,Vo(o),Xt(o)),d=te(e,te(s,p)),f=jr(a.shape,i);return f.length>0&&(d=Je(d,f)),ie(d,a.shape)}}}},Vxe={kernelName:bf,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,s=bo(n,0);return{x:()=>$s(s,e,te(e,r)),alpha:()=>{let o=$s(s,Xt(e),te(e,n)),a=jr(r.shape,e.shape);return a.length>0&&(o=Je(o,a)),ie(o,r.shape)}}}},Wxe={kernelName:Yd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Wn(n.shape,r.shape);return{a:()=>{let i=Me(e,Fe(r,"float32")),l=jr(n.shape,s);return l.length>0?ie(Je(i,l),n.shape):i},b:()=>{let i=te(e,Fe(n,"float32")),l=jr(r.shape,s);l.length>0&&(i=ie(Je(i,l),r.shape));let u=Tn(r);return er(Me(i,Fe(u,"float32")))}}}},Gxe={kernelName:Kg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Me(e,er(Tn(n)))}}},Uxe={kernelName:wf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=te(jc(n,6),E0(n));return{x:()=>te(e,Fe(r,"float32"))}}},jxe={kernelName:Af,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(e,Fe(E0(n),"float32"))}}},Hxe={kernelName:Xg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ie(e,n.shape)}}},qxe={kernelName:vf,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>se.runKernel(Sw,s,n)}}},Kxe={kernelName:q1,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>se.runKernel(Cw,s,n)}}},Xxe={kernelName:kf,gradFunc:(e,t,n)=>{let{dims:r}=n,s=Ra(r,e.shape);return{x:()=>jo(e,s)}}},Zxe={kernelName:If,gradFunc:e=>({x:()=>Xt(e)})},Yxe={kernelName:Cf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>er(Me(e,te(Wl(n,1.5),2)))}}},Jxe={kernelName:Yg,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>Fe(Xt(n),"float32"),t:()=>te(e,Fe(n,e.dtype)),e:()=>te(e,Fe(mb(n),e.dtype))}}},Qxe={kernelName:Jg,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=bo(n,at(0)),s=at(vM),o=at(wM),a=te(e,o),i=te(te(e,s),Bo(Fe(n,"float32")));return $s(r,a,i)}}}},eye={kernelName:Nf,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(e,te(n,Ge(at(1),n)))}}},tye={kernelName:t0,gradFunc:e=>({x:()=>Xt(e)})},nye={kernelName:Sf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(db(Fe(n,"float32")),e)}}},rye={kernelName:e0,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(nk(Fe(n,"float32")),e)}}},sye={kernelName:Qg,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:s,size:o}=n,a=r.shape,[i,l]=A9(r,s,o),u=[];for(let c=0;c<e.rank;c++)u.push([i[c],a[c]-i[c]-l[c]]);return{x:()=>Vl(e,u)}}},oye={kernelName:Ef,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:s}=n,o=!0,a=te(e,r);return{logits:()=>Ge(a,te(Je(a,[s],o),r))}}},aye={kernelName:n0,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(e,xo(n))}}},DM={kernelName:r0,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:s}=n;return{x:()=>pb(e,r,s)}}},$M={kernelName:s0,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>En(e,r)}}},iye={kernelName:Tf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Me(e,te(As(Fe(n,"float32")),2))}}},lye={kernelName:K1,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(e,te(Fe(n,"float32"),2))}}},uye={kernelName:Rf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=at(2);return{a:()=>te(e,te(s,Ge(n,r))),b:()=>te(e,te(s,Ge(r,n)))}}},cye={kernelName:Pc,gradFunc:e=>({x:()=>Xt(e)})},pye={kernelName:Df,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Wn(n.shape,r.shape);return{a:()=>{let i=e,l=jr(n.shape,s);return l.length>0&&(i=Je(i,l)),ie(i,n.shape)},b:()=>{let i=e,l=jr(r.shape,s);return l.length>0&&(i=Je(i,l)),ie(er(i),r.shape)}}}},dye={kernelName:_f,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,s=r.shape.slice(),{axis:o}=n;Ra(o,r.shape).forEach(u=>{s[u]=1});let i=ie(e,s),l=te(i,Go(r.shape,"float32"));return{x:()=>l}}},fye={kernelName:$f,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Me(e,Tn(db(n)))}}},hye={kernelName:Ff,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>te(Ge(at(1),Tn(n)),e)}}},mye={kernelName:Oc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:s}=n;return{x:()=>{let a=Xt(r);if(r.rank===1)for(let i=0;i<s[0];++i)a=Re(a,gt(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let l=0;l<s[1];++l)a=Re(a,gt(e,[i*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)a=Re(a,gt(e,[i*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)a=Re(a,gt(e,[i*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return a}}}},gye={kernelName:Of,gradFunc:(e,t,n)=>{let r=n,{perm:s}=r,o=$_(s);return{x:()=>Kt(e,o)}}},xye={kernelName:l0,gradFunc:(e,t,n)=>{let r=n,{axis:s}=r;return{value:()=>vs(e,s)}}},yye={kernelName:X1,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bye(e,n)}}};function bye(e,t){let n=il(t,Xt(t)),r=Kf(e,n),s=Uc(t,at(0,"int32")),o=r.rank-s.rank;for(let i=0;i<o;++i)s=kr(s,i+1);s=Fa(s,Go(r.shape,"bool"));let a=Xt(r);return $s(s,r,a)}var Aye={kernelName:u0,gradFunc:e=>({x:()=>Xt(e)})},vye=[SM,v0e,w0e,k0e,I0e,C0e,S0e,N0e,T0e,_0e,E0e,R0e,F0e,M0e,z0e,L0e,B0e,V0e,W0e,G0e,U0e,j0e,q0e,H0e,Z0e,Y0e,J0e,Q0e,exe,txe,Wxe,nxe,rxe,sxe,oxe,axe,lxe,ixe,uxe,cxe,pxe,dxe,fxe,hxe,mxe,gxe,xxe,yxe,bxe,wxe,EM,EM,kxe,Sxe,_xe,Exe,Rxe,Dxe,$xe,Fxe,Oxe,Pxe,Mxe,zxe,Lxe,RM,RM,Bxe,Vxe,Gxe,Uxe,jxe,Hxe,qxe,Kxe,Xxe,Zxe,Yxe,Jxe,Qxe,eye,tye,nye,rye,sye,oye,aye,DM,DM,$M,$M,iye,uye,lye,cye,pye,dye,fye,hye,mye,gye,xye,yye,Aye];for(let e of vye)TP(e);ve().prototype.abs=function(){return this.throwIfDisposed(),Tr(this)};ve().prototype.acos=function(){return this.throwIfDisposed(),u_(this)};ve().prototype.acosh=function(){return this.throwIfDisposed(),c_(this)};ve().prototype.add=function(e){return this.throwIfDisposed(),Re(this,e)};ve().prototype.all=function(e,t){return this.throwIfDisposed(),Jw(this,e,t)};ve().prototype.any=function(e,t){return this.throwIfDisposed(),lb(this,e,t)};ve().prototype.argMax=function(e){return this.throwIfDisposed(),xi(this,e)};ve().prototype.argMin=function(e){return this.throwIfDisposed(),p_(this,e)};ve().prototype.asScalar=function(){return this.throwIfDisposed(),H(this.size===1,()=>"The array must have only 1 element."),ie(this,[])};ve().prototype.asType=function(e){return this.throwIfDisposed(),Fe(this,e)};ve().prototype.as1D=function(){return this.throwIfDisposed(),ie(this,[this.size])};ve().prototype.as2D=function(e,t){return this.throwIfDisposed(),ie(this,[e,t])};ve().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),ie(this,[e,t,n])};ve().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),ie(this,[e,t,n,r])};ve().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),ie(this,[e,t,n,r,s])};ve().prototype.asin=function(){return this.throwIfDisposed(),d_(this)};ve().prototype.asinh=function(){return this.throwIfDisposed(),f_(this)};ve().prototype.atan=function(){return this.throwIfDisposed(),h_(this)};ve().prototype.atan2=function(e){return this.throwIfDisposed(),m_(this,e)};ve().prototype.atanh=function(){return this.throwIfDisposed(),g_(this)};ve().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),cb(this,e,t,n,r)};ve().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),pb(this,e,t)};ve().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),qf(this,e,t,n,r,s)};ve().prototype.broadcastTo=function(e){return this.throwIfDisposed(),A0(this,e)};ve().prototype.cast=function(e){return this.throwIfDisposed(),Fe(this,e)};ve().prototype.ceil=function(){return this.throwIfDisposed(),v_(this)};ve().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),yo(this,e,t)};ve().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Vt&&(e=[e]),En([this,...e],t)};ve().prototype.conv1d=function(e,t,n,r,s,o){return this.throwIfDisposed(),ek(this,e,t,n,r,s,o)};ve().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),tk(this,e,t,n,r,s)};ve().prototype.conv2d=function(e,t,n,r,s,o){return this.throwIfDisposed(),Bl(this,e,t,n,r,s,o)};ve().prototype.cos=function(){return this.throwIfDisposed(),db(this)};ve().prototype.cosh=function(){return this.throwIfDisposed(),nk(this)};ve().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),rk(this,e,t,n)};ve().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),I_(this,e,t)};ve().prototype.depthwiseConv2d=function(e,t,n,r,s,o){return this.throwIfDisposed(),w0(this,e,t,n,r,s,o)};ve().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),C_(this,e,t,n,r,s)};ve().prototype.divNoNan=function(e){return this.throwIfDisposed(),S_(this,e)};ve().prototype.div=function(e){return this.throwIfDisposed(),Me(this,e)};ve().prototype.dot=function(e){return this.throwIfDisposed(),B9(this,e)};ve().prototype.elu=function(){return this.throwIfDisposed(),k0(this)};ve().prototype.equal=function(e){return this.throwIfDisposed(),Lo(this,e)};ve().prototype.erf=function(){return this.throwIfDisposed(),N_(this)};ve().prototype.exp=function(){return this.throwIfDisposed(),Bo(this)};ve().prototype.expandDims=function(e){return this.throwIfDisposed(),kr(this,e)};ve().prototype.expm1=function(){return this.throwIfDisposed(),T_(this)};ve().prototype.fft=function(){return this.throwIfDisposed(),wb(this)};ve().prototype.flatten=function(){return this.throwIfDisposed(),ie(this,[this.size])};ve().prototype.floor=function(){return this.throwIfDisposed(),C0(this)};ve().prototype.floorDiv=function(e){return this.throwIfDisposed(),Zw(this,e)};ve().prototype.gather=function(e,t){return this.throwIfDisposed(),Kf(this,e,t)};ve().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Uc(this,e)};ve().prototype.greater=function(e){return this.throwIfDisposed(),bo(this,e)};ve().prototype.ifft=function(){return this.throwIfDisposed(),_0(this)};ve().prototype.irfft=function(){return this.throwIfDisposed(),bk(this)};ve().prototype.isFinite=function(){return this.throwIfDisposed(),W9(this)};ve().prototype.isInf=function(){return this.throwIfDisposed(),G9(this)};ve().prototype.isNaN=function(){return this.throwIfDisposed(),E_(this)};ve().prototype.leakyRelu=function(e){return this.throwIfDisposed(),fb(this,e)};ve().prototype.lessEqual=function(e){return this.throwIfDisposed(),jc(this,e)};ve().prototype.less=function(e){return this.throwIfDisposed(),ok(this,e)};ve().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),R_(this,e,t,n,r)};ve().prototype.logSigmoid=function(){return this.throwIfDisposed(),H9(this)};ve().prototype.logSoftmax=function(e){return this.throwIfDisposed(),ik(this,e)};ve().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),F_(this,e,t)};ve().prototype.log=function(){return this.throwIfDisposed(),Vo(this)};ve().prototype.log1p=function(){return this.throwIfDisposed(),hb(this)};ve().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Fa(this,e)};ve().prototype.logicalNot=function(){return this.throwIfDisposed(),mb(this)};ve().prototype.logicalOr=function(e){return this.throwIfDisposed(),lk(this,e)};ve().prototype.logicalXor=function(e){return this.throwIfDisposed(),Z9(this,e)};ve().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Lt(this,e,t,n)};ve().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),gb(this,e,t,n,r)};ve().prototype.max=function(e,t){return this.throwIfDisposed(),Wo(this,e,t)};ve().prototype.maximum=function(e){return this.throwIfDisposed(),il(this,e)};ve().prototype.mean=function(e,t){return this.throwIfDisposed(),cr(this,e,t)};ve().prototype.min=function(e,t){return this.throwIfDisposed(),xb(this,e,t)};ve().prototype.minimum=function(e){return this.throwIfDisposed(),S0(this,e)};ve().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),P_(this,e,t)};ve().prototype.mod=function(e){return this.throwIfDisposed(),M_(this,e)};ve().prototype.mul=function(e){return this.throwIfDisposed(),te(this,e)};ve().prototype.neg=function(){return this.throwIfDisposed(),er(this)};ve().prototype.norm=function(e,t,n){return this.throwIfDisposed(),kk(this,e,t,n)};ve().prototype.notEqual=function(e){return this.throwIfDisposed(),Yf(this,e)};ve().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),g0(this,e,t,n)};ve().prototype.onesLike=function(){return this.throwIfDisposed(),Uo(this)};ve().prototype.pad=function(e,t){return this.throwIfDisposed(),Vl(this,e,t)};ve().prototype.pool=function(e,t,n,r,s){return this.throwIfDisposed(),Q9(this,e,t,n,r,s)};ve().prototype.pow=function(e){return this.throwIfDisposed(),Wl(this,e)};ve().prototype.prelu=function(e){return this.throwIfDisposed(),bb(this,e)};ve().prototype.prod=function(e,t){return this.throwIfDisposed(),ck(this,e,t)};ve().prototype.reciprocal=function(){return this.throwIfDisposed(),B_(this)};ve().prototype.relu=function(){return this.throwIfDisposed(),yi(this)};ve().prototype.relu6=function(){return this.throwIfDisposed(),pk(this)};ve().prototype.reshapeAs=function(e){return this.throwIfDisposed(),ie(this,e.shape)};ve().prototype.reshape=function(e){return this.throwIfDisposed(),ie(this,e)};ve().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),xM(this,e,t,n)};ve().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),yM(this,e,t,n)};ve().prototype.reverse=function(e){return this.throwIfDisposed(),jo(this,e)};ve().prototype.rfft=function(){return this.throwIfDisposed(),kb(this)};ve().prototype.round=function(){return this.throwIfDisposed(),dk(this)};ve().prototype.rsqrt=function(){return this.throwIfDisposed(),fk(this)};ve().prototype.selu=function(){return this.throwIfDisposed(),hk(this)};ve().prototype.separableConv2d=function(e,t,n,r,s,o){return this.throwIfDisposed(),V_(this,e,t,n,r,s,o)};ve().prototype.sigmoid=function(){return this.throwIfDisposed(),xo(this)};ve().prototype.sign=function(){return this.throwIfDisposed(),W_(this)};ve().prototype.sin=function(){return this.throwIfDisposed(),mk(this)};ve().prototype.sinh=function(){return this.throwIfDisposed(),gk(this)};ve().prototype.slice=function(e,t){return this.throwIfDisposed(),gt(this,e,t)};ve().prototype.softmax=function(e){return this.throwIfDisposed(),Jf(this,e)};ve().prototype.softplus=function(){return this.throwIfDisposed(),Xf(this)};ve().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),yb(this,e,t)};ve().prototype.split=function(e,t){return this.throwIfDisposed(),_r(this,e,t)};ve().prototype.sqrt=function(){return this.throwIfDisposed(),As(this)};ve().prototype.square=function(){return this.throwIfDisposed(),Tn(this)};ve().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Ak(this,e)};ve().prototype.squeeze=function(e){return this.throwIfDisposed(),ln(this,e)};ve().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Vt?[this,e]:[this,...e];return vs(n,t)};ve().prototype.step=function(e){return this.throwIfDisposed(),E0(this,e)};ve().prototype.stridedSlice=function(e,t,n,r,s,o,a,i){return this.throwIfDisposed(),U_(this,e,t,n,r,s,o,a,i)};ve().prototype.sub=function(e){return this.throwIfDisposed(),Ge(this,e)};ve().prototype.sum=function(e,t){return this.throwIfDisposed(),Je(this,e,t)};ve().prototype.tan=function(){return this.throwIfDisposed(),j_(this)};ve().prototype.tanh=function(){return this.throwIfDisposed(),Hf(this)};ve().prototype.tile=function(e){return this.throwIfDisposed(),da(this,e)};ve().prototype.toBool=function(){return this.throwIfDisposed(),Fe(this,"bool")};ve().prototype.toFloat=function(){return this.throwIfDisposed(),Fe(this,"float32")};ve().prototype.toInt=function(){return this.throwIfDisposed(),Fe(this,"int32")};ve().prototype.topk=function(e,t){return this.throwIfDisposed(),H_(this,e,t)};ve().prototype.transpose=function(e){return this.throwIfDisposed(),Kt(this,e)};ve().prototype.unique=function(e){return this.throwIfDisposed(),wk(this,e)};ve().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),q_(this,e,t)};ve().prototype.unstack=function(e){return this.throwIfDisposed(),Vs(this,e)};ve().prototype.where=function(e,t){return this.throwIfDisposed(),$s(e,this,t)};ve().prototype.zerosLike=function(){return this.throwIfDisposed(),Xt(this)};var FM={};Rt(FM,{maxNorm:()=>Cye,minMaxNorm:()=>Tye,nonNeg:()=>Nye,unitNorm:()=>Sye});var tE;function Hr(){return tE==null&&(tE=sl().epsilon()),tE}function Ai(){return"channelsLast"}var jl=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,jl.prototype)}},vi=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,vi.prototype)}},pe=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,pe.prototype)}},Et=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Et.prototype)}},OM=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,OM.prototype)}};function th(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function ul(e,t){if(!e)throw new OM(t)}function PM(e,t){let n=0;for(let r of e)r===t&&n++;return n}function Ao(e){return e.length===1?e[0]:e}function Gn(e){return Array.isArray(e)?e:[e]}function Hl(e){let n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function nh(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var Oa={};function nE(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function rE(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>rE(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:rE(r))}}}function Sb(e,t={},n={},r="object",s=!1){if(typeof e=="string"){let o=e,a;if(o in n)a=n[o];else if(o in Oa)a=Oa[o];else if(a=t[o],a==null)throw new pe(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let o=e;if(o.className==null||o.config==null)throw new pe(`${r}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);let a=o.className,i,l;if(a in n?[i,l]=n[a]:a in Oa?[i,l]=Oa.className:a in t&&([i,l]=t[a]),i==null)throw new pe(`Unknown ${r}: ${a}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let f of Object.keys(Oa))u[f]=Oa[f];for(let f of Object.keys(n))u[f]=n[f];let c=o.config;c.customObjects=u;let p=Object.assign({},Oa);for(let f of Object.keys(n))Oa[f]=n[f];rE(o.config);let d=l(i,o.config,n,s);return Oa=Object.assign({},p),d}else{let u=Object.assign({},Oa);for(let p of Object.keys(n))Oa[p]=n[p];let c=new i(o.config);return Oa=Object.assign({},u),c}}}function wye(e,t){return e<t?-1:e>t?1:0}function Pk(e,t){return-1*wye(e,t)}function qc(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function kye(e){if(e==null)throw new pe(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function rh(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new pe(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function sE(e,t,n=0,r=1/0){return ul(n>=0),ul(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function cs(e,t){Array.isArray(e)?(E.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>cs(n,`element ${r+1} of ${t}`))):E.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${MM(e)}.`)}function MM(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>MM(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function Iye(e,t){let n=E.now(),r;return(...o)=>{let a=E.now();return a-n<t||(n=a,r=e(...o)),r}}function zM(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}function oE(e,t){return ce(()=>As(Je(te(e,e),t,!0)))}var Nb=class extends De.Serializable{getConfig(){return{}}},aE=class extends Nb{constructor(e){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>{let t=oE(e,this.axis),n=yo(t,0,this.maxValue);return te(e,Me(n,Re(Hr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};aE.className="MaxNorm";De.registerClass(aE);var iE=class extends Nb{constructor(e){super();this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>Me(e,Re(Hr(),oE(e,this.axis))))}getConfig(){return{axis:this.axis}}};iE.className="UnitNorm";De.registerClass(iE);var lE=class extends Nb{apply(e){return yi(e)}};lE.className="NonNeg";De.registerClass(lE);var uE=class extends Nb{constructor(e){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>{let t=oE(e,this.axis),n=Re(te(this.rate,yo(t,this.minValue,this.maxValue)),te(1-this.rate,t));return te(e,Me(n,Re(Hr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};uE.className="MinMaxNorm";De.registerClass(uE);var LM={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function qr(e){return nE(e)}function BM(e,t={}){return Sb(e,De.SerializationMap.getMap().classNameMap,t,"constraint")}function Kr(e){if(e==null)return null;if(typeof e=="string"){let n={className:e in LM?LM[e]:e,config:{}};return BM(n)}else return e instanceof Nb?e:BM(e)}function Cye(e){return new aE(e)}function Sye(e){return new iE(e)}function Nye(){return new lE}function Tye(e){return new uE(e)}var VM={};Rt(VM,{constant:()=>Yye,glorotNormal:()=>s1e,glorotUniform:()=>r1e,heNormal:()=>o1e,heUniform:()=>a1e,identity:()=>t1e,leCunNormal:()=>i1e,leCunUniform:()=>l1e,ones:()=>Zye,orthogonal:()=>u1e,randomNormal:()=>Qye,randomUniform:()=>Jye,truncatedNormal:()=>e1e,varianceScaling:()=>n1e,zeros:()=>Xye});var _ye=["channelsFirst","channelsLast"],Eye=["nearest","bilinear"],Rye=["valid","same","causal"],Dye=["max","avg"],$ye=["sum","mul","concat","ave"],D0=new Map;function Ir(e){rh(_ye,"DataFormat",e)}function Fye(e){rh(Eye,"InterpolationFormat",e)}function fa(e){rh(Rye,"PaddingMode",e)}function WM(e){rh(Dye,"PoolMode",e)}var Tb=[],GM="/";function sh(e,t){Tb.push(e);try{let n=t();return Tb.pop(),n}catch(n){throw Tb.pop(),n}}function Oye(){return Tb.length===0?"":Tb.join(GM)+GM}function UM(e){if(!HM(e))throw new Error("Not a valid tensor name: '"+e+"'");return Oye()+e}function jM(e){if(!HM(e))throw new Error("Not a valid tensor name: '"+e+"'");D0.has(e)||D0.set(e,0);let t=D0.get(e);if(D0.set(e,D0.get(e)+1),t>0){let n=`${e}_${t}`;return D0.set(n,1),n}else return e}var Pye=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function HM(e){return!!e.match(Pye)}function Mye(e){return e===parseInt(e.toString(),10)}function Kc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function $0(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function Xc(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function wi(e,t){if(t<e)throw new pe(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Mk(e,t){return Fe(e,t)}function _b(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),ie(e,n)}function zye(e,t){return ce(()=>{if(e.shape.length!==2)throw new pe(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=_b(e,1);return dE(n,[1,t,1])})}function Lye(e){let t=[Kc(e.shape)];return ie(e,t)}function Bye(e){if(e.rank<=1)throw new pe(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Kc(e.shape,1)];return ie(e,t)}function oh(e,t,n){return ce(()=>{switch(e.rank){case 1:return xk(e,t,n);case 2:return G_(e,[t,0],[n,e.shape[1]]);case 3:return yk(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return vb(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return gt(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return gt(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new pe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function cE(e,t,n){return ce(()=>{switch(e.rank){case 1:return xk(e,t,n);case 2:return G_(e,[0,t],[e.shape[0],n]);case 3:return yk(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return vb(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new pe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function zk(e,t,n,r){return ce(()=>{switch(e.rank){case 1:return xk(e,t,n);case 2:switch(r){case 1:return oh(e,t,n);case 2:return cE(e,t,n);default:throw new pe(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return oh(e,t,n);case 2:return yk(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return cE(e,t,n);default:throw new pe(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return oh(e,t,n);case 2:return vb(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return vb(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return cE(e,t,n);default:throw new pe(`The axis is not within the rank of the tensor ${r}`)}default:throw new pe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function pE(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),En(e,t)}function qM(e,t){switch(e.rank){case 1:return F9([e,t]);case 2:return v0([e,t],0);case 3:return O9([e,t],0);case 4:return P9([e,t],0);default:throw new pe(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function dE(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new pe(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return da(e,t)}function Lk(e,t=0,n=1,r,s){return eM(e,t,n,r,s)}function cl(e,t,n,r){if(e.rank<2||t.rank<2)throw new Et(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=e.shape.slice(-1)[0],o=t.shape.slice(-2)[0];if(s!==o)throw new Et(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2){let s=!1,o=!1;return Hc.matMul({a:e,b:t,transposeA:s,transposeB:o,bias:r?fE(e.rank,r,Ai()):null,activation:n})}else{let s=e.shape.slice(),o=s.pop();e=ie(e,[-1,o]);let a=t.shape.slice(),i=a.pop(),l=a.pop(),u=[...a,i],c=Array.from({length:t.rank},(h,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=ie(Kt(t,c),[l,-1]);let p=[...s,...u],d=!1,f=!1;return ie(Hc.matMul({a:e,b:t,transposeA:d,transposeB:f,bias:r?fE(e.rank,r,Ai()):null,activation:n}),p)}}function KM(e,t,n){return ce(()=>(Array.isArray(t)?t=Er(t,"int32"):t=Fe(t,"int32"),Kf(e,t,n)))}function Eb(e){return te(e,e)}function fE(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new pe(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?ie(t,[1,r[0],1,1,1]):ie(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?ie(t,[1,1,1,1,r[0]]):ie(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?ie(t,[1,r[0],1,1]):ie(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?ie(t,[1,1,1,r[0]]):ie(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?ie(t,[1,r[0],1]):ie(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?ie(t,[1,1,r[0]]):ie(t,[1].concat(r))}else if(e<3)return t;throw new pe(`Unsupported input rank by biasAdd: ${t.rank}`)}function ki(e,t,n){return ce(()=>(n==null&&(n=Ai()),Ir(n),Re(e,fE(e.rank,t,n))))}function Vye(e,t=1){if(t!==1)throw new Et(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return k0(e)}function Wye(e){return ce(()=>Me(e,Re(Tr(e),1)))}function XM(e,t,n,r){return ce(()=>iM(e,t,n,r))}function Gye(e){return ce(()=>{let t=Re(.5,te(.2,e));return yo(t,0,1)})}function Rb(e,t,n=!1){return n?e():t()}var Uye=["fanIn","fanOut","fanAvg"],jye=["normal","uniform","truncatedNormal"];function Hye(e){rh(Uye,"FanMode",e)}function qye(e){rh(jye,"Distribution",e)}var Pa=class extends De.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},hE=class extends Pa{apply(e,t){return xr(e,t)}};hE.className="Zeros";De.registerClass(hE);var Bk=class extends Pa{apply(e,t){return Go(e,t)}};Bk.className="Ones";De.registerClass(Bk);var mE=class extends Pa{constructor(e){super();if(typeof e!="object")throw new pe(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new pe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ce(()=>te(at(this.value),Go(e,t)))}getConfig(){return{value:this.value}}};mE.className="Constant";De.registerClass(mE);var gE=class extends Pa{constructor(e){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return N0(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};gE.className="RandomUniform";De.registerClass(gE);var xE=class extends Pa{constructor(e){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Et(`randomNormal does not support dType ${t}.`);return Lk(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};xE.className="RandomNormal";De.registerClass(xE);var yE=class extends Pa{constructor(e){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Et(`truncatedNormal does not support dType ${t}.`);return vk(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};yE.className="TruncatedNormal";De.registerClass(yE);var bE=class extends Pa{constructor(e){super();this.gain=e.gain!=null?e.gain:1}apply(e,t){return ce(()=>{if(e.length!==2||e[0]!==e[1])throw new pe("Identity matrix initializer can only be used for 2D square matrices.");return te(this.gain,__(e[0]))})}getConfig(){return{gain:this.gain}}};bE.className="Identity";De.registerClass(bE);function Kye(e,t="channelsLast"){let n,r;if(Ir(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let s=Kc(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){let s=Kc(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{let s=Kc(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}var vo=class extends Pa{constructor(e){super();if(e.scale<0)throw new pe(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Hye(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,qye(this.distribution),this.seed=e.seed}apply(e,t){let n=Kye(e),r=n[0],s=n[1],o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,s):o/=Math.max(1,(r+s)/2),this.distribution==="normal"){let a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Et(`${this.getClassName()} does not support dType ${t}.`);return vk(e,0,a,t,this.seed)}else{let a=Math.sqrt(3*o);return N0(e,-a,a,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};vo.className="VarianceScaling";De.registerClass(vo);var Vk=class extends vo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return vo.className}};Vk.className="GlorotUniform";De.registerClass(Vk);var Wk=class extends vo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return vo.className}};Wk.className="GlorotNormal";De.registerClass(Wk);var Gk=class extends vo{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return vo.className}};Gk.className="HeNormal";De.registerClass(Gk);var Uk=class extends vo{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return vo.className}};Uk.className="HeUniform";De.registerClass(Uk);var jk=class extends vo{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return vo.className}};jk.className="LeCunNormal";De.registerClass(jk);var Hk=class extends vo{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return vo.className}};Hk.className="LeCunNormal";De.registerClass(Hk);var AE=class extends Pa{constructor(e){super();if(this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Et("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return ce(()=>{if(e.length<2)throw new Et("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let n=e[0]>e[1]?[e[1],e[0]]:e,r=Lk(n,0,1,"float32"),s=AM.gramSchmidt(r);return e[0]>e[1]&&(s=Kt(s)),te(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};AE.className="Orthogonal";De.registerClass(AE);var ZM={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function YM(e,t={}){return Sb(e,De.SerializationMap.getMap().classNameMap,t,"initializer")}function pr(e){return nE(e)}function tr(e){if(typeof e=="string"){let t=e in ZM?ZM[e]:e;if(t==="GlorotNormal")return new Wk;if(t==="GlorotUniform")return new Vk;if(t==="HeNormal")return new Gk;if(t==="HeUniform")return new Uk;if(t==="LeCunNormal")return new jk;if(t==="LeCunUniform")return new Hk;{let n={};return n.className=t,n.config={},YM(n)}}else return e instanceof Pa?e:YM(e)}function Xye(){return new hE}function Zye(){return new Bk}function Yye(e){return new mE(e)}function Jye(e){return new gE(e)}function Qye(e){return new xE(e)}function e1e(e){return new yE(e)}function t1e(e){return new bE(e)}function n1e(e){return new vo(e)}function r1e(e){return new Vk(e)}function s1e(e){return new Wk(e)}function o1e(e){return new Gk(e)}function a1e(e){return new Uk(e)}function i1e(e){return new jk(e)}function l1e(e){return new Hk(e)}function u1e(e){return new AE(e)}var JM={};Rt(JM,{Layer:()=>Yt,RNN:()=>fl,RNNCell:()=>Bb,activation:()=>jbe,add:()=>eAe,alphaDropout:()=>MAe,average:()=>tAe,averagePooling1d:()=>z4,averagePooling2d:()=>L4,averagePooling3d:()=>B4,avgPool1d:()=>cAe,avgPool2d:()=>dAe,avgPool3d:()=>hAe,avgPooling1d:()=>pAe,avgPooling2d:()=>fAe,avgPooling3d:()=>mAe,batchNormalization:()=>iAe,bidirectional:()=>_Ae,concatenate:()=>nAe,conv1d:()=>Pbe,conv2d:()=>Mbe,conv2dTranspose:()=>zbe,conv3d:()=>Lbe,conv3dTranspose:()=>Bbe,convLstm2d:()=>CAe,convLstm2dCell:()=>SAe,cropping2D:()=>Wbe,dense:()=>Hbe,depthwiseConv2d:()=>Ube,dot:()=>aAe,dropout:()=>qbe,elu:()=>Ebe,embedding:()=>Qbe,flatten:()=>Xbe,gaussianDropout:()=>PAe,gaussianNoise:()=>OAe,globalAveragePooling1d:()=>gAe,globalAveragePooling2d:()=>xAe,globalMaxPool1d:()=>RAe,globalMaxPool2d:()=>DAe,globalMaxPooling1d:()=>iL,globalMaxPooling2d:()=>lL,gru:()=>bAe,gruCell:()=>AAe,input:()=>Rz,inputLayer:()=>_be,layerNormalization:()=>lAe,leakyReLU:()=>Dbe,lstm:()=>vAe,lstmCell:()=>wAe,masking:()=>zAe,maxPool1d:()=>$Ae,maxPool2d:()=>FAe,maxPooling1d:()=>uL,maxPooling2d:()=>cL,maxPooling3d:()=>yAe,maximum:()=>rAe,minimum:()=>sAe,multiply:()=>oAe,permute:()=>Jbe,prelu:()=>$be,reLU:()=>Rbe,repeatVector:()=>Zbe,reshape:()=>Ybe,rnn:()=>NAe,separableConv2d:()=>Vbe,simpleRNN:()=>kAe,simpleRNNCell:()=>IAe,softmax:()=>Fbe,spatialDropout1d:()=>Kbe,stackedRNNCells:()=>TAe,thresholdedReLU:()=>Obe,timeDistributed:()=>EAe,upSampling2d:()=>Gbe,zeroPadding2d:()=>uAe});var c1e=0;function QM(){return c1e++}var qk={};function Kk(e=""){return e in qk||(qk[e]=0),qk[e]+=1,e+qk[e].toString()}function vE(e){return Array.isArray(e)&&Array.isArray(e[0])}function Xk(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function $t(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new pe(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function kn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new pe(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function Zk(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}var ez="Variable",tz=class{constructor(e,t="float32",n=ez,r=!0,s=null){this.dtype=t==null?"float32":t,this.shape=e.shape,this.id=QM(),n=n==null?ez:n,this.originalName=UM(n),this.name=jM(this.originalName),this.trainable_=r,this.constraint=s,this.val=nM(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),p1e(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function p1e(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function wE(e){return e.map(t=>t.read())}function kE(e){e.forEach(t=>{t[0].write(t[1])})}var Rr=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Ii=class{constructor(e,t,n,r,s,o,a){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=a,this.id=QM(),o!=null&&(this.originalName=UM(o),this.name=jM(this.originalName)),this.rank=t.length}},d1e=0,Yk=class{constructor(e,t){this.callArgs=t,this.id=d1e++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},f1e=0,Yt=class extends De.Serializable{constructor(e={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=f1e++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Hl(n)+"_"+Kk(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new vi(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new pe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Ao(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Ao(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new jl(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new jl(`Layer ${this.name} is not connected, no input to return.`);return Ao(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new jl(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new jl(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ao(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=Gn(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=Gn(this.inputSpec);if(e.length!==t.length)throw new pe(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],s=t[n];if(s==null)continue;let o=r.rank;if(s.ndim!=null&&o!==s.ndim)throw new pe(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${o}`);if(s.maxNDim!=null&&o>s.maxNDim)throw new pe(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${o}`);if(s.minNDim!=null&&o<s.minNDim)throw new pe(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${o}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new pe(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let a=r.shape;for(let i in s.axes){let l=Number(i),u=s.axes[i],c=l>=0?a[l]:a[a.length+l];if(u!=null&&[u,null].indexOf(c)===-1)throw new pe(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${u} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){let i=s.shape[a],l=r.shape[a];if(i!=null&&l!=null&&i!==l)throw new pe(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=Gn(e),r=!0;for(let o of n)if(!(o instanceof Ii)){r=!1;break}let s=!0;for(let o of n)if(o instanceof Ii){s=!1;break}if(r===s)throw new pe("Arguments to apply() must be all SymbolicTensors or all Tensors");return sh(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let o=[];for(let a of Gn(e))o.push(a.shape);this.build(Ao(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let o=this.call(e,t),a=Gn(o),i=[];for(let l of a)n.indexOf(l)!==-1&&(l=l.clone()),i.push(l);if(o=Ao(i),this.activityRegularizer!=null)throw new Et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{let o=h1e(e),a=this.computeOutputShape(o),i,l=m1e(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?i=a.map((u,c)=>new Ii(l,u,this,Gn(e),t,this.name,c)):i=new Ii(l,a,this,Gn(e),t,this.name),this.addInboundNode(e,i,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new Et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new jl(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new jl(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new vi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Zk(this.weights)}build(e){this.built=!0}getWeights(e=!1){return wE(e?this.trainableWeights:this.weights)}setWeights(e){ce(()=>{let t=this.weights;if(t.length!==e.length)throw new pe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=wE(t);for(let s=0;s<r.length;++s){let o=r[s],a=t[s],i=e[s];if(!E.arraysEqual(o.shape,i.shape))throw new pe(`Layer weight shape ${o.shape} not compatible with provided weight shape ${i.shape}`);n.push([a,i])}kE(n)})}addWeight(e,t,n,r,s,o,a){if(this._addedWeightNames.indexOf(e)!==-1)throw new pe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=tr("zeros"));let i=r.apply(t,n),l=new tz(i,n,e,o,a);return i.dispose(),s!=null&&this.addLoss(()=>s.apply(l.read())),o==null&&(o=!0),o?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Gn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,r,s,o,a=null){let i=Gn(e);t=Gn(t),n=Gn(n),r=Gn(r),s=Xk(s),o=Xk(o);let l=[],u=[],c=[];for(let p of i)l.push(p.sourceLayer),u.push(p.nodeIndex),c.push(p.tensorIndex);new Yk({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:o},a);for(let p=0;p<t.length;p++)t[p].sourceLayer=this,t[p].nodeIndex=this.inboundNodes.length-1,t[p].tensorIndex=p}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount==0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function h1e(e){e=Gn(e);let t=[];for(let n of e)t.push(n.shape);return Ao(t)}function m1e(e){return"float32"}function nz(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let o=0;o<r.inboundLayers.length;o++){let a=r.inputTensors[o],i=r.inboundLayers[o],l=r.nodeIndices[o],u=nz(a,i,l);for(let c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}var F0=class extends Yt{constructor(e){super({dtype:e.dtype,name:e.name!=null?e.name:Kk("input").toString()});if(e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new pe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new pe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new pe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new Ii(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Yk({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new pe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};F0.className="InputLayer";De.registerClass(F0);function rz(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new pe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new F0({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}async function Zc(e){if(e==null)return;let t=[],n=[],r=[];for(let s in e){let o=e[s];if(typeof o!="number"){let a=o;t.push(a.data()),n.push(s),r.push(a)}}if(t.length>0){let s=await Promise.all(t);for(let o=0;o<s.length;++o)e[n[o]]=s[o][0];ye(r)}}function sz(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var oz;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(oz||(oz={}));var g1e=125,O0=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},az=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},x1e=class extends O0{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let s=t[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*n;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;let a=ce(()=>Re(this.totals[r],te(s,n)));this.totals[r]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:ce(()=>{let r=te(Me(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),us(t[n])}))}},iz=class extends O0{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let o=this.history[s];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){let i=o[a];e.push(i.data()),t.push(s),n.push(a)}}let r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}},lz=class extends O0{constructor(e,t){super();if(this.currentEpoch=0,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=g1e),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");E.isNumber(this.yieldEvery)&&(this.maybeWait=Iye(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await Zc(n),r.push(this.yield(e,t,n))),r.push(Ok()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Zc(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Zc(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(Ok()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Zc(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Zc(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(Ok()):E.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Zc(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Zc(e),await this.trainEnd(e))}};function uz(e,t){return e==null&&(e={}),e instanceof O0?[e]:Array.isArray(e)&&e[0]instanceof O0?e:Gn(e).map(r=>new lz(r,t))}var Ma=class{constructor(){}static registerCallbackConstructor(e,t){E.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Ma.checkForDuplicate(t),Ma.constructors[e]==null&&(Ma.constructors[e]=[]),Ma.constructors[e].push(t)}static checkForDuplicate(e){for(let t in Ma.constructors)Ma.constructors[+t].forEach(r=>{if(r===e)throw new pe("Duplicate callback constructor.")})}static clear(){Ma.constructors={}}static createCallbacks(e){let t=[];for(let n in Ma.constructors){let r=+n;e>=r&&t.push(...Ma.constructors[r])}return t.map(n=>new n)}};Ma.constructors={};function cz(e,t,n,r,s,o,a,i,l){let u=new iz,c=[new x1e,...Ma.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);let p=new az(c);return p.setParams({epochs:n,initialEpoch:r,samples:s,steps:o,batchSize:a,verbose:t,doValidation:i,metrics:l}),{callbackList:p,history:u}}function Ci(e,t={},n=!1){return Sb(e,De.SerializationMap.getMap().classNameMap,t,"layer",n)}function Jk(e,t){return ce(()=>{e.dtype!=="float32"&&(e=Fe(e,"float32"));let n=Je(Eb(e),t,!0),r=I0(n.shape,Hr()),s=As(il(n,r));return Me(e,s)})}function ah(e,t){return ce(()=>cr(Eb(Ge(t,e)),-1))}function Qk(e,t){return ce(()=>cr(Tr(Ge(t,e)),-1))}function P0(e,t){return ce(()=>{let n=Ge(e,t),r=yo(Tr(e),Hr(),Number.MAX_VALUE),s=Tr(Me(n,r));return te(100,cr(s,-1))})}function y1e(e,t){return ce(()=>{let n=yo(t,Hr(),Number.MAX_VALUE),r=Vo(Re(1,n)),s=yo(e,Hr(),Number.MAX_VALUE),o=Vo(Re(1,s));return cr(Eb(Ge(r,o)),-1)})}function b1e(e,t){return ce(()=>{let n=il(0,Ge(1,te(e,t)));return cr(Eb(n),-1)})}function A1e(e,t){return ce(()=>{let n=il(0,Ge(1,te(e,t)));return cr(n,-1)})}function v1e(e,t){return ce(()=>{let n=Je(te(e,t),-1),r=Wo(te(Ge(1,e),t),-1);return il(0,Re(1,Ge(r,n)))})}function w1e(e,t){return ce(()=>{let n=Math.log(2),r=Ge(t,e),s=Ge(Re(r,Xf(te(-2,r))),n);return cr(s,-1)})}function Db(e,t,n=!1){return ce(()=>{if(n)t=Jf(t);else{let r=Je(t,t.shape.length-1,!0);t=Me(t,r)}return t=yo(t,Hr(),1-Hr()),er(Je(te(Fe(e,"float32"),Vo(t)),t.shape.length-1))})}function e5(e,t,n=!1){return ce(()=>{let r=Fe(C0(Lye(e)),"int32");t=yo(t,Hr(),1-Hr());let s=t.shape,o=ie(g0(r,s[s.length-1]),s);return Db(o,t,n)})}function k1e(e,t){if(!E.arraysEqual(e.shape,t.shape))throw new pe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ce(()=>{let n=yi(t),r=er(Tr(t));return Re(Ge(n,te(t,e)),hb(Bo(r)))})}function t5(e,t){return ce(()=>{let n;return n=yo(t,Hr(),1-Hr()),n=Vo(Me(n,Ge(1,n))),cr(k1e(e,n),-1)})}function I1e(e,t){return ce(()=>{let n=yo(e,Hr(),1),r=yo(t,Hr(),1);return Je(te(e,Vo(Me(n,r))),-1)})}function C1e(e,t){return ce(()=>{let n=Vo(Re(Hr(),t));return cr(Ge(t,te(e,n)),-1)})}function IE(e,t){return ce(()=>{let n=Jk(e,-1),r=Jk(t,-1),s=te(n,r);return er(Je(s,-1))})}var n5={meanSquaredError:ah,meanAbsoluteError:Qk,meanAbsolutePercentageError:P0,meanSquaredLogarithmicError:y1e,squaredHinge:b1e,hinge:A1e,categoricalHinge:v1e,logcosh:w1e,categoricalCrossentropy:Db,sparseCategoricalCrossentropy:e5,binaryCrossentropy:t5,kullbackLeiblerDivergence:I1e,poisson:C1e,cosineProximity:IE};function CE(e){if(typeof e=="string"){if(e in n5)return n5[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new pe(t)}else return e}function SE(e,t){return ce(()=>{let n=te(.5,Uo(t)),r=Mk(bo(t,n),e.dtype);return cr(Lo(e,r),-1)})}function NE(e,t){return ce(()=>Mk(Lo(xi(e,-1),xi(t,-1)),"float32"))}function pz(e,t){return ce(()=>Fe(Je(Fa(Lo(e,1),Lo(t,1))),"float32"))}function S1e(e,t){return ce(()=>Fe(Je(Fa(Lo(e,1),Lo(t,0))),"float32"))}function N1e(e,t){return ce(()=>Fe(Je(Fa(Lo(e,0),Lo(t,1))),"float32"))}function dz(e,t){return ce(()=>{let n=pz(e,t),r=N1e(e,t),s=Re(n,r);return Fe($s(bo(s,0),Me(n,s),0),"float32")})}function T1e(e,t){return ce(()=>{let n=pz(e,t),r=S1e(e,t),s=Re(n,r);return Fe($s(bo(s,0),Me(n,s),0),"float32")})}function fz(e,t){return t5(e,t)}function hz(e,t){return e.rank===t.rank&&(e=ln(e,[e.rank-1])),t=xi(t,-1),t.dtype!==e.dtype&&(t=Fe(t,e.dtype)),Fe(Lo(e,t),"float32")}var _1e=ah,E1e=ah,R1e=Qk,D1e=Qk,$1e=P0,F1e=P0,TE=Db,O1e=IE,mz=e5,r5={binaryAccuracy:SE,categoricalAccuracy:NE,precision:dz,categoricalCrossentropy:TE,sparseCategoricalCrossentropy:mz,mse:_1e,MSE:E1e,mae:R1e,MAE:D1e,mape:$1e,MAPE:F1e,cosine:O1e};function P1e(e){if(typeof e=="string"&&e in r5)return r5[e];if(typeof e!="string"&&e!=null)return e;throw new pe(`Unknown metric ${e}`)}function s5(e){if(ul(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(n5))if(n5[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(r5))if(r5[n]===e){t=n;break}return t!==void 0?t:e.name}}function M1e(e){let t={Adagrad:()=>eh.adagrad(.01),Adadelta:()=>eh.adadelta(1,.95,Hr()),Adam:()=>eh.adam(.001,.9,.999,Hr()),Adamax:()=>eh.adamax(.002,.9,.999,Hr(),0),RMSProp:()=>eh.rmsprop(.001,.9,0,Hr()),SGD:()=>eh.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new pe(`Unknown Optimizer ${e}`)}var gz=1*1024*1024;function xz(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!_E(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>gz&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${gz}.`)}}function _E(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!_E(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!_E(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function z1e(e,t,n,r=console.log){let s=B1e(e),o=["Layer (type)","Output shape","Param #"];s?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let a;if(!s){o.push("Receives inputs"),a=[];for(let c in e.nodesByDepth)a.push(...e.nodesByDepth[c])}r("_".repeat(t)),o5(o,n,r),r("=".repeat(t));let i=e.layers;for(let c=0;c<i.length;++c)s?V1e(i[c],n,r):W1e(i[c],n,a,r),r((c===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=L1e(e),u=Zk(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function L1e(e){let t;return e.collectedTrainableWeights!=null?t=Zk(e.collectedTrainableWeights):t=Zk(e.trainableWeights),t}function B1e(e){let t=!0,n=[],r=[];for(let s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(let s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of e.layers){let o=!1;for(let a of s.inboundNodes)if(r.indexOf(a)!==-1)if(o){t=!1;break}else o=!0;if(!t)break}return t}function o5(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function V1e(e,t,n){let r;try{r=JSON.stringify(e.outputShape)}catch(i){r="multiple"}let s=e.name,o=e.getClassName(),a=[`${s} (${o})`,r,e.countParams().toString()];o5(a,t,n)}function W1e(e,t,n,r){let s;try{s=JSON.stringify(e.outputShape)}catch(c){s="multiple"}let o=[];for(let c of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(c)===-1))for(let p=0;p<c.inboundLayers.length;++p){let d=c.inboundLayers[p].name,f=c.nodeIndices[p],h=c.tensorIndices[p];o.push(`${d}[${f}][${h}]`)}let a=e.name,i=e.getClassName(),l=o.length===0?"":o[0],u=[`${a} (${i})`,s,e.countParams().toString(),l];o5(u,t,r);for(let c=1;c<o.length;++c)o5(["","","",o[c]],t,r)}function yz(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function $b(e,t){if(e===null)return null;if(typeof e=="string")return nh(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let o=e[s];yz(t,s,o)?n.push(o):n.push($b(o,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{let o=nh(r);n[o]=$b(s,o)}}return n}}function EE(e,t){if(e==null)return null;if(typeof e=="string")return Hl(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let o=e[s];yz(t,s,o)?n.push(o):n.push(EE(o,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r],o=Hl(r);(r==="name"||r==="className")&&typeof s=="string"?n[o]=s:n[o]=EE(s,r)}return n}}var RE="3.9.0";function G1e(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return Fe(t,e.dtype)}catch(n){throw new pe(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var ih=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof ih)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=G1e(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new pe(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Ii){if(this.id2Value[e.id]==null)throw new pe(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new pe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Ii){if(this.id2Value[e.id]==null)throw new pe(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new pe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&ye(this.id2Mask)}},DE={},bz={};function Fb(e,t,n,r){let s=n==null?!1:n.training,o=Array.isArray(e),a=o?e:[e],i=a.map(h=>h.name),l=[],u=t.names();for(let h of i)u.indexOf(h)!==-1?l.push(t.getValue(h)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c=i.join(",")+"|"+t.names().join(","),p,d;if(DE[c]==null){let h=U1e(a,t);p=h.sorted,d=h.recipientCounts,DE[c]=p,bz[c]=d}p=DE[c],d={},s||Object.assign(d,bz[c]);let f=new ih(t);for(let h=0;h<p.length;++h){if(r!=null){let N=Kw().numTensors;N>r.maxNumTensors&&(r.maxNumTensors=N),N<r.minNumTensors&&(r.minNumTensors=N)}let m=p[h],g=m.sourceLayer;if(g instanceof F0)continue;let x=[],y=[],b=[],A=!1;for(let N of m.inputs){let T=f.getValue(N),_=f.getMask(N);x.push(T),y.push(_),_!=null&&(A=!0),s||(d[N.name]--,d[N.name]===0&&!t.hasKey(N)&&i.indexOf(N.name)===-1&&!T.isDisposed&&N.sourceLayer.stateful!==!0&&b.push(T))}A&&(n=n||{},n.mask=y[0]);let v=Gn(g.apply(x,n)),w=null;g.supportsMasking&&(w=g.computeMask(x,y));let k=H1e(m),I=Array.isArray(k)?k:[k];for(let N=0;N<I.length;++N){f.hasKey(I[N])||f.add(I[N],v[N],Array.isArray(w)?w[0]:w);let T=i.indexOf(I[N].name);T!==-1&&(l[T]=v[N])}s||ye(b)}return f.disposeMasks(),o?l:l[0]}function U1e(e,t){E.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let s=Az(e[0],t);n=s.sorted,r=s.recipientMap}else{let s=new Set;for(let o of e){let{sorted:a,recipientMap:i}=Az(o,t);for(let l of a)s.has(l.name)||(n.push(l),s.add(l.name));for(let l in i)r[l]==null&&(r[l]=new Set),i[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:j1e(r)}}function j1e(e){let t={};for(let n in e)t[n]=e[n].size;return t}function Az(e,t){let n=new Set,r=[],s={};for(let i of t.names())n.add(i);let o=[],a=[];for(o.push(e);o.length>0;){let i=o[o.length-1];if(n.has(i.name)){o.pop();continue}let l=a[a.length-1]===o.length-1;if(i.inputs.length===0||l)o.pop(),r.push(i),n.add(i.name),l&&a.pop();else{a.push(o.length-1);for(let u of i.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(i.name),!n.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function H1e(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var pl=class extends Yt{constructor(e){super({});if(this.containerNodes=new Set,this.name=e.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=Kk(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],qc(this.inputs).length!==this.inputs.length)throw new pe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);qc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let y=x.sourceLayer,b=x.nodeIndex,A=x.tensorIndex;this.outputLayers.push(y),this.outputLayersNodeIndices.push(b),this.outputLayersTensorIndices.push(A)}for(let x of this.inputs){let y=x.sourceLayer,b=x.nodeIndex,A=x.tensorIndex;ul(b===0,"input layer has >1 nodes"),ul(A===0,"input layer has >1 tensors"),this.inputLayers.push(y),this.inputLayersNodeIndices.push(b),this.inputLayersTensorIndices.push(A)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let y=this.inputLayers[x];if(!(y instanceof F0))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${x} (0-based) originates from layer type ${y.getClassName()}.`);this.inputNames.push(y.name),this.feedInputShapes.push(y.batchInputShape),this.feedInputNames.push(y.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let t={},n={},r={},s={},o={},a=[],i=(x,y,b,A,v,w)=>{(A==null||v==null||w==null)&&(A=x.sourceLayer,v=x.nodeIndex,w=x.tensorIndex);let k=A.inboundNodes[v];if(b.indexOf(k)!==-1)throw new vi(`The tensor ${x.name} at layer "${A.name}" is part of a cycle.`);if(y.indexOf(k)!==-1)return;this.containerNodes.add(pl.nodeKey(A,v)),A.id in o||(o[A.id]=Object.keys(o).length),b.indexOf(k)===-1&&b.push(k);let I=k.inboundLayers.length;for(let N=0;N<I;N++){let T=k.inputTensors[N],_=k.inboundLayers[N],R=k.nodeIndices[N],S=k.tensorIndices[N];i(T,y,b,_,R,S)}for(y.push(k);b.indexOf(k)>=0;)b.splice(b.indexOf(k),1);a.push(k)},l=[],u=[];for(let x of this.outputs)i(x,l,u);let c=a.slice().reverse();for(let x of c){n[x.id]=x,x.id in t||(t[x.id]=0);let y=t[x.id],b=r[x.outboundLayer.id]==null?0:r[x.outboundLayer.id];y=Math.max(y,b),r[x.outboundLayer.id]=y,s[x.outboundLayer.id]=x.outboundLayer,t[x.id]=y;for(let A=0;A<x.inboundLayers.length;A++){let v=x.inboundLayers[A],w=x.nodeIndices[A],k=v.inboundNodes[w],I=t[k.id]==null?0:t[k.id];t[k.id]=Math.max(y+1,I),n[k.id]=k}}let p={};for(let x in t){let y=t[x];y in p||(p[y]=[]),p[y].push(n[x])}let d={};for(let x in r){let y=r[x];y in d||(d[y]=[]),d[y].push(s[x])}let f=Object.keys(d).map(x=>parseInt(x,10)).sort(Pk);this.layers=[];for(let x of f){let y=d[x];y.sort((b,A)=>{let v=o[b.id],w=o[A.id];return v<w?-1:v>w?1:0});for(let b of y)b instanceof pl&&this.internalContainerRefs.push(b),this.layers.push(b)}this.layersByDepth=d,f=Object.keys(p).map(x=>parseInt(x,10)).sort(Pk);let h=this.inputs.slice(),m=[];for(let x of f)for(let y of p[x]){let b=y.outboundLayer;if(b!=null){for(let A of y.inputTensors)if(h.indexOf(A)===-1)throw new vi(`Graph disconnected: cannot obtain value for tensor ${A} at layer "${b.name}". The following previous layers were accessed without issue: ${m}`);for(let A of y.outputTensors)h.push(A);m.push(b.name)}}this.nodesByDepth=p;let g=this.layers.map(x=>x.name);for(let x of g){let y=g.filter(b=>b===x).length;if(y!==1)throw new vi(`The name "${x}" is used ${y} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new Yk({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new pe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0;for(let o of this.layers)for(let a of o.weights){if(n[a.originalName]!=null)throw new pe(`Duplicate weight name: ${a.originalName}`);n[a.originalName]=a,r++}let s=[];for(let o in e){let a=o;if(n[o]==null){let i=o.split("/");a=i.slice(0,-2).concat([i[i.length-1]]).join("/")}if(n[a]!=null)s.push([n[a],e[o]]);else if(t)throw new pe(`Provided weight data has no target variable: ${o}`);delete n[a]}if(t){let o=[];for(let a in n)o.push(a);if(o.length>0)throw new pe(`${o.length} of ${r} weights are not set: ${o}`)}kE(s)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${RE}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=EE(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return ce(()=>{e=Gn(e);let n=new ih;for(let r=0;r<this.inputs.length;++r)n.add(this.inputs[r],e[r]);return Fb(this.outputs,n,t)})}computeMask(e,t){return ce(()=>{e=Gn(e);let n;return t==null?n=th(null,e.length):n=Gn(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=Xk(e);if(t.length!==this.inputLayers.length)throw new pe(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let a=0;a<t.length;a++){let i=this.inputLayers[a],l=t[a],u=i.name+"_0_0";n[u]=l}let r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Pk);if(r.length>1)for(let a of r){let i=this.nodesByDepth[a];for(let l of i){let u=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(u.id)!==-1)continue;let c=[];for(let h=0;h<l.inboundLayers.length;h++){let m=l.inboundLayers[h],g=l.nodeIndices[h],x=l.tensorIndices[h],y=`${m.name}_${g}_${x}`,b=n[y];c.push(b)}let p=u.computeOutputShape(Ao(c)),d=Xk(p),f=u.inboundNodes.indexOf(l);for(let h=0;h<d.length;h++){let m=`${u.name}_${f}_${h}`;n[m]=d[h]}}}let s=[],o=[];for(let a=0;a<this.outputLayers.length;a++){let i=this.outputLayers[a],l=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],c=`${i.name}_${l}_${u}`;o.push(c)}for(let a=0;a<o.length;a++){let i=o[a];ul(i in n),s.push(n[i])}return Ao(s)}runInternalGraph(e,t){t==null&&(t=th(null,e.length));let n={};for(let i=0;i<this.inputs.length;++i){let l=this.inputs[i],u=e[i],c=t[i];n[l.id]=[u,c]}let r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(Pk);for(let i of r){let l=this.nodesByDepth[i];for(let u of l){let c=u.outboundLayer,p=u.inputTensors,d=u.outputTensors,f=new Array;for(let h of p)h.id in n&&f.push(n[h.id]);if(f.length===p.length){let h={},m,g,x,y;if(u.callArgs!=null&&(h=u.callArgs),f.length===1){let[b,A]=f[0];h.mask==null&&(h.mask=A),x=Gn(c.call(b,h)),y=Gn(c.computeMask(b,A)),m=[b],g=[A]}else m=f.map(b=>b[0]),g=f.map(b=>b[1]),h.mask==null&&(h.mask=g),x=Gn(c.call(m,h)),y=Gn(c.computeMask(m,g));if(c.activityRegularizer)throw new Et("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let b=0;b<d.length;++b){let A=d[b],v=x[b],w=y[b];n[A.id]=[v,w]}}}}let s=[],o=[],a=[];for(let i of this.outputs){ul(i.id in n,`Could not compute output ${i.name} : ${i.id}`);let[l,u]=n[i.id];a.push(l.shape),s.push(l),o.push(u)}return[s,o,a]}buildNodeConversionMap(e){let t={},n;for(let r of this.layers){n=r instanceof pl?1:0;for(let s=0;s<r.inboundNodes.length;s++){let o=pl.nodeKey(r,s);this.containerNodes.has(o)&&(t[o]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new pe(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new pe("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new pe(`No such layer: ${e}`)}calculateLosses(){return ce(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=pl.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let o of this.layers){let a=o.getClassName(),i=o.getConfig(),l=[];for(let c=0;c<o.inboundNodes.length;c++){let p=o.inboundNodes[c],d=pl.nodeKey(o,c),f={};if(this.containerNodes.has(d)){if(p.callArgs)try{JSON.stringify(p.callArgs),f=p.callArgs}catch(h){console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(p.inboundLayers.length>0){let h=[];for(let m=0;m<p.inboundLayers.length;m++){let g=p.inboundLayers[m],x=p.nodeIndices[m],y=p.tensorIndices[m],b=pl.nodeKey(g,x),A=t[b];A==null&&(A=0),h.push([g.name,A,y,f])}l.push(h)}}}let u={};u.name=o.name,u.className=a,u.config=i,u.inboundNodes=l,n.push(u)}e.layers=n;let r=[];for(let o=0;o<this.inputLayers.length;o++){let a=this.inputLayers[o],i=this.inputLayersNodeIndices[o],l=pl.nodeKey(a,i);if(!this.containerNodes.has(l))continue;let u=t[l];u==null&&(u=0);let c=this.inputLayersTensorIndices[o];r.push([a.name,u,c])}e.inputLayers=r;let s=[];for(let o=0;o<this.outputLayers.length;o++){let a=this.outputLayers[o],i=this.outputLayersNodeIndices[o],l=pl.nodeKey(a,i);if(!this.containerNodes.has(l))continue;let u=t[l];u==null&&(u=0);let c=this.outputLayersTensorIndices[o];s.push([a.name,u,c])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){let s={},o={};function a(m,g){m.name in o?o[m.name].push(g):o[m.name]=[g]}function i(m,g){let x=[],y;for(let b of g){let A=b[0],v=b[1],w=b[2];if(y=b[3]==null?{}:b[3],!(A in s)){a(m,g);return}let k=s[A];if(k.inboundNodes.length<=v){a(m,g);return}let I=k.inboundNodes[v];x.push(I.outputTensors[w])}x.length>0&&m.apply(Ao(x),y)}function l(m){let g=m.name,x=Ci(m,t.customObjects!=null?t.customObjects:{});x.setFastWeightInitDuringBuild(r),s[g]=x,m.inboundNodes.forEach(b=>{if(!(b instanceof Array))throw new pe(`Corrupted configuration, expected array for nodeData: ${b}`);a(x,b)})}let u=t.name,c=t.layers;for(let m of c)l(m);for(;!kye(o);)for(let m of c){let g=s[m.name];if(g.name in o){let x=o[g.name];delete o[g.name];for(let y of x)i(g,y)}}let p=[],d=[],f=t.inputLayers;for(let m of f){let g=m[0],x=m[1],y=m[2];ul(g in s);let A=s[g].inboundNodes[x].outputTensors;p.push(A[y])}let h=t.outputLayers;for(let m of h){let g=m[0],x=m[1],y=m[2];ul(g in s);let A=s[g].inboundNodes[x].outputTensors;d.push(A[y])}return new e({inputs:p,outputs:d,name:u})}get stateful(){if(this._stateful)throw new pe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ce(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function q1e(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let s=[];return t.forEach(o=>{o in e?s.push(e[o]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function vz(e,t){return q1e(e,t,"classWeight")}async function wz(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){let s=ce(()=>{if(e.shape.length===1)return mi(e);if(e.shape.length===2){if(e.shape[1]>1)return xi(e,1);if(e.shape[1]===1)return ie(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await s.data());ye(s);let a=[];return o.forEach(i=>{if(n[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(n[i])}),Er(a,"float32")}else return null}function K1e(e,t){return te(e,t)}var X1e=32;function kz(e,t){let n,r,s=t;n=s.xs,r=s.ys,E.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let o=Iz("input",e.inputNames,n),a=Iz("output",e.outputNames,r),i=o[0].shape[0];E.assert(o.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),E.assert(a.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<o.length;l++)E.assert(o[l].shape[0]===i,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${o[l].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);for(let l=0;l<a.length;l++)E.assert(a[l].shape[0]===i,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${a[l].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);return{xs:o,ys:a}}function Iz(e,t,n){if(n instanceof Vt)return[n];if(Array.isArray(n))return E.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let s of t){if(n[s]==null)throw new pe(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function Z1e(e){if(e.length===3)throw new Et("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function Y1e(e,t,n){let r=n.batchesPerEpoch!=null;if(E.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),E.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),E.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),E.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),E.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let s=n.validationData!=null,o,a;if(s)if(Cz(n.validationData))E.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=Z1e(n.validationData);o=g.xs,a=g.ys}let i=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;s?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();let c=uz(n.callbacks,n.yieldEvery),p=n.verbose==null?1:n.verbose,{callbackList:d,history:f}=cz(c,p,n.epochs,null,null,J1e(t,n),null,s,u);d.setModel(e),e.history=f,await d.onTrainBegin(),e.stopTraining_=!1;let h=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;h<n.epochs;){let g={};await d.onEpochBegin(h);let x=0,y=0;for(r||(m=await t.iterator());r?x<n.batchesPerEpoch:!0;){let b=await m.next();if(r&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){let{xs:A,ys:v}=kz(e,b.value),w={};w.batch=y,w.size=A[0].shape[0],await d.onBatchBegin(y,w);let k=[];if(n.classWeight!=null){let T=vz(n.classWeight,e.outputNames);for(let _=0;_<T.length;++_)k.push(await wz(v[_],null,T[_]))}let I=A.concat(v).concat(k),N=i(I);ye(I);for(let T=0;T<l.length;++T){let _=l[T],R=N[T];w[_]=R,us(R)}await d.onBatchEnd(y,w),sz(w),y++,x++}if(r?x>=n.batchesPerEpoch:b.done){if(s){let A;Cz(n.validationData)?A=Gn(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):A=Gn(e.evaluate(o,a,{batchSize:n.validationBatchSize==null?X1e:n.validationBatchSize,verbose:0}));for(let v=0;v<e.metricsNames.length;++v)g[`val_${e.metricsNames[v]}`]=A[v]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(h,g),h++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function J1e(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function Cz(e){return typeof e.iterator=="function"}function Q1e(e){return typeof e.next=="function"}async function ebe(e,t,n){n=n||{};let r=n.batches!=null,s=e.testFunction,o=[];if(n.verbose>0)throw new Et("Verbose mode is not implemented yet.");E.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let a=Q1e(t)?t:await t.iterator(),i=0,l=0;for(;r?l<n.batches:!0;){let u=await a.next();if(o=ce(()=>{if(u.value){let{xs:c,ys:p}=kz(e,u.value),d=c.concat(p),f=ce(()=>s(d));if(ye(d),l===0)for(let m=0;m<f.length;++m)o.push(at(0));let h=d[0].shape[0];for(let m=0;m<f.length;++m){let g=f[m],x=o[m];o[m]=ce(()=>Re(o[m],te(h,g))),l>0&&ye(x)}ye(f),i+=h,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){let c=o[u];o[u]=Me(o[u],i),ye(c)}return Ao(o)}function $E(e){E.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Ob(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>oh(r,t,n-t)):oh(e,t,n-t)}function FE(e,t){return ce(()=>e==null?null:Array.isArray(e)?e.map(n=>FE(n,t)):KM(e,t.dtype==="int32"?t:Fe(t,"int32")))}function OE(e,t){let n=[],r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}async function tbe(e,t,n,r,s,o,a,i,l,u,c,p,d,f,h){s==null&&(s=32),o==null&&(o=1),c==null&&(c=!0),d==null&&(d=0);let m=!1;if(l!=null&&u!=null&&(m=!0),h!=null&&(m=!0,f==null))throw new pe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=e.checkNumSamples(n,s,f,"steps_per_epoch"),x;g!=null&&(x=wi(0,g)),a==null&&(a=1);let{callbackList:y,history:b}=cz(i,a,o,d,g,f,s,m,p);y.setModel(e),e.history=b,await y.onTrainBegin(),e.stopTraining_=!1;for(let A=d;A<o;++A){await y.onEpochBegin(A);let v={};if(f!=null)throw new Et("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Et("batch shuffling is not implemneted yet");c&&E.shuffle(x);let w=Er(x),k=OE(g,s);for(let I=0;I<k.length;++I){let N={};if(await y.onBatchBegin(I,N),ce(()=>{let T=k[I][0],_=k[I][1],R=oh(w,T,_-T);N.batch=I,N.size=_-T;let S=FE(n,R),F=t(S);for(let B=0;B<r.length;++B){let W=r[B],q=F[B];N[W]=q,us(q)}if(I===k.length-1&&m){let B=e.testLoop(l,u,s);for(let W=0;W<r.length;++W){let q=r[W],K=B[W];us(K),v["val_"+q]=K}}}),await y.onBatchEnd(I,N),sz(N),e.stopTraining_)break}w.dispose()}if(await y.onEpochEnd(A,v),e.stopTraining_)break}return await y.onTrainEnd(),await e.history.syncData(),e.history}async function nbe(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;let s,o,a,i,l,u,c;try{let p=r.batchSize==null?32:r.batchSize;$E(p);let d=!1,f=await e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,d,p);s=f[0],o=f[1],c=f[2];let h=!1,m;if(r.validationData!=null&&r.validationData.length>0){if(h=!0,r.validationData.length===2)a=r.validationData[0],i=r.validationData[1];else throw r.validationData.length===3?new Et("validationData including sample weights is not supported yet."):new pe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);let k=!0,I=await e.standardizeUserData(a,i,null,null,k,p);l=I[0],u=I[1],m=l.concat(u)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){h=!0;let k=Math.floor(s[0].shape[0]*(1-r.validationSplit)),I=s[0].shape[0];l=Ob(s,k,I),s=Ob(s,0,k),u=Ob(o,k,I),o=Ob(o,0,k),m=l.concat(u)}else r.validationSteps!=null&&(h=!0);let g=s.concat(o).concat(c);e.checkTrainableWeightsConsistency();let x=e.makeTrainFunction(),y=e.getDedupedMetricsNames(),b,A;h?(e.makeTestFunction(),b=e.testFunction,A=y.slice().concat(y.map(k=>"val_"+k))):(b=null,m=[],A=y.slice());let v=uz(r.callbacks,r.yieldEvery);return await tbe(e,x,g,y,p,r.epochs,r.verbose,v,b,m,r.shuffle,A,r.initialEpoch,null,null)}finally{e.isTraining=!1,lh(s,t),lh(o,n),lh(l,a),lh(u,i),c!=null&&ye(c)}}function Sz(e){let t=[];e instanceof Vt&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(_b(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function lh(e,t){if(e==null)return;let n=[];if(t instanceof Vt)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(let s in t){let o=t[s];n.push(o.id)}let r=[];if(e instanceof Vt)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(let s in e){let o=e[s];n.indexOf(o.id)===-1&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function rbe(e){return e instanceof Vt}function PE(e){return Array.isArray(e)}function Nz(e){return!rbe(e)&&!PE(e)}function Tz(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let a=!1;if(PE(e)&&e.length>0)a=!0;else if(Nz(e)){for(let i in e)if(e.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new pe(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(a=>null);let o;if(Nz(e)){e=e,o=[];for(let a of t){if(e[a]==null)throw new pe(`No data provided for "${a}". Need data for each key in: ${t}`);o.push(e[a])}}else if(PE(e)){if(e=e,e.length!==t.length)throw new pe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);o=e}else{if(e=e,t.length>1)throw new pe(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);o=[e]}if(o=Sz(o),n!=null)for(let a=0;a<t.length;++a){if(n[a]==null)continue;let i=o[a];if(i.shape.length!==n[a].length)throw new pe(`Error when checking ${s}: expected ${t[a]} to have ${n[a].length} dimension(s). but got array with shape ${i.shape}`);for(let l=0;l<n[a].length;++l){if(l===0&&!r)continue;let u=i.shape[l],c=n[a][l];if(c!=null&&c>=0&&u!==c)throw new pe(`${s} expected a batch of elements where each example has shape [${n[a].slice(1,n[a].length)}] (i.e.,tensor shape [*,${n[a].slice(1,n[a].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return o}function sbe(e,t,n){let r=qc(e.map(o=>o.shape[0]));r.sort();let s=qc(t.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new pe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(o=>o.shape))}`);if(s.length>1)throw new pe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!E.arraysEqual(r,s))throw new pe(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function obe(e,t,n){let r=[ah,t5,Db];for(let s=0;s<e.length;++s){let o=e[s],a=t[s],i=n[s];if(a!=null){if(a===Db&&o.shape[o.shape.length-1]===1)throw new pe(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(a)!==-1){let l=o.shape.slice(1),u=i.slice(1);for(let c=0;c<l.length;++c){let p=l[c],d=u[c];if(d!=null&&p!==d)throw new pe(`A target Tensor with shape ${o.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function _z(e,t,n,r=!0,s=""){let o;if(Array.isArray(e)){if(e.length!==t.length)throw new pe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);o=e}else{if(t.length>1)throw new pe(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);o=[e]}if(n!=null)for(let a=0;a<t.length;++a){if(n[a]==null)continue;let i=o[a];if(i.shape.length!==n[a].length)throw new pe(`Error when checking ${s}: expected ${t[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let l=0;l<n[a].length;++l){if(l===0&&!r)continue;let u=i.shape[l],c=n[a][l];if(c!=null&&c!==u)throw new pe(`Error when checking ${s}: expected ${t[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function abe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let s of t){let o=n.hasOwnProperty(s)?n[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}var ibe="layers-model",ql=class extends pl{constructor(e){super(e);this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new pe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");z1e(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=M1e(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ul))throw new pe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new pe(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(let o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(CE(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new pe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>CE(a))}else{let o=CE(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){let a=this.internalOutputShapes[o],i=this.outputNames[o];this.feedOutputNames.push(i),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],sh("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(n.indexOf(o)!==-1)continue;let a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});let r=abe(e.metrics,this.outputNames),s=(o,a,i)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([i,o])};sh("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(n.indexOf(o)!==-1)continue;let a=r[o];(l=>{let u="",c,p,d;for(let f of l){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){let m=this.internalOutputShapes[o];m[m.length-1]===1||this.lossFunctions[o]===t5?["accuracy","acc"].indexOf(f)!==-1?p=SE:["crossentropy","ce"].indexOf(f)!==-1&&(p=fz):this.lossFunctions[o]===e5?["accuracy","acc"].indexOf(f)!==-1?p=hz:["crossentropy","ce"].indexOf(f)!==-1&&(p=mz):["accuracy","acc"].indexOf(f)!==-1?p=NE:["crossentropy","ce"].indexOf(f)!==-1&&(p=TE);let g;["accuracy","acc"].indexOf(f)!==-1?g="acc":["crossentropy","ce"].indexOf(f)!==-1&&(g="ce"),d=p,c=u+g}else d=P1e(f),c=u+s5(f);let h;sh(c,()=>{h=d}),s(o,c,h)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;$E(r);let s=!0,o=this.standardizeUserDataXY(e,t,s,r);try{let a=o[0].concat(o[1]);this.makeTestFunction();let i=this.testFunction,l=this.testLoop(i,a,r,n.verbose,n.steps);return Ao(l)}finally{lh(o[0],e),lh(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),ebe(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(n!=null){if(s=null,t!=null)throw new pe(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new pe(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new pe("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),o=new ih;if(e instanceof Vt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new pe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let i=0;i<this.inputs.length;++i)o.add(this.inputs[i],e[i])}else for(let i of this.inputs){let l=e[i.name];if(l==null)throw new pe(`No value is provided for the model's input ${i.name}`);o.add(i,l)}let a=Fb(s,o);return n?a:a[0]}retrieveSymbolicTensors(e){let t=th(null,e.length),n=e.length;for(let r of this.layers){let s=Array.isArray(r.output)?r.output:[r.output],o=s.map(a=>a.name);for(let a=0;a<e.length;++a){let i=o.indexOf(e[a]);if(i!==-1&&(t[a]=s[i],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((s,o)=>{s==null&&r.push(e[o])}),new pe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return ce(()=>{let r=this.checkNumSamples(e);if(n)throw new Et("Verbose predictLoop() is not implemented yet.");let s=OE(r,t),o=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)ce(()=>{let l=s[a][0],u=s[a][1],c=Ob(e,l,u),p=[];if(Array.isArray(c))for(let f=0;f<c.length;++f)p.push({key:this.inputs[f],value:c[f]});else p.push({key:this.inputs[0],value:c});let d=new ih(p);return Fb(this.outputs,d)}).forEach((l,u)=>o[u].push(l));return Ao(o.map(a=>En(a,0)))})}predict(e,t={}){let n=Sz(e);_z(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return $E(r),this.predictLoop(n,r)}finally{lh(n,e)}}predictOnBatch(e){_z(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new vi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let o=0;o<this.feedOutputShapes.length;++o){let a=this.feedOutputShapes[o];this.feedLossFns[o]===e5?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(e=Tz(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Tz(t,this.feedOutputNames,s,!1,"target"),sbe(e,t,null),obe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!=0)throw new pe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,o){let[a,i]=this.standardizeUserDataXY(e,t,s,o);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let u=vz(r,this.outputNames);l=[];for(let c=0;c<u.length;++c)l.push(await wz(i[c],null,u[c]))}return[a,i,l]}testLoop(e,t,n,r=0,s){return ce(()=>{let o=this.checkNumSamples(t,n,s,"steps"),a=[];if(r>0)throw new Et("Verbose mode is not implemented yet.");if(s!=null)throw new Et("steps mode in testLoop() is not implemented yet");{let i=OE(o,n),l=Er(wi(0,o));for(let u=0;u<i.length;++u){let c=i[u][0],p=i[u][1],d=oh(l,c,p-c),f=FE(t,d),h=e(f);if(u===0)for(let m=0;m<h.length;++m)a.push(at(0));for(let m=0;m<h.length;++m){let g=h[m];a[m]=Re(a[m],te(p-c,g))}}for(let u=0;u<a.length;++u)a[u]=Me(a[u],o)}return a})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],s=r;PM(e,r)>1&&(s+=`_${PM(e.slice(0,n),r)}`),t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{let c=[];for(let h=0;h<this.inputs.length;++h)c.push({key:this.inputs[h],value:n[h]});let p=new ih(c),d=Fb(this.outputs,p,{training:!0}),f;for(let h=0;h<this.lossFunctions.length;++h){let g=this.lossFunctions[h](r[h],d[h]);s[h]!=null&&(g=K1e(g,s[h]));let x=cr(g);t.push(x),h===0?f=g:f=Re(f,g)}for(let h=0;h<this.metricsTensors.length;++h){let m;if(this.outputs.length>1&&h<this.outputs.length)m=t[h];else{let g=this.metricsTensors[h][0],x=this.metricsTensors[h][1];m=cr(g(r[x],d[x]))}us(m),o.push(m)}return f=cr(f),this.calculateLosses().forEach(h=>{f=Re(f,h)}),f},i=this.collectedTrainableWeights.map(c=>c.read()),l=!0;return[this.optimizer_.minimize(a,l,i)].concat(o)}}makeTestFunction(){this.testFunction=e=>ce(()=>{let t=[],n,r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let l=0;l<this.inputs.length;++l)o.push({key:this.inputs[l],value:r[l]});let a=new ih(o),i=Fb(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],c=cr(u(s[l],i[l]));l===0?n=c:n=Re(n,c),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],c=this.metricsTensors[l][1],p=cr(u(s[c],i[c]));t.push(p)}return t})}async fit(e,t,n={}){return nbe(this,e,t,n)}async fitDataset(e,t){return Y1e(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(let l of a){let u=await l.data();i.push(u[0])}return ye(a),Ao(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let o=0;o<r.length;++o)n&&!r[o].trainable||t.push({name:r[o].originalName,tensor:s[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Kw().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Kw().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Hl(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Hl(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=Hl(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Hl(s5(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Hl(s5(e)));{let e={};for(let t in this.metrics)e[t]=Hl(s5(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=$b(e.optimizer_config),n=Ci(t),r;if(typeof e.loss=="string")r=nh(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>nh(o));else if(e.loss!=null){r={};for(let o in e.loss)r[o]=nh(e.loss[o])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(o=>nh(o));else if(e.metrics!=null){s={};for(let o in e.metrics)s[o]=nh(e.metrics[o])}this.compile({loss:r,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let l=go.getSaveHandlers(e);if(l.length===0)throw new pe(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new pe(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new pe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await go.encodeWeights(this.getNamedWeights(t)),r=!1,s=null,a={modelTopology:this.toJSON(s,r),format:ibe,generatedBy:`TensorFlow.js tfjs-layers v${RE}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:u,specs:c}=await go.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...c),n.data=go.concatenateArrayBuffers([n.data,u])}if(this.userDefinedMetadata!=null){let l=!0;xz(this.userDefinedMetadata,this.name,l),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){xz(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};ql.className="Model";De.registerClass(ql);var Ez=class extends ql{};Ez.className="Functional";De.registerClass(Ez);async function lbe(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=$b(n),s=Ci(r,t);if(e.weightsManifest!=null){let o=await go.loadWeights(e.weightsManifest,e.pathPrefix,s.weights.map(i=>i.originalName)),a={};for(let i of s.weights)a[i.originalName]=o[i.originalName];s.loadWeights(a),ye(o)}return s}async function ube(e,t){if(t==null&&(t={}),typeof e=="string"){let n=go.getLoadHandlers(e,t);if(n.length===0)n.push(go.browserHTTPRequest(e,t));else if(n.length>1)throw new pe(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return cbe(e,void 0,t)}async function cbe(e,t,n){if(n==null&&(n={}),e.load==null)throw new pe("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),s=r.modelTopology;s.model_config!=null&&(s=s.model_config);let o=n.strict==null?!0:n.strict,a=r.weightData!=null&&r.weightSpecs!=null&&o,i=Ci($b(s),t,a),l=r.trainingConfig;if(l!=null&&i.loadTrainingConfig(l),r.userDefinedMetadata!=null&&i.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new pe("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:c}=pbe(r.weightData,r.weightSpecs);i.loadWeights(u,o),i.optimizer!=null&&c.length>0&&await i.optimizer.setWeights(c),ye(u),ye(c.map(p=>p.tensor))}return i}function pbe(e,t){let n=go.decodeWeights(e,t),r={},s=[];return t.forEach(o=>{o.group==="optimizer"?s.push({name:o.name,tensor:n[o.name]}):r[o.name]=n[o.name]}),{modelWeights:r,optimizerWeights:s}}var M0=class extends ql{constructor(e){super({inputs:[],outputs:[]});if(e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Kk("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new pe(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof M0||e instanceof ql,n;if(t){if(n=e,n.outputs.length!==1)throw new pe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new pe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new pe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=rz({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new pe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new pe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=nz(this.outputs[0])}this.inboundNodes=[],new Yk({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:th(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(kn(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ql({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new vi("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new pe("Legacy serialization format not supported yet.");s=t}else E.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,o=t;let a=new e(o);if(!(a instanceof M0))throw new Et(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(let i of s){let u=Ci(i,void 0,r);r&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new pe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new pe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};M0.className="Sequential";De.registerClass(M0);function dbe(e){return new ql(e)}function fbe(e){return new M0(e)}function hbe(e,t){return t==null&&(t={}),ube(e,t)}function Rz(e){return rz(e)}function mbe(e,t){Ma.registerCallbackConstructor(e,t)}var wo=class extends De.Serializable{getConfig(){return{}}},Dz=class extends wo{apply(e,t=1){return Vye(e,t)}};Dz.className="elu";De.registerClass(Dz);var $z=class extends wo{apply(e){return hk(e)}};$z.className="selu";De.registerClass($z);var Fz=class extends wo{apply(e){return yi(e)}};Fz.className="relu";De.registerClass(Fz);var Oz=class extends wo{apply(e){return ce(()=>S0(6,yi(e)))}};Oz.className="relu6";De.registerClass(Oz);var Pz=class extends wo{apply(e){return e}};Pz.className="linear";De.registerClass(Pz);var Mz=class extends wo{apply(e){return xo(e)}};Mz.className="sigmoid";De.registerClass(Mz);var zz=class extends wo{apply(e){return Gye(e)}};zz.className="hardSigmoid";De.registerClass(zz);var Lz=class extends wo{apply(e){return Xf(e)}};Lz.className="softplus";De.registerClass(Lz);var Bz=class extends wo{apply(e){return Wye(e)}};Bz.className="softsign";De.registerClass(Bz);var Vz=class extends wo{apply(e){return Hf(e)}};Vz.className="tanh";De.registerClass(Vz);var ME=class extends wo{apply(e,t=-1){return Jf(e,t)}};ME.className="softmax";De.registerClass(ME);var Wz=class extends wo{apply(e,t=-1){return ik(e,t)}};Wz.className="logSoftmax";De.registerClass(Wz);var Gz=class extends wo{apply(e,t=1){return ce(()=>te(xo(te(e,t)),e))}};Gz.className="swish";De.registerClass(Gz);var Uz=class extends wo{apply(e){return ce(()=>te(e,Hf(Xf(e))))}};Uz.className="mish";De.registerClass(Uz);function Yc(e){return e.getClassName()}function zE(e,t={}){return Sb(e,De.SerializationMap.getMap().classNameMap,t,"activation")}function Jc(e){if(e==null){let t={};return t.className="linear",t.config={},zE(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},zE(t)}else return e instanceof wo?e:zE(e)}function LE(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var jz=class extends De.Serializable{},Pb=class extends jz{constructor(e){super();LE(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ce(()=>{let t=xr([1]);return this.hasL1&&(t=Re(t,Je(te(this.l1,Tr(e))))),this.hasL2&&(t=Re(t,Je(te(this.l2,Eb(e))))),ie(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Pb.className="L1L2";De.registerClass(Pb);function gbe(e){return LE(e),new Pb({l1:e!=null?e.l1:null,l2:0})}function xbe(e){return LE(e),new Pb({l2:e!=null?e.l2:null,l1:0})}var Hz={l1l2:"L1L2"};function Rn(e){return nE(e)}function qz(e,t={}){return Sb(e,De.SerializationMap.getMap().classNameMap,t,"regularizer")}function nr(e){if(e==null)return null;if(typeof e=="string"){let n={className:e in Hz?Hz[e]:e,config:{}};return qz(n)}else return e instanceof jz?e:qz(e)}var BE=class extends Yt{constructor(e){super(e==null?{}:e);this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=$t(e);let n=yi(e);return this.maxValue!=null&&(n=yo(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};BE.className="ReLU";De.registerClass(BE);var VE=class extends Yt{constructor(e){super(e==null?{}:e);this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=$t(e);return fb(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};VE.className="LeakyReLU";De.registerClass(VE);var WE=class extends Yt{constructor(e){super(e==null?{}:e);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=tr(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=nr(e.alphaRegularizer),this.alphaConstraint=Kr(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new pe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=kn(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Rr({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=$t(e),bb(e,this.alpha.read())}getConfig(){let e={alphaInitializer:pr(this.alphaInitializer),alphaRegularizer:Rn(this.alphaRegularizer),alphaConstraint:qr(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};WE.className="PReLU";De.registerClass(WE);var GE=class extends Yt{constructor(e){super(e==null?{}:e);if(this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Et(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=$t(e);return k0(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};GE.className="ELU";De.registerClass(GE);var UE=class extends Yt{constructor(e){super(e==null?{}:e);this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=$t(e);return te(n,Fe(bo(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};UE.className="ThresholdedReLU";De.registerClass(UE);var jE=class extends Yt{constructor(e){super(e==null?{}:e);this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new ME().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=$t(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};jE.className="Softmax";De.registerClass(jE);function z0(e,t,n){if(typeof e=="number")return th(e,t);if(e.length!==t)throw new pe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let s=e[r];if(!Mye(s))throw new pe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Si(e,t,n,r,s=1){if(e==null)return e;let o=t+(t-1)*(s-1),a;return n==="same"?a=e:a=e-o+1,Math.floor((a+r-1)/r)}function dl(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Xc([n-t,0]);else if(r==="same")e=e*t;else throw new pe(`Unsupport padding mode: ${r}.`);return e}function HE(e,t){return ce(()=>(Ir(t),t==="channelsFirst"?Kt(e,[0,2,3,1]):e))}function Kz(e,t){return ce(()=>(Ir(t),t==="channelsFirst"?Kt(e,[0,2,3,4,1]):e))}function ybe(e,t,n,r=1,s="valid",o,a=1){return ce(()=>{if(o==null&&(o=Ai()),Ir(o),e.shape.length!==3)throw new pe(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new pe(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new pe(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(o==="channelsFirst"&&(e=Kt(e,[0,2,1])),s==="causal")throw new Et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=ek(e,t,r,s==="same"?"same":"valid","NWC",a);return n!=null&&(i=ki(i,n)),i})}function Xz(e,t,n,r=[1,1],s="valid",o,a,i=null){return ce(()=>{if(o==null&&(o=Ai()),Ir(o),e.rank!==3&&e.rank!==4)throw new pe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new pe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=HE(e,o);if(s==="causal")throw new Et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Hc.conv2d({x:l,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:i}),o==="channelsFirst"&&(l=Kt(l,[0,3,1,2])),l})}function bbe(e,t,n,r=[1,1,1],s="valid",o,a){return ce(()=>{if(o==null&&(o=Ai()),Ir(o),e.rank!==4&&e.rank!==5)throw new pe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new pe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let i=Kz(e,o);if(s==="causal")throw new Et("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=k_(i,t,r,s==="same"?"same":"valid","NDHWC",a),n!=null&&(i=ki(i,n)),o==="channelsFirst"&&(i=Kt(i,[0,4,1,2,3])),i})}var qE=class extends Yt{constructor(e,t){super(t);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",qE.verifyArgs(t),this.rank=e,cs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Et(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=z0(t.kernelSize,e,"kernelSize"),this.strides=z0(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,fa(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ir(this.dataFormat),this.activation=Jc(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=tr(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Kr(t.biasConstraint),this.biasRegularizer=nr(t.biasRegularizer),this.activityRegularizer=nr(t.activityRegularizer),this.dilationRate=z0(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new pe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new pe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new pe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ul("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!sE(e.kernelSize,"number",1,3))throw new pe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Yc(this.activation),useBias:this.useBias,biasInitializer:pr(this.biasInitializer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),biasConstraint:qr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Mb=class extends qE{constructor(e,t){super(e,t);this.kernel=null,Mb.verifyArgs(t),this.filters=t.filters,cs(this.filters,"filters"),this.kernelInitializer=tr(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Kr(t.kernelConstraint),this.kernelRegularizer=nr(t.kernelRegularizer)}build(e){e=kn(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new pe(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return ce(()=>{e=$t(e);let n,r=this.bias==null?null:this.bias.read(),s=zM(this.activation.getClassName());if(s!=null&&this.rank===2)n=Xz(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=ybe(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=Xz(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=bbe(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Et("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=kn(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let o=Si(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:pr(this.kernelInitializer),kernelRegularizer:Rn(this.kernelRegularizer),kernelConstraint:qr(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new pe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},zb=class extends Mb{constructor(e){super(2,e);zb.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!sE(e.kernelSize,"number",1,2))throw new pe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};zb.className="Conv2D";De.registerClass(zb);var Lb=class extends Mb{constructor(e){super(3,e);Lb.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new pe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};Lb.className="Conv3D";De.registerClass(Lb);var KE=class extends zb{constructor(e){super(e);if(this.inputSpec=[new Rr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new pe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=kn(e),e.length!==4)throw new pe("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new pe("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Rr({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ce(()=>{let n=$t(e);if(n.shape.length!==4)throw new pe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);let i=r[o],l=r[a],u=this.kernelSize[0],c=this.kernelSize[1],p=this.strides[0],d=this.strides[1],f=dl(i,p,u,this.padding),h=dl(l,d,c,this.padding),m=[s,f,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Kt(n,[0,2,3,1]));let g=tk(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Kt(g,[0,3,1,2])),this.bias!=null&&(g=ki(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=kn(e);let t=e.slice(),n,r,s;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3):(n=3,r=1,s=2);let o=this.kernelSize[0],a=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=dl(t[r],i,o,this.padding),t[s]=dl(t[s],l,a,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};KE.className="Conv2DTranspose";De.registerClass(KE);var XE=class extends Lb{constructor(e){super(e);if(this.inputSpec=[new Rr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new pe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=kn(e),e.length!==5)throw new pe("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new pe("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Rr({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ce(()=>{let n=$t(e);if(n.shape.length!==5)throw new pe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],o,a,i;this.dataFormat==="channelsFirst"?(i=2,o=3,a=4):(i=1,o=2,a=3);let l=r[i],u=r[o],c=r[a],p=this.kernelSize[0],d=this.kernelSize[1],f=this.kernelSize[2],h=this.strides[0],m=this.strides[1],g=this.strides[2],x=dl(l,h,p,this.padding),y=dl(u,m,d,this.padding),b=dl(c,g,f,this.padding),A=[s,x,y,b,this.filters];this.dataFormat!=="channelsLast"&&(n=Kt(n,[0,2,3,4,1]));let v=z9(n,this.kernel.read(),A,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Kt(v,[0,4,1,2,3])),this.bias!==null&&(v=ki(v,this.bias.read(),this.dataFormat)),this.activation!==null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=kn(e);let t=e.slice(),n,r,s,o;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3,o=4):(n=4,r=1,s=2,o=3);let a=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],p=this.strides[2];return t[n]=this.filters,t[r]=dl(t[r],u,a,this.padding),t[s]=dl(t[s],c,i,this.padding),t[o]=dl(t[o],p,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};XE.className="Conv3DTranspose";De.registerClass(XE);var Zz=class extends Mb{constructor(e,t){super(e,t);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new pe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new pe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new pe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=tr(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=nr(t.depthwiseRegularizer),this.depthwiseConstraint=Kr(t.depthwiseConstraint),this.pointwiseInitializer=tr(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=nr(t.pointwiseRegularizer),this.pointwiseConstraint=Kr(t.pointwiseConstraint)}build(e){if(e=kn(e),e.length<this.rank+2)throw new pe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new pe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(n*this.depthMultiplier,this.filters);let o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Rr({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ce(()=>{e=$t(e);let n;if(this.rank===1)throw new Et("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Kt(e,[0,2,3,1])),n=V_(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=ki(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Kt(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=pr(this.depthwiseInitializer),e.pointwiseInitializer=pr(this.pointwiseInitializer),e.depthwiseRegularizer=Rn(this.depthwiseRegularizer),e.pointwiseRegularizer=Rn(this.pointwiseRegularizer),e.depthwiseConstraint=qr(this.depthwiseConstraint),e.pointwiseConstraint=qr(this.pointwiseConstraint),e}};Zz.className="SeparableConv";var ZE=class extends Zz{constructor(e){super(2,e)}};ZE.className="SeparableConv2D";De.registerClass(ZE);var a5=class extends Mb{constructor(e){super(1,e);a5.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!sE(e.kernelSize,"number",1,1))throw new pe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};a5.className="Conv1D";De.registerClass(a5);var YE=class extends Yt{constructor(e){super(e);typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ce(()=>{if(e=$t(e),this.dataFormat==="channelsLast"){let n=zk(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return zk(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=zk(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return zk(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};YE.className="Cropping2D";De.registerClass(YE);var JE=class extends Yt{constructor(e){super(e);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ir(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Fye(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ce(()=>{let n=$t(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Kt(n,[0,2,3,1]);let s=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?ht.resizeNearestNeighbor(n,[s,o]):ht.resizeBilinear(n,[s,o]);return Kt(a,[0,3,1,2])}else{let s=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?ht.resizeNearestNeighbor(n,[s,o]):ht.resizeBilinear(n,[s,o])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};JE.className="UpSampling2D";De.registerClass(JE);function Abe(e,t,n=[1,1],r="valid",s,o){return ce(()=>{s==null&&(s=Ai()),Ir(s);let a=HE(e,s);if(e.rank!==4)throw new pe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new pe(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=w0(a,t,n,r==="same"?"same":"valid","NHWC",o),s==="channelsFirst"&&(a=Kt(a,[0,3,1,2])),a})}var QE=class extends qE{constructor(e){super(2,e);this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=tr(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Kr(e.depthwiseConstraint),this.depthwiseRegularizer=nr(e.depthwiseRegularizer)}build(e){if(e=kn(e),e.length<4)throw new pe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new pe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{e=$t(e);let n=Abe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=ki(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=kn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Si(t,this.kernelSize[0],this.padding,this.strides[0]),o=Si(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,s,o]:[e[0],s,o,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=pr(this.depthwiseInitializer),e.depthwiseRegularizer=Rn(this.depthwiseRegularizer),e.depthwiseConstraint=qr(this.depthwiseRegularizer),e}};QE.className="DepthwiseConv2D";De.registerClass(QE);function Yz(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new pe("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(o){return o==null||Array.isArray(o)?o:[o]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function Jz(e,t,n,r=!1,s,o,a=!1,i=!1){return ce(()=>{let l=t.shape.length;if(l<3)throw new pe(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(wi(2,l));if(t=Kt(t,u),o!=null)throw new Et("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=Fe(Fe(s,"bool"),"float32"),s.rank===l-1&&(s=kr(s,-1)),s=Kt(s,u)),r&&(t=jo(t,0),s!=null&&(s=jo(s,0)));let c=[],p,d=n,f=t.shape[0],h=Vs(t),m;s!=null&&(m=Vs(s));for(let x=0;x<f;++x){let y=h[x],b=ce(()=>e(y,d));if(s==null)p=b[0],d=b[1];else{let A=ce(()=>{let v=m[x],w=Ge(Uo(v),v),k=Re(te(b[0],v),te(d[0],w)),I=d.map((N,T)=>Re(te(b[1][T],v),te(N,w)));return{output:k,newStates:I}});p=A.output,d=A.newStates}i&&c.push(p)}let g;return i&&(g=vs(c,1)),[p,g,d]})}var fl=class extends Yt{constructor(e){super(e);let t;if(e.cell==null)throw new pe("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new u5({cells:e.cell}):t=e.cell,t.stateSize==null)throw new pe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Rr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return wi(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){vE(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],r;if(this.returnSequences?r=[e[0],e[1],n]:r=[e[0],n],this.returnState){let s=[];for(let o of t)s.push([e[0],o]);return[r].concat(s)}else return r}computeMask(e,t){return ce(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let r=this.states.map(s=>null);return[n].concat(r)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){let t=null;if(this.numConstants!=null)throw new Et("Constants support is not implemented in RNN yet.");vE(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Rr({shape:[n,null,...r]});let s=[e[0]].concat(e.slice(2));if(t!=null)throw new Et("Constants support is not implemented in RNN yet.");this.cell.build(s);let o;if(Array.isArray(this.cell.stateSize)?o=this.cell.stateSize:o=[this.cell.stateSize],this.stateSpec!=null){if(!E.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),o))throw new pe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(a=>new Rr({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){ce(()=>{if(!this.stateful)throw new jl("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new pe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>xr([n,r])):this.states_=[xr([n,this.cell.stateSize])];else if(e==null)ye(this.states_),this.keptStates!=null&&(ye(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>xr([n,r])):this.states_[0]=xr([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new pe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):ye(this.states_);for(let r=0;r<this.states_.length;++r){let s=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[n,o];if(!E.arraysEqual(s.shape,a))throw new pe(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>us(r.clone()))})}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=Yz(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let o=[],a=[];if(n!=null){t.initialState=n,o=o.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new Rr({shape:l.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(t.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof Ii){let l=[e].concat(o),u=this.inputSpec.concat(a),c=this.inputSpec;this.inputSpec=u;let p=super.apply(l,t);return this.inputSpec=c,p}else return super.apply(e,t)}call(e,t){return ce(()=>{let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;e=$t(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==o)throw new pe(`RNN Layer has ${o} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let a={training:r},l=Jz((f,h)=>{let m=this.cell.call([f].concat(h),a);return[m[0],m.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),u=l[0],c=l[1],p=l[2];this.stateful&&this.resetStates(p,r);let d=this.returnSequences?c:u;return this.returnState?[d].concat(p):d})}getInitialState(e){return ce(()=>{let t=xr(e.shape);return t=Je(t,[1,2]),t=_b(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?dE(t,[1,n]):t):this.cell.stateSize>1?[dE(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===fl.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){let r=t.cell,s=Ci(r,n);return new e(Object.assign(t,{cell:s}))}};fl.className="RNN";De.registerClass(fl);var Bb=class extends Yt{},i5=class extends Bb{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,cs(this.units,"units"),this.activation=Jc(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=tr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=nr(e.kernelRegularizer),this.recurrentRegularizer=nr(e.recurrentRegularizer),this.biasRegularizer=nr(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=$0([1,Xc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=$0([1,Xc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=kn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{if(e=e,e.length!==2)throw new pe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Qc({ones:()=>Uo(e),rate:this.dropout,training:r})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Qc({ones:()=>Uo(n),rate:this.recurrentDropout,training:r}));let s,o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?s=cl(te(e,o),this.kernel.read()):s=cl(e,this.kernel.read()),this.bias!=null&&(s=ki(s,this.bias.read())),a!=null&&(n=te(n,a));let i=Re(s,cl(n,this.recurrentKernel.read()));return this.activation!=null&&(i=this.activation.apply(i)),[i,i]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Yc(this.activation),useBias:this.useBias,kernelInitializer:pr(this.kernelInitializer),recurrentInitializer:pr(this.recurrentInitializer),biasInitializer:pr(this.biasInitializer),kernelRegularizer:Rn(this.kernelRegularizer),recurrentRegularizer:Rn(this.recurrentRegularizer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}};i5.className="SimpleRNNCell";De.registerClass(i5);var e4=class extends fl{constructor(e){e.cell=new i5(e);super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(ye(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ye(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}};e4.className="SimpleRNN";De.registerClass(e4);var l5=class extends Bb{constructor(e){super(e);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new pe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,cs(this.units,"units"),this.activation=Jc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Jc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=tr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=nr(e.kernelRegularizer),this.recurrentRegularizer=nr(e.recurrentRegularizer),this.biasRegularizer=nr(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=$0([1,Xc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=$0([1,Xc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=kn(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{if(e=e,e.length!==2)throw new pe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Qc({ones:()=>Uo(e),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Qc({ones:()=>Uo(r),rate:this.recurrentDropout,training:n,count:3}));let s=this.dropoutMask,o=this.recurrentDropoutMask,a,i,l;0<this.dropout&&this.dropout<1&&(e=te(e,s[0]));let u=cl(e,this.kernel.read());this.useBias&&(u=ki(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=te(r,o[0]));let c=this.recurrentKernel.read(),[p,d]=_r(c,[2*this.units,this.units],c.rank-1),f=cl(r,p),[h,m,g]=_r(u,3,u.rank-1),[x,y]=_r(f,2,f.rank-1);a=this.recurrentActivation.apply(Re(h,x)),i=this.recurrentActivation.apply(Re(m,y));let b=cl(te(i,r),d);l=this.activation.apply(Re(g,b));let A=Re(te(a,r),te(Re(1,er(a)),l));return[A,A]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Yc(this.activation),recurrentActivation:Yc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:pr(this.kernelInitializer),recurrentInitializer:pr(this.recurrentInitializer),biasInitializer:pr(this.biasInitializer),kernelRegularizer:Rn(this.kernelRegularizer),recurrentRegularizer:Rn(this.recurrentRegularizer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}};l5.className="GRUCell";De.registerClass(l5);var t4=class extends fl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new l5(e);super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(ye(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ye(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};t4.className="GRU";De.registerClass(t4);var Vb=class extends Bb{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,cs(this.units,"units"),this.activation=Jc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Jc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=tr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=nr(e.kernelRegularizer),this.recurrentRegularizer=nr(e.recurrentRegularizer),this.biasRegularizer=nr(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=$0([1,Xc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=$0([1,Xc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=kn(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,o=this.units;r=new(t=class extends Pa{apply(i,l){let u=s.apply([o]),c=new Bk().apply([o]),p=s.apply([o*2]);return qM(qM(u,c),p)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ce(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new pe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Qc({ones:()=>Uo(e),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Qc({ones:()=>Uo(r),rate:this.recurrentDropout,training:n,count:4}));let o=this.dropoutMask,a=this.recurrentDropoutMask,i,l,u,c;0<this.dropout&&this.dropout<1&&(e=te(e,o[0]));let p=cl(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=te(r,a[0])),p=Re(p,cl(r,this.recurrentKernel.read())),this.useBias&&(p=ki(p,this.bias.read()));let[d,f,h,m]=_r(p,4,p.rank-1);i=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(f),u=Re(te(l,s),te(i,this.activation.apply(h))),c=this.recurrentActivation.apply(m);let g=te(c,this.activation.apply(u));return[g,g,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Yc(this.activation),recurrentActivation:Yc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:pr(this.kernelInitializer),recurrentInitializer:pr(this.recurrentInitializer),biasInitializer:pr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Rn(this.kernelRegularizer),recurrentRegularizer:Rn(this.recurrentRegularizer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}};Vb.className="LSTMCell";De.registerClass(Vb);var n4=class extends fl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Vb(e);super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(ye(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ye(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};n4.className="LSTM";De.registerClass(n4);var u5=class extends Bb{constructor(e){super(e);this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ce(()=>{e=e;let n=e.slice(1),r=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(n.splice(0,a.stateSize.length)):r.push(n.splice(0,1));r.reverse();let s=[],o;for(let a=0;a<this.cells.length;++a){let i=this.cells[a];n=r[a],a===0?o=[e[0]].concat(n):o=[o[0]].concat(n),o=i.call(o,t),s.push(o.slice(1))}n=[];for(let a of s.slice().reverse())n.push(...a);return[o[0]].concat(n)})}build(e){vE(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{sh(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),r={cells:this.cells.map(t)};return Object.assign({},e,r)}static fromConfig(e,t,n={}){let r=[];for(let s of t.cells)r.push(Ci(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return wE(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,s=e.splice(r);for(let o=0;o<n.weights.length;++o)t.push([n.weights[o],s[o]])}kE(t)}};u5.className="StackedRNNCells";De.registerClass(u5);function Qc(e){let{ones:t,rate:n,training:r=!1,count:s=1}=e,o=()=>XM(t(),n),a=()=>Rb(o,t,r);return!s||s<=1?us(a().clone()):Array(s).fill(void 0).map(a).map(l=>us(l.clone()))}var vbe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n},Qz=class extends fl{constructor(e){if(e.unroll)throw new Et("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Et("It is not possible at the moment to stack convolutional cells.");super(e);this.inputSpec=[new Rr({ndim:5})]}call(e,t){return ce(()=>{if(this.cell.dropoutMask!=null&&(ye(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ye(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new pe("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ce(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],o=xr(s);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){ce(()=>{if(!this.stateful)throw new jl("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(n[0]==null)throw new pe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>xr(s)):this.states_=[xr(s)];else if(e==null)ye(this.states_),this.keptStates!=null&&(ye(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>xr(s)):this.states_[0]=xr(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new pe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):ye(this.states_);for(let a=0;a<this.states_.length;++a){let i=e[a],l=s;if(!E.arraysEqual(i.shape,l))throw new pe(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[a]=i}}this.states_=this.states_.map(a=>us(a.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:o,dilationRate:a}=this.cell,i=t==="channelsFirst",l=e[i?3:2],u=e[i?4:3],c=Si(l,r[0],s,o[0],a[0]),p=Si(u,r[1],s,o[1],a[1]);return[...e.slice(0,2),...i?[n,c,p]:[c,p,n]]}};Qz.className="ConvRNN2D";var c5=class extends Vb{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:o,dilationRate:a}=e;super(Object.assign({},e,{units:t}));this.filters=t,cs(this.filters,"filters"),this.kernelSize=z0(n,2,"kernelSize"),this.kernelSize.forEach(i=>cs(i,"kernelSize")),this.strides=z0(r||1,2,"strides"),this.strides.forEach(i=>cs(i,"strides")),this.padding=s||"valid",fa(this.padding),this.dataFormat=o||"channelsLast",Ir(this.dataFormat),this.dilationRate=z0(a||1,2,"dilationRate"),this.dilationRate.forEach(i=>cs(i,"dilationRate"))}build(e){var t;e=kn(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new pe(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],s=4,o=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let i;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;i=new(t=class extends Pa{apply(p,d){let f=l.apply([u]),h=Go([u]),m=l.apply([u*2]);return pE([f,h,m])}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,i,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ce(()=>{if(e.length!==3)throw new pe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],s=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Qc({ones:()=>Uo(r),rate:this.dropout,training:n,count:a}));let i=this.dropoutMask,l=(J,Q,ee)=>!Q||!Q[ee]?J:te(Q[ee],J),u=l(r,i,0),c=l(r,i,1),p=l(r,i,2),d=l(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Qc({ones:()=>Uo(s),rate:this.recurrentDropout,training:n,count:a}));let f=this.recurrentDropoutMask,h=l(s,f,0),m=l(s,f,1),g=l(s,f,2),x=l(s,f,3),y=3,[b,A,v,w]=_r(this.kernel.read(),a,y),[k,I,N,T]=this.useBias?_r(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,A,I,this.padding),p=this.inputConv(p,v,N,this.padding),d=this.inputConv(d,w,T,this.padding);let[_,R,S,F]=_r(this.recurrentKernel.read(),a,y);h=this.recurrentConv(h,_),m=this.recurrentConv(m,R),g=this.recurrentConv(g,S),x=this.recurrentConv(x,F);let B=this.recurrentActivation.apply(Re(u,h)),W=this.recurrentActivation.apply(Re(c,m)),q=Re(te(W,o),te(B,this.activation.apply(Re(p,g)))),K=te(this.recurrentActivation.apply(Re(d,x)),this.activation.apply(q));return[K,K,q]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=vbe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(e,t,n,r){let s=Bl(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?ki(s,n,this.dataFormat):s}recurrentConv(e,t){return Bl(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};c5.className="ConvLSTM2DCell";De.registerClass(c5);var r4=class extends Qz{constructor(e){let t=new c5(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}};r4.className="ConvLSTM2D";De.registerClass(r4);var p5=class extends Yt{constructor(e){super(e);this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,s=this.getNoiseShape(n);return Rb(()=>XM(n,this.rate,s,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};p5.className="Dropout";De.registerClass(p5);var s4=class extends p5{constructor(e){super(e);this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};s4.className="SpatialDropout1D";De.registerClass(s4);var o4=class extends Yt{constructor(e){super(e);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,cs(this.units,"units"),this.activation=Jc(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=tr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=tr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Kr(e.kernelConstraint),this.biasConstraint=Kr(e.biasConstraint),this.kernelRegularizer=nr(e.kernelRegularizer),this.biasRegularizer=nr(e.biasRegularizer),this.activityRegularizer=nr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=kn(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=kn(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e),r=zM(this.activation.getClassName()),s;return r!=null?s=cl(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=cl(n,this.kernel.read()),this.bias!=null&&(s=ki(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:Yc(this.activation),useBias:this.useBias,kernelInitializer:pr(this.kernelInitializer),biasInitializer:pr(this.biasInitializer),kernelRegularizer:Rn(this.kernelRegularizer),biasRegularizer:Rn(this.biasRegularizer),activityRegularizer:Rn(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),biasConstraint:qr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};o4.className="Dense";De.registerClass(o4);var a4=class extends Yt{constructor(e){e=e||{};super(e);this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=kn(e);for(let t of e.slice(1))if(t==null)throw new pe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Kc(e,1)]}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let s=2;s<n.rank;++s)r.push(s);r.push(1),n=Kt(n,r)}return Bye(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};a4.className="Flatten";De.registerClass(a4);var i4=class extends Yt{constructor(e){super(e);this.supportsMasking=!0,this.activation=Jc(e.activation)}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e);return this.activation.apply(n)})}getConfig(){let e={activation:Yc(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};i4.className="Activation";De.registerClass(i4);var l4=class extends Yt{constructor(e){super(e);this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ce(()=>(e=$t(e),zye(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};l4.className="RepeatVector";De.registerClass(l4);var u4=class extends Yt{constructor(e){super(e);this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),s=1,o=null;for(let i=0;i<r.length;++i){let l=r[i];if(this.isUnknown(l))if(o===null)o=i;else throw new pe("Can only specifiy one unknown dimension.");else s*=l}let a=Kc(e);if(o!==null){if(s===0||a%s!=0)throw new pe(n);r[o]=a/s}else if(a!==s)throw new pe(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ie(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};u4.className="Reshape";De.registerClass(u4);var c4=class extends Yt{constructor(e){super(e);if(e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=wi(1,e.dims.length+1);if(!E.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Rr({ndim:this.dims.length+1})]}computeOutputShape(e){e=kn(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Kt($t(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};c4.className="Permute";De.registerClass(c4);var p4=class extends Yt{constructor(e){super(e==null?{}:e);this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=$t(e),r=-1;return lb(Yf(n,this.maskValue),r)}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e),r=-1,s=!0,o=lb(Yf(n,this.maskValue),r,s);return te(n,Fe(o,n.dtype))})}};p4.className="Masking";De.registerClass(p4);var d4=class extends Yt{constructor(e){super(e);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Gn(e.inputLength))}this.inputDim=e.inputDim,cs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,cs(this.outputDim,"outputDim"),this.embeddingsInitializer=tr(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=nr(e.embeddingsRegularizer),this.activityRegularizer=nr(e.activityRegularizer),this.embeddingsConstraint=Kr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ce(()=>this.maskZero?(e=$t(e),Yf(e,Xt(e))):null)}computeOutputShape(e){if(e=kn(e),this.inputLength==null)return[...e,this.outputDim];let t=Gn(this.inputLength);if(t.length!==e.length-1)throw new pe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let s=t[r],o=e[r+1];if(s!=null&&o!=null&&s!==o)throw new pe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=o),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e);n.dtype!=="int32"&&(n=Mk(n,"int32"));let r=KM(this.embeddings.read(),ie(n,[n.size]));return ie(r,kn(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:pr(this.embeddingsInitializer),embeddingsRegularizer:Rn(this.embeddingsRegularizer),activityRegularizer:Rn(this.activityRegularizer),embeddingsConstraint:qr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};d4.className="Embedding";De.registerClass(d4);var uh=class extends Yt{constructor(e){super(e||{});this.supportsMasking=!0}mergeFunction(e){throw new Et}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let s=e[e.length-t.length+r],o=t[r];if(s==null||o==null||s<0||o<0)n.push(null);else if(s===1)n.push(o);else if(o===1)n.push(s);else{if(s!==o)throw new pe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[kn(e)]),e=e,e.length<2)throw new pe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=qc(t),t.length>1)throw new pe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let o=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,o)}let r=e.map(s=>s.length);e.indexOf(null)===-1&&qc(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ce(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(s=>s.rank);if(r.indexOf(null)===-1){let s=Xc(r);for(let o of e){let a=o.rank;for(let i=0;i<s-a;++i)o=_b(o,1);n.push(o)}return this.mergeFunction(n)}else{let s=!1;for(let i of e){let l=i.rank;if(l==null){let u=i.shape,c=u[0],p=u.slice(1).concat([c]),d=ie(i,[c].concat(Kc(u.slice(1))));d=Kt(d,[1,0]),d=ie(d,p),n.push(d),s=!0}else if(l>1){let u=wi(1,l).concat([0]);n.push(Kt(i,u)),s=!0}else n.push(i)}let o=this.mergeFunction(n),a=o.rank;if(s){if(a==null){let i=o.shape,l=i.length,u=i[l-1],c=[u].concat(i.slice(0,i.length-1));o=ie(Kt(ie(o,[-1,u]),[1,0]),c)}else if(a>1){let i=[a-1].concat(wi(0,a-1));o=Kt(o,i)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=qc(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return ce(()=>{if(t==null)return null;if(!Array.isArray(t))throw new pe("`mask` should be an Array");if(!Array.isArray(e))throw new pe("`inputs` should be an Array");if(t.length!==e.length)throw new pe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:kr(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=Fa(n,t[r]);return n})}},f4=class extends uh{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Re(t,e[n]);return t})}};f4.className="Add";De.registerClass(f4);var h4=class extends uh{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=te(t,e[n]);return t})}};h4.className="Multiply";De.registerClass(h4);var m4=class extends uh{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Re(t,e[n]);return te(1/e.length,t)})}};m4.className="Average";De.registerClass(m4);var g4=class extends uh{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=il(t,e[n]);return t})}};g4.className="Maximum";De.registerClass(g4);var x4=class extends uh{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=S0(t,e[n]);return t})}};x4.className="Minimum";De.registerClass(x4);var y4=class extends uh{constructor(e){super(e);this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new pe("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let s=e[r].slice();s.splice(this.axis,1);let o=!1;for(let a of n)if(E.arraysEqual(a,s)){o=!0;break}o||n.push(s)}if(n.length>1)throw new pe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ce(()=>pE(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new pe("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[r]==null||s[r]==null){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new pe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new pe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new pe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ce(()=>{let n=!0;if(t.forEach(o=>{if(o!=null){n=!1;return}}),n)return null;let r=[];for(let o=0;o<e.length;++o)t[o]==null?r.push(Fe(Uo(e[o]),"bool")):t[o].rank<e[o].rank?r.push(kr(t[o],-1)):r.push(t[o]);let s=En(r,this.axis);return Jw(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};y4.className="Concatenate";De.registerClass(y4);function Wb(e,t){for(;e<0;)e+=t;return e}function wbe(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Et("batchDot is not implemented for tensors of 4D or higher rank yet");if(E.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),E.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Et("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);let o=n;return ce(()=>{let a;if(r>s){a=r-s;let l=[];for(let u=0;u<a;++u)l.push(1);t=ie(t,t.shape.concat(l))}else if(s>r){a=s-r;let l=[];for(let u=0;u<a;++u)l.push(1);e=ie(e,e.shape.concat(l))}else a=0;let i;if(e.shape.length===2&&t.shape.length===2)o[0]===o[1]?i=Je(te(e,t),o[0]):i=Je(te(Kt(e,[1,0]),t),o[1]);else{let l=o[0]!==e.shape.length-1,u=o[1]===t.shape.length-1;i=Lt(e,t,l,u)}if(a>0){let l;r>s?l=r+s-3:l=r-1;let u=[];for(let c=l;c<l+a;++c)u.push(c);i=ln(i,u)}return i.shape.length===1&&(i=kr(i,1)),i})}var b4=class extends uh{constructor(e){super(e);this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){E.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Et("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new pe(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new pe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,o)=>Wb(s,e[o].shape.length)):r=[Wb(this.axes,t.shape.length),Wb(this.axes,n.shape.length)],this.normalize&&(t=Jk(t,r[0]),n=Jk(n,r[1])),wbe(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Wb(this.axes,e.length),Wb(this.axes,t.length)],n}computeOutputShape(e){E.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Et("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};b4.className="Dot";De.registerClass(b4);var A4=class extends Yt{constructor(e){super(e);this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e);return Rb(()=>Re(Lk(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};A4.className="GaussianNoise";De.registerClass(A4);var v4=class extends Yt{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=$t(e);return this.rate>0&&this.rate<1?Rb(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return te(n,Lk(n.shape,1,s))},()=>n,t.training||!1):n})}};v4.className="GaussianDropout";De.registerClass(v4);var w4=class extends Yt{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||$t(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ce(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Rb(()=>{let s=$t(e),o=1.6732632423543772,a=1.0507009873554805,i=-o*a,l=Uc(N0(n),this.rate);l=Mk(l,"float32");let u=((1-this.rate)*(1+this.rate*i**2))**-.5,c=-u*i*this.rate,p=Re(te(s,l),te(Re(l,-1),i));return Re(te(p,u),c)},()=>$t(e),t.training||!1)}return e})}};w4.className="AlphaDropout";De.registerClass(w4);function Gb(e,t,n,r,s,o=.001){let a;if(e.rank===2)a=E9(e,t,n,r,s,o);else if(e.rank===3)a=R9(e,t,n,r,s,o);else if(e.rank===4)a=D9(e,t,n,r,s,o);else throw new Et(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return a}function kbe(e,t,n,r,s=.001){return ce(()=>{let o=uk(e,r),a=o.mean,i=o.variance;return[Gb(e,a,i,n,t,s),a,i]})}function Ibe(e,t,n,r,s=.001){return ce(()=>{let o=uk(e,r),a=o.mean,i=o.variance,l=[];for(let h of wi(0,e.rank))r.indexOf(h)!==-1?l.push(1):l.push(e.shape[h]);let u=ie(a,l),c=ie(i,l),p=t==null?null:ie(t,l),d=n==null?null:ie(n,l);return[Gb(e,u,c,d,p,s),a,i]})}function Cbe(e,t,n,r,s=.001){return E.arraysEqual(r.slice().sort(),wi(0,e.rank-1))?kbe(e,t,n,r,s):Ibe(e,t,n,r,s)}var k4=class extends Yt{constructor(e){e==null&&(e={});super(e);this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=tr(e.betaInitializer||"zeros"),this.gammaInitializer=tr(e.gammaInitializer||"ones"),this.movingMeanInitializer=tr(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=tr(e.movingVarianceInitializer||"ones"),this.betaConstraint=Kr(e.betaConstraint),this.gammaConstraint=Kr(e.gammaConstraint),this.betaRegularizer=nr(e.betaRegularizer),this.gammaRegularizer=nr(e.gammaRegularizer)}build(e){e=kn(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new pe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Rr({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ce(()=>{let n=t.training==null?!1:t.training,r=$t(e),s=r.shape,o=s.length,a=wi(0,o),i=this.axis>=0?this.axis:this.axis+o;a.splice(i,1);let l=th(1,o);l[i]=s[i];let u=a.slice();u.sort();let c=!E.arraysEqual(u,wi(0,o).slice(0,o-1)),p=()=>{if(c){let x=ie(this.movingMean.read(),l),y=ie(this.movingVariance.read(),l),b=this.center?ie(this.beta.read(),l):null,A=this.scale?ie(this.gamma.read(),l):null;return Gb(r,x,y,b,A,this.epsilon)}else return Gb(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return p();let[d,f,h]=Cbe(r,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(x,y,b)=>{ce(()=>{let A=1-b,v=x.read(),w=te(Ge(v,y),A);x.write(Ge(v,w))})};return(()=>{m(this.movingMean,f,this.momentum),m(this.movingVariance,h,this.momentum)})(),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:pr(this.betaInitializer),gammaInitializer:pr(this.gammaInitializer),movingMeanInitializer:pr(this.movingMeanInitializer),movingVarianceInitializer:pr(this.movingVarianceInitializer),betaRegularizer:Rn(this.betaRegularizer),gammaRegularizer:Rn(this.gammaRegularizer),betaConstraint:qr(this.betaConstraint),gammaConstraint:qr(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};k4.className="BatchNormalization";De.registerClass(k4);var I4=class extends Yt{constructor(e){e==null&&(e={});super(e);if(this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=tr(e.betaInitializer||"zeros"),this.gammaInitializer=tr(e.gammaInitializer||"ones"),this.betaRegularizer=nr(e.betaRegularizer),this.gammaRegularizer=nr(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=kn(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==qc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=$t(e),r=n.shape,s=r.length;return ce(()=>{let o=!0,{mean:a,variance:i}=uk(n,this.axis,o),l=th(1,s);for(let h of this.axis)l[h]=r[h];let u=h=>h!=null&&h.shape.length!==s&&this.axis!==[s-1]?ie(h,l):h,c=u(this.gamma.read()),p=u(this.beta.read()),d=[],f=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(d.push(r[h]),f.push(1)):(d.push(1),f.push(r[h]));return a=da(a,d),i=da(i,d),c=da(c,f),p=da(p,f),Gb(n,a,i,p,c,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:pr(this.betaInitializer),gammaInitializer:pr(this.gammaInitializer),betaRegularizer:Rn(this.betaRegularizer),gammaRegularizer:Rn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};I4.className="LayerNormalization";De.registerClass(I4);function Sbe(e,t,n){return ce(()=>{if(e.rank!==4)throw new pe(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new pe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Ai()),n!=="channelsLast"&&n!=="channelsFirst")throw new pe(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Vl(e,r)})}var C4=class extends Yt{constructor(e){e==null&&(e={});super(e);if(this.dataFormat=e.dataFormat==null?Ai():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new pe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new pe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new pe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Rr({ndim:4})]}computeOutputShape(e){e=kn(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return ce(()=>Sbe($t(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};C4.className="ZeroPadding2D";De.registerClass(C4);function d5(e,t,n,r,s,o){return ce(()=>{Ir(s),WM(o),fa(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=Ai()),o==null&&(o="max"),e=HE(e,s);let a,i=r==="same"?"same":"valid";return o==="max"?a=gb(e,t,n,i):a=cb(e,t,n,i),s==="channelsFirst"&&(a=Kt(a,[0,3,1,2])),a})}function eL(e,t,n,r,s,o){return ce(()=>{Ir(s),WM(o),fa(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=Ai()),o==null&&(o="max"),e=Kz(e,s);let a,i=r==="same"?"same":"valid";return o==="max"?a=O_(e,t,n,i):a=b_(e,t,n,i),s==="channelsFirst"&&(a=Kt(a,[0,4,1,2,3])),a})}var tL=class extends Yt{constructor(e){e.poolSize==null&&(e.poolSize=2);super(e);if(typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new pe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(cs(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new pe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);cs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,fa(this.padding),this.inputSpec=[new Rr({ndim:3})]}computeOutputShape(e){e=kn(e);let t=Si(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ce(()=>{this.invokeCallHook(e,t),e=_b($t(e),2);let n=this.poolingFunction($t(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ln(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},S4=class extends tL{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ir(s),fa(r),d5(e,t,n,r,s,"max")}};S4.className="MaxPooling1D";De.registerClass(S4);var N4=class extends tL{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ir(s),fa(r),d5(e,t,n,r,s,"avg")}};N4.className="AveragePooling1D";De.registerClass(N4);var nL=class extends Yt{constructor(e){e.poolSize==null&&(e.poolSize=[2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new pe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];cs(this.poolSize,"poolSize"),cs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ir(this.dataFormat),fa(this.padding),this.inputSpec=[new Rr({ndim:4})]}computeOutputShape(e){e=kn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Si(t,this.poolSize[0],this.padding,this.strides[0]),n=Si(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ce(()=>(this.invokeCallHook(e,t),this.poolingFunction($t(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},T4=class extends nL{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ir(s),fa(r),d5(e,t,n,r,s,"max")}};T4.className="MaxPooling2D";De.registerClass(T4);var _4=class extends nL{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ir(s),fa(r),d5(e,t,n,r,s,"avg")}};_4.className="AveragePooling2D";De.registerClass(_4);var rL=class extends Yt{constructor(e){e.poolSize==null&&(e.poolSize=[2,2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new pe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];cs(this.poolSize,"poolSize"),cs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ir(this.dataFormat),fa(this.padding),this.inputSpec=[new Rr({ndim:5})]}computeOutputShape(e){e=kn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Si(t,this.poolSize[0],this.padding,this.strides[0]),n=Si(n,this.poolSize[1],this.padding,this.strides[1]),r=Si(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return ce(()=>(this.invokeCallHook(e,t),this.poolingFunction($t(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},E4=class extends rL{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ir(s),fa(r),eL(e,t,n,r,s,"max")}};E4.className="MaxPooling3D";De.registerClass(E4);var R4=class extends rL{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ir(s),fa(r),eL(e,t,n,r,s,"avg")}};R4.className="AveragePooling3D";De.registerClass(R4);var sL=class extends Yt{constructor(e){super(e);this.inputSpec=[new Rr({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Et}},D4=class extends sL{constructor(e){super(e||{})}call(e,t){return ce(()=>{let n=$t(e);return cr(n,1)})}};D4.className="GlobalAveragePooling1D";De.registerClass(D4);var $4=class extends sL{constructor(e){super(e||{})}call(e,t){return ce(()=>{let n=$t(e);return Wo(n,1)})}};$4.className="GlobalMaxPooling1D";De.registerClass($4);var oL=class extends Yt{constructor(e){super(e);this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ir(this.dataFormat),this.inputSpec=[new Rr({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Et}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},F4=class extends oL{call(e,t){return ce(()=>{let n=$t(e);return this.dataFormat==="channelsLast"?cr(n,[1,2]):cr(n,[2,3])})}};F4.className="GlobalAveragePooling2D";De.registerClass(F4);var O4=class extends oL{call(e,t){return ce(()=>{let n=$t(e);return this.dataFormat==="channelsLast"?Wo(n,[1,2]):Wo(n,[2,3])})}};O4.className="GlobalMaxPooling2D";De.registerClass(O4);var aL=class extends Yt{constructor(e){super(e);this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,s=Ci(r,n);delete t.layer;let o={layer:s};return Object.assign(o,t),new e(o)}},P4=class extends aL{constructor(e){super(e);this.supportsMasking=!0}build(e){if(e=kn(e),e.length<3)throw new pe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=kn(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return ce(()=>(e=$t(e),Jz((o,a)=>[$t(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};P4.className="TimeDistributed";De.registerClass(P4);function Nbe(e){rh($ye,"BidirectionalMergeMode",e)}var Tbe="concat",M4=class extends aL{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ci(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Ci(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Tbe:e.mergeMode,Nbe(this.mergeMode),e.weights)throw new Et("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Ao(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=Yz(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let o=[],a=[];if(n!=null){let l=n.length;if(l%2>0)throw new pe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,o.push(...n);let u=n.map(c=>new Rr({shape:c.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),a.push(...u)}if(r!=null)throw new Et("Support for constants in Bidirectional layers is not implemented yet.");let i=o[0]instanceof Ii;for(let l of o)if(l instanceof Ii!==i)throw new pe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){let l=[e].concat(o),u=this.inputSpec.concat(a),c=this.inputSpec;this.inputSpec=u;let p=super.apply(l,t);return this.inputSpec=c,p}else return super.apply(e,t)}call(e,t){return ce(()=>{let n=t.initialState,r,s;if(n==null)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let i=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:i})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=jo(s,1));let a;return this.mergeMode==="concat"?a=pE([r,s]):this.mergeMode==="sum"?a=Re(r,s):this.mergeMode==="ave"?a=te(.5,Re(r,s)):this.mergeMode==="mul"?a=te(r,s):this.mergeMode==null&&(a=[r,s]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){sh(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),sh(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(o=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Ci(t.layer);if(delete t.layer,t.numConstants!=null)throw new Et("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};M4.className="Bidirectional";De.registerClass(M4);function _be(e){return new F0(e)}function Ebe(e){return new GE(e)}function Rbe(e){return new BE(e)}function Dbe(e){return new VE(e)}function $be(e){return new WE(e)}function Fbe(e){return new jE(e)}function Obe(e){return new UE(e)}function Pbe(e){return new a5(e)}function Mbe(e){return new zb(e)}function zbe(e){return new KE(e)}function Lbe(e){return new Lb(e)}function Bbe(e){return new XE(e)}function Vbe(e){return new ZE(e)}function Wbe(e){return new YE(e)}function Gbe(e){return new JE(e)}function Ube(e){return new QE(e)}function jbe(e){return new i4(e)}function Hbe(e){return new o4(e)}function qbe(e){return new p5(e)}function Kbe(e){return new s4(e)}function Xbe(e){return new a4(e)}function Zbe(e){return new l4(e)}function Ybe(e){return new u4(e)}function Jbe(e){return new c4(e)}function Qbe(e){return new d4(e)}function eAe(e){return new f4(e)}function tAe(e){return new m4(e)}function nAe(e){return new y4(e)}function rAe(e){return new g4(e)}function sAe(e){return new x4(e)}function oAe(e){return new h4(e)}function aAe(e){return new b4(e)}function iAe(e){return new k4(e)}function lAe(e){return new I4(e)}function uAe(e){return new C4(e)}function z4(e){return new N4(e)}function cAe(e){return z4(e)}function pAe(e){return z4(e)}function L4(e){return new _4(e)}function dAe(e){return L4(e)}function fAe(e){return L4(e)}function B4(e){return new R4(e)}function hAe(e){return B4(e)}function mAe(e){return B4(e)}function gAe(e){return new D4(e)}function xAe(e){return new F4(e)}function iL(e){return new $4(e)}function lL(e){return new O4(e)}function uL(e){return new S4(e)}function cL(e){return new T4(e)}function yAe(e){return new E4(e)}function bAe(e){return new t4(e)}function AAe(e){return new l5(e)}function vAe(e){return new n4(e)}function wAe(e){return new Vb(e)}function kAe(e){return new e4(e)}function IAe(e){return new i5(e)}function CAe(e){return new r4(e)}function SAe(e){return new c5(e)}function NAe(e){return new fl(e)}function TAe(e){return new u5(e)}function _Ae(e){return new M4(e)}function EAe(e){return new P4(e)}var RAe=iL,DAe=lL,$Ae=uL,FAe=cL;function OAe(e){return new A4(e)}function PAe(e){return new v4(e)}function MAe(e){return new w4(e)}function zAe(e){return new p4(e)}var pL={};Rt(pL,{MAPE:()=>XAe,MSE:()=>JAe,binaryAccuracy:()=>LAe,binaryCrossentropy:()=>BAe,categoricalAccuracy:()=>WAe,categoricalCrossentropy:()=>GAe,cosineProximity:()=>HAe,mape:()=>ZAe,meanAbsoluteError:()=>qAe,meanAbsolutePercentageError:()=>KAe,meanSquaredError:()=>YAe,mse:()=>QAe,precision:()=>UAe,recall:()=>jAe,sparseCategoricalAccuracy:()=>VAe});function LAe(e,t){return SE(e,t)}function BAe(e,t){return fz(e,t)}function VAe(e,t){return hz(e,t)}function WAe(e,t){return NE(e,t)}function GAe(e,t){return TE(e,t)}function UAe(e,t){return dz(e,t)}function jAe(e,t){return T1e(e,t)}function HAe(e,t){return IE(e,t)}function qAe(e,t){return Qk(e,t)}function KAe(e,t){return P0(e,t)}function XAe(e,t){return P0(e,t)}function ZAe(e,t){return P0(e,t)}function YAe(e,t){return ah(e,t)}function JAe(e,t){return ah(e,t)}function QAe(e,t){return ah(e,t)}var dL={};Rt(dL,{modelFromJSON:()=>lbe});var fL={};Rt(fL,{l1:()=>t2e,l1l2:()=>e2e,l2:()=>n2e});function e2e(e){return new Pb(e)}function t2e(e){return gbe(e)}function n2e(e){return xbe(e)}var hL=class extends O0{constructor(){super(...arguments);this.model=null}setModel(e){if(!(e instanceof ql))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function f5(e,t){return e<t}function mL(e,t){return e>t}var gL=class extends hL{constructor(e){super();if(e==null&&(e={}),e.restoreBestWeights)throw new Et("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=f5:this.mode==="max"?this.monitorFunc=mL:this.monitor.indexOf("acc")!==-1?this.monitorFunc=mL:this.monitorFunc=f5,this.monitorFunc===f5&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===f5?1/0:-1/0}async onEpochEnd(e,t){await Zc(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function r2e(e){return new gL(e)}var s2e={earlyStopping:r2e},Ni;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(Ni||(Ni={}));var xL;(function(e){let t;(function(n){n[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(xL||(xL={}));var V4={};function o2e(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};V4[e]=n}function yL(e){return V4[e]}function a2e(e){delete V4[e]}function $(e,t,n,r,s){let o=t.inputParams[e];if(o&&o.inputIndexStart!==void 0){let i=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?i+1:o.inputIndexEnd;if(o.type==="tensor")return Gs(t.inputNames[o.inputIndexStart],n,r,s);if(o.type==="tensors")return t.inputNames.slice(i,l).map(d=>Gs(d,n,r,s));let u=Gs(t.inputNames.slice(i)[0],n,r,s),c=u.dataSync();return o.type==="number"?c[0]:E.toNestedArray(u.shape,c)}let a=t.attrParams[e];return a&&a.value}function Gs(e,t,n,r){let[s,o]=Ho(e);if(r!=null){let i=r.getHashTableHandleByName(s);if(i!=null)return i}let a=n.currentContextIds.find(i=>!!t[h5(s,i)]);return a!==void 0?t[h5(s,a)][o]:void 0}function i2e(e,t,n){return t[h5(e,n.currentContextId)]}function Kl(e,t){let[n,r,s]=Ho(e);return[h5(n,t&&t.currentContextId),r,s]}function h5(e,t){return t?`${e}-${t}`:e}function Ho(e){let t=e.split(":");if(t.length===1)return[e,0,void 0];let n=t[0],r=t.length===3?t[1]:void 0,s=Number(t[t.length-1]);return[n,s,r]}function m5(e,t,n){let r=$("pad",e,t,n);if(r==="explicit"){r=$("explicitPaddings",e,t,n);let s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function Xl(e){return e.kept?e:mi(e)}var bL={};Rt(bL,{json:()=>l2e});var l2e=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],AL={};Rt(AL,{json:()=>u2e});var u2e=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],vL={};Rt(vL,{json:()=>c2e});var c2e=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],wL={};Rt(wL,{json:()=>p2e});var p2e=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],kL={};Rt(kL,{json:()=>d2e});var d2e=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],IL={};Rt(IL,{json:()=>f2e});var f2e=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],CL={};Rt(CL,{json:()=>h2e});var h2e=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],SL={};Rt(SL,{json:()=>m2e});var m2e=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],NL={};Rt(NL,{json:()=>g2e});var g2e=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],TL={};Rt(TL,{json:()=>x2e});var x2e=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],_L={};Rt(_L,{json:()=>y2e});var y2e=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],EL={};Rt(EL,{json:()=>b2e});var b2e=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],RL={};Rt(RL,{json:()=>A2e});var A2e=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],DL={};Rt(DL,{json:()=>v2e});var v2e=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],$L={};Rt($L,{json:()=>w2e});var w2e=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],FL={};Rt(FL,{json:()=>k2e});var k2e=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],OL={};Rt(OL,{json:()=>I2e});var I2e=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],PL={};Rt(PL,{json:()=>C2e});var C2e=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],ML={};Rt(ML,{json:()=>S2e});var S2e=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],zL=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[bL,AL,vL,wL,kL,IL,CL,SL,NL,TL,_L,EL,RL,DL,$L,FL,OL,PL,ML],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],s=[],o=[],a=n.reduce((h,m)=>(h[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(h[m.name]):m.op==="Const"?s.push(h[m.name]):(m.input==null||m.input.length===0)&&o.push(h[m.name]),h),{}),i=[],l=[],u={},c={};t!=null&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let p=Object.keys(a);p.forEach(h=>{let m=a[h];m.inputNames.forEach((g,x)=>{let[y,,b]=Kl(g),A=a[y];if(A.outputs!=null){let v=A.outputs.indexOf(b);if(v!==-1){let w=`${y}:${v}`;m.inputNames[x]=w}}m.inputs.push(A),A.children.push(m)})}),Object.keys(c).length===0?p.forEach(h=>{let m=a[h];m.children.length===0&&l.push(m)}):Object.keys(c).forEach(h=>{let[m]=Kl(h),g=a[m];g!=null&&(g.signatureKey=c[h],l.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(h=>{let[m]=Kl(h),g=a[m];g&&(g.signatureKey=u[h],i.push(g))}):i=r;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((h,m)=>(h[m.signature.name]=this.mapFunction(m),h),{}));let f={nodes:a,inputs:i,outputs:l,weights:s,placeholders:r,signature:t,functions:d};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=yL(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.substr(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,s)=>{let o=s.type,a;switch(s.type){case"string":a=W4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=W4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=Z4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Z4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=U4(e.attr,s.tfName,s.defaultValue||0),a===void 0&&!!s.tfDeprecatedName&&(a=U4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=X4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=X4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=G4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=G4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=J4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=J4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=K4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=K4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=Y4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Y4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=H4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=H4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=q4(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=q4(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=BL(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=BL(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:a,type:o},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],s={};t!=null&&(s=t.reduce((c,p)=>(c[p.name]=this.mapNode(p),p.op==="Const"&&r.push(c[p.name]),c),{}));let o=[],a=[];e.signature.inputArg.forEach(c=>{let[p]=Kl(c.name),d={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:j4(c.type),type:"dtype"}},children:[]};d.signatureKey=c.name,o.push(d),s[p]=d}),Object.keys(s).forEach(c=>{let p=s[c];p.inputNames.forEach((d,f)=>{let[h,,m]=Kl(d),g=s[h];if(g.outputs!=null){let x=g.outputs.indexOf(m);if(x!==-1){let y=`${h}:${x}`;p.inputNames[f]=y}}p.inputs.push(g),g.children.push(p)})});let l=e.ret;e.signature.outputArg.forEach(c=>{let[p,d]=Kl(l[c.name]),f=s[p];f!=null&&(f.defaultOutput=d,a.push(f))});let u=this.mapArgsToSignature(e);return{nodes:s,inputs:o,outputs:a,weights:r,placeholders:n,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function N2e(e){let t=be().global;if(typeof t.atob!="undefined")return t.atob(e);if(typeof Buffer!="undefined")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function LL(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):N2e(e);return t?n:n.toLowerCase()}function W4(e,t,n,r=!1){let s=e[t];return s!=null?LL(s.s,r):n}function G4(e,t,n){let r=e[t];return r?r.b:n}function U4(e,t,n){let r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function j4(e){switch(typeof e=="string"&&(e=Ni[e]),e){case Ni.DT_FLOAT:return"float32";case Ni.DT_INT32:case Ni.DT_INT64:case Ni.DT_INT8:case Ni.DT_UINT8:return"int32";case Ni.DT_BOOL:return"bool";case Ni.DT_DOUBLE:return"float32";case Ni.DT_STRING:return"string";default:return null}}function BL(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function H4(e,t,n){let r=e[t];return r&&r.type?j4(r.type):n}function q4(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>j4(s)):n}function VL(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function K4(e,t,n){let r=e[t];return r&&r.shape?VL(r.shape):n}function X4(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function Z4(e,t,n,r=!1){let s=e[t];return s&&s.list&&s.list.s?s.list.s.map(o=>LL(o,r)):n}function Y4(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>VL(s)):n}function J4(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var T2e=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return Gs(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return Gs(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return U4(this.node.rawAttrs,e,t);if(n.s!=null)return W4(this.node.rawAttrs,e,t);if(n.b!=null)return G4(this.node.rawAttrs,e,t);if(n.shape!=null)return K4(this.node.rawAttrs,e,t);if(n.type!=null)return H4(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return X4(this.node.rawAttrs,e,t);if(n.list.s!=null)return Z4(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Y4(this.node.rawAttrs,e,t);if(n.list.b!=null)return J4(this.node.rawAttrs,e,t);if(n.list.type!=null)return q4(this.node.rawAttrs,e,t)}return t}},_2e=(e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[Re($("a",e,t,n),$("b",e,t,n))];case"AddN":return[Yw($("tensors",e,t,n))];case"FloorMod":case"Mod":return[M_($("a",e,t,n),$("b",e,t,n))];case"Mul":return[te($("a",e,t,n),$("b",e,t,n))];case"RealDiv":case"Div":return[Me($("a",e,t,n),$("b",e,t,n))];case"DivNoNan":return[S_($("a",e,t,n),$("b",e,t,n))];case"FloorDiv":return[Zw($("a",e,t,n),$("b",e,t,n))];case"Sub":return[Ge($("a",e,t,n),$("b",e,t,n))];case"Minimum":return[S0($("a",e,t,n),$("b",e,t,n))];case"Maximum":return[il($("a",e,t,n),$("b",e,t,n))];case"Pow":return[Wl($("a",e,t,n),$("b",e,t,n))];case"SquaredDifference":return[Ak($("a",e,t,n),$("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},E2e=(e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[Tr($("x",e,t,n))];case"Acos":return[u_($("x",e,t,n))];case"Acosh":return[c_($("x",e,t,n))];case"Asin":return[d_($("x",e,t,n))];case"Asinh":return[f_($("x",e,t,n))];case"Atan":return[h_($("x",e,t,n))];case"Atan2":return[m_($("x",e,t,n),$("y",e,t,n))];case"Atanh":return[g_($("x",e,t,n))];case"Ceil":return[v_($("x",e,t,n))];case"Complex":return[Lc($("real",e,t,n),$("imag",e,t,n))];case"Cos":return[db($("x",e,t,n))];case"Cosh":return[nk($("x",e,t,n))];case"Elu":return[k0($("x",e,t,n))];case"Erf":return[N_($("x",e,t,n))];case"Exp":return[Bo($("x",e,t,n))];case"Expm1":return[T_($("x",e,t,n))];case"Floor":return[C0($("x",e,t,n))];case"Log":return[Vo($("x",e,t,n))];case"Log1p":return[hb($("x",e,t,n))];case"Imag":return[sk($("x",e,t,n))];case"Neg":return[er($("x",e,t,n))];case"Reciprocal":return[B_($("x",e,t,n))];case"Real":return[Ab($("x",e,t,n))];case"Relu":return[yi($("x",e,t,n))];case"Round":return[dk($("x",e,t,n))];case"Selu":return[hk($("x",e,t,n))];case"Sigmoid":return[xo($("x",e,t,n))];case"Sin":return[mk($("x",e,t,n))];case"Sign":return[W_($("x",e,t,n))];case"Sinh":return[gk($("x",e,t,n))];case"Softplus":return[Xf($("x",e,t,n))];case"Sqrt":return[As($("x",e,t,n))];case"Square":return[Tn($("x",e,t,n))];case"Tanh":return[Hf($("x",e,t,n))];case"Tan":return[j_($("x",e,t,n))];case"ClipByValue":return[yo($("x",e,t,n),$("clipValueMin",e,t,n),$("clipValueMax",e,t,n))];case"Relu6":return[pk($("x",e,t,n))];case"Rsqrt":return[fk(Gs(e.inputNames[0],t,n))];case"Prod":return[ck($("x",e,t,n),$("axes",e,t,n))];case"LeakyRelu":return[fb($("x",e,t,n),$("alpha",e,t,n))];case"Prelu":return[bb($("x",e,t,n),$("alpha",e,t,n))];case"IsNan":return[E_(Gs(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function za(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){E.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let s=e[r],o=t[r];E.assert(s<0||o<0||s===o,()=>n+` Shapes ${e} and ${t} must match`)}}}function WL(e){return!(typeof e=="number"||e.some(t=>t<0))}function Ub(e,t,n){let r=Q4(e,n),s=!WL(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(o=>{r=Q4(o.shape,r)}),!WL(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Q4(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let s=e[r],o=t[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:o}return n}var R2e=class{constructor(e,t,n,r,s,o,a){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=at(0),us(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),za(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,us(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return ls([],[0].concat(this.elementShape));let n=this.readMany(e);return za(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),vs(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ls([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return za(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),En(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Vs(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(i=>(n+=i,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,o=[];ce(()=>{t=ie(t,[1,n,s]);for(let i=0;i<e.length;++i){let l=i===0?0:r[i-1],u=[0,l,0],c=[1,e[i],s];o[i]=ie(gt(t,u,c),this.elementShape)}return o});let a=[];for(let i=0;i<e.length;i++)a[i]=i;this.writeMany(a,o)}},jb=class{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);za(t,s.shape,"TensorList shape mismatch: "),us(s)}),this.idTensor=at(0),this.maxNumElements=r,us(this.idTensor)}get id(){return this.idTensor.id}copy(){return new jb([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);za(e,this.elementShape,"TensorList shape mismatch: ");let r=Ub(this.elementShape,this.tensors,e);return ce(()=>{let s=this.tensors.map(o=>ie(o,r));return vs(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=Ub(this.elementShape,this.tensors,e),r=this.tensors.pop();return za(r.shape,e,"TensorList shape mismatch: "),ie(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(za(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");us(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);za(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=Ub(this.elementShape,this.tensors,t);return ie(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);za(this.elementShape,t.shape,"TensorList shape mismatch: "),us(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);za(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=Ub(this.elementShape,this.tensors,n);return e.length===0?ls([],[0].concat(r)):ce(()=>{let s=e.map(o=>ie(this.tensors[o],r));return vs(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);za(this.elementShape,t,"TensorList shape mismatch: ");let n=Ub(this.elementShape,this.tensors,t);return this.size()===0?ls([],[0].concat(n)):ce(()=>{let r=this.tensors.map(s=>ie(s,n));return En(r,0)})}};function D2e(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let s=e.shape.slice(1);za(s,t,"TensorList shape mismatch: ");let o=Vs(e);return new jb(o,t,r)}function $2e(e,t,n){return new jb([],e,t,n)}function F2e(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let o=new jb([],n,e.dtype,r),a=Vs(e,0);return t.forEach((i,l)=>{o.setItem(i,a[l])}),o}function O2e(e,t,n){let r=0,s=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let o=e.shape.slice(1),a=Q4(o,n),i=r===0?0:e.size/r,l=ce(()=>{let c=[];e=ie(e,[1,r,i]);for(let p=0;p<t.length;++p){let d=p===0?0:s[p-1],f=[0,d,0],h=[1,t[p],i];c[p]=ie(gt(e,f,h),a)}return e.dispose(),c}),u=new jb([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var P2e=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=$("thenBranch",e,t,n),s=$("elseBranch",e,t,n),o=$("cond",e,t,n),a=$("args",e,t,n);return(await o.data())[0]?n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=$("body",e,t,n),s=$("cond",e,t,n),o=$("args",e,t,n),a=await n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),i=o.map(c=>c.id),l=await a[0].data();a.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let u=o;for(;l[0];){let c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let p=u.map(f=>f.id);c.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let d=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await d[0].data(),d.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return u}case"LoopCond":{let r=$("pred",e,t,n);return[Xl(r)]}case"Switch":{let r=$("pred",e,t,n),s=$("data",e,t,n);return s.kept||(s=Xl(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=e.inputNames.find(s=>Gs(s,t,n)!==void 0);if(r){let s=Gs(r,t,n);return[Xl(s)]}return}case"Enter":{let r=$("frameName",e,t,n),s=$("tensor",e,t,n);return n.enterFrame(r),[Xl(s)]}case"Exit":{let r=$("tensor",e,t,n);return n.exitFrame(),[Xl(r)]}case"NextIteration":{let r=$("tensor",e,t,n);return n.nextIteration(),[Xl(r)]}case"TensorArrayV3":{let r=$("size",e,t,n),s=$("dtype",e,t,n),o=$("elementShape",e,t,n),a=$("dynamicSize",e,t,n),i=$("clearAfterRead",e,t,n),l=$("identicalElementShapes",e,t,n),u=$("name",e,t,n),c=new R2e(u,s,r,o,l,a,i);return n.addTensorArray(c),[c.idTensor,at(1)]}case"TensorArrayWriteV3":{let r=$("tensorArrayId",e,t,n),s=$("index",e,t,n),o=$("tensor",e,t,n),a=n.getTensorArray(r.id);return a.write(s,o),[a.idTensor]}case"TensorArrayReadV3":{let r=$("tensorArrayId",e,t,n),s=$("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{let r=$("tensorArrayId",e,t,n),s=$("indices",e,t,n),o=$("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{let r=$("tensorArrayId",e,t,n),s=$("indices",e,t,n),o=$("tensor",e,t,n),a=n.getTensorArray(r.id);return a.scatter(s,o),[a.idTensor]}case"TensorArrayConcatV3":{let r=$("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),o=$("dtype",e,t,n);return[s.concat(o)]}case"TensorArraySplitV3":{let r=$("tensorArrayId",e,t,n),s=$("tensor",e,t,n),o=$("lengths",e,t,n),a=n.getTensorArray(r.id);return a.split(o,s),[a.idTensor]}case"TensorArraySizeV3":{let r=$("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[at(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=$("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=$("tensorListId",e,t,n),s=$("index",e,t,n),o=$("tensor",e,t,n),a=n.getTensorList(r.id);return a.setItem(s,o),[a.idTensor]}case"TensorListGetItem":{let r=$("tensorListId",e,t,n),s=$("index",e,t,n),o=$("elementShape",e,t,n),a=$("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{let r=$("indices",e,t,n),s=$("tensor",e,t,n),o=$("elementShape",e,t,n),a=$("numElements",e,t,n),i=F2e(s,r,o,a);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=$("elementShape",e,t,n),s=$("elementDType",e,t,n),o;e.op==="TensorListReserve"?o="numElements":o="maxNumElements";let a=$(o,e,t,n),i=$2e(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{let r=$("tensorListId",e,t,n),s=$("indices",e,t,n),o=$("elementShape",e,t,n),a=$("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,a,o)]}case"TensorListStack":{let r=$("tensorListId",e,t,n),s=$("elementShape",e,t,n),o=$("elementDType",e,t,n),a=$("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,o,a)]}case"TensorListFromTensor":{let r=$("tensor",e,t,n),s=$("elementShape",e,t,n),o=$("elementDType",e,t,n),a=D2e(r,s,o);return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":{let r=$("tensorListId",e,t,n),s=n.getTensorList(r.id),o=$("dtype",e,t,n),a=$("elementShape",e,t,n);return[s.concat(o,a)]}case"TensorListPushBack":{let r=$("tensorListId",e,t,n),s=$("tensor",e,t,n),o=n.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{let r=$("tensorListId",e,t,n),s=$("elementShape",e,t,n),o=$("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{let r=$("tensor",e,t,n),s=$("elementShape",e,t,n),o=$("lengths",e,t,n),a=O2e(r,o,s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function GL(e,t,n){let[r,s]=$("fusedOps",e,t,n),o=r==="biasadd",a=!o,i=s==="prelu",l=r==="fusedbatchnorm",u=$("numArgs",e,t,n);if(o){if(i&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=$("strides",e,t,n),p=m5(e,t,n),d=$("dataFormat",e,t,n).toUpperCase(),f=$("dilations",e,t,n),[h,m]=$("args",e,t,n);a&&(m=h,h=void 0);let g=$("leakyreluAlpha",e,t,n);return{stride:c,pad:p,dataFormat:d,dilations:f,biasArg:h,preluArg:m,activationFunc:s,leakyreluAlpha:g}}var M2e=(e,t,n)=>{switch(e.op){case"Conv1D":{let r=$("stride",e,t,n),s=$("pad",e,t,n),o=$("dataFormat",e,t,n).toUpperCase(),a=$("dilation",e,t,n);return[ek($("x",e,t,n),$("filter",e,t,n),r,s,o,a)]}case"Conv2D":{let r=$("strides",e,t,n),s=m5(e,t,n),o=$("dataFormat",e,t,n).toUpperCase(),a=$("dilations",e,t,n);return[Bl($("x",e,t,n),$("filter",e,t,n),[r[1],r[2]],s,o,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:i,preluArg:l,activationFunc:u,leakyreluAlpha:c}=GL(e,t,n);return[Hc.conv2d({x:$("x",e,t,n),filter:$("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:i,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:i,preluArg:l,activationFunc:u,leakyreluAlpha:c}=GL(e,t,n);return[Hc.depthwiseConv2d({x:$("x",e,t,n),filter:$("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:i,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=$("outputShape",e,t,n),s=$("strides",e,t,n),o=m5(e,t,n);return[tk($("x",e,t,n),$("filter",e,t,n),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=$("strides",e,t,n),s=m5(e,t,n),o=$("dilations",e,t,n),a=$("dataFormat",e,t,n).toUpperCase();return[w0($("input",e,t,n),$("filter",e,t,n),[r[1],r[2]],s,a,[o[1],o[2]])]}case"Conv3D":{let r=$("strides",e,t,n),s=$("pad",e,t,n),o=$("dataFormat",e,t,n).toUpperCase(),a=$("dilations",e,t,n);return[k_($("x",e,t,n),$("filter",e,t,n),[r[1],r[2],r[3]],s,o,[a[1],a[2],a[3]])]}case"AvgPool":{let r=$("strides",e,t,n),s=$("pad",e,t,n),o=$("kernelSize",e,t,n);return[cb($("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=$("strides",e,t,n),s=$("pad",e,t,n),o=$("kernelSize",e,t,n);return[gb($("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=$("strides",e,t,n),s=$("pad",e,t,n),o=$("kernelSize",e,t,n),a=$("includeBatchInIndex",e,t,n),{result:i,indexes:l}=Y9($("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s,a);return[i,l]}case"AvgPool3D":{let r=$("strides",e,t,n),s=$("pad",e,t,n),o=$("kernelSize",e,t,n);return[b_($("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=$("strides",e,t,n),s=$("pad",e,t,n),o=$("kernelSize",e,t,n);return[O_($("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=$("strides",e,t,n),s=$("pad",e,t,n),o=$("dilations",e,t,n),a=r[1],i=r[2],l=o[1],u=o[2];return[C_($("x",e,t,n),$("filter",e,t,n),[a,i],s,[l,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},z2e=(e,t,n)=>{switch(e.op){case"Fill":{let r=$("shape",e,t,n),s=$("dtype",e,t,n),o=$("value",e,t,n);return[I0(r,o,s)]}case"LinSpace":{let r=$("start",e,t,n),s=$("stop",e,t,n),o=$("num",e,t,n);return[U9(r,s,o)]}case"Multinomial":{let r=$("logits",e,t,n),s=$("numSamples",e,t,n),o=$("seed",e,t,n);return[J9(r,s,o)]}case"OneHot":{let r=$("indices",e,t,n),s=$("depth",e,t,n),o=$("onValue",e,t,n),a=$("offValue",e,t,n);return[g0(r,s,o,a)]}case"Ones":return[Go($("shape",e,t,n),$("dtype",e,t,n))];case"OnesLike":return[Uo($("x",e,t,n))];case"RandomUniform":return[N0($("shape",e,t,n),$("minval",e,t,n),$("maxval",e,t,n),$("dtype",e,t,n))];case"Range":{let r=$("start",e,t,n),s=$("stop",e,t,n),o=$("step",e,t,n);return[T0(r,s,o,$("dtype",e,t,n))]}case"TruncatedNormal":{let r=$("shape",e,t,n),s=$("mean",e,t,n),o=$("stdDev",e,t,n),a=$("seed",e,t,n);return[vk(r,s,o,$("dtype",e,t,n),a)]}case"Zeros":return[xr($("shape",e,t,n),$("dtype",e,t,n))];case"ZerosLike":return[Xt($("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function eR(e,t,n){let r=$("boxes",e,t,n),s=$("scores",e,t,n),o=$("maxOutputSize",e,t,n),a=$("iouThreshold",e,t,n),i=$("scoreThreshold",e,t,n),l=$("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}}var L2e=async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}=eR(e,t,n),u=await ht.nonMaxSuppressionWithScoreAsync(r,s,o,a,i,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i}=eR(e,t,n),l=$("padToMaxOutputSize",e,t,n),u=await ht.nonMaxSuppressionPaddedAsync(r,s,o,a,i,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i}=eR(e,t,n);return[await ht.nonMaxSuppressionAsync(r,s,o,a,i)]}case"Where":{let r=Fe($("condition",e,t,n),"bool"),s=[await K_(r)];return r.dispose(),s}case"ListDiff":return tM($("x",e,t,n),$("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},B2e=(e,t,n)=>{switch(e.op){case"TopKV2":{let r=$("x",e,t,n),s=$("k",e,t,n),o=$("sorted",e,t,n),a=H_(r,s,o);return[a.values,a.indices]}case"Unique":{let r=$("x",e,t,n),s=wk(r);return[s.values,s.indices]}case"UniqueV2":{let r=$("x",e,t,n),s=$("axis",e,t,n),o=wk(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},V2e=(e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=$("default",e,t,n);return[Gs(e.name,t,n)||r];case"Placeholder":return[Gs(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=$("x",e,t,n);return[Xl(u)]}case"IdentityN":return $("x",e,t,n).map(u=>Xl(u));case"Snapshot":let s=$("x",e,t,n);return[Xl(s)];case"Shape":return[Er($("x",e,t,n).shape,"int32")];case"ShapeN":return $("x",e,t,n).map(u=>Er(u.shape));case"Size":return[at($("x",e,t,n).size,"int32")];case"Rank":return[at($("x",e,t,n).rank,"int32")];case"NoOp":return[at(1)];case"Print":let o=$("x",e,t,n),a=$("data",e,t,n),i=$("message",e,t,n),l=$("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${e.op} is not implemented`)}},W2e=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=at(0),this.tensorMap=new Map,us(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return at(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ce(()=>{let r=Vs(t),s=n.length,o=r.length;E.assert(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let a=0;a<s;a++){let i=n[a],l=r[a];us(l),this.tensorMap.set(i,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ce(()=>{let r=[];for(let s=0;s<n.length;s++){let o=n[s],a=this.findWithDefault(o,t);r.push(a)}return vs(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},G2e=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let s=$("keyDType",e,t,n),o=$("valueDType",e,t,n),a=new W2e(s,o);return r.addHashTable(e.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{let s=$("tableHandle",e,t,n,r),o=$("keys",e,t,n),a=$("values",e,t,n);return[await r.getHashTableById(s.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{let s=$("tableHandle",e,t,n,r),o=$("keys",e,t,n),a=$("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let s=$("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},U2e=(e,t,n)=>{switch(e.op){case"ResizeBilinear":{let r=$("images",e,t,n),s=$("size",e,t,n),o=$("alignCorners",e,t,n),a=$("halfPixelCenters",e,t,n);return[ht.resizeBilinear(r,[s[0],s[1]],o,a)]}case"ResizeNearestNeighbor":{let r=$("images",e,t,n),s=$("size",e,t,n),o=$("alignCorners",e,t,n),a=$("halfPixelCenters",e,t,n);return[ht.resizeNearestNeighbor(r,[s[0],s[1]],o,a)]}case"CropAndResize":{let r=$("image",e,t,n),s=$("boxes",e,t,n),o=$("boxInd",e,t,n),a=$("cropSize",e,t,n),i=$("method",e,t,n),l=$("extrapolationValue",e,t,n);return[ht.cropAndResize(r,s,o,a,i,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},j2e=(e,t,n)=>{switch(e.op){case"Equal":return[Lo($("a",e,t,n),$("b",e,t,n))];case"NotEqual":return[Yf($("a",e,t,n),$("b",e,t,n))];case"Greater":return[bo($("a",e,t,n),$("b",e,t,n))];case"GreaterEqual":return[Uc($("a",e,t,n),$("b",e,t,n))];case"Less":return[ok($("a",e,t,n),$("b",e,t,n))];case"LessEqual":return[jc($("a",e,t,n),$("b",e,t,n))];case"LogicalAnd":return[Fa($("a",e,t,n),$("b",e,t,n))];case"LogicalNot":return[mb($("a",e,t,n))];case"LogicalOr":return[lk($("a",e,t,n),$("b",e,t,n))];case"Select":case"SelectV2":return[$s($("condition",e,t,n),$("a",e,t,n),$("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},H2e=(e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Lt($("a",e,t,n),$("b",e,t,n),$("transposeA",e,t,n),$("transposeB",e,t,n))];case"Einsum":return[V9($("equation",e,t,n),...$("tensors",e,t,n))];case"Transpose":return[Kt($("x",e,t,n),$("perm",e,t,n))];case"_FusedMatMul":let[r,s]=$("fusedOps",e,t,n),o=r==="biasadd",a=s==="prelu",i=$("numArgs",e,t,n),l=$("leakyreluAlpha",e,t,n);if(o){if(a&&i!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,c]=$("args",e,t,n);return[Hc.matMul({a:$("a",e,t,n),b:$("b",e,t,n),transposeA:$("transposeA",e,t,n),transposeB:$("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${e.op} is not implemented`)}},q2e=(e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[qf($("x",e,t,n),$("mean",e,t,n),$("variance",e,t,n),$("offset",e,t,n),$("scale",e,t,n),$("epsilon",e,t,n))];case"FusedBatchNormV3":return[qf($("x",e,t,n),$("mean",e,t,n),$("variance",e,t,n),$("offset",e,t,n),$("scale",e,t,n),$("epsilon",e,t,n))];case"LRN":return[R_($("x",e,t,n),$("radius",e,t,n),$("bias",e,t,n),$("alpha",e,t,n),$("beta",e,t,n))];case"Softmax":return[Jf($("x",e,t,n))];case"LogSoftmax":return[ik($("x",e,t,n))];case"SparseToDense":return[X_($("sparseIndices",e,t,n),$("outputShape",e,t,n),$("sparseValues",e,t,n),$("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},K2e=(e,t,n)=>{switch(e.op){case"Max":{let a=$("axis",e,t,n),i=$("keepDims",e,t,n);return[Wo($("x",e,t,n),a,i)]}case"Mean":{let a=$("axis",e,t,n),i=$("keepDims",e,t,n);return[cr($("x",e,t,n),a,i)]}case"Min":{let a=$("axis",e,t,n),i=$("keepDims",e,t,n);return[xb($("x",e,t,n),a,i)]}case"Sum":{let a=$("axis",e,t,n),i=$("keepDims",e,t,n);return[Je($("x",e,t,n),a,i)]}case"All":{let a=$("axis",e,t,n),i=$("keepDims",e,t,n);return[Jw($("x",e,t,n),a,i)]}case"Any":{let a=$("axis",e,t,n),i=$("keepDims",e,t,n);return[lb($("x",e,t,n),a,i)]}case"ArgMax":{let a=$("axis",e,t,n);return[xi($("x",e,t,n),a)]}case"ArgMin":{let a=$("axis",e,t,n);return[p_($("x",e,t,n),a)]}case"Prod":{let a=$("axis",e,t,n),i=$("keepDims",e,t,n);return[ck($("x",e,t,n),a,i)]}case"Cumsum":{let a=$("axis",e,t,n),i=$("exclusive",e,t,n),l=$("reverse",e,t,n);return[rk($("x",e,t,n),a,i,l)]}case"Bincount":let r=$("x",e,t,n),s=$("weights",e,t,n),o=$("size",e,t,n);return[A_(r,s,o)];case"DenseBincount":{let a=$("x",e,t,n),i=$("weights",e,t,n),l=$("size",e,t,n),u=$("binaryOutput",e,t,n);return[L9(a,i,l,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},X2e=(e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=$("n",e,t,n),s=$("axis",e,t,n),o=$("tensors",e,t,n);return o=o.slice(0,r),[En(o,s)]}case"Gather":{let r=$("x",e,t,n),s=$("indices",e,t,n);return[Kf(r,Fe(s,"int32"),0)]}case"GatherV2":{let r=$("axis",e,t,n),s=$("batchDims",e,t,n),o=$("x",e,t,n),a=$("indices",e,t,n);return[Kf(o,Fe(a,"int32"),r,s)]}case"Reverse":{let r=$("dims",e,t,n),s=[];for(let a=0;a<r.length;a++)r[a]&&s.push(a);let o=$("x",e,t,n);return[jo(o,s)]}case"ReverseV2":{let r=$("axis",e,t,n),s=$("x",e,t,n);return[jo(s,r)]}case"Slice":{let r=$("begin",e,t,n),s=$("size",e,t,n);return[gt($("x",e,t,n),r,s)]}case"StridedSlice":{let r=$("begin",e,t,n),s=$("end",e,t,n),o=$("strides",e,t,n),a=$("beginMask",e,t,n),i=$("endMask",e,t,n),l=$("ellipsisMask",e,t,n),u=$("newAxisMask",e,t,n),c=$("shrinkAxisMask",e,t,n),p=$("x",e,t,n);return[U_(p,r,s,o,a,i,l,u,c)]}case"Pack":return ce(()=>{let r=$("axis",e,t,n),s=$("tensors",e,t,n),o=s[0].shape,a=ln(s[0]).shape,i=s.map(l=>{let u=E.arraysEqual(l.shape,o);if(!u&&!E.arraysEqual(ln(l).shape,a))throw new Error("the input tensors shape does not match");return u?l:ie(l,o)});return[vs(i,r)]});case"Unpack":{let r=$("axis",e,t,n),s=$("tensor",e,t,n);return Vs(s,r)}case"Tile":{let r=$("reps",e,t,n);return[da($("x",e,t,n),r)]}case"Split":case"SplitV":{let r=$("axis",e,t,n),s=$("numOrSizeSplits",e,t,n),o=$("x",e,t,n);return _r(o,s,r)}case"ScatterNd":{let r=$("indices",e,t,n),s=$("values",e,t,n),o=$("shape",e,t,n);return[oM(r,s,o)]}case"GatherNd":{let r=$("x",e,t,n),s=$("indices",e,t,n);return[aM(r,s)]}case"SparseToDense":{let r=$("sparseIndices",e,t,n),s=$("outputShape",e,t,n),o=$("sparseValues",e,t,n),a=$("defaultValue",e,t,n);return[X_(r,o,s,o.dtype===a.dtype?a:Fe(a,o.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Z2e=(e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:a}=Ib.sparseFillEmptyRows($("indices",e,t,n),$("values",e,t,n),$("denseShape",e,t,n),$("defaultValue",e,t,n));return[r,s,o,a]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=Ib.sparseReshape($("inputIndices",e,t,n),$("inputShape",e,t,n),$("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[Ib.sparseSegmentMean($("data",e,t,n),$("indices",e,t,n),$("segmentIds",e,t,n))];case"SparseSegmentSum":return[Ib.sparseSegmentSum($("data",e,t,n),$("indices",e,t,n),$("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Y2e=(e,t,n)=>{switch(e.op){case"FFT":return[wb($("x",e,t,n))];case"IFFT":return[_0($("x",e,t,n))];case"RFFT":return[kb($("x",e,t,n))];case"IRFFT":return[bk($("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},J2e=(e,t,n)=>{switch(e.op){case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=Tk.stringNGrams($("data",e,t,n),$("dataSplits",e,t,n),$("separator",e,t,n),$("nGramWidths",e,t,n),$("leftPad",e,t,n),$("rightPad",e,t,n),$("padWidth",e,t,n),$("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:o}=Tk.stringSplit($("input",e,t,n),$("delimiter",e,t,n),$("skipEmpty",e,t,n));return[r,s,o]}case"StringToHashBucketFast":return[Tk.stringToHashBucketFast($("input",e,t,n),$("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Q2e=(e,t,n)=>{switch(e.op){case"Cast":return[Fe($("x",e,t,n),$("dtype",e,t,n))];case"ExpandDims":{let r=$("axis",e,t,n);return[kr($("x",e,t,n),r)]}case"Squeeze":{let r=$("axis",e,t,n);return[ln($("x",e,t,n),r)]}case"Reshape":return[ie($("x",e,t,n),$("shape",e,t,n))];case"MirrorPad":return[P_($("x",e,t,n),$("padding",e,t,n),$("mode",e,t,n))];case"PadV2":case"Pad":return[Vl($("x",e,t,n),$("padding",e,t,n),$("constantValue",e,t,n))];case"SpaceToBatchND":{let r=$("blockShape",e,t,n),s=$("paddings",e,t,n);return[yb($("x",e,t,n),r,s)]}case"BatchToSpaceND":{let r=$("blockShape",e,t,n),s=$("crops",e,t,n);return[pb($("x",e,t,n),r,s)]}case"DepthToSpace":{let r=$("blockSize",e,t,n),s=$("dataFormat",e,t,n).toUpperCase();return[I_($("x",e,t,n),r,s)]}case"BroadcastTo":return[A0($("x",e,t,n),$("shape",e,t,n))];case"BroadcastArgs":return[$9($("s0",e,t,n),$("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function UL(e,t,n,r){let s=((o,a,i)=>{switch(o.category){case"arithmetic":return ce(()=>_2e(o,a,i));case"basic_math":return ce(()=>E2e(o,a,i));case"control":return P2e(o,a,i);case"convolution":return ce(()=>M2e(o,a,i));case"creation":return ce(()=>z2e(o,a,i));case"dynamic":return L2e(o,a,i);case"evaluation":return ce(()=>B2e(o,a,i));case"image":return ce(()=>U2e(o,a,i));case"graph":return ce(()=>V2e(o,a,i));case"logical":return ce(()=>j2e(o,a,i));case"matrices":return ce(()=>H2e(o,a,i));case"normalization":return ce(()=>q2e(o,a,i));case"reduction":return ce(()=>K2e(o,a,i));case"slice_join":return ce(()=>X2e(o,a,i));case"sparse":return ce(()=>Z2e(o,a,i));case"spectral":return ce(()=>Y2e(o,a,i));case"string":return ce(()=>J2e(o,a,i));case"transformation":return ce(()=>Q2e(o,a,i));case"hash_table":return G2e(o,a,i,r);case"custom":let l=yL(o.op);if(l&&l.customExecutor)return l.customExecutor(new T2e(o,a,i));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return E.isPromise(s)?s.then(o=>[].concat(o)):[].concat(s)}var jL=class{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function HL(e,t,n,r){let s=new Set,o=[],a=null,i=null,l=new Set,u=Object.keys(e).map(d=>Ho(d)[0]),c=[];r!=null&&(c=r.map(d=>Ho(d.name)[0]));let p=[...t];for(;p.length>0;){let d=p.pop();if((qL(d)||sve(d)||ove(d))&&a==null&&(a=d,i=a.children.map(f=>f.name).filter(f=>s.has(f))),s.add(d.name),n[d.name]==null&&u.indexOf(d.name)===-1&&c.indexOf(d.name)===-1){if(d.inputs.length===0){o.push(d.name);continue}d.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),p.push(f))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:o,dynamicNode:a,syncInputs:i}}function eve(e,t,n){let{usedNodes:r,inputs:s}=n,o=[],a=Object.keys(s).map(c=>Ho(c)[0]).map(c=>e.nodes[c]),i=e.initNodes;a.forEach(c=>{r.has(c.name)&&o.push(c)}),e.weights.forEach(c=>{r.has(c.name)&&o.push(c)}),i!=null&&i.forEach(c=>{r.has(c.name)&&o.push(c)});let l=new Set,u=[];for(;o.length>0;){let c=o.pop();l.add(c.name),t[c.name]||u.push(c),c.children.forEach(p=>{!l.has(p.name)&&r.has(p.name)&&p.inputs.every(d=>l.has(d.name))&&o.push(p)})}return u}var tve=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],nve=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],rve=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function qL(e){return tve.indexOf(e.op)>=0}function sve(e){return nve.indexOf(e.op)>=0}function ove(e){return rve.indexOf(e.op)>=0}var tR=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new tR(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),r=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){let n=HL(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:o}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){let a=t.map(l=>l.name),i=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${i}]. Missing the following inputs: [${r}]`)}return eve(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map(c=>this.graph.nodes[Ho(c)[0]]),s=t.map(c=>Ho(c)[0]),o=s.map(c=>this.graph.nodes[c]);o.length===0&&(o=this._outputs);let a=this.getCompilationKey(r,o),i=this.compiledMap.get(a);i==null&&(i=this.compile(e,o),this.compiledMap.set(a,i));let l={},u={};return ce(()=>{let c=new jL(this.weightMap,l,u,this.functionExecutorMap),p=Object.assign({},this.weightMap);Object.keys(e).forEach(h=>{let[m,g]=Ho(h),x=[];x[g]=e[h],p[m]=x});let d=this.getFrozenTensorIds(p),f={};for(let h=0;h<i.length;h++){let m=i[h];if(!p[m.name]){let g=UL(m,p,c,this._resourceManager);if(E.isPromise(g))throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);p[m.name]=g,this.checkTensorForDisposal(m.name,m,p,c,d,s,f)}}return this.parent==null&&c.dispose(d),t.map(h=>Gs(h,p,c))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,o,a){t.category==="control"||o.indexOf(e)!==-1||(n[e].forEach(i=>{i!=null&&(a[i.id]=(a[i.id]||0)+t.children.length)}),t.inputs.forEach(i=>{if(i.category!=="control"){let l=i2e(i.name,n,r);l!=null&&l.forEach(u=>{if(u&&!u.kept&&!s.has(u.id)){let c=a[u.id];c===1?(u.dispose(),delete a[u.id]):c!=null&&a[u.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,n=!1,r={},s={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));let o=new jL(this.weightMap,r,s,this.functionExecutorMap),a=await this.executeWithControlFlow(e,o,t,n),i=t.map(p=>Gs(p,a,o)),l=i.map(p=>p.id),u=Object.keys(e).map(p=>e[p].id),c=new Set([...l,...u,...this.weightIds]);return Object.keys(a).forEach(p=>{a[p].forEach(f=>{f&&!f.kept&&!f.isDisposed&&!c.has(f.id)&&f.dispose()})}),this.parent==null&&o.dispose(c),i}async executeFunctionAsync(e,t,n){let r=e.reduce((s,o,a)=>(s[this.inputs[a].name]=o,s),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let s=Object.keys(e),o=s.map(y=>this.graph.nodes[Ho(y)[0]]),a=n.map(y=>Ho(y)[0]),i=a.map(y=>this.graph.nodes[y]);i.length===0&&(i=this._outputs);let{usedNodes:l,missingInputs:u,dynamicNode:c,syncInputs:p}=HL(e,i,this.weightMap,this._initNodes),d=[...o,...this.graph.weights,...this._initNodes||[]].map(y=>({node:y,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(y=>{let[b,A]=Ho(y),v=[];v[A]=e[y],f[b]=v});let h={},m=this.getFrozenTensorIds(f),g={};for(;d.length>0;){let y=this.processStack(o,d,t,f,g,m,a,h,l);await Promise.all(y)}c==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let x=i.filter(y=>!qL(y)&&!Gs(y.name,f,t)).map(y=>y.name);if(x.length>0){let y="";throw c!=null&&(y=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${s}]. Consider providing the following inputs: [${u}]. ${y}`)}return f}processStack(e,t,n,r,s,o,a,i,l){let u=[];for(;t.length>0;){let c=t.pop();n.currentContext=c.contexts;let p="";if(c.node.op==="Enter"&&$("isConstant",c.node,r,n)&&([p]=Kl(c.node.name,n)),r[c.node.name]==null){let d=UL(c.node,r,n,this._resourceManager);p||([p]=Kl(c.node.name,n));let f=n.currentContext;E.isPromise(d)?u.push(d.then(h=>(r[p]=h,n.currentContext=f,this.checkTensorForDisposal(p,c.node,r,n,o,a,i),this.processChildNodes(c.node,t,n,r,s,l),h))):(r[p]=d,this.checkTensorForDisposal(p,c.node,r,n,o,a,i),this.processChildNodes(c.node,t,n,r,s,l))}else this.processChildNodes(c.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,o){e.children.forEach(a=>{let[i]=Kl(a.name,n);s[i]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!Gs(l,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:a})):a.inputNames.every(l=>!!Gs(l,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[r]=Ho(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let o=s.attrParams.shape.value,a=o.length===n.shape.length&&n.shape.every((i,l)=>o[l]===-1||o[l]===i);E.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${o}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&E.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let r=this._signature.inputs[n];t[r.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){let t=Object.keys(e).filter(n=>{let[r]=Ho(n);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{let[n]=Ho(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}},ave=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},ive="?tfjs-format=file",lve="model.json",KL=class{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new ave}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=go.browserHTTPRequest(e,this.loadOptions);else{let t=go.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(go.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let r=go.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new tR(zL.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=zL.Instance.transformGraph(e.modelInitializer);this.initializer=new tR(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){let n=go.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Vt)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,r)=>(t[n]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function yn(e,t={}){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&e.load==null&&(e.endsWith("/")||(e=e+"/"),e=`${e}${lve}${ive}`);let n=new KL(e,t);return await n.load(),n}var uve="3.9.0",XL={};Rt(XL,{CSVDataset:()=>iB,Dataset:()=>B0,FileDataSource:()=>hB,TextLineDataset:()=>sB,URLDataSource:()=>mB,array:()=>Dve,csv:()=>Gve,func:()=>Uve,generator:()=>jve,microphone:()=>qve,version_data:()=>Kve,webcam:()=>Hve,zip:()=>$ve});var cve=Pd(pP()),pve=Pd(pP());function dve(e,t){return g5(e,t)}function g5(e,t,n=new Map,r=new Set){if(e==null)return null;if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(L0(e)){let o=Array.isArray(e)?[]:{};r.add(e);for(let a in e){let i=e[a],l=g5(i,t,n,r);o[a]=l}return r.delete(e),o}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,s.value),s.value}function fve(e,t=YL){return ZL(e,t)}function ZL(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(L0(r)){let o=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let i=e.map(u=>u[a]),l=ZL(i,t,n);o[a]=l}return n.delete(r),o}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function YL(e){return e===null?null:L0(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function JL(e,t){let n=new Map;g5(e,t,n);for(let s of Array.from(n.keys())){let o=n.get(s);if(E.isPromise(o)){let a=await o;n.set(s,a)}}return g5(e,t,n)}function L0(e){let t=!1;if(be().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=dP();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Vt)&&!(e instanceof Promise)&&!t)}function hve(e){return e==null||mve(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Vt||E.isTypedArray(e)}function mve(e){return e===null||typeof e!="object"&&typeof e!="function"}function gve(e){return dve(e,xve)}function xve(e){return e instanceof Vt?{value:e.clone(),recurse:!1}:L0(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var QL=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},nR=class extends QL{constructor(){super(nR.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};nR.INITIAL_CAPACITY=32;function eB(e){return new Ave(e)}function rR(e){return new vve(e)}function yve(e,t){return new nB(e,t)}function bve(e,t=ep.FAIL){return new Eve(e,t)}var ps=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new Tve(this,e)}filter(e){return new Sve(this,e)}map(e){return new Nve(this,e)}mapAsync(e){return new tB(this,e)}serialMapAsync(e){return new tB(this,e).serial()}flatmap(e){return new _ve(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new Cve(this,e,t)}columnMajorBatch(e,t=!0,n=YL){return this.rowMajorBatch(e,t).map(s=>fve(s,n))}concatenate(e,t){return new nB(eB([this,e]),t)}take(e){return e<0||e==null?this:new Ive(this,e)}skip(e){return e<0||e==null?this:new kve(this,e)}prefetch(e){return new rB(this,e)}shuffle(e,t){return new Rve(this,e,t)}serial(){return new wve(this)}},Ave=class extends ps{constructor(e){super();this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:gve(e),done:!1}}},vve=class extends ps{constructor(e){super();this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},wve=class extends ps{constructor(e){super();this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},kve=class extends ps{constructor(e,t){super();this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;ye(e.value)}return this.upstream.next()}},Ive=class extends ps{constructor(e,t){super();this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},Cve=class extends ps{constructor(e,t,n=!0){super();this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},Sve=class extends ps{constructor(e,t){super();this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;ye(e.value)}}},Nve=class extends ps{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=fi.getTensorsInContainer(e.value),n=this.transform(e.value),r=fi.getTensorsInContainer(n);for(let s of t)fi.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},Tve=class extends ps{constructor(e,t){super();this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},tB=class extends ps{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=fi.getTensorsInContainer(e.value),n=await this.transform(e.value),r=fi.getTensorsInContainer(n);for(let s of t)fi.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},sR=class extends ps{constructor(){super();this.outputQueue=new nR,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},_ve=class extends sR{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=fi.getTensorsInContainer(e.value),n=this.transform(e.value),r=fi.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)fi.isTensorInList(s,r)||s.dispose();return!0}},nB=class extends ps{constructor(e,t){super();this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},ep;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(ep||(ep={}));var Eve=class extends ps{constructor(e,t=ep.FAIL){super();this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(o){return o instanceof ps?{value:o.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let s=await JL(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case ep.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case ep.SHORTEST:return{value:null,done:!0};case ep.LONGEST:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},rB=class extends ps{constructor(e,t){super();this.upstream=e,this.bufferSize=t,this.buffer=new QL(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},Rve=class extends rB{constructor(e,t,n){super(e,t);this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=pve.alea(n||E.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},B0=class{constructor(){this.size=null}batch(e,t=!0){let n=this;E.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),qo(async()=>(await n.iterator()).columnMajorBatch(e,t,Fve),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,qo(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,qo(async()=>(await t.iterator()).filter(r=>ce(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return qo(async()=>(await t.iterator()).map(n=>ce(()=>e(n))),this.size)}mapAsync(e){let t=this;return qo(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return qo(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,qo(async()=>{let r=rR(async()=>({value:await t.iterator(),done:!1}));return yve(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,qo(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,s=cve.alea(t||E.now().toString());return qo(async()=>{let o=s.int32();return n&&(o+=s.int32()),(await r.iterator()).shuffle(e,o.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,qo(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};B0.MAX_BUFFER_SIZE=1e4;function qo(e,t=null){return new class extends B0{constructor(){super(...arguments);this.size=t}async iterator(){return e()}}}function Dve(e){return qo(async()=>eB(e),e.length)}function $ve(e){if(!L0(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return qo(async()=>{let n=await JL(e,r=>{if(r instanceof B0)return{value:r.iterator(),recurse:!1};if(L0(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return bve(n,ep.SHORTEST)},t)}function Fve(e){if(e===null)return null;let t=e[0];return hve(t)?{value:Ove(e),recurse:!1}:{value:null,recurse:!0}}function Ove(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Vt?vs(e):ls(e)}var sB=class extends B0{constructor(e){super();this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}},x5='"',Hb=Symbol("out"),oB=Symbol("field"),y5=Symbol("quote"),oR=Symbol("quoteafterquote"),aB=Symbol("quoteinquote"),iB=class extends B0{constructor(e,t){super();this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new sB(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(E.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&E.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,s)=>(r[s]=r[s]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(E.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");let n=t.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){let o=this.fullColumnNames[s],a=this.columnConfigs?this.columnConfigs[o]:null;if(!(this.configuredColumnsOnly&&!a)){let i=t[s],l=null;if(i==="")if(a&&a.default!==void 0)l=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${o} is empty in this line: ${e}`);l=void 0}else{let u=Number(i);if(isNaN(u))a&&a.dtype==="bool"?l=this.getBoolean(i):l=i;else if(!a||!a.dtype)l=u;else switch(a.dtype){case"float32":l=u;break;case"int32":l=Math.floor(u);break;case"bool":l=this.getBoolean(i);break;default:l=u}}a&&a.isLabel?r[o]=l:n[o]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,s=e.length,o=Hb;for(let a=0;a<s;a++)switch(o){case Hb:switch(e.charAt(a)){case x5:r=a+1,o=y5;break;case this.delimiter:if(r=a+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),o=Hb;break;default:o=oB,r=a;break}break;case oB:switch(e.charAt(a)){case this.delimiter:n.push(e.substring(r,a)),o=Hb,r=a+1;break;default:}break;case y5:switch(e.charAt(a)){case x5:o=oR;break;default:}break;case oR:switch(e.charAt(a)){case this.delimiter:n.push(e.substring(r,a-1)),o=Hb,r=a+1;break;case x5:o=y5;break;default:o=aB;break}break;case aB:switch(e.charAt(a)){case x5:o=y5;break;default:}break;default:}if(o===oR?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},lB=class extends ps{constructor(e){super();this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(be().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");let t=new lB(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((r,s)=>n.set(r,s*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(E.sizeFromShape(t));return n.set(e,n.length-e.length),ls(n,t)}},uB=class extends ps{constructor(e,t){super();if(this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Er([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,o=(1-r)/2,a=s+n,i=r+o;this.cropBox=bi([o,s,i,a],[1,4])}else this.cropBox=bi([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(be().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new uB(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&E.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Mo.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return ce(()=>{let t=kr(Fe(e,"float32"),0),n;n=ht.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=n.shape;return ie(n,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},cB=class{},pB=class extends ps{split(e){return new Pve(this,e)}},Pve=class extends pB{constructor(e,t){super();this.upstream=e,this.impl=new Mve(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Mve=class extends sR{constructor(e,t){super();this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},zve=class extends ps{decodeUTF8(){return new Lve(this)}},Lve=class extends pB{constructor(e){super();this.upstream=e,this.impl=new Bve(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Bve=class extends sR{constructor(e){super();if(this.upstream=e,be().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=dP();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return be().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},dB=class extends zve{constructor(e,t={}){super();this.file=e,this.options=t,E.assert(e instanceof Uint8Array||(be().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,n)=>{let r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{let s=new FileReader;s.onload=a=>{let i=s.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));t(i)},s.onabort=a=>n(new Error("Aborted")),s.onerror=a=>n(new Error(a.type));let o=this.file.slice(this.offset,r);s.readAsArrayBuffer(o)}this.offset=r}),done:!1}}};async function Vve(e,t={}){let n,r;typeof e=="string"?n=e:(n=e.url,r=Wve(e));let s=await E.fetch(n,r);if(s.ok){let o=new Uint8Array(await s.arrayBuffer());return new dB(o,t)}else throw new Error(s.statusText)}var Wve=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function fB(e){return typeof e=="string"&&e.substr(0,7)==="file://"}var hB=class extends cB{constructor(e,t={}){super();this.input=e,this.options=t}async iterator(){if(fB(this.input)&&be().get("IS_NODE")){let e=ig("fs");this.input=e.readFileSync(this.input.substr(7))}return new dB(this.input,this.options)}},mB=class extends cB{constructor(e,t={}){super();this.url=e,this.fileOptions=t}async iterator(){return fB(this.url)?new hB(this.url,this.fileOptions).iterator():Vve(this.url,this.fileOptions)}};function Gve(e,t={}){return new iB(new mB(e),t)}function Uve(e){let t=rR(e);return qo(async()=>t)}function jve(e){return qo(async()=>{let t=await e();return rR(()=>t.next())})}async function Hve(e,t){return uB.create(e,t)}async function qve(e){return lB.create(e)}var Kve="3.9.0";function rt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&E.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var Xve=ll.whereImpl,aR=class extends $1{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new Xv(this,zo())}nextDataId(){return aR.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,be().get("IS_NODE")&&G.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&E.isString(n[0])){let s=n.map(o=>E.encodeString(o));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let r=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return G.mergeRealAndImagArrays(r,s)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(r=>E.decodeString(r))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return Wt(e.shape,e.dtype,n)}makeOutput(e,t,n){let r=this.write(e,t,n);return zo().makeTensorFromDataId(r,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=E.now();return e(),{kernelMs:E.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){rt([e],"where");let t=this.readSync(e.dataId);return Xve(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};aR.nextDataId=0;var gB={};Rt(gB,{addImpl:()=>yB,bincountImpl:()=>lR,bincountReduceImpl:()=>bB,ceilImpl:()=>AB,concatImpl:()=>uR,equalImpl:()=>vB,expImpl:()=>kB,expm1Impl:()=>CB,floorImpl:()=>SB,gatherNdImpl:()=>NB,gatherV2Impl:()=>TB,greaterEqualImpl:()=>EB,greaterImpl:()=>_B,lessEqualImpl:()=>DB,lessImpl:()=>RB,linSpaceImpl:()=>$B,logImpl:()=>FB,maxImpl:()=>OB,maximumImpl:()=>PB,minimumImpl:()=>MB,multiplyImpl:()=>cR,negImpl:()=>zB,notEqualImpl:()=>LB,prodImpl:()=>BB,rangeImpl:()=>dR,rsqrtImpl:()=>VB,sigmoidImpl:()=>Mwe,simpleAbsImpl:()=>xB,sliceImpl:()=>v5,sparseFillEmptyRowsImpl:()=>GB,sparseReshapeImpl:()=>UB,sparseSegmentReductionImpl:()=>fR,sqrtImpl:()=>Bwe,squaredDifferenceImpl:()=>jB,stridedSliceImpl:()=>HB,stringNGramsImpl:()=>qB,stringSplitImpl:()=>KB,stringToHashBucketFastImpl:()=>XB,subImpl:()=>ZB,tileImpl:()=>YB,topKImpl:()=>QB,transposeImpl:()=>pR,uniqueImpl:()=>eV});function xB(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var Zve=e=>{let{x:t}=e.inputs,n=e.backend;rt(t,"abs");let r=new Float32Array(E.sizeFromShape(t.shape)),s=n.data.get(t.dataId).values;return r=xB(s),n.makeOutput(r,t.shape,"float32")},Yve={kernelName:cg,backendName:"cpu",kernelFunc:Zve};function Dr(e){return(t,n,r,s,o)=>{let a=G.assertAndGetBroadcastShape(t,n),i=a.length,l=E.computeStrides(a),u=E.sizeFromShape(a),c=E.getTypedArrayFromDType(o,u),p=t.length,d=n.length,f=E.computeStrides(t),h=E.computeStrides(n),m=G.getBroadcastDims(t,a),g=G.getBroadcastDims(n,a);if(m.length+g.length===0)for(let x=0;x<c.length;++x)c[x]=e(r[x%r.length],s[x%s.length]);else for(let x=0;x<c.length;++x){let y=E.indexToLoc(x,i,l),b=y.slice(-p);m.forEach(k=>b[k]=0);let A=E.locToIndex(b,p,f),v=y.slice(-d);g.forEach(k=>v[k]=0);let w=E.locToIndex(v,d,h);c[x]=e(r[A],s[w])}return[c,a]}}function Ko(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,i=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(i.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",o),imag:n.makeTensorInfo(s.shape,"float32",a)},i}var Jve={kernelName:rw,backendName:"cpu",kernelFunc:Ko};function b5(e,t,n="float32"){if(n==="complex64"){let s=b5(e,t,"float32"),o=b5(e,t,"float32");return Ko({inputs:{real:s,imag:o},backend:e})}let r=E.makeZerosTypedArray(E.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function hl(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Qve={kernelName:sf,backendName:"cpu",kernelFunc:hl};function ch(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}var ewe={kernelName:Iw,backendName:"cpu",kernelFunc:ch};function tp(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return hl({inputs:{x:s},backend:n});let a=b5(n,s.shape,s.dtype),i=tp({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Ko({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}if(s.dtype==="complex64"){let a=ch({inputs:{input:s},backend:n}),i=tp({inputs:{x:a},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(a),i}if(!E.hasEncodingLoss(s.dtype,o)){let a=hl({inputs:{x:s},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32"){let a=n.data.get(s.dataId).values,i=Int32Array.from(a);return n.makeTensorInfo(s.shape,"int32",i)}if(o==="bool"){let a=n.data.get(s.dataId).values,i=E.toTypedArray([0],s.dtype),[l,u]=Dr((c,p)=>c!==p?1:0)(s.shape,[],a,i,"bool");return n.makeTensorInfo(u,"bool",l)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}var twe={kernelName:Gd,backendName:"cpu",kernelFunc:tp};function ds(e,t,n,r){return n==null?({inputs:s,backend:o})=>{let{a,b:i}=s,l=o;rt([a,i],e);let u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,p=a.dtype==="string"?G.fromUint8ToStringArray(u):u,d=a.dtype==="string"?G.fromUint8ToStringArray(c):c,f=r||a.dtype,[h,m]=t(a.shape,i.shape,p,d,f);return l.makeTensorInfo(m,f,h)}:({inputs:s,backend:o})=>{let{a,b:i}=s,l=o;if(a.dtype==="complex64"||i.dtype==="complex64"){let u=tp({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),p=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,f=l.data.get(p.dataId).values,h=l.data.get(d.dataId).values,m=tp({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),x=g.complexTensorInfos.real,y=g.complexTensorInfos.imag,b=l.data.get(x.dataId).values,A=l.data.get(y.dataId).values,[v,w,k]=n(a.shape,i.shape,f,h,b,A),I=l.makeTensorInfo(k,"float32",v),N=l.makeTensorInfo(k,"float32",w),T=Ko({inputs:{real:I,imag:N},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(N),T}else{let u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,p=r||a.dtype,[d,f]=t(a.shape,i.shape,u,c,p);return l.makeTensorInfo(f,p,d)}}}function iR(e){return(t,n,r,s,o,a)=>{let i=G.assertAndGetBroadcastShape(t,n),l=E.sizeFromShape(i),u=i.length,c=E.computeStrides(i),p=E.getTypedArrayFromDType("float32",l),d=E.getTypedArrayFromDType("float32",l),f=G.getBroadcastDims(t,i),h=G.getBroadcastDims(n,i),m=G.mergeRealAndImagArrays(r,s),g=G.mergeRealAndImagArrays(o,a),x=t.length,y=E.computeStrides(t),b=n.length,A=E.computeStrides(n);if(f.length+h.length===0)for(let v=0;v<p.length;v++){let w=v%m.length,k=v%g.length,I=e(m[w*2],m[w*2+1],g[k*2],g[k*2+1]);p[v]=I.real,d[v]=I.imag}else for(let v=0;v<p.length;v++){let w=E.indexToLoc(v,u,c),k=w.slice(-x);f.forEach(R=>k[R]=0);let I=E.locToIndex(k,x,y),N=w.slice(-b);h.forEach(R=>N[R]=0);let T=E.locToIndex(N,b,A),_=e(m[I*2],m[I*2+1],g[T*2],g[T*2+1]);p[v]=_.real,d[v]=_.imag}return[p,d,i]}}var yB=Dr((e,t)=>e+t),nwe=iR((e,t,n,r)=>({real:e+n,imag:t+r})),qb=ds($c,yB,nwe),rwe={kernelName:$c,backendName:"cpu",kernelFunc:qb};function lR(e,t,n,r,s){let o=E.sizeFromShape(r),a=E.makeZerosTypedArray(s,n);for(let i=0;i<e.length;i++){let l=e[i];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o>0?a[l]+=t[i]:a[l]+=1)}return a}function bB(e,t,n,r=!1){let s=e.shape[0],o=e.shape[1],a=Wt([s,n],t.dtype);for(let i=0;i<s;i++)for(let l=0;l<o;l++){let u=e.get(i,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?a.set(1,i,u):t.size>0?a.set(a.get(i,u)+t.get(i,l),i,u):a.set(a.get(i,u)+1,i,u))}return a}function np(e){return(t,n,r)=>{let s=E.getTypedArrayFromDType(n,t.length);for(let o=0;o<t.length;++o)s[o]=e(t[o],r);return s}}function In(e,t,n){return({inputs:r,attrs:s,backend:o})=>{let{x:a}=r;if(rt(a,e),a.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=o,l=i.data.get(a.dataId).values,u=E.sizeFromShape(a.shape),c=n||a.dtype,p=E.getArrayFromDType(c,u);for(let d=0;d<u;++d)p[d]=t(l[d],s);return i.makeTensorInfo(a.shape,c,p)}}function V0(e,t,n){return({inputs:r,attrs:s,backend:o})=>{let{x:a}=r;if(rt(a,e),a.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=o,l=i.data.get(a.dataId).values,u=n||a.dtype,c=t(l,u,s);return i.makeTensorInfo(a.shape,u,c)}}var AB=np(e=>Math.ceil(e)),swe=V0(Ud,AB),owe={kernelName:Ud,backendName:"cpu",kernelFunc:swe};function uR(e,t,n,r){let s=E.getArrayFromDType(n,E.sizeFromShape(t));if(r&&n!=="string"){let o=0;e.forEach(a=>{let i=E.sizeFromShape(a.shape);s.set(a.vals,o),o+=i})}else{let o=0;e.forEach(a=>{let i=n==="string"?G.fromUint8ToStringArray(a.vals):a.vals,l=0;for(let u=0;u<a.shape[0];++u){let c=u*t[1]+o;for(let p=0;p<a.shape[1];++p)s[c+p]=i[l++]}o+=a.shape[1]})}return s}var vB=Dr((e,t)=>e===t?1:0),wB=ds(Cg,vB,null,"bool"),awe={kernelName:Cg,backendName:"cpu",kernelFunc:wB},kB=np(e=>Math.exp(e)),IB=V0(Qd,kB),iwe={kernelName:Qd,backendName:"cpu",kernelFunc:IB},CB=np(e=>Math.expm1(e)),lwe=V0(Ng,CB),uwe={kernelName:Ng,backendName:"cpu",kernelFunc:lwe},SB=np(e=>Math.floor(e)),cwe=V0(ef,SB),pwe={kernelName:ef,backendName:"cpu",kernelFunc:cwe};function NB(e,t,n,r,s,o,a,i,l){let u=Wt([r,o],n);for(let c=0;c<r;c++){let p=[],d=0;for(let f=0;f<s;f++){let h=e[c*s+f];d+=h*a[f],p.push(h)}if(d<0||d>=l/o)throw new Error(`Invalid indices: ${p} does not index into ${i}`);for(let f=0;f<o;f++)u.values[c*o+f]=t.get(...t.indexToLoc(d*o+f))}return u}function TB(e,t,n){let r=Wt(n,e.dtype);for(let s=0;s<r.size;++s){let a=r.indexToLoc(s).slice(),i=a[0],l=a[2],u=t.locToIndex([i,l]);a[2]=t.values[u];let c=e.locToIndex(a);r.values[s]=e.values[c]}return r}var _B=Dr((e,t)=>e>t?1:0),dwe=ds(Rg,_B,null,"bool"),fwe={kernelName:Rg,backendName:"cpu",kernelFunc:dwe},EB=Dr((e,t)=>e>=t?1:0),hwe=ds(rf,EB,null,"bool"),mwe={kernelName:rf,backendName:"cpu",kernelFunc:hwe},RB=Dr((e,t)=>e<t?1:0),gwe=ds(Og,RB,null,"bool"),xwe={kernelName:Og,backendName:"cpu",kernelFunc:gwe},DB=Dr((e,t)=>e<=t?1:0),ywe=ds(Pg,DB,null,"bool"),bwe={kernelName:Pg,backendName:"cpu",kernelFunc:ywe};function $B(e,t,n){let r=(t-e)/(n-1),s=E.makeZerosTypedArray(n,"float32");s[0]=e;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}var FB=np(e=>Math.log(e)),Awe=V0(af,FB),vwe={kernelName:af,backendName:"cpu",kernelFunc:Awe};function OB(e,t,n,r){let s=E.getTypedArrayFromDType(r,E.sizeFromShape(n));for(let o=0;o<s.length;++o){let a=o*t,i=e[a];for(let l=0;l<t;++l){let u=e[a+l];(Number.isNaN(u)||u>i)&&(i=u)}s[o]=i}return s}var PB=Dr((e,t)=>Math.max(e,t)),wwe=ds(uf,PB),kwe={kernelName:uf,backendName:"cpu",kernelFunc:wwe},MB=Dr((e,t)=>Math.min(e,t)),Iwe=ds(ff,MB),Cwe={kernelName:ff,backendName:"cpu",kernelFunc:Iwe},cR=Dr((e,t)=>e*t),Swe=iR((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),A5=ds(mf,cR,Swe),Nwe={kernelName:mf,backendName:"cpu",kernelFunc:A5};function zB(e,t,n){let r=E.createScalarValue(-1,n);return cR([],t,r,e,n)}function Twe(e){let{inputs:t,backend:n}=e,{x:r}=t;rt(r,"neg");let s=n.data.get(r.dataId).values,[o,a]=zB(s,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,o)}var _we={kernelName:Bg,backendName:"cpu",kernelFunc:Twe},LB=Dr((e,t)=>e!==t?1:0),Ewe=ds(Vg,LB,null,"bool"),Rwe={kernelName:Vg,backendName:"cpu",kernelFunc:Ewe};function pR(e,t,n,r,s){let o=t.length,a=E.sizeFromShape(t),i=E.computeStrides(t),l=E.computeStrides(s),u=E.getTypedArrayFromDType(n,E.sizeFromShape(s));for(let c=0;c<a;++c){let p=E.indexToLoc(c,o,i),d=new Array(p.length);for(let h=0;h<d.length;h++)d[h]=p[r[h]];let f=E.locToIndex(d,o,l);u[f]=e[c]}return u}function ha(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:o}=n;rt(s,"transpose");let a=s.shape.length,i=new Array(a);for(let p=0;p<i.length;p++)i[p]=s.shape[o[p]];let l=r.data.get(s.dataId).values,u=pR(l,s.shape,s.dtype,o,i);return{dataId:r.write(u,i,s.dtype),shape:i,dtype:s.dtype}}var Dwe={kernelName:Of,backendName:"cpu",kernelFunc:ha};function BB(e,t,n,r){let[s,o]=G.computeOutAndReduceShapes(e,r),a=$a(t,"int32"),i=E.makeZerosTypedArray(E.sizeFromShape(s),a),l=E.sizeFromShape(o);for(let u=0;u<i.length;++u){let c=u*l,p=1;for(let d=0;d<l;++d)p*=n[c+d];i[u]=p}return{outVals:i,outShape:s,outDtype:a}}function $we(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;rt(s,"prod");let i=s.shape.length,l=E.parseAxisParam(o,s.shape),u=G.getAxesPermutation(l,i),c=l,p=s,d=[];u!=null&&(p=ha({inputs:{x:s},backend:n,attrs:{perm:u}}),d.push(p),c=G.getInnerMostAxes(c.length,i));let f=n.data.get(p.dataId).values,{outVals:h,outShape:m,outDtype:g}=BB(p.shape,p.dtype,f,c),x=m;return a&&(x=G.expandShapeToKeepDim(m,l)),d.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(x,g,h)}var Fwe={kernelName:qg,backendName:"cpu",kernelFunc:$we};function dR(e,t,n,r){let s=e===t,o=e<t&&n<0,a=t<e&&n>1;if(s||o||a)return E.makeZerosTypedArray(0,r);let i=Math.abs(Math.ceil((t-e)/n)),l=E.makeZerosTypedArray(i,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var VB=np(e=>1/Math.sqrt(e)),Owe=V0(Cf,VB),Pwe={kernelName:Cf,backendName:"cpu",kernelFunc:Owe},Mwe=np(e=>1/(1+Math.exp(-e))),WB=In(Nf,e=>1/(1+Math.exp(-e))),zwe={kernelName:Nf,backendName:"cpu",kernelFunc:WB};function v5(e,t,n,r,s){let o=Bs.isSliceContinous(r,t,n),a=E.sizeFromShape(n),i=E.computeStrides(r);if(o){let p=Bs.computeFlatOffset(t,i);return s==="string"?e.slice(p,p+a):e.subarray(p,p+a)}let l=s==="string"?G.fromUint8ToStringArray(e):e,u=Wt(r,s,l),c=Wt(n,s);for(let p=0;p<c.size;++p){let d=c.indexToLoc(p),f=d.map((h,m)=>h+t[m]);c.set(u.get(...f),...d)}return s==="string"?G.fromStringArrayToUint8(c.values):c.values}function ph(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,size:a}=r;rt(s,"slice");let[i,l]=Bs.parseSliceParams(s,o,a);Bs.assertParamsValid(s,i,l);let u=n.data.get(s.dataId).values,c=v5(u,i,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}var Lwe={kernelName:Qg,backendName:"cpu",kernelFunc:ph};function GB(e,t,n,r,s,o,a){let i=t[0],l=o[0],u=new Array(l),c=new Array(i),p=t[1];if(l===0){if(i!==0)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${i}`);let g=E.getArrayFromDType(n,0),x=E.getArrayFromDType(s,0);return[g,[0,p],x,u,c]}let d=!0,f=0,h=new Array(l).fill(0);for(let g=0;g<i;++g){let x=e[g*p];if(x<0)throw new Error(`indices(${g}, 0) is invalid: ${x} < 0`);if(x>=l)throw new Error(`indices(${g}, 0) is invalid: ${x} >= ${l}`);++h[x],d=d&&x>=f,f=x}let m=!0;for(let g=0;g<l;++g){let x=h[g]===0;u[g]=x,m=m&&!x,h[g]=Math.max(h[g],1),g>0&&(h[g]+=h[g-1])}if(m&&d){let g=e,x=r;for(let y=0;y<i;++y)c[y]=y;return[g,[i,p],x,u,c]}else{let g=h[l-1],x=E.getArrayFromDType(n,g*p),y=E.getArrayFromDType(s,g),b=new Array(l).fill(0);for(let A=0;A<i;++A){let v=e[A*p],w=b[v],k=(v===0?0:h[v-1])+w;b[v]++;for(let I=0;I<p;++I)x[k*p+I]=e[A*p+I];y[k]=r[A],c[A]=k}for(let A=0;A<l;++A)if(b[A]===0){let w=A===0?0:h[A-1];x[w*p+0]=A;for(let k=1;k<p;++k)x[w*p+k]=0;y[w]=a}return[x,[g,p],y,u,c]}}function UB(e,t,n,r,s){let o=E.sizeFromShape(r),a=t[0],i=s.length,l=[],u=1,c=-1;for(let g=0;g<i;++g){let x=s[g];if(x===-1){if(c!==-1)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,l.push(1)}else{if(x<0)throw new Error(`size ${g} must be non-negative, not ${x}`);u*=x,l.push(x)}}if(c!==-1){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");let g=Math.trunc(o/u);if(u*g!==o)throw new Error(`Input to reshape is a SparseTensor with ${o}
          dense values, but the requested shape requires a multiple of ${u}. inputShape=${r} outputShape= ${l}`);l[c]=g}let p=E.sizeFromShape(l);if(p!==o)throw new Error(`Input to reshape is a tensor with ${o} dense values, but the requested shape has ${p}. inputShape=${r} outputShape=${l}`);let d=r.length,f=[];if(d>0){f[d-1]=1;for(let g=d-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}let h=[];if(i>0){h[i-1]=1;for(let g=i-2;g>=0;--g)h[g]=h[g+1]*l[g+1]}let m=E.getArrayFromDType(n,a*i);for(let g=0;g<a;++g){let x=0;for(let y=0;y<d;++y)x+=e[g*d+y]*f[y];for(let y=0;y<i;++y)m[g*i+y]=Math.trunc(x/h[y]),x%=h[y]}return[m,[a,i],l]}function fR(e,t,n,r,s,o=!1,a=0){let i=r.length;if(i!==s.length)throw new Error("segmentIds and indices should have same size.");let l=[t[0],e.length/t[0]],u=l[1],p=i>0?s[i-1]+1:0;if(p<0)throw new Error("segment ids must be >= 0");let d=t.slice();d[0]=p;let f=d.reduce((b,A)=>b*A,1),h=E.getArrayFromDType(n,f);if(i===0)return p>0&&h.fill(a),[h,d];if(p<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,x=0,y=s[m];for(;;){let b=0;if(g<i){if(b=s[g],y===b){++g;continue}if(y>=b)throw new Error("segment ids are not increasing")}if(y<0||y>=p)throw new Error(`Segment id ${y} out of range [0, ${p}), possibly because segmentIds input is not sorted.`);y>x&&h.fill(a,x*u,y*u);for(let A=m;A<g;++A){let v=r[A];if(v<0||v>=l[0])throw new Error(`Bad: indices[${A}] == ${r[A]} out of range [0, ${l[0]})`);for(let w=0;w<u;w++)h[y*u+w]+=e[v*u+w]}if(o)for(let A=0;A<u;A++)h[y*u+A]/=g-m;if(m=g,++g,x=y+1,y=b,g>i)break}return x<p&&h.fill(a,x*u,p*u),[h,d]}var Bwe=np(e=>Math.sqrt(e)),Vwe=In(Tf,e=>Math.sqrt(e)),Wwe={kernelName:Tf,backendName:"cpu",kernelFunc:Vwe},jB=Dr((e,t)=>{let n=e-t;return n*n}),Gwe=ds(Rf,jB),Uwe={kernelName:Rf,backendName:"cpu",kernelFunc:Gwe};function HB(e,t,n,r){let s=Wt(e,t.dtype);for(let o=0;o<s.size;o++){let a=s.indexToLoc(o),i=new Array(a.length);for(let l=0;l<i.length;l++)i[l]=a[l]*n[l]+r[l];s.set(t.get(...i),...a)}return s}var jwe=class{constructor(e,t,n,r,s,o){this.separator=E.encodeString(e),this.nGramWidths=t,this.leftPad=E.encodeString(n),this.rightPad=E.encodeString(r),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,o){for(let a=0;a<s;++a){let i=this.getPadWidth(o),l=Math.max(0,i-a),u=Math.max(0,i-(s-(a+1))),c=o-(l+u),p=t+(l>0?0:a-i),d=0;d+=l*this.leftPad.length;for(let x=0;x<c;++x)d+=e[p+x].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[r+a]=new Uint8Array(d);let h=n[r+a],m=0,g=x=>x.forEach(y=>h[m++]=y);for(let x=0;x<l;++x)g(this.leftPad),g(this.separator);for(let x=0;x<c-1;++x)g(e[p+x]),g(this.separator);if(c>0){g(e[p+c-1]);for(let x=0;x<u;++x)g(this.separator),g(this.rightPad)}else{for(let x=0;x<u-1;++x)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let i=t[0];if(i!==0)throw new Error(`First split value must be 0, got ${i}`);for(let l=1;l<r;++l){let u=t[l]>=i;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${i}, ${n}]`);i=t[l]}if(i!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${i}`)}let s=r-1,o=E.getArrayFromDType("int32",r);if(n===0||r===0){let i=new Array(n);for(let l=0;l<=s;++l)o[l]=0;return[i,o]}o[0]=0;for(let i=1;i<=s;++i){let l=t[i]-t[i-1],u=0;this.nGramWidths.forEach(c=>{u+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&u===0&&(u=1),o[i]=o[i-1]+u}let a=new Array(o[s]);for(let i=0;i<s;++i){let l=t[i],u=o[i];if(this.nGramWidths.forEach(c=>{let p=t[i+1]-t[i],d=this.getNumNGrams(p,c);this.createNGrams(e,l,a,u,d,c),u+=d}),this.preserveShort&&u===o[i]){let c=t[i+1]-t[i];if(c===0)continue;let p=c+2*this.padWidth,d=1;this.createNGrams(e,l,a,u,d,p)}}return[a,o]}};function qB(e,t,n,r,s,o,a,i){return new jwe(n,r,s,o,a,i).compute(e,t)}function Hwe(e,t,n,r){if(!e.length)return;if(t.length===0){for(let o=0;o<e.length;++o)r.push(e.subarray(o,o+1));return}if(t.length===1){let o=t[0],a=e.indexOf(o);for(;a!==-1;){let i=e.subarray(0,a);(!n||i.length!==0)&&r.push(i),e=e.subarray(a+1),a=e.indexOf(o)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let o=0;o<e.length+1;o++)if(o===e.length||t.indexOf(e[o])!==-1){let a=e.subarray(s,o);(!n||a.length!==0)&&r.push(a),s=o+1}}function KB(e,t,n){let r=e.length,s=[],o=0,a=0,i=new Array(r);for(let d=0;d<r;++d){let f=s.length;Hwe(e[d],t,n,s);let h=s.length-f;i[d]=h,o+=h,a=Math.max(a,h)}let l=E.getArrayFromDType("int32",o*2),u=new Array(o),c=[r,a],p=0;for(let d=0;d<r;++d)for(let f=0;f<i[d];++f)l[p*2]=d,l[p*2+1]=f,u[p]=s[p],++p;return[l,u,c]}function XB(e,t){let n=E.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=E.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var ZB=Dr((e,t)=>e-t),qwe=iR((e,t,n,r)=>({real:e-n,imag:t-r})),hR=ds(Df,ZB,qwe),Kwe={kernelName:Df,backendName:"cpu",kernelFunc:hR};function YB(e,t){let n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];let r=Wt(n,e.dtype);for(let s=0;s<r.values.length;++s){let o=r.indexToLoc(s),a=new Array(e.rank);for(let l=0;l<a.length;l++)a[l]=o[l]%e.shape[l];let i=e.locToIndex(a);r.values[s]=e.values[i]}return r}var Kb=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function JB(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let i=r-n+1,l=t-n+1,u=Math.log(i),c=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*c*(i-c)/i)*Math.sign(l-i/2),d=Math.max(n,Math.floor(t-l*c/i+p)),f=Math.min(r,Math.floor(t+(i-l)*c/i+p));JB(e,t,d,f)}let s=e[t],o=n,a=r;for(E.swap(e,n,t),Kb(e[r],s)>0&&E.swap(e,n,r);o<a;){for(E.swap(e,o,a),o++,a--;Kb(e[o],s)<0;)o=o+1;for(;Kb(e[a],s)>0;)a=a-1}Kb(e[n],s)===0?E.swap(e,n,a):(a=a+1,E.swap(e,a,r)),a<=t&&(n=a+1),t<=a&&(r=a-1)}}function QB(e,t,n,r,s){let o=t[t.length-1],[a,i]=[e.length/o,o],l=E.getTypedArrayFromDType(n,a*r),u=E.getTypedArrayFromDType("int32",a*r);for(let p=0;p<a;p++){let d=p*i,f=e.subarray(d,d+i),h=new Array(f.length);f.forEach((y,b)=>h[b]={value:y,index:b}),r<h.length&&(JB(h,r),h=h.slice(0,r)),s&&h.sort(Kb);let m=p*r,g=l.subarray(m,m+r),x=u.subarray(m,m+r);for(let y=0;y<r;y++)g[y]=h[y].value,x[y]=h[y].index}let c=t.slice();return c[c.length-1]=r,[Wt(c,n,l),Wt(c,"int32",u)]}function eV(e,t,n,r){let s=E.parseAxisParam(t,n)[0],o=[1,n[0],1];for(let h=0;h<s;h++)o[0]*=n[h];o[1]=n[s];for(let h=s+1;h<n.length;h++)o[2]*=n[h];let a={},i=new Int32Array(n[s]),l=new Ur(o,r,e),u=[],c=o[0]===1&&o[2]===1;for(let h=0;h<n[s];h++){let m;if(c)m=e[h].toString();else{let g=[];for(let x=0;x<o[0];x++)for(let y=0;y<o[2];y++)g.push(l.get(x,h,y));m=g.join(",")}if(a[m]!==void 0)i[h]=a[m];else{let g=Object.keys(a).length;a[m]=g,i[h]=g,u.push(h)}}let p=o.slice();p[1]=Object.keys(a).length;let d=new Ur(p,r);u.forEach((h,m)=>{for(let g=0;g<o[0];g++)for(let x=0;x<o[2];x++)d.set(l.get(g,h,x),g,m,x)});let f=n.slice();return f[s]=p[1],{outputValues:d.values,outputShape:f,indices:i}}y0("cpu",()=>new aR,1);var tV=In(Jd,e=>e>=0?e:Math.exp(e)-1),Xwe={kernelName:Jd,backendName:"cpu",kernelFunc:tV};function nV(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:o}=r;rt([s],"leakyRelu");let a=E.sizeFromShape(s.shape),i=n.data.get(s.dataId).values,l=E.getTypedArrayFromDType("float32",a);for(let u=0;u<i.length;u++)l[u]=i[u]<0?o*i[u]:i[u];return n.makeTensorInfo(s.shape,"float32",l)}var Zwe={kernelName:of,backendName:"cpu",kernelFunc:nV},Ywe=Dr((e,t)=>e<0?t*e:e);function rV(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t;rt([r,s],"prelu");let o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,[i,l]=Ywe(r.shape,s.shape,o,a,r.dtype);return n.makeTensorInfo(l,r.dtype,i)}var Jwe={kernelName:bf,backendName:"cpu",kernelFunc:rV},sV=In(Af,e=>Math.max(0,e)),Qwe={kernelName:Af,backendName:"cpu",kernelFunc:sV},oV=In(wf,e=>Math.min(Math.max(0,e),6)),eke={kernelName:wf,backendName:"cpu",kernelFunc:oV};function mR(e,t,n,r,s){if(n==="linear")return hl({inputs:{x:t},backend:e});if(n==="relu")return sV({inputs:{x:t},backend:e});if(n==="elu")return tV({inputs:{x:t},backend:e});if(n==="relu6")return oV({inputs:{x:t},backend:e});if(n==="prelu")return rV({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return nV({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return WB({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Un(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:o}=r,a=E.sizeFromShape(s.shape),i=E.inferFromImplicitShape(o,a),l=E.sizeFromShape(i);E.assert(a===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);let u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,p=u.complexTensorInfos.imag;c.shape=i,p.shape=i}return{dataId:s.dataId,shape:i,dtype:s.dtype}}var tke={kernelName:Xg,backendName:"cpu",kernelFunc:Un};function aV(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o}=t,{transposeA:a,transposeB:i}=r;rt([s,o],"matMul");let l=s.shape.length,u=o.shape.length,c=a?s.shape[l-2]:s.shape[l-1],p=i?o.shape[u-1]:o.shape[u-2],d=a?s.shape[l-1]:s.shape[l-2],f=i?o.shape[u-2]:o.shape[u-1],h=s.shape.slice(0,-2),m=o.shape.slice(0,-2),g=E.sizeFromShape(h),x=E.sizeFromShape(m),y=g===x||g===1||x===1;E.assert(l>=2&&u>=2&&y,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${m}).`);let A=(g>x?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([d,f]);E.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${a} and transposeB=${i} must match.`);let v=a?[g,c,d]:[g,d,c],w=i?[x,f,p]:[x,p,f],k=Un({inputs:{x:s},backend:n,attrs:{shape:v}}),I=Un({inputs:{x:o},backend:n,attrs:{shape:w}}),N=a?k.shape[1]:k.shape[2],T=a?k.shape[2]:k.shape[1],_=i?I.shape[1]:I.shape[2],R=Math.max(g,x),S=n.data.get(k.dataId).values,F=n.data.get(I.dataId).values,B=E.computeStrides(k.shape),W=E.computeStrides(I.shape),[q,K,J]=a?[B[0],1,B[1]]:[B[0],B[1],1],[Q,ee,ue]=i?[1,W[1],W[0]]:[W[1],1,W[0]],re=T*_,de=Wt([R,T,_],k.dtype),fe=de.values,me=n.blockSize;for(let xe=0;xe<R;xe++)for(let Ne=0;Ne<T;Ne+=me)for(let _e=0;_e<_;_e+=me)for(let Oe=0;Oe<N;Oe+=me){let Ve=Math.min(Ne+me,T),He=Math.min(_e+me,_),At=Math.min(Oe+me,N);for(let ft=Ne;ft<Ve;ft++)for(let dt=_e;dt<He;dt++){let ct=0;for(let mt=Oe;mt<At;mt++){let it=Math.min(xe,g-1)*q,Zn=Math.min(xe,x-1)*ue,Dt=S[it+ft*K+mt*J],Yn=F[mt*Q+dt*ee+Zn];ct+=Dt*Yn}fe[xe*re+(ft*_+dt)]+=ct}}return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(A,de.dtype,de.values)}var nke={kernelName:Wd,backendName:"cpu",kernelFunc:aV};function rke(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o,bias:a,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r,d,f,h,m=[];d=aV({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(f=qb({inputs:{a:d,b:a},backend:n}),m.push(d),d=f),c&&(h=mR(n,d,c,i,p),m.push(d),d=h);for(let x of m)n.disposeIntermediateTensorInfo(x);return d}var ske={kernelName:Pf,backendName:"cpu",kernelFunc:rke},oke=In(pg,e=>Math.acos(e)),ake={kernelName:pg,backendName:"cpu",kernelFunc:oke},ike=In(dg,e=>Math.acosh(e)),lke={kernelName:dg,backendName:"cpu",kernelFunc:ike};function uke(e){let{inputs:t,backend:n}=e,r=t;rt(t,"addN");let s=r.map(i=>n.data.get(i.dataId).values),o=Wt(r[0].shape,r[0].dtype),a=o.values;for(let i=0;i<r.length;i++){let l=s[i];for(let u=0;u<a.length;u++)a[u]+=l[u]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}var cke={kernelName:Ld,backendName:"cpu",kernelFunc:uke};function pke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;rt(s,"all");let i=E.parseAxisParam(o,s.shape),l=i,u=G.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=ha({inputs:{x:s},backend:n,attrs:{perm:u}}),l=G.getInnerMostAxes(l.length,s.shape.length)),G.assertAxesAreInnerMostDims("all",l,c.shape.length);let[p,d]=G.computeOutAndReduceShapes(c.shape,l),f=E.sizeFromShape(d),h=E.makeZerosTypedArray(E.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let y=x*f,b=m[y];for(let A=0;A<f;++A){let v=m[y+A];b=b&&v}h[x]=b}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,h);if(a){let x=G.expandShapeToKeepDim(p,i),y=Un({inputs:{x:g},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(g),y}return g}var dke={kernelName:fg,backendName:"cpu",kernelFunc:pke};function fke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;rt(s,"any");let i=E.parseAxisParam(o,s.shape),l=i,u=G.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=ha({inputs:{x:s},backend:n,attrs:{perm:u}}),l=G.getInnerMostAxes(l.length,s.shape.length)),G.assertAxesAreInnerMostDims("any",l,c.shape.length);let[p,d]=G.computeOutAndReduceShapes(c.shape,l),f=E.sizeFromShape(d),h=E.makeZerosTypedArray(E.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let y=x*f,b=m[y];for(let A=0;A<f;++A){let v=m[y+A];b=b||v}h[x]=b}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,h);if(a){let x=G.expandShapeToKeepDim(p,i),y=Un({inputs:{x:g},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(g),y}return g}var hke={kernelName:hg,backendName:"cpu",kernelFunc:fke};function mke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r;rt(s,"argMax");let a=E.parseAxisParam(o,s.shape),i=G.getAxesPermutation(a,s.shape.length),l=s,u=[];i!=null&&(l=ha({inputs:{x:s},backend:n,attrs:{perm:i}}),u.push(l),a=G.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],G.assertAxesAreInnerMostDims("argMax",a,l.shape.length);let[c,p]=G.computeOutAndReduceShapes(l.shape,a),d=E.sizeFromShape(c),f=E.makeZerosTypedArray(d,"int32"),h=E.sizeFromShape(p),m=n.data.get(l.dataId).values;for(let g=0;g<f.length;++g){let x=g*h,y=m[x],b=0;for(let A=0;A<h;++A){let v=m[x+A];v>y&&(y=v,b=A)}f[g]=b}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",f)}var gke={kernelName:Bd,backendName:"cpu",kernelFunc:mke};function xke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r;rt(s,"argMin");let a=E.parseAxisParam(o,s.shape),i=G.getAxesPermutation(a,s.shape.length),l=s,u=[];i!=null&&(l=ha({inputs:{x:s},backend:n,attrs:{perm:i}}),u.push(l),a=G.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],G.assertAxesAreInnerMostDims("argMin",a,l.shape.length);let[c,p]=G.computeOutAndReduceShapes(l.shape,a),d=E.sizeFromShape(c),f=E.makeZerosTypedArray(d,"int32"),h=E.sizeFromShape(p),m=n.data.get(l.dataId).values;for(let g=0;g<f.length;++g){let x=g*h,y=m[x],b=0;for(let A=0;A<h;++A){let v=m[x+A];v<y&&(y=v,b=A)}f[g]=b}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",f)}var yke={kernelName:P1,backendName:"cpu",kernelFunc:xke},bke=In(mg,e=>Math.asin(e)),Ake={kernelName:mg,backendName:"cpu",kernelFunc:bke},vke=In(gg,e=>Math.asinh(e)),wke={kernelName:gg,backendName:"cpu",kernelFunc:vke},kke=In(xg,e=>Math.atan(e)),Ike={kernelName:xg,backendName:"cpu",kernelFunc:kke},Cke=Dr((e,t)=>Math.atan2(e,t)),Ske=ds(bg,Cke),Nke={kernelName:bg,backendName:"cpu",kernelFunc:Ske},Tke=In(yg,e=>Math.atanh(e)),_ke={kernelName:yg,backendName:"cpu",kernelFunc:Tke};function gR(e,t,n,r,s,o){let a=s.strideHeight,i=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,p=s.effectiveFilterWidth,d=s.padInfo.top,f=s.padInfo.left,h=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Wt(s.outShape,n),g=m.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],b=s.outShape[3];for(let A=0;A<s.batchSize;++A){let v=A*x,w=A*r[0];for(let k=0;k<s.inChannels;++k)for(let I=0;I<s.outHeight;++I){let N=I*a-d,T=Math.max(0,N),_=Math.min(s.inHeight,c+N),R=v+I*y;for(let S=0;S<s.outWidth;++S){let F=S*i-f,B=Math.max(0,F),W=Math.min(s.inWidth,p+F),q=h,K=0,J=0;for(let ee=T;ee<_;ee+=l){let ue=w+ee*r[1];for(let re=B;re<W;re+=u){let de=ue+re*r[2],fe=e[de+k];o==="max"&&fe>q?q=fe:o==="avg"&&(K+=fe,J++)}if(isNaN(q))break}let Q=R+S*b+k;g[Q]=o==="avg"?K/J:q}}}return m}function iV(e,t,n,r,s=!1,o=!1){let a=Wt(r.outShape,"int32"),i=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,f=r.padInfo.top,h=r.padInfo.left,m=Wt(t,n,e);for(let g=0;g<r.batchSize;++g)for(let x=0;x<r.inChannels;++x)for(let y=0;y<r.outHeight;++y){let b=y*i-f,A=b;for(;A<0;)A+=u;let v=Math.min(r.inHeight,p+b);for(let w=0;w<r.outWidth;++w){let k=w*l-h,I=k;for(;I<0;)I+=c;let N=Math.min(r.inWidth,d+k),T=Number.NEGATIVE_INFINITY,_=-1;for(let R=A;R<v;R+=u){let S=R-b;for(let F=I;F<N;F+=c){let B=F-k,W=m.get(g,R,F,x);W>T&&(T=W,s?_=o?((g*r.inHeight+R)*r.inWidth+F)*r.inChannels+x:(R*r.inWidth+F)*r.inChannels+x:_=S*d+B)}}a.set(_,g,y,w,x)}}return a}function lV(e,t,n,r,s,o){let a=s.strideDepth,i=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,p=s.dilationWidth,d=s.effectiveFilterDepth,f=s.effectiveFilterHeight,h=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,x=s.padInfo.left,y=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=Wt(s.outShape,n),A=b.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],w=s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let N=0;N<s.batchSize;++N){let T=N*v,_=N*r[0];for(let R=0;R<s.inChannels;++R)for(let S=0;S<s.outDepth;++S){let F=S*a-m,B=F;for(;B<0;)B+=u;let W=Math.min(s.inDepth,d+F),q=T+S*w;for(let K=0;K<s.outHeight;++K){let J=K*i-g,Q=J;for(;Q<0;)Q+=c;let ee=Math.min(s.inHeight,f+J),ue=q+K*k;for(let re=0;re<s.outWidth;++re){let de=re*l-x,fe=de;for(;fe<0;)fe+=p;let me=Math.min(s.inWidth,h+de),xe=ue+re*I,Ne=y,_e=0,Oe=0;for(let He=B;He<W;He+=u){let At=_+He*r[1];for(let ft=Q;ft<ee;ft+=c){let dt=At+ft*r[2];for(let ct=fe;ct<me;ct+=p){let mt=dt+ct*r[3],it=e[mt+R];if(o==="max"&&it>Ne?Ne=it:o==="avg"&&(_e+=it,Oe++),isNaN(Ne))break}if(isNaN(Ne))break}if(isNaN(Ne))break}let Ve=xe+R;A[Ve]=o==="avg"?_e/Oe:Ne}}}}return b}function Eke(e,t){let n=Wt(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,i=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,d=t.padInfo.front,f=t.padInfo.top,h=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let x=0;x<t.outDepth;++x){let y=x*r-d,b=y;for(;b<0;)b+=a;let A=Math.min(t.inDepth,u+y);for(let v=0;v<t.outHeight;++v){let w=v*s-f,k=w;for(;k<0;)k+=i;let I=Math.min(t.inHeight,c+w);for(let N=0;N<t.outWidth;++N){let T=N*o-h,_=T;for(;_<0;)_+=l;let R=Math.min(t.inWidth,p+T),S=Number.NEGATIVE_INFINITY,F=-1;for(let B=b;B<A;B+=a){let W=B-y;for(let q=k;q<I;q+=i){let K=q-w;for(let J=_;J<R;J+=l){let Q=J-T,ee=e.get(m,B,q,J,g);ee>=S&&(S=ee,F=W*c*p+K*c+Q)}}}n.set(F,m,x,v,N,g)}}}return n}function Rke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;rt(s,"avgPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,u=1;E.assert(G.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=G.computePool2DInfo(s.shape,o,a,u,i,l),p;if(c.filterWidth===1&&c.filterHeight===1&&E.arraysEqual(c.inShape,c.outShape))p=hl({inputs:{x:s},backend:n});else{let d=n.data.get(s.dataId).values,f=E.computeStrides(s.shape),h=gR(d,s.shape,s.dtype,f,c,"avg");p=n.makeTensorInfo(c.outShape,s.dtype,h.values)}return p}var Dke={kernelName:Vd,backendName:"cpu",kernelFunc:Rke};function $ke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=r;rt(s,"avgPool3d");let c=G.computePool3DInfo(s.shape,o,a,1,i,l,u),p=n.data.get(s.dataId).values,d=lV(p,s.shape,s.dtype,E.computeStrides(s.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var Fke={kernelName:M1,backendName:"cpu",kernelFunc:$ke};function Oke(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=r;rt([s,o],"avgPool3DGrad");let c=G.computePool3DInfo(o.shape,a,i,1,l,u),p=c.strideDepth,d=c.strideHeight,f=c.strideWidth,h=c.filterDepth,m=c.filterHeight,g=c.filterWidth,x=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,A=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,k=A-1-c.padInfo.front,I=w-1-c.padInfo.left,N=v-1-c.padInfo.top,T=Wt(o.shape,"float32"),_=1/(h*m*g),R=n.bufferSync(s);for(let S=0;S<c.batchSize;++S)for(let F=0;F<c.inChannels;++F)for(let B=0;B<c.inDepth;++B)for(let W=0;W<c.inHeight;++W)for(let q=0;q<c.inWidth;++q){let K=B-k,J=W-N,Q=q-I,ee=0;for(let ue=0;ue<A;ue+=x){let re=(K+ue)/p;if(!(re<0||re>=c.outDepth||Math.floor(re)!==re))for(let de=0;de<v;de+=y){let fe=(J+de)/d;if(!(fe<0||fe>=c.outHeight||Math.floor(fe)!==fe))for(let me=0;me<w;me+=b){let xe=(Q+me)/f;if(xe<0||xe>=c.outWidth||Math.floor(xe)!==xe)continue;ee+=R.get(S,re,fe,xe,F)}}}T.set(ee*_,S,B,W,q,F)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var Pke={kernelName:tw,backendName:"cpu",kernelFunc:Oke};function Mke(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,a=o;rt([s,o],"avgPoolGrad");let{filterSize:i,strides:l,pad:u}=r,c=G.computePool2DInfo(a.shape,i,l,1,u),p=c.strideHeight,d=c.strideWidth,f=c.filterHeight,h=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,x=c.effectiveFilterHeight,y=c.effectiveFilterWidth,b=y-1-c.padInfo.left,A=x-1-c.padInfo.top,v=Wt(a.shape,"float32"),w=1/(f*h),k=n.data.get(s.dataId).values,I=Wt(s.shape,"float32",k);for(let N=0;N<c.batchSize;++N)for(let T=0;T<c.inChannels;++T)for(let _=0;_<c.inHeight;++_)for(let R=0;R<c.inWidth;++R){let S=_-A,F=R-b,B=0;for(let W=0;W<x;W+=m){let q=(S+W)/p;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(let K=0;K<y;K+=g){let J=(F+K)/d;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;B+=I.get(N,q,J,T)}}v.set(B*w,N,_,R,T)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var zke={kernelName:ew,backendName:"cpu",kernelFunc:Mke};function Lke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,scale:o,offset:a,mean:i,variance:l}=t;E.assert(i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E.assert(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),rt([s,i,l,o,a],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let c=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values,d=n.data.get(l.dataId).values,f=o?n.data.get(o.dataId).values:new Float32Array([1]),h=a?n.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=h.length,x=f.length,y=d.length,b=p.length,A=0,v=0,w=0,k=0;for(let I=0;I<c.length;++I)m[I]=h[A++]+(c[I]-p[v++])*f[w++]/Math.sqrt(d[k++]+u),A>=g&&(A=0),v>=b&&(v=0),w>=x&&(w=0),k>=y&&(k=0);return n.makeTensorInfo(s.shape,s.dtype,m)}var Bke={kernelName:nf,backendName:"cpu",kernelFunc:Lke};function Vke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,crops:a}=r;rt([s],"batchToSpaceND");let i=o.reduce((x,y)=>x*y),l=G.getReshaped(s.shape,o,i),u=G.getPermuted(l.length,o.length),c=G.getReshapedPermuted(s.shape,o,i),p=G.getSliceBeginCoords(a,o.length),d=G.getSliceSize(c,a,o.length),f=Un({inputs:{x:s},backend:n,attrs:{shape:l}}),h=ha({inputs:{x:f},backend:n,attrs:{perm:u}}),m=Un({inputs:{x:h},backend:n,attrs:{shape:c}}),g=ph({inputs:{x:m},backend:n,attrs:{begin:p,size:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var Wke={kernelName:Ag,backendName:"cpu",kernelFunc:Vke};function Gke(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:a}=r,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,u=lR(i,l,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,u)}var Uke={kernelName:nw,backendName:"cpu",kernelFunc:Gke};function jke(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,i=G.assertAndGetBroadcastShape(Array.from(o),Array.from(a));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var Hke={kernelName:ET,backendName:"cpu",kernelFunc:jke},qke=In(Fc,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),Kke={kernelName:Fc,backendName:"cpu",kernelFunc:qke},Xke=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(E.sizeFromShape(t.shape)),s=n.data.get(t.dataId),o=s.complexTensorInfos.real,a=s.complexTensorInfos.imag,i=n.data.get(o.dataId).values,l=n.data.get(a.dataId).values;for(let u=0;u<i.length;u++){let c=i[u],p=l[u];r[u]=Math.hypot(c,p)}return n.makeOutput(r,t.shape,"float32")},Zke={kernelName:z1,backendName:"cpu",kernelFunc:Xke};function W0(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}var Yke={kernelName:xw,backendName:"cpu",kernelFunc:W0};function G0(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,o=E.parseAxisParam(s,t[0].shape)[0],a=G.computeOutShape(t.map(m=>m.shape),o);if(E.sizeFromShape(a)===0)return n.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(m=>E.sizeFromShape(m.shape)>0);if(i.length===1)return hl({inputs:{x:i[0]},backend:n});let l=i.map(m=>m.shape);if(G.assertParamsConsistent(l,o),i[0].dtype==="complex64"){let m=i.map(A=>ch({inputs:{input:A},backend:n})),g=i.map(A=>W0({inputs:{input:A},backend:n})),x=G0({inputs:m,backend:n,attrs:{axis:o}}),y=G0({inputs:g,backend:n,attrs:{axis:o}}),b=Ko({inputs:{real:x,imag:y},backend:n});return m.forEach(A=>n.disposeIntermediateTensorInfo(A)),g.forEach(A=>n.disposeIntermediateTensorInfo(A)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(y),b}let u=i.map(m=>{let g=E.sizeFromShape(m.shape.slice(o));return Un({inputs:{x:m},backend:n,attrs:{shape:[-1,g]}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));a=G.computeOutShape(u.map(m=>m.shape),1);let p=u[0].shape[0]===1,d=uR(c,a,t[0].dtype,p),f=G.computeOutShape(i.map(m=>m.shape),o),h=n.makeTensorInfo(f,t[0].dtype,d);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var Jke={kernelName:vg,backendName:"cpu",kernelFunc:G0};function uV(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=r;rt([s,o],"conv2d");let p=G.convertConv2DDataFormat(l),d=G.computeConv2DInfo(s.shape,o.shape,a,u,i,c,!1,p),f=d.filterHeight,h=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,x=d.padInfo.left,y=d.padInfo.top,b=d.dataFormat==="channelsLast",A=new Ur(d.outShape,s.dtype),v=E.computeStrides(s.shape),w=E.computeStrides(o.shape),k=v[0],I=b?v[1]:v[2],N=b?v[2]:1,T=b?1:v[1],_=A.strides[0],R=b?A.strides[1]:A.strides[2],S=b?A.strides[2]:1,F=b?1:A.strides[1],B=n.data.get(s.dataId).values,W=n.data.get(o.dataId).values,q=A.values;for(let K=0;K<d.batchSize;++K){let J=K*k,Q=K*_;for(let ee=0;ee<d.outHeight;++ee){let ue=Q+ee*R,re=ee*d.strideHeight-y;for(let de=0;de<f;++de){let fe=re+de*m;if(fe<0||fe>=d.inHeight)continue;let me=de*w[0],xe=J+fe*I;for(let Ne=0;Ne<d.outWidth;++Ne){let _e=ue+Ne*S,Oe=Ne*d.strideWidth-x;for(let Ve=0;Ve<h;++Ve){let He=Oe+Ve*g;if(He<0||He>=d.inWidth)continue;let At=me+Ve*w[1],ft=xe+He*N,dt=At;for(let ct=0;ct<d.inChannels;++ct){let mt=B[ft+ct*T];for(let it=0;it<d.outChannels;++it)q[_e+it*F]+=mt*W[dt+it];dt+=d.outChannels}}}}}}return n.makeTensorInfo(A.shape,A.dtype,q)}var Qke={kernelName:jd,backendName:"cpu",kernelFunc:uV};function e5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;rt([s,o],"conv2dBackpropFilter");let p=G.convertConv2DDataFormat(l),d=G.computeConv2DInfo(s.shape,c,a,1,i,u,!1,p),{strideHeight:f,strideWidth:h,filterHeight:m,filterWidth:g}=d,x=d.dataFormat==="channelsLast",y=new Ur(d.filterShape,"float32"),b=d.padInfo.left,A=d.padInfo.top,v=n.data.get(s.dataId).values,w=n.data.get(o.dataId).values,k=new Ur(s.shape,s.dtype,v),I=new Ur(o.shape,o.dtype,w);for(let N=0;N<m;++N){let T=Math.max(0,Math.ceil((A-N)/f)),_=Math.min(d.outHeight,(d.inHeight+A-N)/f);for(let R=0;R<g;++R){let S=Math.max(0,Math.ceil((b-R)/h)),F=Math.min(d.outWidth,(d.inWidth+b-R)/h);for(let B=0;B<d.inChannels;++B)for(let W=0;W<d.outChannels;++W){let q=0;for(let K=0;K<d.batchSize;++K)for(let J=T;J<_;++J){let Q=N+J*f-A;for(let ee=S;ee<F;++ee){let ue=R+ee*h-b;x?q+=k.get(K,Q,ue,B)*I.get(K,J,ee,W):q+=k.get(K,B,Q,ue)*I.get(K,W,J,ee)}}y.set(q,N,R,B,W)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var t5e={kernelName:sw,backendName:"cpu",kernelFunc:e5e};function n5e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=r;rt([s,o],"conv2dBackpropInput");let p=E.computeStrides(o.shape),d=E.computeStrides(s.shape),f=G.convertConv2DDataFormat(u),h=G.computeConv2DInfo(a,o.shape,i,1,l,c,!1,f),m=new Ur(h.inShape,"float32"),g=m.values,x=n.data.get(s.dataId).values,y=n.data.get(o.dataId).values,[b,A,v]=p,{batchSize:w,filterHeight:k,filterWidth:I,inChannels:N,inHeight:T,inWidth:_,outChannels:R,outHeight:S,outWidth:F,strideHeight:B,strideWidth:W}=h;f=h.dataFormat;let q=k-1-h.padInfo.top,K=I-1-h.padInfo.left,J=f==="channelsLast",Q=m.strides[0],ee=J?m.strides[1]:m.strides[2],ue=J?m.strides[2]:1,re=J?1:m.strides[1],de=d[0],fe=J?d[1]:d[2],me=J?d[2]:1,xe=J?1:d[1];for(let Ne=0;Ne<w;++Ne)for(let _e=0;_e<N;++_e)for(let Oe=0;Oe<T;++Oe){let Ve=Oe-q,He=Math.max(0,Math.ceil(Ve/B)),At=Math.min(S,(k+Ve)/B);for(let ft=0;ft<_;++ft){let dt=ft-K,ct=Math.max(0,Math.ceil(dt/W)),mt=Math.min(F,(I+dt)/W),it=0;for(let Dt=He;Dt<At;++Dt){let Yn=Dt*B-Ve;for(let cn=ct;cn<mt;++cn){let Vr=cn*W-dt,_n=de*Ne+fe*Dt+me*cn,hr=b*(k-1-Yn)+A*(I-1-Vr)+v*_e;for(let Ar=0;Ar<R;++Ar){let Pn=x[_n+xe*Ar],vr=y[hr+Ar];it+=Pn*vr}}}let Zn=Q*Ne+ee*Oe+ue*ft+re*_e;g[Zn]=it}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var r5e={kernelName:Hd,backendName:"cpu",kernelFunc:n5e};function s5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l}=r;rt([s,o],"conv3d");let u=G.computeConv3DInfo(s.shape,o.shape,a,l,i),{filterDepth:c,filterHeight:p,filterWidth:d,dilationDepth:f,dilationHeight:h,dilationWidth:m,padInfo:g}=u,x=g.front,y=g.left,b=g.top,A=new Ur(u.outShape,s.dtype),v=n.data.get(s.dataId).values,w=n.data.get(o.dataId).values,k=A.values,I=E.computeStrides(s.shape),N=E.computeStrides(o.shape);for(let T=0;T<u.batchSize;++T){let _=T*I[0],R=T*A.strides[0];for(let S=0;S<u.outDepth;++S){let F=R+S*A.strides[1],B=S*u.strideDepth-x;for(let W=0;W<c;++W){let q=B+W*f;if(q<0||q>=u.inDepth)continue;let K=W*N[0],J=_+q*I[1];for(let Q=0;Q<u.outHeight;++Q){let ee=F+Q*A.strides[2],ue=Q*u.strideHeight-b;for(let re=0;re<p;++re){let de=ue+re*h;if(de<0||de>=u.inHeight)continue;let fe=K+re*N[1],me=J+de*I[2];for(let xe=0;xe<u.outWidth;++xe){let Ne=ee+xe*u.outChannels,_e=xe*u.strideWidth-y;for(let Oe=0;Oe<d;++Oe){let Ve=_e+Oe*m;if(Ve<0||Ve>=u.inWidth)continue;let He=fe+Oe*N[2],At=me+Ve*u.inChannels,ft=He;for(let dt=0;dt<u.inChannels;++dt){let ct=v[At+dt];for(let mt=0;mt<u.outChannels;++mt)k[Ne+mt]+=ct*w[ft+mt];ft+=u.outChannels}}}}}}}}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var o5e={kernelName:L1,backendName:"cpu",kernelFunc:s5e};function a5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,pad:i,filterShape:l}=r;rt([s,o],"conv3dBackpropFilterV2");let u=E.computeStrides(s.shape),c=E.computeStrides(o.shape),p=G.computeConv3DInfo(s.shape,l,a,1,i),d=p.strideDepth,f=p.strideHeight,h=p.strideWidth,m=p.filterDepth,g=p.filterHeight,x=p.filterWidth,y=new Ur(p.filterShape,"float32"),b=y.values,[A,v,w,k]=y.strides,I=n.data.get(o.dataId).values,[N,T,_,R]=c,S=n.data.get(s.dataId).values,[F,B,W,q]=u,K=p.padInfo.front,J=p.padInfo.left,Q=p.padInfo.top;for(let ee=0;ee<m;++ee){let ue=Math.max(0,Math.ceil((K-ee)/d)),re=Math.min(p.outDepth,(p.inDepth+K-ee)/d),de=ee*A;for(let fe=0;fe<g;++fe){let me=Math.max(0,Math.ceil((Q-fe)/f)),xe=Math.min(p.outHeight,(p.inHeight+Q-fe)/f),Ne=fe*v+de;for(let _e=0;_e<x;++_e){let Oe=Math.max(0,Math.ceil((J-_e)/h)),Ve=Math.min(p.outWidth,(p.inWidth+J-_e)/h),He=_e*w+Ne;for(let At=0;At<p.inChannels;++At){let ft=At*k+He;for(let dt=0;dt<p.outChannels;++dt){let ct=0;for(let mt=0;mt<p.batchSize;++mt){let it=mt*F,Zn=mt*N;for(let Dt=ue;Dt<re;++Dt){let cn=(ee+Dt*d-K)*B+it,Vr=Dt*T+Zn;for(let _n=me;_n<xe;++_n){let Ar=(fe+_n*f-Q)*W+cn,Pn=_n*_+Vr;for(let vr=Oe;vr<Ve;++vr){let ys=(_e+vr*h-J)*q+Ar,Oo=vr*R+Pn;ct+=S[ys+At]*I[Oo+dt]}}}}b[ft+dt]=ct}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var i5e={kernelName:ow,backendName:"cpu",kernelFunc:a5e};function l5e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{pad:a,strides:i,inputShape:l}=r;rt([s],"conv3dBackpropInputV2");let u=E.computeStrides(s.shape),c=E.computeStrides(o.shape),p=G.computeConv3DInfo(l,o.shape,i,1,a),d=new Ur(p.inShape,"float32"),f=d.values,[h,m,g,x]=d.strides,y=n.data.get(s.dataId).values,[b,A,v,w]=u,k=n.data.get(o.dataId).values,[I,N,T,_]=c,{batchSize:R,filterDepth:S,filterHeight:F,filterWidth:B,inChannels:W,inDepth:q,inHeight:K,inWidth:J,outChannels:Q,outDepth:ee,outHeight:ue,outWidth:re,strideDepth:de,strideHeight:fe,strideWidth:me}=p,xe=S-1-p.padInfo.front,Ne=F-1-p.padInfo.top,_e=B-1-p.padInfo.left;for(let Oe=0;Oe<R;++Oe)for(let Ve=0;Ve<W;++Ve)for(let He=0;He<q;++He){let At=He-xe,ft=Math.max(0,Math.ceil(At/de)),dt=Math.min(ee,(S+At)/de);for(let ct=0;ct<K;++ct){let mt=ct-Ne,it=Math.max(0,Math.ceil(mt/fe)),Zn=Math.min(ue,(F+mt)/fe);for(let Dt=0;Dt<J;++Dt){let Yn=Dt-_e,cn=Math.max(0,Math.ceil(Yn/me)),Vr=Math.min(re,(B+Yn)/me),_n=0;for(let hr=ft;hr<dt;++hr){let Ar=hr*de-At;for(let Pn=it;Pn<Zn;++Pn){let vr=Pn*fe-mt;for(let rs=cn;rs<Vr;++rs){let ys=rs*me-Yn,Oo=b*Oe+A*hr+v*Pn+w*rs,di=I*(S-1-Ar)+N*(F-1-vr)+T*(B-1-ys)+_*Ve;for(let ca=0;ca<Q;++ca){let kc=y[Oo+ca],_a=k[di+ca];_n+=kc*_a}}}}f[h*Oe+m*He+g*ct+x*Dt+Ve]=_n}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var u5e={kernelName:aw,backendName:"cpu",kernelFunc:l5e},c5e=In(qd,e=>Math.cos(e)),p5e={kernelName:qd,backendName:"cpu",kernelFunc:c5e},d5e=In(Kd,e=>Math.cosh(e)),f5e={kernelName:Kd,backendName:"cpu",kernelFunc:d5e};function h5e(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:o,boxInd:a}=t,{cropSize:i,method:l,extrapolationValue:u}=r,[c,p,d,f]=s.shape,h=o.shape[0],[m,g]=i,x=Wt([h,m,g,f],"float32"),y=n.data.get(o.dataId).values,b=n.data.get(a.dataId).values,A=n.data.get(s.dataId).values,v=E.computeStrides(s.shape),w=E.computeStrides(x.shape);for(let k=0;k<h;k++){let I=k*4,N=y[I],T=y[I+1],_=y[I+2],R=y[I+3],S=b[k];if(S>=c)continue;let F=m>1?(_-N)*(p-1)/(m-1):0,B=g>1?(R-T)*(d-1)/(g-1):0;for(let W=0;W<m;W++){let q=m>1?N*(p-1)+W*F:.5*(N+_)*(p-1);if(q<0||q>p-1){for(let K=0;K<g;K++)for(let J=0;J<f;J++){let Q=J+K*w[2]+W*w[1]+k*w[0];x.values[Q]=u}continue}if(l==="bilinear"){let K=Math.floor(q),J=Math.ceil(q),Q=q-K;for(let ee=0;ee<g;ee++){let ue=g>1?T*(d-1)+ee*B:.5*(T+R)*(d-1);if(ue<0||ue>d-1){for(let me=0;me<f;me++){let xe=me+ee*w[2]+W*w[1]+k*w[0];x.values[xe]=u}continue}let re=Math.floor(ue),de=Math.ceil(ue),fe=ue-re;for(let me=0;me<f;me++){let xe=me+re*v[2]+K*v[1]+S*v[0],Ne=A[xe];xe=me+de*v[2]+K*v[1]+S*v[0];let _e=A[xe];xe=me+re*v[2]+J*v[1]+S*v[0];let Oe=A[xe];xe=me+de*v[2]+J*v[1]+S*v[0];let Ve=A[xe],He=Ne+(_e-Ne)*fe,At=Oe+(Ve-Oe)*fe;xe=me+ee*w[2]+W*w[1]+k*w[0],x.values[xe]=He+(At-He)*Q}}}else for(let K=0;K<g;++K){let J=g>1?T*(d-1)+K*B:.5*(T+R)*(d-1);if(J<0||J>d-1){for(let ue=0;ue<f;ue++){let re=ue+K*w[2]+W*w[1]+k*w[0];x.values[re]=u}continue}let Q=Math.round(J),ee=Math.round(q);for(let ue=0;ue<f;ue++){let re=ue+Q*v[2]+ee*v[1]+S*v[0],de=ue+K*w[2]+W*w[1]+k*w[0];x.values[de]=A[re]}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var m5e={kernelName:wg,backendName:"cpu",kernelFunc:h5e};function g5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,exclusive:a,reverse:i}=r;rt(s,"cumsum");let l=G.getAxesPermutation([o],s.shape.length),u=s;l!=null&&(u=ha({inputs:{x:s},backend:n,attrs:{perm:l}}));let c=G.getInnerMostAxes(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=$a(u.dtype,"int32"),d=E.makeZerosTypedArray(E.sizeFromShape(u.shape),p),f=n.data.get(u.dataId).values,h=u.shape[u.shape.length-1],m=i?(x,y)=>x+h-y-1:(x,y)=>x+y;for(let x=0;x<f.length;x+=h)for(let y=0;y<h;y++){let b=m(x,y);if(y===0)d[b]=a?0:f[b];else{let A=m(x,y-1);d[b]=a?f[A]+d[A]:f[b]+d[A]}}let g=n.makeTensorInfo(u.shape,p,d);if(l!=null){let x=G.getUndoAxesPermutation(l),y=ha({inputs:{x:g},backend:n,attrs:{perm:x}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),y}return g}var x5e={kernelName:Xd,backendName:"cpu",kernelFunc:g5e};function y5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:a,binaryOutput:i}=r;if(s.shape.length===1){let l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,c=lR(l,u,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(o),c=bB(l,u,a,i);return n.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var b5e={kernelName:iw,backendName:"cpu",kernelFunc:y5e};function A5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:o,dataFormat:a}=r;E.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`),E.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let i=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],p=l*o,d=u*o,f=c/(o*o),h=n.data.get(s.dataId).values,m=new Float32Array(i*p*d*f),g=0;for(let x=0;x<i;++x)for(let y=0;y<p;++y){let b=Math.floor(y/o),A=y%o;for(let v=0;v<d;++v){let w=Math.floor(v/o),k=v%o,I=(A*o+k)*f;for(let N=0;N<f;++N){let _=N+I+c*(w+u*(b+l*x));m[g++]=h[_]}}}return n.makeTensorInfo([i,p,d,f],s.dtype,m)}var v5e={kernelName:kg,backendName:"cpu",kernelFunc:A5e};function cV(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=r;rt([s,o],"depthwiseConv2DNative");let c=E.computeStrides(s.shape),p=E.computeStrides(o.shape),d=l;d==null&&(d=[1,1]),E.assert(G.eitherStridesOrDilationsAreOne(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);let f=G.computeConv2DInfo(s.shape,o.shape,a,d,i,u,!0),{filterHeight:h,filterWidth:m,dilationHeight:g,dilationWidth:x,padInfo:y}=f,b=y.left,A=y.top,v=f.outChannels/f.inChannels,w=new Ur(f.outShape,s.dtype),k=n.data.get(s.dataId).values,I=n.data.get(o.dataId).values,N=w.values;for(let T=0;T<f.batchSize;++T){let _=T*c[0],R=T*w.strides[0];for(let S=0;S<f.outHeight;++S){let F=R+S*w.strides[1],B=S*f.strideHeight-A;for(let W=0;W<h;++W){let q=B+W*g;if(q<0||q>=f.inHeight)continue;let K=W*p[0],J=_+q*c[1];for(let Q=0;Q<f.outWidth;++Q){let ee=F+Q*w.strides[2],ue=Q*f.strideWidth-b;for(let re=0;re<m;++re){let de=ue+re*x;if(de<0||de>=f.inWidth)continue;let fe=K+re*p[1],me=J+de*f.inChannels,xe=ee,Ne=fe;for(let _e=0;_e<f.inChannels;++_e){let Oe=k[me+_e];for(let Ve=0;Ve<v;++Ve)N[xe+Ve]+=Oe*I[Ne+Ve];xe+=v,Ne+=v}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var w5e={kernelName:Zd,backendName:"cpu",kernelFunc:cV};function k5e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=r;rt([s,o],"depthwiseConv2dNativeBackpropFilter");let p=G.computeConv2DInfo(s.shape,c,a,i,l,u,!0),{strideHeight:d,strideWidth:f,filterHeight:h,filterWidth:m}=p,g=new Ur(p.filterShape,"float32"),x=p.padInfo.left,y=p.padInfo.top,b=p.outChannels/p.inChannels,A=n.data.get(s.dataId).values,v=new Ur(s.shape,s.dtype,A),w=n.data.get(o.dataId).values,k=new Ur(o.shape,o.dtype,w);for(let I=0;I<h;++I){let N=Math.max(0,Math.ceil((y-I)/d)),T=Math.min(p.outHeight,(p.inHeight+y-I)/d);for(let _=0;_<m;++_){let R=Math.max(0,Math.ceil((x-_)/f)),S=Math.min(p.outWidth,(p.inWidth+x-_)/f);for(let F=0;F<p.outChannels;++F){let B=Math.trunc(F/b),W=F%b,q=0;for(let K=0;K<p.batchSize;++K)for(let J=N;J<T;++J){let Q=I+J*d-y;for(let ee=R;ee<S;++ee){let ue=_+ee*f-x;q+=v.get(K,Q,ue,B)*k.get(K,J,ee,F)}}g.set(q,I,_,B,W)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var I5e={kernelName:lw,backendName:"cpu",kernelFunc:k5e};function C5e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=r;rt([s,o],"depthwiseConv2DNativeBackpropInput");let p=E.computeStrides(s.shape),d=E.computeStrides(o.shape),f=G.computeConv2DInfo(c,o.shape,a,i,l,u,!0),h=new Ur(f.inShape,"float32"),m=h.values,[g,x,y]=h.strides,b=n.data.get(s.dataId).values,[A,v,w]=p,k=n.data.get(o.dataId).values,[I,N,T]=d,{batchSize:_,filterHeight:R,filterWidth:S,inChannels:F,inHeight:B,inWidth:W,outChannels:q,outHeight:K,outWidth:J,strideHeight:Q,strideWidth:ee}=f,ue=R-1-f.padInfo.top,re=S-1-f.padInfo.left,de=q/F;for(let fe=0;fe<_;++fe)for(let me=0;me<F;++me)for(let xe=0;xe<B;++xe){let Ne=xe-ue,_e=Math.max(0,Math.ceil(Ne/Q)),Oe=Math.min(K,(R+Ne)/Q);for(let Ve=0;Ve<W;++Ve){let He=Ve-re,At=Math.max(0,Math.ceil(He/ee)),ft=Math.min(J,(S+He)/ee),dt=0;for(let ct=_e;ct<Oe;++ct){let mt=ct*Q-Ne;for(let it=At;it<ft;++it){let Zn=it*ee-He,Dt=A*fe+v*ct+w*it,Yn=I*(R-1-mt)+N*(S-1-Zn)+T*me;for(let cn=0;cn<de;++cn){let Vr=me*de+cn,_n=b[Dt+Vr],hr=k[Yn+cn];dt+=_n*hr}}}m[g*fe+x*xe+y*Ve+me]=dt}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}var S5e={kernelName:uw,backendName:"cpu",kernelFunc:C5e};function N5e(e){let{inputs:t,backend:n}=e,{x:r}=t,s=E.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,a=Wt([s,s],r.dtype),i=a.values;for(let u=0;u<o.length;u++)i[u*s+u]=o[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,a.dtype,a.values)}var T5e={kernelName:cw,backendName:"cpu",kernelFunc:N5e},_5e={kernelName:B1,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s}=e,{strides:o,pad:a,dilations:i}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,p=l.data.get(s.dataId).values,d=s.shape.length,{batchSize:f,inHeight:h,inWidth:m,inChannels:g,outHeight:x,outWidth:y,padInfo:b,strideHeight:A,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:T}=G.computeDilation2DInfo(r.shape,s.shape,o,a,"NHWC",i),_=E.sizeFromShape(T),R=T.length,S=E.getArrayFromDType(r.dtype,_);for(let B=0;B<f;++B)for(let W=0;W<x;++W){let q=W*A-b.top;for(let K=0;K<y;++K){let J=K*v-b.left;for(let Q=0;Q<g;++Q){let ee=Number.MIN_SAFE_INTEGER;for(let re=0;re<w;++re){let de=q+re*I;if(de>=0&&de<h)for(let fe=0;fe<k;++fe){let me=J+fe*N;if(me>=0&&me<m){let xe=E.locToIndex([B,de,me,Q],c,E.computeStrides(r.shape)),Ne=E.locToIndex([re,fe,Q],d,E.computeStrides(s.shape)),_e=u[xe]+p[Ne];_e>ee&&(ee=_e)}}}let ue=E.locToIndex([B,W,K,Q],R,E.computeStrides(T));S[ue]=ee}}}return{dataId:l.write(E.toTypedArray(S,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},E5e={kernelName:dw,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:o}=e,{strides:a,pad:i,dilations:l}=n,u=t,c=E.toNestedArray(r.shape,u.data.get(r.dataId).values),p=E.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:f,inWidth:h,inChannels:m,outHeight:g,outWidth:x,padInfo:y,strideHeight:b,strideWidth:A,filterHeight:v,filterWidth:w,dilationHeight:k,dilationWidth:I,outShape:N}=G.computeDilation2DInfo(r.shape,s.shape,a,i,"NHWC",l);E.assert(o.rank===N.length,()=>`Error in ${dw}, dy must have the same rank as output ${N.length}, but got ${o.rank}`);let T=E.toNestedArray(N,u.data.get(o.dataId).values),_=E.makeZerosNestedTypedArray(s.shape,s.dtype);for(let S=0;S<d;++S)for(let F=0;F<g;++F){let B=F*b-y.top;for(let W=0;W<x;++W){let q=W*A-y.left;for(let K=0;K<m;++K){let J=Number.MIN_SAFE_INTEGER,Q=0,ee=0;for(let ue=0;ue<v;++ue){let re=B+ue*k;if(re>=0&&re<f)for(let de=0;de<w;++de){let fe=q+de*I;if(fe>=0&&fe<h){let me=c[S][re][fe][K]+p[ue][de][K];me>J&&(J=me,Q=ue,ee=de)}}}_[Q][ee][K]+=T[S][F][W][K]}}}return{dataId:u.write(E.toTypedArray(_,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},R5e={kernelName:pw,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:o}=e,{strides:a,pad:i,dilations:l}=n,u=t,c=E.toNestedArray(r.shape,u.data.get(r.dataId).values),p=E.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:f,inWidth:h,inChannels:m,outHeight:g,outWidth:x,padInfo:y,strideHeight:b,strideWidth:A,filterHeight:v,filterWidth:w,dilationHeight:k,dilationWidth:I,outShape:N}=G.computeDilation2DInfo(r.shape,s.shape,a,i,"NHWC",l);E.assert(o.rank===N.length,()=>`Error in ${pw}, dy must have the same rank as output ${N.length}, but got ${o.rank}`);let T=E.toNestedArray(N,u.data.get(o.dataId).values),_=E.makeZerosNestedTypedArray(r.shape,r.dtype);for(let S=0;S<d;++S)for(let F=0;F<g;++F){let B=F*b-y.top;for(let W=0;W<x;++W){let q=W*A-y.left;for(let K=0;K<m;++K){let J=Number.MIN_SAFE_INTEGER,Q=B<0?0:B,ee=q<0?0:q;for(let ue=0;ue<v;++ue){let re=B+ue*k;if(re>=0&&re<f)for(let de=0;de<w;++de){let fe=q+de*I;if(fe>=0&&fe<h){let me=c[S][re][fe][K]+p[ue][de][K];me>J&&(J=me,Q=re,ee=fe)}}}_[S][Q][ee][K]+=T[S][F][W][K]}}}return{dataId:u.write(E.toTypedArray(_,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Xb(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;rt(s,"sum");let i;s.dtype==="bool"?i=tp({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):i=hl({inputs:{x:s},backend:n});let l=i.shape.length,u=E.parseAxisParam(o,i.shape),c=G.getAxesPermutation(u,l),p=u,d=i;c!=null&&(d=ha({inputs:{x:i},backend:n,attrs:{perm:c}}),p=G.getInnerMostAxes(p.length,l)),G.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[f,h]=G.computeOutAndReduceShapes(d.shape,p),m=G.upcastType(d.dtype,"int32"),g=b5(n,f,m),x=E.sizeFromShape(h),y=n.data.get(g.dataId).values,b=n.data.get(d.dataId).values;for(let A=0;A<y.length;++A){let v=A*x,w=0;for(let k=0;k<x;++k)w+=b[v+k];y[A]=w}if(a){let A=G.expandShapeToKeepDim(g.shape,u),v=g;g=Un({inputs:{x:g},backend:n,attrs:{shape:A}}),n.disposeIntermediateTensorInfo(v)}return n.disposeIntermediateTensorInfo(i),c!=null&&n.disposeIntermediateTensorInfo(d),g}var D5e={kernelName:_f,backendName:"cpu",kernelFunc:Xb};function $5e(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,o=t,{allDims:a,summedDims:i,idDims:l}=G.decodeEinsumEquation(s,o.length);G.checkEinsumDimSizes(a.length,l,o);let{path:u,steps:c}=G.getEinsumComputePath(i,l),p=c.length,d=null,f=a.length,h=[];for(let m=0;m<p;++m){for(let g of c[m]){let{permutationIndices:x,expandDims:y}=G.getEinsumPermutation(f,l[g]),b;G.isIdentityPermutation(x)?b=o[g]:(b=ha({inputs:{x:o[g]},backend:n,attrs:{perm:x}}),h.push(b));let A=b.shape.slice();for(let v=0;v<y.length;++v)A.splice(y[v],0,1);E.arraysEqual(b.shape,A)||(b=Un({inputs:{x:b},backend:n,attrs:{shape:A}}),h.push(b)),d===null?d=b:(d=A5({inputs:{a:b,b:d},backend:n}),h.push(d))}m<p-1&&(u[m]>=0&&(d=Xb({inputs:{x:d},backend:n,attrs:{axis:u[m]-(a.length-f),keepDims:!1}}),h.push(d)),f--)}for(let m of h)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var F5e={kernelName:fw,backendName:"cpu",kernelFunc:$5e};function O5e(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t;rt([r,s],"eluGrad");let o=new Float32Array(E.sizeFromShape(s.shape)),a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values;for(let l=0;l<a.length;++l){let u=a[l];u>=1?o[l]=i[l]:o[l]=i[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",o)}var P5e={kernelName:hw,backendName:"cpu",kernelFunc:O5e},M5e=G.ERF_P,z5e=G.ERF_A1,L5e=G.ERF_A2,B5e=G.ERF_A3,V5e=G.ERF_A4,W5e=G.ERF_A5,G5e=In(Ig,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+M5e*n);return t*(1-((((W5e*r+V5e)*r+B5e)*r+L5e)*r+z5e)*r*Math.exp(-n*n))}),U5e={kernelName:Ig,backendName:"cpu",kernelFunc:G5e};function w5(e){let{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:o}=r,a=s.shape.length,i=s.shape.slice(),l=o;return o<0&&(E.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),i.splice(l,0,1),Un({inputs:{x:s},backend:n,attrs:{shape:i}})}var j5e={kernelName:Sg,backendName:"cpu",kernelFunc:w5},H5e=Dr((e,t)=>e/t),xR=ds(Yd,H5e),yR={kernelName:Yd,backendName:"cpu",kernelFunc:xR};function pV(e,t,n){let r=e.shape,s=r[0],o=r[1],a=n.data.get(e.dataId),i=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[s,o],c=E.sizeFromShape(u),p=E.getTypedArrayFromDType("float32",c),d=E.getTypedArrayFromDType("float32",c);for(let g=0;g<s;g++){let x=ph({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,o]}}),y=ph({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,o]}}),b=Ko({inputs:{real:x,imag:y},backend:n}),{real:A,imag:v}=q5e(b,t,n),w=G.mergeRealAndImagArrays(A,v);for(let k=0;k<o;k++){let I=G.getComplexWithIndex(w,k);p[g*o+k]=I.real,d[g*o+k]=I.imag}n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b)}let f=n.makeTensorInfo(u,"float32",p),h=n.makeTensorInfo(u,"float32",d),m=Ko({inputs:{real:f,imag:h},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),m}function q5e(e,t,n){let r=E.sizeFromShape(e.shape),s=n.data.get(e.dataId),o=n.data.get(s.complexTensorInfos.real.dataId).values,a=n.data.get(s.complexTensorInfos.imag.dataId).values;if(K5e(r)){let i=bR(o,a,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,"float32",i.real),c=n.makeTensorInfo(l,"float32",i.imag),p=n.makeTensorInfo([],"float32",E.createScalarValue(r,"float32")),d=hl({inputs:{x:p},backend:n}),f=yR.kernelFunc({inputs:{a:u,b:p},backend:n}),h=yR.kernelFunc({inputs:{a:c,b:d},backend:n}),m=n.data.get(f.dataId).values,g=n.data.get(h.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),{real:m,imag:g}}return i}else{let i=G.mergeRealAndImagArrays(o,a),l=X5e(i,r,t);return G.splitRealAndImagArrays(l)}}function K5e(e){return(e&e-1)==0}function bR(e,t,n,r,s){if(n===1)return{real:e,imag:t};let o=G.mergeRealAndImagArrays(e,t),a=n/2,i=G.complexWithEvenIndex(o),l=i.real,u=i.imag,c=[l.length],p=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),f=Ko({inputs:{real:p,imag:d},backend:s}),h=G.complexWithOddIndex(o),m=h.real,g=h.imag,x=[m.length],y=s.makeTensorInfo(x,"float32",m),b=s.makeTensorInfo(x,"float32",g),A=Ko({inputs:{real:y,imag:b},backend:s}),v=bR(l,u,a,r,s),w=v.real,k=v.imag,I=[w.length],N=s.makeTensorInfo(I,"float32",w),T=s.makeTensorInfo(I,"float32",k),_=Ko({inputs:{real:N,imag:T},backend:s}),R=bR(m,g,a,r,s),S=R.real,F=R.imag,B=[S.length],W=s.makeTensorInfo(B,"float32",S),q=s.makeTensorInfo(B,"float32",F),K=Ko({inputs:{real:W,imag:q},backend:s}),J=G.exponents(n,r),Q=[J.real.length],ee=s.makeTensorInfo(Q,"float32",J.real),ue=s.makeTensorInfo(Q,"float32",J.imag),re=Ko({inputs:{real:ee,imag:ue},backend:s}),de=A5({inputs:{a:re,b:K},backend:s}),fe=qb({inputs:{a:_,b:de},backend:s}),me=hR({inputs:{a:_,b:de},backend:s}),xe=ch({inputs:{input:fe},backend:s}),Ne=ch({inputs:{input:me},backend:s}),_e=W0({inputs:{input:fe},backend:s}),Oe=W0({inputs:{input:me},backend:s}),Ve=G0({inputs:[xe,Ne],backend:s,attrs:{axis:0}}),He=G0({inputs:[_e,Oe],backend:s,attrs:{axis:0}}),At=s.data.get(Ve.dataId).values,ft=s.data.get(He.dataId).values;return s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(fe),s.disposeIntermediateTensorInfo(me),s.disposeIntermediateTensorInfo(xe),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(Ve),s.disposeIntermediateTensorInfo(He),{real:At,imag:ft}}function X5e(e,t,n){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let o=0,a=0;for(let i=0;i<t;i++){let l=G.exponent(s*i,t,n),u=G.getComplexWithIndex(e,i);o+=u.real*l.real-u.imag*l.imag,a+=u.real*l.imag+u.imag*l.real}n&&(o/=t,a/=t),G.assignToTypedArray(r,o,a,s)}return r}function Z5e(e){let{inputs:t,backend:n}=e,{input:r}=t,s=E.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=s/o,i=Un({inputs:{x:r},backend:n,attrs:{shape:[a,o]}}),l=pV(i,!1,n),u=Un({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var Y5e={kernelName:mw,backendName:"cpu",kernelFunc:Z5e};function AR(e){let{backend:t,attrs:n}=e,{shape:r,value:s,dtype:o}=n,a=o||E.inferDtype(s),i=E.getArrayFromDType(a,E.sizeFromShape(r));return Q5e(i,s,a),t.makeTensorInfo(r,a,i)}var J5e={kernelName:V1,backendName:"cpu",kernelFunc:AR};function Q5e(e,t,n){e.fill(t)}var e3e={kernelName:Tg,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,s=n,o=E.getTypedArrayFromDType(r.dtype,E.sizeFromShape(r.shape)),[a,i,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let d=0;d<a;d++){let f=d*l*i*u;for(let h=0;h<i;h++){let m=h*(l*u);for(let g=0;g<l;g++){let x=g*u;for(let y=0;y<u;y++){let b=Math.round(l-g-1),A=f+m+x+y,v=c[A];if(b>=0&&b<l){let w=b*u,k=f+m+w+y;v=c[k]}o[A]=v}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},t3e=Dr((e,t)=>Math.floor(e/t)),n3e=ds(tf,t3e,null,"int32"),r3e={kernelName:tf,backendName:"cpu",kernelFunc:n3e};function s3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=r,m=uV({inputs:{x:s,filter:o},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d}});if(a){let g=m;m=qb({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(g)}if(f){let g=m;m=mR(n,m,f,i,h),n.disposeIntermediateTensorInfo(g)}return m}var o3e={kernelName:Mf,backendName:"cpu",kernelFunc:s3e};function a3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=r,m=cV({inputs:{x:s,filter:o},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d}});if(a){let g=m;m=qb({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(g)}if(f){let g=m;m=mR(n,m,f,i,h),n.disposeIntermediateTensorInfo(g)}return m}var i3e={kernelName:zf,backendName:"cpu",kernelFunc:a3e};function l3e(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,o=E.sizeFromShape(r.shape),a=s.shape,i=a[a.length-1],[l,u,c,p]=G.prepareAndValidate(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);let d=n.data.get(s.dataId).values,f=n.bufferSync(r),h=NB(d,f,r.dtype,u,i,c,p,r.shape,o);return n.makeTensorInfo(l,r.dtype,h.values)}var u3e={kernelName:Eg,backendName:"cpu",kernelFunc:l3e};function c3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:o}=t,{axis:a,batchDims:i}=r;rt([s,o],"gatherV2");let l=i;i==null&&(l=0);let u=E.sizeFromShape(o.shape),c=E.parseAxisParam(a,s.shape)[0],p=G.segment_util.collectGatherOpShapeInfo(s,o,c,l),d=Un({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),f=Un({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,u/p.batchSize]}}),h=[p.batchSize,p.outerSize,u/p.batchSize,p.sliceSize],m=n.bufferSync(f),g=n.bufferSync(d),x=TB(g,m,h);return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}var p3e={kernelName:_g,backendName:"cpu",kernelFunc:c3e};function d3e(e){let{inputs:t,backend:n}=e,{input:r}=t,s=E.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=s/o,i=Un({inputs:{x:r},backend:n,attrs:{shape:[a,o]}}),l=pV(i,!0,n),u=Un({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var f3e={kernelName:gw,backendName:"cpu",kernelFunc:d3e},h3e=In(Dg,e=>Number.isFinite(e)?1:0,"bool"),m3e={kernelName:Dg,backendName:"cpu",kernelFunc:h3e},g3e=In($g,e=>Math.abs(e)===1/0?1:0,"bool"),x3e={kernelName:$g,backendName:"cpu",kernelFunc:g3e},y3e=In(Fg,e=>Number.isNaN(e)?1:0,"bool"),b3e={kernelName:Fg,backendName:"cpu",kernelFunc:y3e};function A3e(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:o}=n,a=$B(r,s,o);return t.makeTensorInfo([a.length],"float32",a)}var v3e={kernelName:yw,backendName:"cpu",kernelFunc:A3e},w3e=In(Mg,e=>Math.log1p(e)),k3e={kernelName:Mg,backendName:"cpu",kernelFunc:w3e},I3e=Dr((e,t)=>e&&t),C3e=ds(zg,I3e,null,"bool"),S3e={kernelName:zg,backendName:"cpu",kernelFunc:C3e},N3e=In(W1,e=>e?0:1,"bool"),T3e={kernelName:W1,backendName:"cpu",kernelFunc:N3e},_3e=Dr((e,t)=>e||t),E3e=ds(G1,_3e,null,"bool"),R3e={kernelName:G1,backendName:"cpu",kernelFunc:E3e};function D3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:o,bias:a,alpha:i,beta:l}=r;rt(s,"LRN");let u=s.shape[3],c=u-1,p=n.data.get(s.dataId).values,d=E.sizeFromShape(s.shape),f=new Float32Array(d);function h(m){let g=m%u,x=m-g+Math.max(0,g-o),y=m-g+Math.min(g+o,c),b=0;for(;x<=y;x++){let A=p[x];b+=A*A}return b}for(let m=0;m<d;m++){let g=h(m),x=p[m]*Math.pow(a+i*g,-l);f[m]=x}return n.makeTensorInfo(s.shape,s.dtype,f)}var $3e={kernelName:U1,backendName:"cpu",kernelFunc:D3e};function F3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:o,dy:a}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=r;rt(a,"LRNGrad");let p=E.sizeFromShape(a.shape),d=a.shape[3],f=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,m=n.data.get(o.dataId).values,g=new Float32Array(p),x=p;for(let y=0;y<x;y++){let b=y%d,A=y-b+Math.max(0,b-i),v=y-b+Math.min(d,b+i+1),w=0;for(let k=A;k<v;k++)w+=Math.pow(h[k],2);w=u*w+l;for(let k=A;k<v;k++){let I=-2*u*c*h[k]*m[y]/w;y===k&&(I+=Math.pow(w,-c)),I*=f[y],g[k]+=I}}return n.makeTensorInfo(a.shape,s.dtype,g)}var O3e={kernelName:bw,backendName:"cpu",kernelFunc:F3e};function dV(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:o,keepDims:a}=r,i=n,l=s.shape,u=l.length,c=E.parseAxisParam(o,l),p=c,d=G.getAxesPermutation(p,u),f=i.data.get(s.dataId).values;if(d!=null){let A=new Array(u);for(let v=0;v<A.length;v++)A[v]=l[d[v]];f=pR(f,l,s.dtype,d,A),p=G.getInnerMostAxes(p.length,u),l=A}rt(s,"max"),G.assertAxesAreInnerMostDims("max",p,u);let[h,m]=G.computeOutAndReduceShapes(l,p),g=E.sizeFromShape(m),x=OB(f,g,h,s.dtype),y=i.write(x,h,s.dtype),b=h;return a&&(b=G.expandShapeToKeepDim(h,c)),{dataId:y,shape:b,dtype:s.dtype}}var P3e={kernelName:lf,backendName:"cpu",kernelFunc:dV};function M3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;rt(s,"maxPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,u=1;E.assert(G.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=G.computePool2DInfo(s.shape,o,a,u,i,l),p;if(c.filterWidth===1&&c.filterHeight===1&&E.arraysEqual(c.inShape,c.outShape))p=hl({inputs:{x:s},backend:n});else{let d=n.data.get(s.dataId).values,f=E.computeStrides(s.shape),h=gR(d,s.shape,s.dtype,f,c,"max");p=n.makeTensorInfo(c.outShape,s.dtype,h.values)}return p}var z3e={kernelName:cf,backendName:"cpu",kernelFunc:M3e};function L3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=r;rt(s,"maxPool3d");let c=G.computePool3DInfo(s.shape,o,a,1,i,l,u),p=n.data.get(s.dataId).values,d=lV(p,s.shape,s.dtype,E.computeStrides(s.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var B3e={kernelName:j1,backendName:"cpu",kernelFunc:L3e};function V3e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=r;rt([s,o],"maxPool3DGrad");let c=G.computePool3DInfo(o.shape,a,i,1,l,u),p=n.bufferSync(o),d=Eke(p,c),f=c.strideDepth,h=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,x=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,A=c.effectiveFilterHeight,v=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=v-1-c.padInfo.left,I=A-1-c.padInfo.top,N=Wt(o.shape,"float32"),T=n.bufferSync(s);for(let _=0;_<c.batchSize;++_)for(let R=0;R<c.inChannels;++R)for(let S=0;S<c.inDepth;++S)for(let F=0;F<c.inHeight;++F)for(let B=0;B<c.inWidth;++B){let W=S-w,q=F-I,K=B-k,J=0;for(let Q=0;Q<b;Q+=g){let ee=(W+Q)/f;if(!(ee<0||ee>=c.outDepth||Math.floor(ee)!==ee))for(let ue=0;ue<A;ue+=x){let re=(q+ue)/h;if(!(re<0||re>=c.outHeight||Math.floor(re)!==re))for(let de=0;de<v;de+=y){let fe=(K+de)/m;if(fe<0||fe>=c.outWidth||Math.floor(fe)!==fe)continue;let me=b*A*v-1-d.get(_,ee,re,fe,R),xe=Q*A*v+ue*v+de,Ne=me===xe?1:0;if(Ne===0)continue;J+=T.get(_,ee,re,fe,R)*Ne}}}N.set(J,_,S,F,B,R)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var W3e={kernelName:vw,backendName:"cpu",kernelFunc:V3e};function G3e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o,output:a}=t,i=o;rt([o,a],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,d=G.computePool2DInfo(i.shape,l,u,1,c,p),f=n.data.get(i.dataId).values,h=Wt(d.outShape,i.dtype,iV(f,i.shape,i.dtype,d).values),m=d.strideHeight,g=d.strideWidth,x=d.dilationHeight,y=d.dilationWidth,b=d.effectiveFilterHeight,A=d.effectiveFilterWidth,v=A-1-d.padInfo.left,w=b-1-d.padInfo.top,k=Wt(i.shape,"float32"),I=n.data.get(s.dataId).values,N=Wt(s.shape,"float32",I);for(let T=0;T<d.batchSize;++T)for(let _=0;_<d.inChannels;++_)for(let R=0;R<d.inHeight;++R)for(let S=0;S<d.inWidth;++S){let F=R-w,B=S-v,W=0;for(let q=0;q<b;q+=x){let K=(F+q)/m;if(!(K<0||K>=d.outHeight||Math.floor(K)!==K))for(let J=0;J<A;J+=y){let Q=(B+J)/g;if(Q<0||Q>=d.outWidth||Math.floor(Q)!==Q)continue;let ee=b*A-1-h.get(T,K,Q,_),ue=q*A+J,re=ee===ue?1:0;if(re===0)continue;W+=N.get(T,K,Q,_)*re}}k.set(W,T,R,S,_)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var U3e={kernelName:Aw,backendName:"cpu",kernelFunc:G3e};function j3e(e,t,n,r,s){let o=E.computeStrides(t),a=gR(e,t,n,o,s,"max"),i=iV(e,t,n,s,!0,r);return[a.values,i.values]}var H3e={kernelName:ww,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:o,pad:a,includeBatchInIndex:i}=t,l=n;rt(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=G.computePool2DInfo(r.shape,s,o,[1,1],a),[p,d]=j3e(u,r.shape,r.dtype,i,c),f=l.write(p,c.outShape,r.dtype),h=l.write(d,c.outShape,r.dtype);return[{dataId:f,shape:c.outShape,dtype:r.dtype},{dataId:h,shape:c.outShape,dtype:"int32"}]}};function q3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=E.parseAxisParam(o,s.shape),u=G.computeOutAndReduceShapes(s.shape,i)[1],c=E.sizeFromShape(u),p=[],d=n.makeTensorInfo([],"float32",new Float32Array([c]));p.push(d);let f=tp({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});p.push(f);let h=xR({inputs:{a:f,b:d},backend:n});p.push(h);let m=Xb({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:a}});return p.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var K3e={kernelName:pf,backendName:"cpu",kernelFunc:q3e};function X3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;rt(s,"min");let i=E.parseAxisParam(o,s.shape),l=i,u=G.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=ha({inputs:{x:s},backend:n,attrs:{perm:u}}),l=G.getInnerMostAxes(l.length,s.shape.length)),G.assertAxesAreInnerMostDims("min",l,c.shape.length);let[p,d]=G.computeOutAndReduceShapes(c.shape,l),f=E.sizeFromShape(d),h=E.makeZerosTypedArray(E.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let y=x*f,b=m[y];for(let A=0;A<f;++A){let v=m[y+A];(Number.isNaN(v)||v<b)&&(b=v)}h[x]=b}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,h);if(a){let x=G.expandShapeToKeepDim(p,i),y=Un({inputs:{x:g},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(g),y}return g}var Z3e={kernelName:df,backendName:"cpu",kernelFunc:X3e};function Y3e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,mode:a}=r;rt(s,"mirrorPad");let i=o.map((b,A)=>b[0]+s.shape[A]+b[1]),l=o.map(b=>b[0]),u=o.map((b,A)=>b[0]+s.shape[A]),c=a==="reflect"?0:1,p=n.data.get(s.dataId).values,d=s.shape.length,f=E.computeStrides(s.shape),h=E.sizeFromShape(i),m=i.length,g=E.computeStrides(i),x=E.getTypedArrayFromDType(s.dtype,h);for(let b=0;b<h;b++){let A=E.indexToLoc(b,m,g);for(let w=0;w<m;w++)A[w]<l[w]?A[w]=l[w]*2-A[w]-c:A[w]>=u[w]&&(A[w]=(u[w]-1)*2-A[w]+c);A=A.map((w,k)=>w-l[k]);let v=E.locToIndex(A,d,f);x[b]=p[v]}return{dataId:n.write(x,i,s.dtype),shape:i,dtype:s.dtype}}var J3e={kernelName:hf,backendName:"cpu",kernelFunc:Y3e},Q3e=Dr((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),eIe=ds(Lg,Q3e),tIe={kernelName:Lg,backendName:"cpu",kernelFunc:eIe},nIe=Pd(cP());function fV(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:o}=r,a=s.shape.length,i=o;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let l=E.parseAxisParam([i],s.shape),u=dV({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=G.expandShapeToKeepDim(u.shape,l),p=Un({inputs:{x:u},backend:n,attrs:{shape:c}}),d=hR({inputs:{a:s,b:p},backend:n}),f=IB({inputs:{x:d},backend:n}),h=Xb({inputs:{x:f},backend:n,attrs:{axis:l,keepDims:!1}}),m=Un({inputs:{x:h},backend:n,attrs:{shape:c}}),g=xR({inputs:{a:f,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var rIe={kernelName:Ef,backendName:"cpu",kernelFunc:fV};function sIe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:o,seed:a,normalized:i}=r;rt(s,"multinomial");let l=i?s:fV({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],p=n.data.get(l.dataId).values,d=[u,o],f=E.makeZerosTypedArray(E.sizeFromShape(d),"int32");for(let h=0;h<u;++h){let m=h*c,g=new Float32Array(c-1);g[0]=p[m];for(let b=1;b<g.length;++b)g[b]=g[b-1]+p[m+b];let x=nIe.alea(a.toString()),y=h*o;for(let b=0;b<o;++b){let A=x();f[y+b]=g.length;for(let v=0;v<g.length;v++)if(A<g[v]){f[y+b]=v;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",f)}var oIe={kernelName:kw,backendName:"cpu",kernelFunc:sIe},aIe=ll.nonMaxSuppressionV3Impl;function iIe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=r;rt(s,"NonMaxSuppression");let u=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values,{selectedIndices:p}=aIe(u,c,a,i,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var lIe={kernelName:Wg,backendName:"cpu",kernelFunc:iIe},uIe=ll.nonMaxSuppressionV4Impl;function cIe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=r;rt(s,"NonMaxSuppressionPadded");let c=n.data.get(s.dataId).values,p=n.data.get(o.dataId).values,{selectedIndices:d,validOutputs:f}=uIe(c,p,a,i,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}var pIe={kernelName:Gg,backendName:"cpu",kernelFunc:cIe},dIe=ll.nonMaxSuppressionV5Impl;function fIe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=r;rt(s,"NonMaxSuppressionWithScore");let c=n.data.get(s.dataId).values,p=n.data.get(o.dataId).values,d=a,f=i,h=l,m=u,{selectedIndices:g,selectedScores:x}=dIe(c,p,d,f,h,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var hIe={kernelName:Ug,backendName:"cpu",kernelFunc:fIe};function mIe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:o,onValue:a,offValue:i}=r;rt(s,"oneHot");let l=E.sizeFromShape(s.shape),u=new Float32Array(l*o);u.fill(i);let c=n.data.get(s.dataId).values;for(let p=0;p<l;++p)c[p]>=0&&c[p]<o&&(u[p*o+c[p]]=a);return n.makeTensorInfo([...s.shape,o],"int32",u)}var gIe={kernelName:gf,backendName:"cpu",kernelFunc:mIe};function k5(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let s=ch({inputs:{input:r},backend:n}),o=k5({inputs:{x:s},backend:n}),a=W0({inputs:{input:r},backend:n}),i=k5({inputs:{x:a},backend:n}),l=Ko({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return AR({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var xIe={kernelName:u0,backendName:"cpu",kernelFunc:k5};function hV(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let s=ch({inputs:{input:r},backend:n}),o=hV({inputs:{x:s},backend:n}),a=W0({inputs:{input:r},backend:n}),i=k5({inputs:{x:a},backend:n}),l=Ko({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return AR({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var yIe={kernelName:jg,backendName:"cpu",kernelFunc:hV};function mV(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return w5({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let o=t[0].shape,a=t[0].dtype;t.forEach(c=>{E.assertShapesMatch(o,c.shape,"All tensors passed to stack must have matching shapes"),E.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=t.map(c=>{let p=w5({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(p),p}),u=G0({inputs:l,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var bIe={kernelName:Hg,backendName:"cpu",kernelFunc:mV};function AIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,constantValue:a}=r;rt(s,"pad");let i=o.map((y,b)=>y[0]+s.shape[b]+y[1]),l=o.map(y=>y[0]),u=n.data.get(s.dataId).values,c=E.sizeFromShape(s.shape),p=s.shape.length,d=E.computeStrides(s.shape),f=E.sizeFromShape(i),h=i.length,m=E.computeStrides(i),g=E.getTypedArrayFromDType(s.dtype,f);a!==0&&g.fill(a);for(let y=0;y<c;y++){let A=E.indexToLoc(y,p,d).map((w,k)=>w+l[k]),v=E.locToIndex(A,h,m);g[v]=u[y]}return{dataId:n.write(g,i,s.dtype),shape:i,dtype:s.dtype}}var gV={kernelName:xf,backendName:"cpu",kernelFunc:AIe},vIe=Dr((e,t)=>Math.pow(e,t)),wIe=ds(yf,vIe),kIe={kernelName:yf,backendName:"cpu",kernelFunc:wIe};function IIe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,dtype:o,step:a}=n,i=dR(r,s,a,o);return t.makeTensorInfo([i.length],o,i)}var CIe={kernelName:H1,backendName:"cpu",kernelFunc:IIe},SIe=In(Kg,e=>1/e),NIe={kernelName:Kg,backendName:"cpu",kernelFunc:SIe};function TIe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:i}=r;rt(s,"resizeBilinear");let l=E.computeStrides(s.shape),[u,c]=i,[p,d,f,h]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(E.sizeFromShape([p,u,c,h])),x=[o&&u>1?d-1:d,o&&c>1?f-1:f],y=[o&&u>1?u-1:u,o&&c>1?c-1:c],b=0,A=x[0]/y[0],v=x[1]/y[1];for(let w=0;w<p;w++)for(let k=0;k<u;k++){let I;a?I=A*(k+.5)-.5:I=A*k;let N=Math.max(0,Math.floor(I)),T=I-N,_=Math.min(d-1,Math.ceil(I)),R=w*l[0]+N*l[1],S=w*l[0]+_*l[1];for(let F=0;F<c;F++){let B;a?B=v*(F+.5)-.5:B=v*F;let W=Math.max(0,Math.floor(B)),q=B-W,K=Math.min(f-1,Math.ceil(B)),J=R+W*l[2],Q=S+W*l[2],ee=R+K*l[2],ue=S+K*l[2];for(let re=0;re<h;re++){let de=m[J+re],fe=m[Q+re],me=m[ee+re],xe=m[ue+re],Ne=de+(me-de)*q,_e=fe+(xe-fe)*q,Oe=Ne+(_e-Ne)*T;g[b++]=Oe}}}return n.makeTensorInfo([p,u,c,h],"float32",g)}var _Ie={kernelName:vf,backendName:"cpu",kernelFunc:TIe};function EIe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:a}=r;rt([o,s],"resizeBilinearGrad");let i=E.computeStrides(s.shape),[l,u,c,p]=s.shape,[,d,f]=o.shape,h=new Float32Array(l*u*c*p),m=[a&&d>1?u-1:u,a&&f>1?c-1:c],g=[a&&d>1?d-1:d,a&&f>1?f-1:f],x=m[0]/g[0],y=m[1]/g[1],b=n.data.get(o.dataId).values,A=0;for(let v=0;v<l;v++){let w=v*i[0];for(let k=0;k<d;k++){let I=k*x,N=Math.floor(I),T=Math.min(Math.ceil(I),u-1),_=w+N*i[1],R=w+T*i[1],S=I-N,F=1-S;for(let B=0;B<f;B++){let W=B*y,q=Math.floor(W),K=Math.min(Math.ceil(W),c-1),J=W-q,Q=1-J,ee=_+q*i[2],ue=_+K*i[2],re=R+q*i[2],de=R+K*i[2],fe=F*Q,me=F*J,xe=S*Q,Ne=S*J;for(let _e=0;_e<p;_e++){let Oe=b[A++];h[ee+_e]+=Oe*fe,h[ue+_e]+=Oe*me,h[re+_e]+=Oe*xe,h[de+_e]+=Oe*Ne}}}}return n.makeTensorInfo([l,c,u,p],"float32",h)}var RIe={kernelName:Sw,backendName:"cpu",kernelFunc:EIe};function DIe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:i}=r;rt(s,"resizeNearestNeighbor");let l=E.computeStrides(s.shape),[u,c]=i,[p,d,f,h]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(p*u*c*h),x=[o&&u>1?d-1:d,o&&c>1?f-1:f],y=[o&&u>1?u-1:u,o&&c>1?c-1:c],b=x[0]/y[0],A=x[1]/y[1],v=0;for(let w=0;w<p;w++){let k=w*l[0];for(let I=0;I<u;I++){let N=a?b*(I+.5):b*I,T=Math.min(d-1,o?Math.round(N):Math.floor(N));a&&(T=Math.max(0,T));let _=k+T*l[1];for(let R=0;R<c;R++){let S=a?A*(R+.5):A*R,F=Math.min(f-1,o?Math.round(S):Math.floor(S));a&&(F=Math.max(0,F));let B=_+F*l[2];for(let W=0;W<h;W++){let q=m[B+W];g[v++]=q}}}}return n.makeTensorInfo([p,u,c,h],s.dtype,g)}var $Ie={kernelName:q1,backendName:"cpu",kernelFunc:DIe};function FIe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:a}=r;rt([o,s],"resizeNearestNeighborGrad");let i=E.computeStrides(s.shape),l=E.computeStrides(o.shape),[u,c,p,d]=s.shape,[,f,h]=o.shape,m=new Float32Array(u*c*p*d),g=n.data.get(o.dataId).values,x=[a&&f>1?c-1:c,a&&h>1?p-1:p],y=[a&&f>1?f-1:f,a&&h>1?h-1:h],b=x[0]/y[0],A=x[1]/y[1],v=1/b,w=1/A,k=Math.ceil(v)*2+2,I=Math.ceil(w)*2+2;for(let N=0;N<u;N++){let T=N*i[0];for(let _=0;_<c;_++){let R=T+_*i[1],S=Math.floor(_*v),F=Math.floor(S-k/2);for(let B=0;B<p;B++){let W=R+B*i[2],q=Math.floor(B*w),K=Math.floor(q-I/2);for(let J=0;J<d;J++){let Q=0;for(let ee=0;ee<k;ee++){let ue=ee+F;if(ue<0||ue>=f)continue;let re=T+ue*l[1],de=ue*b,fe=Math.min(c-1,a?Math.round(de):Math.floor(de));if(_===fe)for(let me=0;me<I;me++){let xe=me+K;if(xe<0||xe>=h)continue;let Ne=re+xe*l[2],_e=xe*A,Oe=Math.min(p-1,a?Math.round(_e):Math.floor(_e));B===Oe&&(Q+=g[Ne+J])}}m[W+J]=Q}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}var OIe={kernelName:Cw,backendName:"cpu",kernelFunc:FIe};function PIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:o}=r;rt(s,"reverse");let a=s.shape.length,i=E.parseAxisParam(o,s.shape);if(a===0)return hl({inputs:{x:s},backend:n});let l=new Ur(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){let p=l.indexToLoc(c),d=p.slice();i.forEach(f=>d[f]=s.shape[f]-1-d[f]),l.set(u.get(...d),...p)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var MIe={kernelName:kf,backendName:"cpu",kernelFunc:PIe},zIe={kernelName:c0,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:o,center:a}=t,i=n,l=E.getTypedArrayFromDType(r.dtype,E.sizeFromShape(r.shape)),[u,c,p,d]=r.shape,[f,h]=G.getImageCenter(a,c,p),m=255,g=Math.sin(s),x=Math.cos(s),y=i.data.get(r.dataId).values;for(let A=0;A<u;A++){let v=A*p*c*d;for(let w=0;w<c;w++){let k=w*(p*d);for(let I=0;I<p;I++){let N=I*d;for(let T=0;T<d;T++){let _=[u,w,I,T],R=_[2],S=_[1],F=(R-f)*x-(S-h)*g,B=(R-f)*g+(S-h)*x;F=Math.round(F+f),B=Math.round(B+h);let W=o;if(typeof o!="number"&&(T===3?W=m:W=o[T]),F>=0&&F<p&&B>=0&&B<c){let K=B*(p*d),J=F*d,Q=v+K+J+T;W=y[Q]}let q=v+k+N+T;l[q]=W}}}}return{dataId:i.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},LIe=In(If,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),BIe={kernelName:If,backendName:"cpu",kernelFunc:LIe};function xV(e,t,n,r,s,o,a,i,l,u){let c=[r/s,s],p=e.values,d=t.values;if(r===0)return Wt(n,t.dtype);let f=Wt(c,t.dtype);f.values.fill(l);for(let h=0;h<o;h++){let m=[],g=0;for(let x=0;x<a;x++){let y=p[h*a+x];m.push(y),g+=y*i[x]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let x=0;x<s;x++)u?f.values[g*s+x]+=d[h*s+x]:f.values[g*s+x]=t.rank===0?d[0]:d[h*s+x]}return f}function VIe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:o}=t,{shape:a}=r,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=G.calculateShapes(o,s,a),d=!0,f=n.bufferSync(s),h=n.bufferSync(o),m=xV(f,h,a,p,u,l,i,c,0,d);return n.makeTensorInfo(a,m.dtype,m.values)}var WIe={kernelName:Zg,backendName:"cpu",kernelFunc:VIe};function GIe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:o}=t;rt([r,s,o],"select");let a=r.shape.length,i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,c=$a(s.dtype,o.dtype),p=E.makeZerosTypedArray(E.sizeFromShape(s.shape),c),d=0,f=a===0||a>1||s.shape.length===1?1:E.sizeFromShape(s.shape.slice(1));for(let h=0;h<i.length;h++)for(let m=0;m<f;m++)i[h]===1?p[d++]=l[h]:p[d++]=u[h];return n.makeTensorInfo(s.shape,c,p)}var UIe={kernelName:Yg,backendName:"cpu",kernelFunc:GIe},jIe=G.SELU_SCALEALPHA,HIe=G.SELU_SCALE,qIe=In(Jg,e=>e>=0?HIe*e:jIe*(Math.exp(e)-1)),KIe={kernelName:Jg,backendName:"cpu",kernelFunc:qIe},XIe=In(t0,e=>e<0?-1:e>0?1:0),ZIe={kernelName:t0,backendName:"cpu",kernelFunc:XIe},YIe=In(Sf,e=>Math.sin(e)),JIe={kernelName:Sf,backendName:"cpu",kernelFunc:YIe},QIe=In(e0,e=>Math.sinh(e)),eCe={kernelName:e0,backendName:"cpu",kernelFunc:QIe},tCe=11920928955078125e-23,yV=Math.log(tCe)+2,nCe=In(n0,e=>{let t=e>-yV,n=e<yV,r=Math.exp(e),s;return n?s=r:t?s=e:s=Math.log(1+r),s}),rCe={kernelName:n0,backendName:"cpu",kernelFunc:nCe};function sCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,paddings:a}=r;rt([s],"spaceToBatchND");let i=E.sizeFromShape(o),l=[[0,0]];l.push(...a);for(let w=1+o.length;w<s.shape.length;++w)l.push([0,0]);let u=gV.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=G.getReshaped(u.shape,o,i,!1),p=G.getPermuted(c.length,o.length,!1),d=G.getReshapedPermuted(u.shape,o,i,!1),m=Un({inputs:{x:u},backend:n,attrs:{shape:c}}),y=ha({inputs:{x:m},backend:n,attrs:{perm:p}}),v=Un({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),v}var oCe={kernelName:r0,backendName:"cpu",kernelFunc:sCe};function aCe(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:o,defaultValue:a}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,c=n.data.get(a.dataId).values[0],[p,d,f,h,m]=GB(i,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],s.dtype,f),n.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var iCe={kernelName:Nw,backendName:"cpu",kernelFunc:aCe};function lCe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:o}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);let a=Array.from(n.data.get(s.dataId).values),i=n.data.get(r.dataId).values,l=Array.from(n.data.get(o.dataId).values),[u,c,p]=UB(i,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([p.length],o.dtype,new Int32Array(p))]}var uCe={kernelName:Tw,backendName:"cpu",kernelFunc:lCe};function cCe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);let a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,[u,c]=fR(a,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var pCe={kernelName:_w,backendName:"cpu",kernelFunc:cCe};function dCe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);let a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,[u,c]=fR(a,r.shape,r.dtype,i,l);return n.makeTensorInfo(c,r.dtype,u)}var fCe={kernelName:Ew,backendName:"cpu",kernelFunc:dCe};function hCe(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:a}=t,{outputShape:i}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:d}=G.calculateShapes(o,s,i),f=!1,h=n.bufferSync(s),m=n.bufferSync(o),g=n.data.get(a.dataId).values[0],x=xV(h,m,i,d,c,u,l,p,g,f);return n.makeTensorInfo(i,x.dtype,x.values)}var mCe={kernelName:Rw,backendName:"cpu",kernelFunc:hCe};function gCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:o,axis:a}=r,i=E.parseAxisParam(a,s.shape)[0],l=G.prepareSplitSize(s,o,i),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(p=>{let d=[...c];d[i]=p;let f=ph({inputs:{x:s},backend:n,attrs:{begin:u,size:d}});return u[i]+=p,f})}var xCe={kernelName:s0,backendName:"cpu",kernelFunc:gCe},yCe={kernelName:K1,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;rt(n,"square");let s=r.data.get(n.dataId).values,o=new Float32Array(s.length);for(let i=0;i<s.length;++i){let l=s[i];o[i]=l*l}return{dataId:r.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},bCe=In(Pc,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),ACe={kernelName:Pc,backendName:"cpu",kernelFunc:bCe};function vCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=r;rt(s,"stridedSlice");let{nonStrided:f,$begin:h,$strides:m,size:g,newShape:x,outShape:y}=Bs.sliceInfo(s.shape,o,a,i,l,u,c,p,d),b=Un({inputs:{x:s},backend:n,attrs:{shape:x}}),A;if(f){let w=ph({inputs:{x:b},backend:n,attrs:{begin:h,size:g}});A=Un({inputs:{x:w},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(w)}else if(y.some(w=>w===0))A=n.makeTensorInfo(y,s.dtype,[]);else{let w=n.bufferSync(b),k=HB(y,w,m,h);A=n.makeTensorInfo(k.shape,k.dtype,k.values)}let v=Un({inputs:{x:A},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(A),v}var wCe={kernelName:o0,backendName:"cpu",kernelFunc:vCe};function kCe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=t,d=n.data.get(c.dataId).values,f=n.data.get(p.dataId).values,[h,m]=qB(d,f,s,o,a,i,l,u);return[n.makeTensorInfo([h.length],"string",h),n.makeTensorInfo(p.shape,"int32",m)]}var ICe={kernelName:Dw,backendName:"cpu",kernelFunc:kCe};function CCe(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:o,delimiter:a}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=n.data.get(o.dataId).values,l=n.data.get(a.dataId).values[0],[u,c,p]=KB(i,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var SCe={kernelName:$w,backendName:"cpu",kernelFunc:CCe};function NCe(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let a=n.data.get(o.dataId).values,i=XB(a,s);return n.makeTensorInfo(o.shape,"int32",i)}var TCe={kernelName:Fw,backendName:"cpu",kernelFunc:NCe},_Ce=In($f,e=>Math.tan(e)),ECe={kernelName:$f,backendName:"cpu",kernelFunc:_Ce},RCe=In(Ff,e=>Math.tanh(e)),DCe={kernelName:Ff,backendName:"cpu",kernelFunc:RCe};function $Ce(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:o}=r;rt(s,"tile");let a=YB(n.bufferSync(s),o);return n.makeTensorInfo(a.shape,a.dtype,a.values)}var FCe={kernelName:Oc,backendName:"cpu",kernelFunc:$Ce};function OCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:o,sorted:a}=r;rt(s,"topk");let i=n.data.get(s.dataId).values,[l,u]=QB(i,s.shape,s.dtype,o,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var PCe={kernelName:a0,backendName:"cpu",kernelFunc:OCe};function MCe(e){let{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:o}=t,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=n,[c,p,d,f]=s.shape,[h,m]=u!=null?u:[p,d],g=[c,h,m,f],x=E.computeStrides(s.shape),y=x[0],b=x[1],A=x[2],v=E.getTypedArrayFromDType(s.dtype,E.sizeFromShape(g));v.fill(l);let w=r.data.get(s.dataId).values,k=r.data.get(o.dataId).values;for(let N=0;N<c;++N){let T=o.shape[0]===1?k:k.subarray(N*8,N*8+8);for(let _=0;_<h;++_)for(let R=0;R<m;++R)for(let S=0;S<f;++S){let F,B=T[6]*R+T[7]*_+1;if(B===0)continue;let W=(T[0]*R+T[1]*_+T[2])/B,q=(T[3]*R+T[4]*_+T[5])/B,K=bV(W,d,i),J=bV(q,p,i);switch(a){case"nearest":F=GCe(w,p,d,y,b,A,N,J,K,S,l);break;case"bilinear":F=UCe(w,p,d,y,b,A,N,J,K,S,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let Q=N*y+_*b+R*A+S;v[Q]=F}return r.makeTensorInfo(g,s.dtype,v)}return{dataId:r.write(v,g,s.dtype),shape:s.shape,dtype:s.dtype}}var zCe={kernelName:i0,backendName:"cpu",kernelFunc:MCe};function bV(e,t,n){switch(n){case"reflect":return LCe(e,t);case"wrap":return BCe(e,t);case"nearest":return WCe(e,t);case"constant":default:return VCe(e,t)}}function LCe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return E.clamp(0,n,t-1)}function BCe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return E.clamp(0,n,t-1)}function VCe(e,t){return e}function WCe(e,t){return E.clamp(0,e,t-1)}function Zb(e,t,n,r,s,o,a,i,l,u,c){let p=a*r+i*s+l*o+u;return 0<=i&&i<t&&0<=l&&l<n?e[p]:c}function GCe(e,t,n,r,s,o,a,i,l,u,c){let p=Math.round(i),d=Math.round(l);return Zb(e,t,n,r,s,o,a,p,d,u,c)}function UCe(e,t,n,r,s,o,a,i,l,u,c){let p=Math.floor(i),d=Math.floor(l),f=p+1,h=d+1,m=(h-l)*Zb(e,t,n,r,s,o,a,p,d,u,c)+(l-d)*Zb(e,t,n,r,s,o,a,p,h,u,c),g=(h-l)*Zb(e,t,n,r,s,o,a,f,d,u,c)+(l-d)*Zb(e,t,n,r,s,o,a,f,h,u,c);return(f-i)*m+(i-p)*g}function jCe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:o}=t;rt(o,"unique");let a=r.data.get(o.dataId).values,{outputValues:i,outputShape:l,indices:u}=eV(a,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,i),r.makeTensorInfo([u.length],"int32",u)]}var HCe={kernelName:Ow,backendName:"cpu",kernelFunc:jCe};function qCe(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:o}=r;o<0&&(o+=s.shape.length);let a=s.shape.length,i=s.shape[o],l=new Array(a-1),u=0;for(let f=0;f<a;f++)f!==o&&(l[u++]=s.shape[f]);let c=new Array(a).fill(0),p=s.shape.slice();p[o]=1;let d=new Array(i);for(let f=0;f<d.length;f++){c[o]=f;let h=ph({inputs:{x:s},backend:n,attrs:{begin:c,size:p}});d[f]=Un({inputs:{x:h},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(h)}return d}var KCe={kernelName:l0,backendName:"cpu",kernelFunc:qCe};function XCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:o}=t,{numSegments:a}=r;rt(s,"unsortedSegmentSum");let i=s.shape.length,l=o.shape.length,u=[],c=[],p=i-l,d=o;for(let h=0;h<p;++h){let m=w5({inputs:{input:d},backend:n,attrs:{dim:h+1}});d=m,c.push(m)}for(let h=0;h<a;++h){let m=E.createScalarValue(h,"int32"),g=n.makeTensorInfo([],"int32",m),x=wB({inputs:{a:g,b:d},backend:n}),y=tp({inputs:{x},backend:n,attrs:{dtype:"float32"}}),b=A5({inputs:{a:y,b:s},backend:n}),A=Xb({inputs:{x:b},backend:n,attrs:{axis:0,keepDims:!1}});u.push(A),c.push(g),c.push(x),c.push(y),c.push(b),c.push(A)}let f=mV({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(h=>n.disposeIntermediateTensorInfo(h)),f}var ZCe={kernelName:X1,backendName:"cpu",kernelFunc:XCe},YCe=[ske,Yve,ake,lke,rwe,cke,dke,hke,gke,yke,Ake,wke,Ike,Nke,_ke,Dke,Fke,Pke,zke,nke,Bke,Wke,Uke,Hke,twe,owe,Kke,Jve,Zke,Jke,t5e,r5e,Qke,i5e,u5e,o5e,p5e,f5e,m5e,x5e,b5e,v5e,w5e,I5e,S5e,T5e,_5e,R5e,E5e,yR,F5e,Xwe,P5e,awe,U5e,iwe,j5e,uwe,Y5e,J5e,e3e,pwe,r3e,o3e,i3e,u3e,p3e,fwe,mwe,Qve,f3e,Yke,m3e,x3e,b3e,Zwe,xwe,bwe,v3e,vwe,k3e,S3e,T3e,R3e,$3e,O3e,kwe,z3e,B3e,W3e,U3e,H3e,P3e,K3e,Z3e,Cwe,J3e,tIe,oIe,Nwe,_we,lIe,pIe,hIe,Rwe,gIe,yIe,bIe,gV,kIe,Jwe,Fwe,CIe,ewe,NIe,Qwe,eke,tke,_Ie,RIe,$Ie,OIe,MIe,zIe,BIe,Pwe,WIe,UIe,KIe,zwe,ZIe,JIe,eCe,Lwe,rIe,rCe,oCe,iCe,uCe,pCe,fCe,mCe,xCe,Wwe,yCe,Uwe,ACe,wCe,ICe,SCe,TCe,Kwe,D5e,ECe,DCe,FCe,PCe,Dwe,zCe,HCe,KCe,ZCe,xIe];for(let e of YCe)Mc(e);var AV={};Rt(AV,{assertNotComplex:()=>j0,bindCanvasToFramebuffer:()=>uSe,bindColorTextureToFramebuffer:()=>N5,bindTextureToProgramUniformSampler:()=>OV,bindTextureUnit:()=>DV,bindVertexBufferToProgramAttribute:()=>kR,callAndCheck:()=>Qe,canBeRepresented:()=>vV,createFragmentShader:()=>IV,createFramebuffer:()=>RV,createProgram:()=>CV,createStaticIndexBuffer:()=>TV,createStaticVertexBuffer:()=>NV,createTexture:()=>_V,createVertexShader:()=>kV,getBatchDim:()=>fh,getExtensionOrThrow:()=>Qb,getFramebufferErrorMessage:()=>PV,getMaxTexturesInShader:()=>BV,getNumChannels:()=>iSe,getProgramUniformLocation:()=>FV,getProgramUniformLocationOrThrow:()=>$V,getRowsCols:()=>hh,getShapeAs3D:()=>T5,getTextureShapeFromLogicalShape:()=>zV,getWebGLDisjointQueryTimerVersion:()=>VV,getWebGLErrorMessage:()=>wV,getWebGLMaxTextureSize:()=>LV,hasExtension:()=>ga,isCapableOfRenderingToFloatTexture:()=>WV,isDownloadFloatTextureEnabled:()=>GV,isReshapeFree:()=>tA,isWebGLFenceEnabled:()=>UV,isWebGLVersionEnabled:()=>CR,linkProgram:()=>SV,resetMaxTextureSize:()=>cSe,resetMaxTexturesInShader:()=>pSe,unbindColorTextureFromFramebuffer:()=>IR,unbindTextureUnit:()=>lSe,validateFramebuffer:()=>eA,validateProgram:()=>S5,validateTextureSize:()=>EV});var dh={},vR={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function I5(e,t){dh[e]=t}function ml(e){if(!(e in dh)){let n=QCe(e);if(n!==null)dh[e]=n;else return console.log("Could not get context for WebGL version",e),null}let t=dh[e];return t.isContextLost()?(delete dh[e],ml(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),dh[e])}function JCe(e){if(typeof OffscreenCanvas!="undefined"&&e===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function QCe(e){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=JCe(e);return t.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete dh[e]},!1),e===1?t.getContext("webgl",vR)||t.getContext("experimental-webgl",vR):t.getContext("webgl2",vR)}var Yb;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(Yb||(Yb={}));var ma;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(ma||(ma={}));var ws;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(ws||(ws={}));function Jb(e,t){return[t,e]}function eSe(e,t){return e*t}function C5(e){let t=E.sizeFromShape(e),n=Math.ceil(t/4);return E.sizeToSquarishShape(n)}function U0(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function tSe(e,t){let[n,r]=U0(e,t);return n*r*4}function wR(e,t){let n=e,r,s,o,a,i,l,u,c,p,d;return be().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,o=n.RGBA16F,a=n.RGBA32F,i=n.RED,u=4,c=1,p=n.HALF_FLOAT,d=n.FLOAT):(r=e.RGBA,s=e.RGBA,o=e.RGBA,a=n.RGBA,i=e.RGBA,u=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,d=e.FLOAT),l=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:d}}function Qe(e,t){let n=t();return be().getBool("DEBUG")&&nSe(e),n}function nSe(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+wV(e,t))}var rSe=596e-10,sSe=65504;function vV(e){return!!(be().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||rSe<Math.abs(e)&&Math.abs(e)<sSe)}function wV(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Qb(e,t){return Zl(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function kV(e,t){let n=Zl(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Qe(e,()=>e.shaderSource(n,t)),Qe(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function IV(e,t){let n=Zl(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Qe(e,()=>e.shaderSource(n,t)),Qe(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw aSe(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var oSe=/ERROR: [0-9]+:([0-9]+):/g;function aSe(e,t){let n=oSe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],s=e.split(`
`),o=s.length.toString().length+2,a=s.map((p,d)=>E.rightPad((d+1).toString(),o)+p),i=0;for(let p=0;p<a.length;p++)i=Math.max(a[p].length,i);let l=a.slice(0,r-1),u=a.slice(r-1,r),c=a.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${E.rightPad(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function CV(e){return Zl(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function SV(e,t){if(Qe(e,()=>e.linkProgram(t)),e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function S5(e,t){if(Qe(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function NV(e,t){let n=Zl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Qe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Qe(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function TV(e,t){let n=Zl(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Qe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),Qe(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function iSe(){return be().getNumber("WEBGL_VERSION")===2?1:4}function _V(e){return Zl(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function EV(e,t){let n=be().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function RV(e){return Zl(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function kR(e,t,n,r,s,o,a){let i=e.getAttribLocation(t,n);return i===-1?!1:(Qe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),Qe(e,()=>e.vertexAttribPointer(i,s,e.FLOAT,!1,o,a)),Qe(e,()=>e.enableVertexAttribArray(i)),!0)}function DV(e,t,n){MV(e,n),Qe(e,()=>e.activeTexture(e.TEXTURE0+n)),Qe(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function lSe(e,t){MV(e,t),Qe(e,()=>e.activeTexture(e.TEXTURE0+t)),Qe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function $V(e,t,n){return Zl(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function FV(e,t,n){return e.getUniformLocation(t,n)}function OV(e,t,n,r){Qe(e,()=>DV(e,t,r)),Qe(e,()=>e.uniform1i(n,r))}function uSe(e){Qe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Qe(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),Qe(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function N5(e,t,n){Qe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),Qe(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function IR(e,t){Qe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),Qe(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function eA(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+PV(e,t))}function PV(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Zl(e,t,n){let r=Qe(e,()=>t());if(r==null)throw new Error(n);return r}function MV(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function fh(e,t=2){return E.sizeFromShape(e.slice(0,e.length-t))}function hh(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function T5(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[fh(e),...hh(e)]),t}function zV(e,t=!1){let n=be().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(n=n*2,e=e.map((s,o)=>o>=e.length-2?E.nearestLargerEven(e[o]):e[o]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=E.squeezeShape(e).newShape);let r=E.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(e.length===2&&e[0]<=n&&e[1]<=n)return e;if(e.length===3&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(e.length===3&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){let s=fh(e),o=2,a=2;return e.length&&([o,a]=hh(e)),r=s*(o/2)*(a/2),E.sizeToSquarishShape(r).map(i=>i*2)}return E.sizeToSquarishShape(r)}function _5(e){return e%2==0}function tA(e,t){if(e=e.slice(-2),t=t.slice(-2),E.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r||_5(n)&&_5(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&_5(e[0])&&_5(t[0])}var E5,R5;function LV(e){if(E5==null){let t=ml(e);E5=t.getParameter(t.MAX_TEXTURE_SIZE)}return E5}function cSe(){E5=null}function pSe(){R5=null}function BV(e){if(R5==null){let t=ml(e);R5=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,R5)}function VV(e){if(e===0)return 0;let t,n=ml(e);return ga(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:ga(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function ga(e,t){return e.getExtension(t)!=null}function CR(e){try{if(ml(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function WV(e){if(e===0)return!1;let t=ml(e);if(e===1){if(!ga(t,"OES_texture_float"))return!1}else if(!ga(t,"EXT_color_buffer_float"))return!1;return SR(t)}function GV(e){if(e===0)return!1;let t=ml(e);if(e===1){if(!ga(t,"OES_texture_float")||!ga(t,"WEBGL_color_buffer_float"))return!1}else{if(ga(t,"EXT_color_buffer_float"))return SR(t);let r="EXT_color_buffer_half_float";if(ga(t,r)){let s=t.getExtension(r);return dSe(t,s)}return!1}return SR(t)}function SR(e){let t=wR(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(o),a}function dSe(e,t){let n=wR(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let s=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),i}function UV(e){return e!==2?!1:ml(e).fenceSync!=null}function j0(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&E.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var xt=be();xt.registerFlag("HAS_WEBGL",()=>xt.getNumber("WEBGL_VERSION")>0);xt.registerFlag("WEBGL_VERSION",()=>CR(2)?2:CR(1)?1:0);xt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);xt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>xt.get("WEBGL_VERSION")===2);xt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);xt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);xt.registerFlag("WEBGL_PACK",()=>xt.getBool("HAS_WEBGL"));xt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_CLIP",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_PACK_REDUCE",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_LAZILY_UNPACK",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_CONV_IM2COL",()=>xt.getBool("WEBGL_PACK"));xt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>LV(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>BV(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=xt.getNumber("WEBGL_VERSION");return e===0?0:VV(e)});xt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>xt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ob.isMobile());xt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>WV(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>xt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:xt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));xt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>GV(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>UV(xt.getNumber("WEBGL_VERSION")));xt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>xt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);xt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});xt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ob.isMobile()&&xt.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});xt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);xt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);xt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);xt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function Us(){let e,t,n,r,s,o,a,i,l,u;return be().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",o="outputColor",a="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function mh(e,t,n="index"){let r=E.computeStrides(t);return r.map((s,o)=>{let a=`int ${e[o]} = ${n} / ${s}`,i=o===r.length-1?`int ${e[o+1]} = ${n} - ${e[o]} * ${s}`:`index -= ${e[o]} * ${s}`;return`${a}; ${i};`}).join("")}function D5(e,t,n="index"){let r=E.computeStrides(t);return r.map((s,o)=>{let a=`int ${e[o]} = ${n} / outShapeStrides[${o}]`,i=o===r.length-1?`int ${e[o+1]} = ${n} - ${e[o]} * outShapeStrides[${o}]`:`index -= ${e[o]} * outShapeStrides[${o}]`;return`${a}; ${i};`}).join("")}function fSe(e,t){let n=e.length,r=e.map(o=>`${t}[${o}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let o=n-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function hSe(e,t,n="index"){let r=e.map((o,a)=>a),s=fSe(r,t);return s.map((o,a)=>{let i=`int ${e[a]} = ${n} / ${s[a]}`,l=a===s.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s[a]}`:`index -= ${e[a]} * ${s[a]}`;return`${i}; ${l};`}).join("")}function NR(e){let t=E.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function TR(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var jV=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:HV}=G;function mSe(e,t,n){let r=[];if(e.forEach(f=>{let h=E.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${h>1?`[${h}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),n.enableShapeUniforms){let{uniformShape:m}=_R(n.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let s=r.join(`
`),o=e.map(f=>gSe(f,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),a=t.texShape,i=Us(),l=bSe(i),u,c,p=wSe(i);return t.isPacked?(u=xSe(t.logicalShape,a,n.enableShapeUniforms),c=vSe(i)):(u=ySe(t.logicalShape,a,n.enableShapeUniforms),c=ASe(i)),n.packedInputs&&(p+=SSe),[p,l,c,s,u,o,n.userCode].join(`
`)}function H0(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return zSe(e,t);case 1:return BSe(e,t);case 2:return WSe(e,t);case 3:return USe(e,t);case 4:return HSe(e,t);case 5:return qSe(e);case 6:return KSe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function qV(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return MSe(e);case 1:return LSe(e,t);case 2:return VSe(e,t);case 3:return GSe(e,t);default:return jSe(e,t)}}function gSe(e,t,n=!1,r){let s="";n?s+=qV(e,r):s+=H0(e,r);let o=e.shapeInfo.logicalShape,a=t.logicalShape;return o.length<=a.length&&(n?s+=XSe(e,t):s+=ZSe(e,t)),s}function xSe(e,t,n){switch(e.length){case 0:return KV();case 1:return NSe(e,t,n);case 2:return OSe(e,t,n);case 3:return _Se(e,t,n);default:return RSe(e,t,n)}}function ySe(e,t,n){switch(e.length){case 0:return KV();case 1:return TSe(e,t,n);case 2:return PSe(e,t,n);case 3:return ESe(e,t,n);case 4:return DSe(e,t,n);case 5:return $Se(e,t);case 6:return FSe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function bSe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function ASe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function vSe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function wSe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${kSe}
    ${ISe}
    ${CSe}
  `}var kSe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ISe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,CSe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SSe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function KV(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function NSe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function TSe(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function _Se(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),o=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function ESe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${D5(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=mh(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function RSe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),o=s*Math.ceil(e[e.length-2]/2),a=o,i="",l="b, r, c";for(let u=2;u<e.length-1;u++)a*=e[e.length-u-1],i=`
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    `+i,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${i}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${l});
    }
  `}function DSe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${D5(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=mh(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function $Se(e,t){let n=mh(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function FSe(e,t){let n=mh(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function OSe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(E.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function PSe(e,t,n){return E.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function gh(e){return`offset${e}`}function MSe(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Us();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function zSe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[s,o]=e.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let a=gh(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});
      return sampleTexture(${n}, uv);
    }
  `;let[i,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${i}, ${l}, ${a});
      return sampleTexture(${n}, uv);
    }
  `}function LSe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,o=Us();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;let a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function BSe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${q0(e)}
      }
    `;let s=e.shapeInfo.texShape,o=s[0],a=s[1];if(a===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=gh(n);return a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${a}, index + ${i});
      return sampleTexture(${n}, uv);
    }
  `}function VSe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=o[0],i=o[1],l=Us();if(o!=null&&E.arraysEqual(n,o))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function WSe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape;if(o!=null&&E.arraysEqual(n,o)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=o[0],f=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:a,keptDims:i}=E.squeezeShape(n),l=a;if(l.length<n.length){let d=K0(e,l),f=["row","col"];return`
      ${H0(d,t)}
      float ${s}(int row, int col) {
        return ${s}(${X0(f,i)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${q0(e)}
      }
    `;let u=o[0],c=o[1],p=gh(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function GSe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){let d=n.slice(1),f=[1,2],h=K0(e,d),m=["b","row","col"];return`
        ${qV(h,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${X0(m,f)});
        }
      `}let i=Us();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `;let l=a[0],u=a[1],c=Math.ceil(n[2]/2),p=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${p}, ${c}, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `}function USe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],a=n[2],{newShape:i,keptDims:l}=E.squeezeShape(n),u=i;if(u.length<n.length){let m=K0(e,u),g=["row","col","depth"];return`
        ${H0(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${X0(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${a}, 1)));
        ${q0(e)}
      }
    `;let c=e.shapeInfo.texShape,p=c[0],d=c[1],f=e.shapeInfo.flatOffset;if(d===o&&f==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===a&&f==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let h=gh(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * ${o} + col * ${a} + depth + ${h};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${a} + depth + ${h};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function jSe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Us();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;let o=e.shapeInfo.logicalShape,a=o.length,i=e.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=l[0],c=l[1],p=Math.ceil(o[a-1]/2),d=p*Math.ceil(o[a-2]/2),f="int b, int row, int col",h=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let m=2;m<a-1;m++)f=`int b${m}, `+f,d*=o[a-m-1],h=`b${m} * ${d} + `+h;return`
    vec4 ${r}(${f}) {
      int index = ${h};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function HSe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],a=n[2]*o,i=n[1]*a,{newShape:l,keptDims:u}=E.squeezeShape(n);if(l.length<n.length){let y=K0(e,l),b=["row","col","depth","depth2"];return`
      ${H0(y,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${X0(b,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${o}, 1)));
        ${q0(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],f=p[1],h=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===i&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${h}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(f===o&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let x=gh(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${x});
      return sampleTexture(${r}, uv);
    }
  `}function qSe(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],o=t[3]*s,a=t[2]*o,i=t[1]*a,{newShape:l,keptDims:u}=E.squeezeShape(t);if(l.length<t.length){let m=K0(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${H0(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${X0(g,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${o}, ${s})) +
          depth3;
        ${q0(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],f=p[1];if(f===i&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;let h=gh(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${o} +
          depth2 * ${s} + depth3 + ${h};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function KSe(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=E.squeezeShape(t);if(s.length<t.length){let g=K0(e,s),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${H0(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${X0(x,o)});
      }
    `}let a=t[5],i=t[4]*a,l=t[3]*i,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${q0(e)}
      }
    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,f=d[0],h=d[1];if(h===c&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===a&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=gh(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${m};
      vec2 uv = uvFromFlat(${f}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function q0(e){let t=e.name,n=E.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function XSe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,a=t.logicalShape.length,i=HV(e.shapeInfo.logicalShape,t.logicalShape),l=Dn(a),u=a-o,c,p=["x","y","z","w","u","v"];o===0?c="":a<2&&i.length>=1?c="coords = 0;":c=i.map(y=>`coords.${p[y+u]} = 0;`).join(`
`);let d="";a<2&&o>0?d="coords":d=e.shapeInfo.logicalShape.map((y,b)=>`coords.${p[b+u]}`).join(", ");let f="return outputValue;",m=E.sizeFromShape(e.shapeInfo.logicalShape)===1,x=E.sizeFromShape(t.logicalShape)===1;if(o===1&&!m&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!x)a===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(i.length){let y=o-2,b=o-1;i.indexOf(y)>-1&&i.indexOf(b)>-1?f="return vec4(outputValue.x);":i.indexOf(y)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(b)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${d});
      ${f}
    }
  `}function ZSe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.texShape,a=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===l&&e.shapeInfo.flatOffset==null&&E.arraysEqual(a,o))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let u=Dn(l),c=HV(e.shapeInfo.logicalShape,t.logicalShape),p=l-i,d,f=["x","y","z","w","u","v"];i===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(m=>`coords.${f[m+p]} = 0;`).join(`
`);let h="";return l<2&&i>0?h="coords":h=e.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${r}(${h});
    }
  `}function Dn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function _R(e,t,n){let{newShape:r,keptDims:s}=E.squeezeShape(t),o=t.length,a=e&&o===3&&t[0]===1,i=a?t.slice(1):r,l=!e&&o>1&&!E.arraysEqual(t,n)&&r.length<o||a;return{useSqueezeShape:l,uniformShape:l?i:t,keptDims:s}}function K0(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function X0(e,t){return t.map(n=>e[n]).join(", ")}function YSe(e,t,n,r){let s=n.map((b,A)=>{let v={logicalShape:b.shape,texShape:b.isUniform?null:b.texData.texShape,isUniform:b.isUniform,isPacked:b.isUniform?!1:b.texData.isPacked,flatOffset:null};return b.texData!=null&&b.texData.slice!=null&&b.texData.slice.flatOffset>0&&(v.flatOffset=b.texData.slice.flatOffset),{name:t.variableNames[A],shapeInfo:v}}),o=s.map(b=>b.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=mSe(s,a,t),l=e.createProgram(i),u=null,c=e.getUniformLocation(l,"NAN",!1);be().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(l,"INFINITY",!1));let p=!1,d={},f={},h={};for(let b=0;b<t.variableNames.length;b++){let A=t.variableNames[b];d[A]=e.getUniformLocation(l,A,p),d[`offset${A}`]=e.getUniformLocation(l,`offset${A}`,p),t.enableShapeUniforms&&(f[`${A}Shape`]=e.getUniformLocation(l,`${A}Shape`,p),h[`${A}TexShape`]=e.getUniformLocation(l,`${A}TexShape`,p))}let m,g,x;t.enableShapeUniforms&&(m=e.getUniformLocation(l,"outShape",p),x=e.getUniformLocation(l,"outShapeStrides",p),g=e.getUniformLocation(l,"outTexShape",p));let y=[];return t.customUniforms&&t.customUniforms.forEach((b,A)=>{y[A]=e.getUniformLocation(l,b.name,p)}),{program:t,source:i,webGLProgram:l,uniformLocations:d,customUniformLocations:y,inShapeInfos:o,outShapeInfo:a,infLoc:u,nanLoc:c,inShapesLocations:f,inTexShapesLocations:h,outShapeLocation:m,outShapeStridesLocation:x,outTexShapeLocation:g}}function XV(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let s=n.logicalShape,o=t[r],a=o.shape;if(!E.arraysEqual(s,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${a} must match`);if(n.isUniform&&o.isUniform)return;let i=n.texShape,l=o.isUniform?null:o.texData.texShape;if(!E.arraysEqual(i,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${l} must match`)})}function JSe(e,t,n,r,s){t.program.enableShapeUniforms||(XV(t.inShapeInfos,n),XV([t.outShapeInfo],[r]));let o=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(o,a[0],a[1]):e.setOutputMatrixTexture(o,a[0],a[1]),e.setProgram(t.webGLProgram),be().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((l,u)=>{let c=t.program.variableNames[u],p=t.uniformLocations[c],d=t.uniformLocations[`offset${c}`],f=t.inShapesLocations[`${c}Shape`],h=t.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:m}=_R(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(f,new Int32Array(m));break;case 2:e.gl.uniform2iv(f,new Int32Array(m));break;case 3:e.gl.uniform3iv(f,new Int32Array(m));break;case 4:e.gl.uniform4iv(f,new Int32Array(m));break;default:break}}if(h&&e.gl.uniform2i(h,l.texData.texShape[0],l.texData.texShape[1]),p!=null){if(l.isUniform){if(E.sizeFromShape(l.shape)<2)e.gl.uniform1f(p,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(p,m)}return}l.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,l.texData.slice.flatOffset),e.setInputMatrixTexture(l.texData.texture,p,u)}});let i=t.outShapeLocation;if(i)switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let l=E.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break;default:break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((l,u)=>{let c=t.customUniformLocations[u],p=s[u];if(l.type==="float")e.gl.uniform1fv(c,p);else if(l.type==="vec2")e.gl.uniform2fv(c,p);else if(l.type==="vec3")e.gl.uniform3fv(c,p);else if(l.type==="vec4")e.gl.uniform4fv(c,p);else if(l.type==="int")e.gl.uniform1iv(c,p);else if(l.type==="ivec2")e.gl.uniform2iv(c,p);else if(l.type==="ivec3")e.gl.uniform3iv(c,p);else if(l.type==="ivec4")e.gl.uniform4iv(c,p);else throw Error(`uniform type ${l.type} is not supported yet.`)}),e.executeProgram()}function QSe(e,t,n){let r="";t.concat(n).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!a.isUniform){let l=a.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:p}=_R(e.packedInputs,a.shape,l),d="",f="",h="";if(c.length===1&&e.packedInputs){let v=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${v[0]>1}_${v[1]>1}`}else if(c.length===2&&!e.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let v=E.computeStrides(c);h=`${v[0]===l[1]}_${v[v.length-1]===l[1]}`}let m=a.shape.length,g=c.length===2&&E.arraysEqual(a.shape,l),x=E.sizeFromShape(a.shape)===1,y=G.getBroadcastDims(a.shape,n.shape),b=!e.packedInputs&&m===n.shape.length&&E.arraysEqual(l,n.texData.texShape),A=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${b}_${u?p:""}_${c.length}_${x}_${y}_${g}_${d}_${f}_${h}_${A}_${i}`}else{let l=a.isUniform?"uniform":a.texData.texShape;r+=`${a.shape}_${l}_${i}`}});let s=e.userCode,o=e.constructor.name;return o+="_"+r+"_"+s+`${be().getNumber("WEBGL_VERSION")}`,o}function xa(e){return be().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var eNe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Yb.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Us();this.outputShape=e,this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?D5(["r","c","d"],e):mh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},tNe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Yb.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Us();this.outputShape=e,this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?D5(["r","c","d"],e):mh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},nNe=class{constructor(e){this.variableNames=["A"],this.outTexUsage=ma.DOWNLOAD;let t=Us();this.outputShape=e,this.userCode=`
      ${jV}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},rNe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ma.DOWNLOAD;let t=Us();this.outputShape=e,this.userCode=`
      ${jV}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},sNe=class{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Us();this.outputShape=e,this.enableShapeUniforms=xa(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?TR():NR(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${r}, 0., 0., 0.);
      }
    `}},oNe=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Us();this.outputShape=e,this.enableShapeUniforms=xa(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){let i=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${i}] = values[0];
            } else if (offset == 1) {
              result[${i}] = values[1];
            } else if (offset == 2) {
              result[${i}] = values[2];
            } else {
              result[${i}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?TR():NR(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${s};
        }
    `}},ZV={};Rt(ZV,{bindVertexProgramAttributeStreams:()=>oW,createBufferFromOutputTexture:()=>lW,createFloat16MatrixTexture:()=>tW,createFloat16PackedMatrixTexture:()=>sW,createFloat32MatrixTexture:()=>eW,createIndexBuffer:()=>QV,createPackedMatrixTexture:()=>rW,createUnsignedBytesMatrixTexture:()=>nW,createVertexBuffer:()=>JV,createVertexShader:()=>YV,downloadByteEncodedFloatMatrixFromOutputTexture:()=>cW,downloadFloat32MatrixFromBuffer:()=>uW,downloadMatrixFromPackedOutputTexture:()=>dW,downloadPackedMatrixFromBuffer:()=>pW,getInternalFormatForFloat16MatrixTexture:()=>RR,getInternalFormatForFloat16PackedMatrixTexture:()=>FR,getInternalFormatForFloat32MatrixTexture:()=>ER,getInternalFormatForPackedMatrixTexture:()=>$R,getInternalFormatForUnsignedBytesMatrixTexture:()=>DR,uploadDenseMatrixToTexture:()=>aW,uploadPixelDataToTexture:()=>iW});function YV(e){let t=Us(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return kV(e,n)}function JV(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return NV(e,t)}function QV(e){let t=new Uint16Array([0,1,2,2,1,3]);return TV(e,t)}function nA(e,t,n,r,s,o){EV(t,n);let a=_V(e),i=e.TEXTURE_2D;return Qe(e,()=>e.bindTexture(i,a)),Qe(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),Qe(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),Qe(e,()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST)),Qe(e,()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST)),Qe(e,()=>e.texImage2D(i,0,r,t,n,0,s,o,null)),Qe(e,()=>e.bindTexture(e.TEXTURE_2D,null)),a}function ER(e){return e.internalFormatFloat}function eW(e,t,n,r){let[s,o]=Jb(t,n);return nA(e,s,o,ER(r),r.textureFormatFloat,e.FLOAT)}function RR(e){return e.internalFormatHalfFloat}function tW(e,t,n,r){let[s,o]=Jb(t,n);return nA(e,s,o,RR(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function DR(e){return e.downloadTextureFormat}function nW(e,t,n,r){let[s,o]=Jb(t,n);return nA(e,s,o,DR(r),e.RGBA,e.UNSIGNED_BYTE)}function $R(e){return e.internalFormatPackedFloat}function rW(e,t,n,r){let[s,o]=U0(t,n);return nA(e,s,o,$R(r),e.RGBA,e.FLOAT)}function FR(e){return e.internalFormatPackedHalfFloat}function sW(e,t,n,r){let[s,o]=U0(t,n);return nA(e,s,o,FR(r),e.RGBA,r.textureTypeHalfFloat)}function oW(e,t,n){let r=0,s=3*4,o=3*4+2*4;return Qe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),kR(e,t,"clipSpacePos",n,3,o,r)&&kR(e,t,"uv",n,2,o,s)}function aW(e,t,n,r,s,o){Qe(e,()=>e.bindTexture(e.TEXTURE_2D,t));let a,i,l;s instanceof Uint8Array?(a=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,l=e.RGBA):(a=new Float32Array(n*r*4),i=e.FLOAT,l=o.internalFormatPackedFloat),a.set(s),Qe(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,i,a)),Qe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function iW(e,t,n){Qe(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?Qe(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):Qe(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),Qe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function lW(e,t,n,r){let s=e.createBuffer();Qe(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));let i=4*4*t*n;return Qe(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),Qe(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),Qe(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function uW(e,t,n){let r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function cW(e,t,n,r){let[s,o]=Jb(t,n),a=4,i=new Uint8Array(eSe(t*n,a));return Qe(e,()=>e.readPixels(0,0,s,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function pW(e,t,n,r,s,o,a,i){let l=e,u=new Float32Array(tSe(o,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function dW(e,t,n){let r=new Float32Array(t*n*4);return Qe(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var $5=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let t=be().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,I5(t,e)):this.gl=ml(t);let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(be().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Qb(this.gl,s),ga(this.gl,o))this.textureHalfFloatExtension=Qb(this.gl,o);else if(be().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),ga(this.gl,r))this.colorBufferHalfFloatExtension=Qb(this.gl,r);else if(be().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",ga(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(ga(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=JV(this.gl),this.indexBuffer=QV(this.gl),this.framebuffer=RV(this.gl),this.textureConfig=wR(this.gl,this.textureHalfFloatExtension)}get debug(){return be().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Qe(e,()=>e.finish()),Qe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Qe(e,()=>e.deleteFramebuffer(this.framebuffer)),Qe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Qe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Qe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),eW(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),tW(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),nW(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),iW(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),aW(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),sW(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),rW(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(IR(this.gl,this.framebuffer),this.outputTexture=null),Qe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>cW(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,o){return pW(this.gl,e,t,n,r,s,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return uW(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=lW(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(be().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let o=r.clientWaitSync(s,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=s}else be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>dW(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl,n=IV(t,e);this.vertexShader==null&&(this.vertexShader=YV(t));let r=CV(t);return Qe(t,()=>t.attachShader(r,this.vertexShader)),Qe(t,()=>t.attachShader(r,n)),SV(t,r),this.debug&&S5(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=oW(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&Qe(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&S5(this.gl,this.program),Qe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?$V(this.gl,e,t):FV(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Qe(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),OV(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,s]=U0(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&S5(this.gl,this.program),eA(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),Qe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Qe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Qb(this.gl,be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await E.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=aNe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&E.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),N5(this.gl,e,this.framebuffer),this.debug&&eA(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(N5(this.gl,this.outputTexture,this.framebuffer),this.debug&&eA(this.gl)):IR(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;N5(r,e,this.framebuffer),this.debug&&eA(r),this.outputTexture=e,Qe(r,()=>r.viewport(0,0,t,n)),Qe(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),Qe(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function aNe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:iNe,bincountImpl:fW,bincountReduceImpl:lNe,ceilImpl:uNe,concatImpl:cNe,equalImpl:pNe,expImpl:dNe,expm1Impl:fNe,floorImpl:hNe,gatherNdImpl:mNe,gatherV2Impl:gNe,greaterImpl:xNe,greaterEqualImpl:yNe,lessImpl:bNe,lessEqualImpl:ANe,linSpaceImpl:vNe,logImpl:wNe,maxImpl:kNe,maximumImpl:INe,minimumImpl:CNe,multiplyImpl:SNe,negImpl:NNe,notEqualImpl:TNe,prodImpl:_Ne,rangeImpl:ENe,rsqrtImpl:RNe,sigmoidImpl:DNe,simpleAbsImpl:hW,sliceImpl:$Ne,sparseFillEmptyRowsImpl:FNe,sparseReshapeImpl:ONe,sparseSegmentReductionImpl:mW,sqrtImpl:PNe,stridedSliceImpl:MNe,stringNGramsImpl:zNe,stringSplitImpl:LNe,stringToHashBucketFastImpl:BNe,subImpl:VNe,tileImpl:WNe,topKImpl:GNe,transposeImpl:OR,uniqueImpl:UNe}=gB;function gW(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function js(e,t){return t===1?[e]:gW(e,t)}function jNe(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var HNe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;let t=e.length;if(t===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let n=js("rc",t),r=Dn(t),s=KNe(t,e,n),o=XNe(t,e[e.length-1],e[e.length-2],n),a=ZNe(e,n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${a}));
          }
        }
      `}}};function qNe(e,t){let n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let a=2;a<e;a++)o=`${t[t.length-1-a]},`+o;n.push(o)}return n}function KNe(e,t,n){if(e===1)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s]}`,s<e-1&&(r+="||");return r}function XNe(e,t,n,r){if(e===1)return"";let s=r.slice(-2);return`
    int r = ${s[0]};
    int c = ${s[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${t};
    bool rEdge = rp1 >= ${n};
  `}function ZNe(e,t){let n=e.length,r=qNe(n,t);return n===1?`getA(rc),
            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${r[0]}),
          cEdge ? 0. : getA(${r[1]}),
          rEdge ? 0. : getA(${r[2]}),
          rEdge || cEdge ? 0. : getA(${r[3]})`}var xW=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=xa(this.outputShape.length);let n="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2==1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${YNe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?TR():NR(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function YNe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?hSe(["r","c","d"],"inputShape"):mh(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var JNe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){let r=bW(t,n),s=AW(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let o=yW(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();let i=this.freeTextures[s].shift();return this.usedTextures[s].push(i),i}let a;return r===ws.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===ws.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===ws.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===ws.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===ws.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let s=bW(n,r),o=AW(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]);let a=yW(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=be().get("WEBGL_DELETE_TEXTURE_THRESHOLD");i!==-1&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[o],u=l.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function QNe(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}function yW(e,t,n,r,s){let o=eTe(t,r),a;if(s){let[l,u]=U0(e[0],e[1]);a=l*u}else{let[l,u]=Jb(e[0],e[1]);a=l*u}let i=QNe(n,o);return a*i}function eTe(e,t){switch(e){case ws.PACKED_2X2_FLOAT32:return $R(t);case ws.PACKED_2X2_FLOAT16:return FR(t);case ws.UNPACKED_FLOAT32:return ER(t);case ws.UNPACKED_FLOAT16:return RR(t);case ws.PACKED_4X1_UNSIGNED_BYTE:return DR(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function tTe(e){return be().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?ws.PACKED_2X2_FLOAT32:ws.UNPACKED_FLOAT32:e?ws.PACKED_2X2_FLOAT16:ws.UNPACKED_FLOAT16}function bW(e,t){if(e===ma.UPLOAD)return ws.PACKED_2X2_FLOAT32;if(e===ma.RENDER||e==null)return tTe(t);if(e===ma.DOWNLOAD||e===ma.PIXELS)return ws.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function AW(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var rp=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Ti="if (isnan(x)) return x;",nTe="return x;",vW="return abs(x);",rTe="return (x >= 0.0) ? x : (exp(x) - 1.0);",sTe=Ti+`
  return (x < 0.0) ? 0.0 : x;
`,oTe=Ti+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,F5="return x;",aTe="return 1.0 / (1.0 + exp(-1.0 * x));",iTe="return x;",lTe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,uTe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cTe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,pTe="return 1.0 / (1.0 + exp(-1.0 * x));",Z0=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},dTe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;let t=e.length,n=js("rc",t),r=Dn(t),s=jNe(t,n),o=n.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}},fTe=ll.whereImpl,hTe=1e-7,mTe=1e-4,O5={};function gTe(e){return e in O5||(O5[e]={}),O5[e]}var xTe=be().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),yTe=600;function bTe(){return be().global.screen==null?1024:be().global.screen.height*be().global.screen.width*window.devicePixelRatio*yTe/1024/1024}var Y0=class extends $1{constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!be().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){let t=ml(be().getNumber("WEBGL_VERSION"));this.binaryCache=gTe(be().getNumber("WEBGL_VERSION")),this.gpgpu=new $5(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new JNe(this.gpgpu),this.numMBBeforeWarning=bTe(),this.texData=new Xv(this,zo())}nextDataId(){return Y0.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((be().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||be().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:ma.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,s){if(be().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:ma.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:o,shape:a,isPacked:i}=t;if(o!=null){let p;i?p=new Z0(a,F5):p=new rp(a,F5);let d=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:r}],r),f=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),f}if(n!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return n;let l=this.activeTimers!=null,u;l&&(u=E.now());let c;if(r==="complex64"){let p=this.readSync(s.real.dataId),d=this.readSync(s.imag.dataId);c=G.mergeRealAndImagArrays(p,d)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=E.now()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){let f=this.pendingRead.get(e);return new Promise(h=>f.push(h))}let t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:o,complexTensorInfos:a,isPacked:i}=t;if(s!=null){let f;i?f=new Z0(r,F5):f=new rp(r,F5);let h=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:o}],o),m=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),m}if(n!=null)return this.convertAndCacheOnCPU(e);if(!be().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&be().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,u;if(o!=="complex64"&&be().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);let f=this.texData.get(u.dataId);l=this.gpgpu.createBufferFromTexture(f.texture,...C5(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let c;if(o==="complex64"){let f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),h=f[0],m=f[1];c=G.mergeRealAndImagArrays(h,m)}else if(l==null)c=this.getValuesFromTexture(e);else{let f=E.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),l!=null){let f=this.gpgpu.gl;Qe(f,()=>f.deleteBuffer(l))}let p=this.convertAndCacheOnCPU(e,c),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(f=>f(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&zo().removeDataId(e,this),this.pendingDeletes--),p}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(r=>E.decodeString(r))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return Wt(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!vV(n))throw be().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=E.sizeFromShape(t);if(be().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let p=this.decode(e),d=this.texData.get(p.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(d.texture,...C5(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(p),f}let o=be().getBool("WEBGL_PACK")&&r===!0,a=o?T5(t):t,i=o?new rNe(a):new nNe(a),l=this.runWebGLProgram(i,[{shape:a,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){let t=this.activeTimers,n=[],r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=E.flatten(this.activeTimers.map(i=>i.query)).filter(i=>i!=null),o=E.flatten(this.activeTimers.map(i=>i.name)).filter(i=>i!=null);this.activeTimers=t,r&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let i=await Promise.all(s);a.kernelMs=E.sum(i),a.getExtraProfileInfo=()=>i.map((l,u)=>({name:o[u],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:E.now(),endMs:null}}endTimer(e){return be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=E.now(),e)}async getQueryTime(e){if(be().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:s,isPacked:o,slice:a}=this.texData.get(e),i=a&&a.origDataId||e,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,o)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=xTe){return be().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&E.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){G.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return fTe(e.shape,t)}packedUnaryOp(e,t,n){let r=new Z0(e.shape,t),s=this.compileAndRun(r,[e],n);return zo().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let r=hW(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(be().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,vW,e.dtype);let t=new rp(e.shape,vW),n=this.compileAndRun(t,[e]);return zo().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&E.isString(n[0])){let s=n.map(o=>E.encodeString(o));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){let{dataId:r}=this.makeTensorInfo(e,t,n);return zo().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){let t=new dTe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new HNe(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[fh(e.shape),...hh(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[fh(t),...hh(t)],o=new xW(s,n),a=!0,i=[n],l=this.runWebGLProgram(o,[r],e.dtype,i,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e){let t=this.texData.get(e),{isPacked:n,shape:r,dtype:s}=t,o=T5(r),a,i=C5(o);n?a=new tNe(o):a=new eNe(o);let l=!0,u=[i],c=this.runWebGLProgram(a,[{shape:o,dtype:s,dataId:e}],s,u,l);return{dtype:s,shape:r,dataId:c.dataId}}runWebGLProgram(e,t,n,r,s=!1){let o=this.makeTensorInfo(e.outputShape,n),a=this.texData.get(o.dataId);if(e.packedOutput&&(a.isPacked=!0),e.outPackingScheme===Yb.DENSE){let m=C5(e.outputShape);a.texShape=m.map(g=>g*2)}if(e.outTexUsage!=null&&(a.usage=e.outTexUsage),E.sizeFromShape(o.shape)===0)return a.values=E.getTypedArrayFromDType(o.dtype,0),o;let i=[],l=t.map(m=>{if(m.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let g=this.texData.get(m.dataId);if(g.texture==null){if(!e.packedInputs&&E.sizeFromShape(m.shape)<=be().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:m.shape,texData:null,isUniform:!0,uniformValues:g.values};e.packedInputs&&(g.isPacked=!0,g.shape=m.shape)}else if(!!g.isPacked!=!!e.packedInputs)m=g.isPacked?this.unpackTensor(m):this.packTensor(m),i.push(m),g=this.texData.get(m.dataId);else if(g.isPacked&&!tA(g.shape,m.shape)){let x=m,y=m.shape;m.shape=g.shape,m=this.packedReshape(m,y),i.push(m),g=this.texData.get(m.dataId),x.shape=y}return this.uploadToGPU(m.dataId),{shape:m.shape,texData:g,isUniform:!1}});this.uploadToGPU(o.dataId);let u={shape:o.shape,texData:a,isUniform:!1},c=QSe(e,l,u),p=this.getAndSaveBinary(c,()=>YSe(this.gpgpu,e,l,u)),d=this.activeTimers!=null,f;d&&(f=this.startTimer()),JSe(this.gpgpu,p,l,u,r),i.forEach(m=>this.disposeIntermediateTensorInfo(m)),d&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));let h=be().get("WEBGL_FLUSH_THRESHOLD");if(h>0){let m=E.now();m-this.lastGlFlushTime>h&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=m)}if(!be().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&s===!1){let m=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),m}return o}compileAndRun(e,t,n,r,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(be().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ce(()=>{if(!be().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=be().getBool("DEBUG");be().set("DEBUG",!1);let t=this.abs(at(1e-8)).dataSync()[0];if(be().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?hTe:mTe}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:o,usage:a,isPacked:i}=t;if(o!=null)return;let l=this.activeTimers!=null,u;l&&(u=E.now());let c=t.texShape;if(c==null&&(c=zV(n,i),t.texShape=c),s!=null){let p=T5(n),d,f=c[1],h=c[0],m=s instanceof Uint8Array;i?([f,h]=U0(c[0],c[1]),d=new oNe(p,m)):d=new sNe(p,m);let g=this.makeTensorInfo([h,f],r);m?this.texData.get(g.dataId).usage=ma.PIXELS:this.texData.get(g.dataId).usage=ma.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId),f,h,s);let x=[[h,f]],y=!0,b=this.runWebGLProgram(d,[g],r,x,y),A=this.texData.get(b.dataId);t.texture=A.texture,t.texShape=A.texShape,t.isPacked=A.isPacked,t.usage=A.usage,this.disposeIntermediateTensorInfo(g),this.texData.delete(b.dataId),t.values=null,l&&(this.uploadWaitMs+=E.now()-u)}else{let p=this.acquireTexture(c,a,r,i);t.texture=p}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),t!=null&&(n.values=ATe(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*E.bytesPerElement(t)}};Y0.nextDataId=0;function ATe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var vTe="3.9.0";function wW(){be().set("WEBGL_FORCE_F16_TEXTURES",!0)}ob.isBrowser()&&y0("webgl",()=>new Y0,2);var wTe={forceHalfFloat:wW},kW=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,J0=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=G.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=xa(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},P5=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`,rA=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=G.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=xa(s);let o="";if(r)if(s===0||E.sizeFromShape(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Dn(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=js("coords",s);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}};function Xo(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var kTe={kernelName:sf,backendName:"webgl",kernelFunc:Xo};function sp(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(o.dataId),i=Xo({inputs:{x:r},backend:n}),l=Xo({inputs:{x:s},backend:n});return a.complexTensorInfos={real:i,imag:l},o}var ITe={kernelName:rw,backendName:"webgl",kernelFunc:sp},IW="return (a < 0.) ? b * a : a;",CW=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function CTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:o}=r,a=n.makeTensorInfo([],"float32",E.createScalarValue(o,"float32")),i=be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rA(CW,s.shape,a.shape):new J0(IW,s.shape,a.shape),l=n.runWebGLProgram(i,[s,a],s.dtype);return n.disposeIntermediateTensorInfo(a),l}var STe={kernelName:of,backendName:"webgl",kernelFunc:CTe},SW="return (a < 0.) ? b * a : a;",NW=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function NTe(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,o=be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rA(NW,r.shape,s.shape):new J0(SW,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)}var TTe={kernelName:bf,backendName:"webgl",kernelFunc:NTe},TW="if (isnan(x)) return x;",_Te=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,ETe=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function tn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{let{x:a}=s,i=o,l=r||a.dtype;if(i.shouldExecuteOnCPU([a])&&n!=null){let p=i.texData.get(a.dataId),d=n(p.values,l);return i.makeTensorInfo(a.shape,l,d)}let u=be().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new Z0(a.shape,t):c=new rp(a.shape,e),i.runWebGLProgram(c,[a],l)}}function ks({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:a,backend:i})=>{let{a:l,b:u}=a,c=i;if(r&&l.dtype==="complex64"){let h=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,x]=[[h.complexTensorInfos.real,m.complexTensorInfos.real],[h.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(b=>{let[A,v]=b,w={dataId:A.dataId,dtype:A.dtype,shape:l.shape},k={dataId:v.dataId,dtype:v.dtype,shape:u.shape},I=new J0(e,l.shape,u.shape);return c.runWebGLProgram(I,[w,k],$a(A.dtype,v.dtype))}),y=sp({inputs:{real:g,imag:x},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(x),y}let p=o||$a(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){let h=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?G.fromUint8ToStringArray(h):h,x=l.dtype==="string"?G.fromUint8ToStringArray(m):m,[y,b]=s(l.shape,u.shape,g,x,p),A=c.makeTensorInfo(b,p),v=c.texData.get(A.dataId);return v.values=y,A}let d=be().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return d?f=new rA(t,l.shape,u.shape,n):f=new J0(e,l.shape,u.shape),c.runWebGLProgram(f,[l,u],p)}}function M5(e,t=!1){if(e==="linear")return t?iTe:nTe;if(e==="relu")return t?uTe:sTe;if(e==="elu")return t?lTe:rTe;if(e==="relu6")return t?cTe:oTe;if(e==="prelu")return t?NW:SW;if(e==="leakyrelu")return t?CW:IW;if(e==="sigmoid")return t?pTe:aTe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var _W=class{constructor(e,t,n,r=!1,s=!1,o=!1,a=null,i=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=xa(this.outputShape.length);let u=r?e[1]:e[2],c=Math.ceil(u/2),p=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";a&&(i?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:m=`vec4 activation(vec4 x) {
          ${a}
        }`,g="result = activation(result);");let x=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",b="rc.x";e[0]<t[0]?y=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(b=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${c}; i++) {
          int batchA = ${y};
          int batchB = ${b};
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${h[0]});
          result += (${f[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${g}

        setOutput(result);
      }
    `}},EW={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},RW=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=G.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},DW="return a * b;";function PR(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,o=G.upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){let i=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new RW(EW.REAL,r.shape,s.shape),c=new RW(EW.IMAG,r.shape,s.shape),p=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:r.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],d=n.runWebGLProgram(u,p,"float32"),f=n.runWebGLProgram(c,p,"float32"),h=sp({inputs:{real:d,imag:f},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),h}if(n.shouldExecuteOnCPU([r,s])){let i=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=SNe(r.shape,s.shape,i.values,l.values,o),p=n.makeTensorInfo(c,o),d=n.texData.get(p.dataId);return d.values=u,p}let a;return be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new rA(DW,r.shape,s.shape):a=new J0(DW,r.shape,s.shape),n.runWebGLProgram(a,[r,s],o)}var RTe={kernelName:mf,backendName:"webgl",kernelFunc:PR};function DTe(e,t,n){let r=[fh(e.shape),...hh(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[fh(t),...hh(t)],a=new xW(o,r),i=!0,l=[r],u=n.runWebGLProgram(a,[s],e.dtype,l,i);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function qe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:o}=r,a=n,i=E.sizeFromShape(s.shape),l=E.inferFromImplicitShape(o,i),u=E.sizeFromShape(l);E.assert(i===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let c=a.texData.get(s.dataId);return c.isPacked&&!tA(s.shape,l)&&!(c.texture!==null&&tA(c.shape,l))?DTe(s,l,a):(a.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}var $Te={kernelName:Xg,backendName:"webgl",kernelFunc:qe},$W=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];let a=Math.floor(n/4)*4,i=n%4,l="sumValue += dot(values, ones);";if(t!=null){let c=1/t;l=`sumValue += dot(values * ${E.isInt(c)?c.toPrecision(2):c}, ones);`}let u="";s%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${i===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${i===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${i===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},FTe=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];let a="0.0",i="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",i="min"):t==="max"&&(a="-1.0 / 1e-20",i="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let u=Math.floor(n/4)*4,c=n%4,p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${i}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${i}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(a="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(a="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${c===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${c===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${l});
      }
    `}};function OTe(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=G.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function xh(e,t,n,r){let s=OTe(e.shape),o=e;for(let a=0;a<s.length;a++){let{inSize:i,windowSize:l,outSize:u}=s[a],c,p;n==="mean"?c=a===0?new $W({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u},i):new $W({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u}):c=new FTe({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u},n),p=o,o=r.runWebGLProgram(c,[o],t),p.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(p)}return o}var PTe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;let r=Dn(this.rank),s=MTe(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function MTe(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}var zTe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=Dn(this.rank),s=gW("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=s[u];let a=`vec2(${o.slice(-2).join()})`,i=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${i}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${i}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function z5(e,t,n){let r=be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zTe(e.shape,t):new PTe(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function LTe(e,t,n,r){let s=t,o=e.shape.length,a=E.parseAxisParam(s,e.shape),i=a,l=G.getAxesPermutation(i,o),u=l!=null,c=e;u&&(c=z5(e,l,r),i=G.getInnerMostAxes(i.length,o)),G.assertAxesAreInnerMostDims("sum",i,o);let[p,d]=G.computeOutAndReduceShapes(c.shape,i),f=p;n&&(f=G.expandShapeToKeepDim(p,a));let h=E.sizeFromShape(d),g=E.sizeFromShape(e.shape)/h,x=qe({inputs:{x:c},attrs:{shape:[g,h]},backend:r}),y=Ww(e.dtype),b=xh(x,y,"sum",r),A=qe({inputs:{x:b},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),A}function L5(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;return LTe(s,o,a,n)}var BTe={kernelName:_f,backendName:"webgl",kernelFunc:L5};function Hs(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:o}=r,a=n,i=s.shape.length,l=new Array(i);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(a.shouldExecuteOnCPU([s])){let p=a.texData.get(s.dataId).values,d=OR(p,s.shape,s.dtype,o,l);u=a.makeTensorInfo(l,s.dtype);let f=a.texData.get(u.dataId);f.values=d}else u=z5(s,o,a);return u}var VTe={kernelName:Of,backendName:"webgl",kernelFunc:Hs},FW=1e3;function B5({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,p=n?e.shape[u-2]:e.shape[u-1],d=r?t.shape[c-1]:t.shape[c-2],f=n?e.shape[u-1]:e.shape[u-2],h=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),x=E.sizeFromShape(m),y=E.sizeFromShape(g),b=x===y||x===1||y===1;E.assert(u>=2&&c>=2&&b,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);let v=(x>y?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([f,h]);E.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let w=n?[x,p,f]:[x,f,p],k=r?[y,h,d]:[y,d,h],I=qe({inputs:{x:e},backend:s,attrs:{shape:w}}),N=qe({inputs:{x:t},backend:s,attrs:{shape:k}}),T=[I,N],_=Math.max(x,y),R=n?I.shape[1]:I.shape[2],S=o!=null,F=a!=null,B=l==="leakyrelu",W=l!=null?M5(l,!0):null,q=S||F||B||W!=null,K;if((f===1||h===1)&&R>FW&&q===!1){let Q=I,ee=N;n&&(Q=Hs({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),T.push(Q)),r&&(ee=Hs({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),T.push(ee));let ue=h!==1,re=h===1,de=Q;ue&&(de=qe({inputs:{x:Q},backend:s,attrs:{shape:[_,R,1]}}),T.push(de));let fe=h===1?2:1,me=ee;re&&(me=qe({inputs:{x:ee},backend:s,attrs:{shape:[_,1,R]}}),T.push(me));let xe=PR({inputs:{a:de,b:me},backend:s});K=L5({inputs:{x:xe},backend:s,attrs:{axis:fe,keepDims:!0}}),T.push(xe)}else{let Q=$a(e.dtype,t.dtype),ee=new _W(w,k,[_,f,h],n,r,S,W,F,B),ue=[I,N];if(o!=null&&ue.push(o),F&&ue.push(a),B){let re=s.makeTensorInfo([],"float32",E.createScalarValue(i,"float32"));ue.push(re),T.push(re)}K=s.runWebGLProgram(ee,ue,Q)}let J=qe({inputs:{x:K},backend:s,attrs:{shape:v}});T.push(K);for(let Q of T)s.disposeIntermediateTensorInfo(Q);return J}function WTe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o,bias:a,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r;return B5({a:s,b:o,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:i,leakyreluAlpha:p,activation:c})}var GTe={kernelName:Pf,backendName:"webgl",kernelFunc:WTe},OW="return abs(x);";function UTe(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let o=n.texData.get(r.dataId),a=hW(o.values);return n.makeTensorInfo(r.shape,r.dtype,a)}let s;return be().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Z0(r.shape,OW):s=new rp(r.shape,OW),n.runWebGLProgram(s,[r],r.dtype)}var jTe={kernelName:cg,backendName:"webgl",kernelFunc:UTe},HTe=Ti+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,qTe=tn({opSnippet:HTe}),KTe={kernelName:pg,backendName:"webgl",kernelFunc:qTe},XTe=Ti+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,ZTe=tn({opSnippet:XTe}),YTe={kernelName:dg,backendName:"webgl",kernelFunc:ZTe},PW="return a + b;",JTe=ks({opSnippet:PW,packedOpSnippet:PW,supportsComplex:!0,cpuKernelImpl:iNe}),QTe={kernelName:$c,backendName:"webgl",kernelFunc:JTe},e_e=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,o)=>`T${o}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},t_e=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,o)=>`T${o}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function V5(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return Xo({inputs:{x:r[0]},backend:n});if(r.length>be().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(r.length/2),u=V5({inputs:r.slice(0,l),backend:n}),c=V5({inputs:r.slice(l),backend:n});return V5({inputs:[u,c],backend:n})}let s=r.map(l=>l.dtype).reduce((l,u)=>$a(l,u)),o=r.map(l=>l.shape),i=be().getBool("WEBGL_PACK")?new t_e(r[0].shape,o):new e_e(r[0].shape,o);return n.runWebGLProgram(i,r,s)}var n_e={kernelName:Ld,backendName:"webgl",kernelFunc:V5};function r_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=s.shape.length,l=E.parseAxisParam(o,s.shape),u=l,c=G.getAxesPermutation(u,i),p=s;c!=null&&(p=Hs({inputs:{x:s},backend:n,attrs:{perm:c}}),u=G.getInnerMostAxes(u.length,i)),G.assertAxesAreInnerMostDims("all",u,i);let[d,f]=G.computeOutAndReduceShapes(p.shape,u),h=E.sizeFromShape(f),m=qe({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}}),g=xh(m,m.dtype,"all",n),x;if(a){let y=G.expandShapeToKeepDim(d,l);x=qe({inputs:{x:g},backend:n,attrs:{shape:y}})}else x=qe({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(p),x}var s_e={kernelName:fg,backendName:"webgl",kernelFunc:r_e};function o_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=s.shape.length,l=E.parseAxisParam(o,s.shape),u=l,c=G.getAxesPermutation(u,i),p=s;c!=null&&(p=Hs({inputs:{x:s},backend:n,attrs:{perm:c}}),u=G.getInnerMostAxes(u.length,i)),G.assertAxesAreInnerMostDims("any",u,i);let[d,f]=G.computeOutAndReduceShapes(p.shape,u),h=E.sizeFromShape(f),m=qe({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}}),g=xh(m,m.dtype,"any",n),x;if(a){let y=G.expandShapeToKeepDim(d,l);x=qe({inputs:{x:g},backend:n,attrs:{shape:y}})}else x=qe({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(p),x}var a_e={kernelName:hg,backendName:"webgl",kernelFunc:o_e},i_e=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:s,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];let a=t==="max"?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${i};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},l_e=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,E.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],o=Math.ceil(s/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");let a=this.outputShape,i=a.length,l=Dn(i),u=js("coords",i),c,p;if(o===1){p=i+1;let k=Dn(p);c=`
        ${k} sourceLocR = ${k}(${u.join()}, 0);
        ++${u[i-1]};
        ${k} sourceLocG = ${k}(${u.join()}, 0);
        ++${u[i-2]};
        ${k} sourceLocA = ${k}(${u.join()}, 0);
        --${u[i-1]};
        ${k} sourceLocB = ${k}(${u.join()}, 0);
        --${u[i-2]};`}else p=i,c=`
        ${l} sourceLocR = coords;
        ++${u[i-1]};
        ${l} sourceLocG = coords;
        ++${u[i-2]};
        ${l} sourceLocA = coords;
        --${u[i-1]};
        ${l} sourceLocB = coords;
        --${u[i-2]};`;let d=["x","y","z","w","u","v"].slice(0,p),f="."+d[p-1],h=d.map(k=>"int "+k),m=js("sourceLocR",p-1).concat("inIdx.r"),g=js("sourceLocG",p-1).concat("inIdx.g"),x=js("sourceLocB",p-1).concat("inIdx.b"),y=js("sourceLocA",p-1).concat("inIdx.a"),b=n==="max"?"greaterThan":"lessThan",A=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,w=r?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${w}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[i-1]} < ${a[i-1]-1};
        bool hasNextRow = ${u[i-2]} < ${a[i-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${v};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${A}
          vec4 candidate = ${v};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function MW(e,t,n,r=null){let s=t.shape[0],o=t.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);let a=G.computeOptimalWindowSize(o),i={windowSize:a,inSize:o,batchSize:s,outSize:Math.ceil(o/a)},l=new i_e(i,n,r==null),u=[t];r!=null&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let p=MW(e,t,n,c);return e.disposeIntermediateTensorInfo(c),p}function zW(e,t,n,r=null){let s=r!=null?r.shape:t.shape,o=s[s.length-1],a=G.computeOptimalWindowSize(o),i=new l_e(s,a,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(i,l,"int32");if(u.shape.length===t.shape.length){let c=zW(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function LW(e,t,n,r){let s=[n];if(G.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!be().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let o=[],a=e.texData.get(t.dataId),i=a!==null&&a.isPacked,l=t;i&&(l=e.unpackTensor(t),o.push(l));let[u,c]=G.computeOutAndReduceShapes(l.shape,s),p=E.sizeFromShape(c),d=qe({inputs:{x:l},backend:e,attrs:{shape:[-1,p]}});o.push(d);let f=MW(e,d,r);o.push(f);let h=qe({inputs:{x:f},backend:e,attrs:{shape:u}});return o.forEach(m=>e.disposeIntermediateTensorInfo(m)),h}return zW(e,t,r)}function u_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r,a=E.parseAxisParam(o,s.shape),i=G.getAxesPermutation(a,s.shape.length),l=s,u=[];i!=null&&(l=Hs({inputs:{x:s},backend:n,attrs:{perm:i}}),u.push(l),a=G.getInnerMostAxes(a.length,l.shape.length)),G.assertAxesAreInnerMostDims("argMax",[a[0]],l.shape.length);let c=LW(n,l,a[0],"max");return u.forEach(p=>n.disposeIntermediateTensorInfo(p)),c}var c_e={kernelName:Bd,backendName:"webgl",kernelFunc:u_e};function p_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r,a=E.parseAxisParam(o,s.shape),i=G.getAxesPermutation(a,s.shape.length),l=s,u=[];i!=null&&(l=Hs({inputs:{x:s},backend:n,attrs:{perm:i}}),u.push(l),a=G.getInnerMostAxes(a.length,l.shape.length)),G.assertAxesAreInnerMostDims("argMin",[a[0]],l.shape.length);let c=LW(n,l,a[0],"min");return u.forEach(p=>n.disposeIntermediateTensorInfo(p)),c}var d_e={kernelName:P1,backendName:"webgl",kernelFunc:p_e},f_e=Ti+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,h_e=tn({opSnippet:f_e}),m_e={kernelName:mg,backendName:"webgl",kernelFunc:h_e},g_e=Ti+"return log(x + sqrt(x * x + 1.0));",x_e=tn({opSnippet:g_e}),y_e={kernelName:gg,backendName:"webgl",kernelFunc:x_e},b_e=Ti+`
  return atan(x);
`,A_e=tn({opSnippet:b_e}),v_e={kernelName:xg,backendName:"webgl",kernelFunc:A_e},w_e=_Te+`
  return atan(a, b);
`,k_e=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+ETe+`
  return result;
`,I_e=ks({opSnippet:w_e,packedOpSnippet:k_e}),C_e={kernelName:bg,backendName:"webgl",kernelFunc:I_e},S_e=Ti+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,N_e=tn({opSnippet:S_e}),T_e={kernelName:yg,backendName:"webgl",kernelFunc:N_e},sA=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let o=e.filterWidth,a=e.strideHeight,i=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,x="0.0";if(h||(x="-1.0 / 1e-20"),n){let k=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${i});
        const ivec2 pads = ivec2(${d}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${k} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?m:g:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let y="max",b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(b="avgValue / count");let A=Math.floor(o/4)*4,v=o%4,w=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${y}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${d}, ${f});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${A}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${w}
          }

          int xC = xCCorner + ${A};
          if (${v===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${w}
          } else if (${v===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${w}
          } else if (${v===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${w}
          }
        }
        setOutput(${b});
      }
    `}},MR=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let o=e.filterWidth,a=e.strideDepth,i=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,p=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,h=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;let y=t==="avg",b="0.0";if(y||(b="-1.0 / 1e-20"),n){let N=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${i}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${N} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let A="max",v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(v="avgValue / count");let w=Math.floor(o/4)*4,k=o%4,I=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${A}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${i}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${x});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${w}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${I}
            }

            int xC = xCCorner + ${w};
            if (${k===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${k===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${k===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${I}
            }
          }
          setOutput(${v});
        }
      }
    `}};function __e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;j0(s,"avgPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,u=1;E.assert(G.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=G.computePool2DInfo(s.shape,o,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&E.arraysEqual(c.inShape,c.outShape))return Xo({inputs:{x:s},backend:n});let p=new sA(c,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}var E_e={kernelName:Vd,backendName:"webgl",kernelFunc:__e};function R_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],p=G.computePool3DInfo(s.shape,o,a,c,i,l,u),d=new MR(p,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}var D_e={kernelName:M1,backendName:"webgl",kernelFunc:R_e},$_e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,i=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.top,c=l-1-e.padInfo.left,p=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},F_e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=c-1-e.padInfo.front,h=p-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${h}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function O_e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,a=o,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],d=G.computePool3DInfo(a.shape,i,l,p,u,c),f=new F_e(d);return n.runWebGLProgram(f,[s],a.dtype)}var P_e={kernelName:tw,backendName:"webgl",kernelFunc:O_e};function M_e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,a=o;j0([s,o],"avgPoolGrad");let{filterSize:i,strides:l,pad:u}=r,c=G.computePool2DInfo(a.shape,i,l,1,u),p=new $_e(c);return n.runWebGLProgram(p,[s],a.dtype)}var z_e={kernelName:ew,backendName:"webgl",kernelFunc:M_e};function L_e(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o}=t,{transposeA:a,transposeB:i}=r;return B5({a:s,b:o,transposeA:a,transposeB:i,backend:n})}var B_e={kernelName:Wd,backendName:"webgl",kernelFunc:L_e},V_e=class{constructor(e,t,n,r,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],G.assertAndGetBroadcastShape(e,t),G.assertAndGetBroadcastShape(e,n);let a="0.0";r!=null&&(G.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let i="1.0";s!=null&&(G.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${i};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},W_e=class{constructor(e,t,n,r,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],G.assertAndGetBroadcastShape(e,t),G.assertAndGetBroadcastShape(e,n);let a="vec4(0.0)";r!=null&&(G.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let i="vec4(1.0)";s!=null&&(G.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${i};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}},G_e=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:s,variance:o,offset:a,scale:i}=e;E.assert(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E.assert(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E.assert(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[r,s,o],c=null;a!=null&&(c=a.shape,u.push(a));let p=null;i!=null&&(p=i.shape,u.push(i));let d=be().getBool("WEBGL_PACK_NORMALIZATION")?new W_e(r.shape,s.shape,o.shape,c,p,l):new V_e(r.shape,s.shape,o.shape,c,p,l);return t.runWebGLProgram(d,u,u[0].dtype)},U_e={kernelName:nf,backendName:"webgl",kernelFunc:G_e},j_e=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Dn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=H_e(this.rank),r,s=e.map((o,a)=>`sourceLoc.${zR[a]} = start[${a}] + coords.${zR[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},zR=["x","y","z","w","u","v"];function H_e(e){if(e===1)return"sourceLoc";if(e<=6)return zR.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var q_e=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Dn(this.rank),n=js("coords",this.rank),r=js("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${s})`,a=`
      result.x = ${o};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,i=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,c)=>`start[${c}]`).join()});`:e.map((u,c)=>`${r[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${i}
        setOutput(result);
      }
    `}};function K_e(e,t,n,r){let s=r.texData.get(e.dataId),o=r.makeTensorInfo(n,e.dtype),a=r.texData.get(o.dataId);Object.assign(a,s),a.refCount=1,a.shape=n,a.dtype=e.dtype;let i=Bs.computeFlatOffset(t,E.computeStrides(e.shape));s.slice&&(i+=s.slice.flatOffset),a.slice={flatOffset:i,origDataId:s.slice&&s.slice.origDataId||e.dataId};let l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),o}function Q0(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,size:a}=r,[i,l]=Bs.parseSliceParams(s,o,a);if(Bs.assertParamsValid(s,i,l),E.sizeFromShape(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){let p=n.texData.get(s.dataId),d=$Ne(p.values,i,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,d)}let{isPacked:u}=n.texData.get(s.dataId),c=Bs.isSliceContinous(s.shape,i,l);if(u||!c){let p=be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new q_e(l):new j_e(l),d=[i];return n.runWebGLProgram(p,[s],s.dtype,d)}return n.uploadToGPU(s.dataId),K_e(s,i,l,n)}var X_e={kernelName:Qg,backendName:"webgl",kernelFunc:Q0},Z_e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,crops:a}=r;E.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=o.reduce((y,b)=>y*b),l=G.getReshaped(s.shape,o,i),u=G.getPermuted(l.length,o.length),c=G.getReshapedPermuted(s.shape,o,i),p=G.getSliceBeginCoords(a,o.length),d=G.getSliceSize(c,a,o.length),f=[],h=qe({inputs:{x:s},backend:n,attrs:{shape:l}}),m=Hs({inputs:{x:h},backend:n,attrs:{perm:u}}),g=qe({inputs:{x:m},backend:n,attrs:{shape:c}}),x=Q0({inputs:{x:g},backend:n,attrs:{begin:p,size:d}});return f.push(h),f.push(m),f.push(g),f.forEach(y=>n.disposeIntermediateTensorInfo(y)),x},Y_e={kernelName:Ag,backendName:"webgl",kernelFunc:Z_e};function J_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:a}=r,i=n.readSync(s.dataId),l=n.readSync(o.dataId),u=fW(i,l,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,u)}var Q_e={kernelName:nw,backendName:"webgl",kernelFunc:J_e},eEe="return float(a != b);",BW=ks({opSnippet:eEe,cpuKernelImpl:TNe,dtype:"bool"}),tEe={kernelName:Vg,backendName:"webgl",kernelFunc:BW};function oA(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return Xo({inputs:{x:s.complexTensorInfos.real},backend:n})}var nEe={kernelName:Iw,backendName:"webgl",kernelFunc:oA},rEe="return float(int(x));";function sEe(e,t){let n=new rp(e.shape,rEe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function LR(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return Xo({inputs:{x:s},backend:n});let a=xr(s.shape),i=LR({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=sp({inputs:{real:i,imag:a},backend:n});return a.dispose(),n.disposeIntermediateTensorInfo(i),l}if(s.dtype==="complex64"){let a=oA({inputs:{input:s},backend:n}),i=LR({inputs:{x:a},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(a),i}if(!E.hasEncodingLoss(s.dtype,o)){let a=Xo({inputs:{x:s},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32")return sEe(s,n);if(o==="bool"){let a=n.makeTensorInfo([],"bool",E.getTypedArrayFromDType("bool",1)),l=BW({inputs:{a:s,b:a},backend:n});return n.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}var oEe={kernelName:Gd,backendName:"webgl",kernelFunc:LR},VW="return ceil(x);",aEe=tn({opSnippet:VW,packedOpSnippet:VW,cpuKernelImpl:uNe}),iEe={kernelName:Ud,backendName:"webgl",kernelFunc:aEe},lEe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},uEe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function cEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:o,clipValueMax:a}=r,i;be().getBool("WEBGL_PACK_CLIP")?i=new uEe(s.shape):i=new lEe(s.shape);let l=[[o],[a]];return n.runWebGLProgram(i,[s],s.dtype,l)}var pEe={kernelName:Fc,backendName:"webgl",kernelFunc:cEe},dEe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function WW(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function fEe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),o=new dEe(r.shape),a=[WW(r,s.complexTensorInfos.real),WW(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,a,a[0].dtype)}var hEe={kernelName:z1,backendName:"webgl",kernelFunc:fEe},mEe=class{constructor(e){this.outputShape=[],this.outputShape=G.computeOutShape(e,1),this.variableNames=e.map((o,a)=>`T${a}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){let a=t[o-1];n.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}let r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},gEe=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=G.computeOutShape(e,t);let n=this.outputShape,r=n.length,s=Dn(r),o=js("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((h,m)=>`T${m}`);let i=new Array(e.length-1);i[0]=e[0][t];for(let h=1;h<i.length;h++)i[h]=i[h-1]+e[h][t];let l=a[t],u=a.slice(-2),c=a.join(),p=`if (${l} < ${i[0]}) {
        return getChannel(
            getT0(${c}), vec2(${u.join()}));
        }`;for(let h=1;h<i.length;h++){let m=i[h-1];p+=`
        if (${l} < ${i[h]}  && ${l} >= ${i[h-1]}) {
          return getChannel(
            getT${h}(${W5(a,l,m)}),
            vec2(${W5(u,l,m)}));
        }`}let d=i.length,f=i[i.length-1];p+=`
        return getChannel(
          getT${d}(${W5(a,l,f)}),
          vec2(${W5(u,l,f)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${p}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${n[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${n[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${n[r-2]} &&
            ${o[r-1]} < ${n[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}};function W5(e,t,n){let r=e.indexOf(t);return e.map((o,a)=>a===r?`${o} - ${n}`:o).join()}function G5(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return Xo({inputs:{x:s.complexTensorInfos.imag},backend:n})}var xEe={kernelName:xw,backendName:"webgl",kernelFunc:G5};function ex(e,t,n){let r=e[0].dtype;if(r==="complex64"){let c=e.map(m=>oA({inputs:{input:m},backend:n})),p=e.map(m=>G5({inputs:{input:m},backend:n})),d=ex(c,t,n),f=ex(p,t,n),h=sp({inputs:{real:d,imag:f},backend:n});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),p.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),h}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let c=e.map(x=>{let y=E.sizeFromShape(x.shape.slice(t));return qe({inputs:{x},backend:n,attrs:{shape:[-1,y]}})}),p=c.map(x=>({vals:n.readSync(x.dataId),shape:x.shape})),d=G.computeOutShape(c.map(x=>x.shape),1),f=c[0].shape[0]===1,h=cNe(p,d,r,f),m=G.computeOutShape(e.map(x=>x.shape),t),g=n.makeTensorInfo(m,r,h);return c.forEach(x=>n.disposeIntermediateTensorInfo(x)),g}if(e.length>be().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(e.length/2),p=ex(e.slice(0,c),t,n),d=ex(e.slice(c),t,n),f=ex([p,d],t,n);return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),f}if(be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){let c=new gEe(e.map(p=>p.shape),t);return n.runWebGLProgram(c,e,r)}let{tensors2D:o,outShape:a}=yEe(e,t,n),i=new mEe(o.map(c=>c.shape)),l=n.runWebGLProgram(i,o,r);o.forEach(c=>n.disposeIntermediateTensorInfo(c));let u=qe({inputs:{x:l},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(l),u}function yEe(e,t,n){let r=G.computeOutShape(e.map(o=>o.shape),t);return{tensors2D:e.map(o=>qe({inputs:{x:o},attrs:{shape:[-1,E.sizeFromShape(o.shape.slice(t))]},backend:n})),outShape:r}}function GW(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,o=E.parseAxisParam(s,t[0].shape)[0],a=G.computeOutShape(t.map(u=>u.shape),o);if(E.sizeFromShape(a)===0)return n.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(u=>E.sizeFromShape(u.shape)>0);if(i.length===1)return Xo({inputs:{x:i[0]},backend:n});let l=i.map(u=>u.shape);return G.assertParamsConsistent(l,o),ex(i,o,n)}var bEe={kernelName:vg,backendName:"webgl",kernelFunc:GW},UW=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let o=e.padInfo.top,a=e.padInfo.left,i=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,p=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,x=m?2:3,y=m?3:1,b="",A="";n&&(r?b=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?b=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:b=`
          float activation(float x) {
            ${n}
          }
        `,A="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${y}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${v}
        ${A}
        setOutput(result);
      }
    `}},AEe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,p=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${i};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},vEe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=xa(this.outputShape.length);let{dataFormat:n}=t,r=Us(),s=n==="channelsLast",o=s?0:1,a=s?1:2,i=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`,l="";for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.y + ${c};
          pos = rc.x + ${u};

          ${i}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+c}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+c}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function jW({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){let l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,p=l[0]*l[1]*l[2],d=n.outChannels,f=n.dataFormat==="channelsLast",h=!1,m=!1,g,x=[];if(!((p===1||d===1)&&c>FW)&&u.isPacked&&f&&u.texture!=null&&l[2]%2!=0&&E.arraysEqual(u.shape.slice(-3),l.slice(-3))){let A=l[0]*l[1]*(l[2]+1),v={dataId:e.dataId,shape:[1,A,n.inChannels],dtype:e.dtype},w=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,E.assert(tA(u.shape,v.shape),()=>`packed reshape ${u.shape} to ${v.shape} isn't free`);let k=qe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});x.push(k);let I=B5({a:v,b:k,backend:r,transposeA:h,transposeB:m,bias:s,activation:i,preluActivationWeights:o,leakyreluAlpha:a}),N=r.texData.get(I.dataId);E.assert(N.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=w,N.shape=n.outShape,g=Xo({inputs:{x:I},backend:r}),g.shape=n.outShape,x.push(I)}else{let A=f?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],v=qe({inputs:{x:e},backend:r,attrs:{shape:[1,A,n.inChannels]}}),w=qe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),k=B5({a:v,b:w,transposeA:h,transposeB:m,backend:r,bias:s,activation:i,preluActivationWeights:o,leakyreluAlpha:a});g=qe({inputs:{x:k},backend:r,attrs:{shape:n.outShape}}),x.push(v),x.push(w),x.push(k)}for(let A of x)r.disposeIntermediateTensorInfo(A);return g}function HW({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:p,outHeight:d,dataFormat:f}=n,h=f==="channelsLast",m=l*u*c,g=d*p,x=[m,g],y=!0,b=!1,A=[],v=qe({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),w=qe({inputs:{x:t},backend:r,attrs:{shape:[1,m,E.sizeFromShape(t.shape)/m]}});A.push(v),A.push(w);let k=new vEe(x,n),I=[v.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],N=r.runWebGLProgram(k,[v],"float32",I),T=qe({inputs:{x:N},backend:r,attrs:{shape:[1,x[0],x[1]]}});A.push(N),A.push(T);let _=s!=null,R=o!=null,S=i==="leakyrelu",F=i?M5(i,!0):null,B=new _W(T.shape,w.shape,[1,g,n.outChannels],y,b,_,F,R,S),W=[T,w];if(s&&W.push(s),R&&W.push(o),S){let Q=r.makeTensorInfo([],"float32",E.createScalarValue(a,"float32"));W.push(Q),A.push(Q)}let q=r.runWebGLProgram(B,W,"float32"),K=h?[1,d,p,n.outChannels]:[1,n.outChannels,d,p],J=qe({inputs:{x:q},backend:r,attrs:{shape:K}});A.push(q);for(let Q of A)r.disposeIntermediateTensorInfo(Q);return J}function wEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=r,p=G.convertConv2DDataFormat(l),d=G.computeConv2DInfo(s.shape,o.shape,a,u,i,c,!1,p),f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=jW({x:s,filter:o,convInfo:d,backend:n});else if(be().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)f=HW({x:s,filter:o,convInfo:d,backend:n});else{let m=new UW(d);f=n.runWebGLProgram(m,[s,o],"float32")}let h=qe({inputs:{x:f},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(f),h}var kEe={kernelName:jd,backendName:"webgl",kernelFunc:wEe},IEe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},CEe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,l=o?1:2,u=o?2:3,c=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},SEe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},NEe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,i=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${i}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function TEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,p=G.convertConv2DDataFormat(l),d=G.computeConv2DInfo(s.shape,c,a,1,i,u,!1,p),f=new IEe(d);return n.runWebGLProgram(f,[s,o],"float32")}var _Ee={kernelName:sw,backendName:"webgl",kernelFunc:TEe};function EEe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=r,p=G.convertConv2DDataFormat(u),d=G.computeConv2DInfo(a,o.shape,i,1,l,c,!1,p),f=new CEe(d);return n.runWebGLProgram(f,[s,o],"float32")}var REe={kernelName:Hd,backendName:"webgl",kernelFunc:EEe};function DEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l}=r,u=G.computeConv3DInfo(s.shape,o.shape,a,l,i),c=new AEe(u);return n.runWebGLProgram(c,[s,o],"float32")}var $Ee={kernelName:L1,backendName:"webgl",kernelFunc:DEe};function FEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,pad:i,filterShape:l}=r,u=G.computeConv3DInfo(s.shape,l,a,1,i),c=new SEe(u);return n.runWebGLProgram(c,[s,o],"float32")}var OEe={kernelName:ow,backendName:"webgl",kernelFunc:FEe};function PEe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{pad:a,strides:i,inputShape:l}=r,u=G.computeConv3DInfo(l,o.shape,i,1,a),c=new NEe(u);return n.runWebGLProgram(c,[s,o],"float32")}var MEe={kernelName:aw,backendName:"webgl",kernelFunc:PEe},zEe=TW+`
  return cos(x);
`,LEe=tn({opSnippet:zEe}),BEe={kernelName:qd,backendName:"webgl",kernelFunc:LEe},VEe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,WEe=tn({opSnippet:VEe}),GEe={kernelName:Kd,backendName:"webgl",kernelFunc:WEe},UEe=class{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[o,a,i,l]=e,[u]=t,[c,p]=n;this.outputShape=[u,c,p,l];let d=r==="bilinear"?1:0,[f,h]=[`${a-1}.0`,`${i-1}.0`],[m,g,x]=c>1?[`${(a-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[y,b,A]=p>1?[`${(i-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${y});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${b};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${A};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},jEe=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:o,boxInd:a}=t,{cropSize:i,method:l,extrapolationValue:u}=r,c=new UEe(s.shape,o.shape,i,l,u);return n.runWebGLProgram(c,[s,o,a],"float32")},HEe={kernelName:wg,backendName:"webgl",kernelFunc:jEe},qW=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;let r=e.length,s=t?"0.0":`getX(${KW(r,"coords")})`,o=e[e.length-1],a="",i="";t?(a=n?`end != ${o-1}`:"end != 0",i=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${o}`:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Dn(r)} coords = getOutputCoords();
        int end = ${XW(r,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${a}) {
          int idx = ${i};
          ${XW(r,"coords")} = idx;
          val += getX(${KW(r,"coords")});
        }
        setOutput(val);
      }
    `}};function KW(e,t){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function XW(e,t){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function qEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,exclusive:a,reverse:i}=r,l=s.shape.length,u=G.getAxesPermutation([o],l),c=s;u!=null&&(c=Hs({inputs:{x:s},backend:n,attrs:{perm:u}}));let p=G.getInnerMostAxes(1,l)[0];if(p!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);let d=c.shape[p],f=Xo({inputs:{x:c},backend:n});for(let h=0;h<=Math.ceil(Math.log2(d))-1;h++){let m=new qW(c.shape,!1,i),g=[[h]],x=f;f=n.runWebGLProgram(m,[f],f.dtype,g),n.disposeIntermediateTensorInfo(x)}if(a){let h=new qW(c.shape,a,i),m=f;f=n.runWebGLProgram(h,[f],f.dtype),n.disposeIntermediateTensorInfo(m)}if(u!=null){let h=G.getUndoAxesPermutation(u),m=Hs({inputs:{x:f},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(c),m}return f}var KEe={kernelName:Xd,backendName:"webgl",kernelFunc:qEe};function XEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:a,binaryOutput:i}=r;if(s.shape.length===1){let l=n.readSync(s.dataId),u=n.readSync(o.dataId),c=fW(l,u,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(o),c=lNe(l,u,a,i);return n.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var ZEe={kernelName:iw,backendName:"webgl",kernelFunc:XEe},YEe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function JEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:o,dataFormat:a}=r;E.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let i=s.shape[0],l=a==="NHWC"?s.shape[1]:s.shape[2],u=a==="NHWC"?s.shape[2]:s.shape[3],c=a==="NHWC"?s.shape[3]:s.shape[1],p=l*o,d=u*o,f=c/(o*o),h=a==="NHWC"?[i,p,d,f]:[i,f,p,d],m=new YEe(h,o,a);return n.runWebGLProgram(m,[s],s.dtype)}var QEe={kernelName:kg,backendName:"webgl",kernelFunc:JEe},ZW=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xa(this.outputShape.length);let o=e.filterHeight,a=e.filterWidth,i=e.outChannels/e.inChannels,l="",u="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${u}
        setOutput(result);
      }
    `}},YW=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xa(this.outputShape.length);let o=e.outChannels/e.inChannels,a=e.padInfo.left,i=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,p=c,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)d+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;for(let g=0;g<u;g++){for(let x=0;x<c;x++)d+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;d+=`
        xR = xRCorner + ${g} * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(p+1)/2;x++){let y=x*2;if(d+=`
          xC = xCCorner + ${y*l};
          `,i===1){if(y<c&&(a%2==1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?d+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<c)){let b=a%2==0?E.nearestLargerEven(l):l;l%2==0&&a%2==1||l%2!=0&&a%2!=1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1&&(d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                      xTexelC${y} = getX(batch, xR, xCOffset, d1);
                      xTexelC${y}Ready = 1;
                    }
                    `),d+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                  `):b===1?d+=`
                    xC${y+1} = xTexelC${y};
                    `:d+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<c&&(a%2==1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<c&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<c&&(d+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<c&&(d+=`
            wTexel = getW(${g}, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<c&&(d+=`
              wTexel = getW(${g}, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
        }
      `}let f="",h="";n&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:f=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${h}
        setOutput(result);
      }
    `}};function e4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=r,c=l;c==null&&(c=[1,1]),E.assert(G.eitherStridesOrDilationsAreOne(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let p=G.computeConv2DInfo(s.shape,o.shape,a,c,i,u,!0),d;be().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?d=new YW(p):d=new ZW(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(d,[s,o],"float32",f)}var t4e={kernelName:Zd,backendName:"webgl",kernelFunc:e4e},n4e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},r4e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.top,a=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${i}; dm++) {
              int d2 = d1 * ${i} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function s4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=r,p=G.computeConv2DInfo(s.shape,c,a,i,l,u,!0),d=new n4e(p);return n.runWebGLProgram(d,[s,o],"float32")}var o4e={kernelName:lw,backendName:"webgl",kernelFunc:s4e};function a4e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=r,p=G.computeConv2DInfo(c,o.shape,a,i,l,u,!0),d=new r4e(p);return n.runWebGLProgram(d,[s,o],"float32")}var i4e={kernelName:uw,backendName:"webgl",kernelFunc:a4e},l4e=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function u4e(e){let{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],o=E.sizeFromShape(r.shape),a=qe({inputs:{x:r},backend:n,attrs:{shape:[o]}}),i=new l4e(o),l=n.runWebGLProgram(i,[a],a.dtype),u=qe({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}var c4e={kernelName:cw,backendName:"webgl",kernelFunc:u4e},p4e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:o,filterHeight:a,filterWidth:i,dilationHeight:l,dilationWidth:u}=e,{top:c,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${o});
      const ivec2 pads = ivec2(${c}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${i}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function d4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l}=r,u=G.computeDilation2DInfo(s.shape,o.shape,a,i,"NHWC",l),c,p=new p4e(u);c=n.runWebGLProgram(p,[s,o],"float32");let d=qe({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}var f4e={kernelName:B1,backendName:"webgl",kernelFunc:d4e};function h4e(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,o=t,{allDims:a,summedDims:i,idDims:l}=G.decodeEinsumEquation(s,o.length);G.checkEinsumDimSizes(a.length,l,o);let{path:u,steps:c}=G.getEinsumComputePath(i,l),p=c.length,d=null,f=a.length,h=[];for(let m=0;m<p;++m){for(let g of c[m]){let{permutationIndices:x,expandDims:y}=G.getEinsumPermutation(f,l[g]),b;G.isIdentityPermutation(x)?b=o[g]:(b=Hs({inputs:{x:o[g]},backend:n,attrs:{perm:x}}),h.push(b));let A=b.shape.slice();for(let v=0;v<y.length;++v)A.splice(y[v],0,1);E.arraysEqual(b.shape,A)||(b=qe({inputs:{x:b},backend:n,attrs:{shape:A}}),h.push(b)),d===null?d=b:(d=PR({inputs:{a:b,b:d},backend:n}),h.push(d))}m<p-1&&(u[m]>=0&&(d=L5({inputs:{x:d},backend:n,attrs:{axis:u[m]-(a.length-f),keepDims:!1}}),h.push(d)),f--)}for(let m of h)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var m4e={kernelName:fw,backendName:"webgl",kernelFunc:h4e},g4e="return (x >= 0.0) ? x : (exp(x) - 1.0);",x4e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,y4e=tn({opSnippet:g4e,packedOpSnippet:x4e}),b4e={kernelName:Jd,backendName:"webgl",kernelFunc:y4e},A4e="return (b >= 1.0) ? a : a * (b + 1.0);",v4e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,w4e=e=>{let{inputs:t,backend:n}=e,{dy:r,y:s}=t,o=be().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rA(v4e,r.shape,s.shape):new J0(A4e,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)},k4e={kernelName:hw,backendName:"webgl",kernelFunc:w4e},I4e=`
  return vec4(equal(a, b));
`,C4e="return float(a == b);",S4e=ks({opSnippet:C4e,packedOpSnippet:I4e,dtype:"bool",cpuKernelImpl:pNe}),N4e={kernelName:Cg,backendName:"webgl",kernelFunc:S4e},T4e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${G.ERF_P};
  float a1 = ${G.ERF_A1};
  float a2 = ${G.ERF_A2};
  float a3 = ${G.ERF_A3};
  float a4 = ${G.ERF_A4};
  float a5 = ${G.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,_4e=tn({opSnippet:T4e}),E4e={kernelName:Ig,backendName:"webgl",kernelFunc:_4e},JW="return exp(x);",QW=tn({opSnippet:JW,packedOpSnippet:JW,cpuKernelImpl:dNe}),R4e={kernelName:Qd,backendName:"webgl",kernelFunc:QW};function BR(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:o}=t,a=o.shape.length,i=o.shape.slice(),l=s;return s<0&&(E.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),i.splice(l,0,1),qe({inputs:{x:o},backend:r,attrs:{shape:i}})}var D4e={kernelName:Sg,backendName:"webgl",kernelFunc:BR},eG="return exp(x) - 1.0;",$4e=tn({opSnippet:eG,packedOpSnippet:eG,cpuKernelImpl:fNe}),F4e={kernelName:Ng,backendName:"webgl",kernelFunc:$4e},tG=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${r}.0`:"1.0",a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function nG(e,t,n){let r=n.texData.get(e.dataId),s=E.sizeFromShape(e.shape),o=e.shape[e.shape.length-1],a=s/o,i=qe({inputs:{x:e},backend:n,attrs:{shape:[a,o]}}),l=i.shape,u=new tG("real",l,t),c=new tG("imag",l,t),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,p,"float32"),f=n.runWebGLProgram(c,p,"float32"),h=sp({inputs:{real:d,imag:f},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f);let m=qe({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(h),m}function O4e(e){let{inputs:t,backend:n}=e,{input:r}=t;return nG(r,!1,n)}var P4e={kernelName:mw,backendName:"webgl",kernelFunc:O4e},M4e=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function aA(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:o}=n;if(o=o||E.inferDtype(s),o==="string"){let a=E.getArrayFromDType(o,E.sizeFromShape(r));return a.fill(s),t.makeTensorInfo(r,o,a)}else{let a=new M4e(r,s),i=[[s]];return t.runWebGLProgram(a,[],o,i)}}var z4e={kernelName:V1,backendName:"webgl",kernelFunc:aA},L4e=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},B4e={kernelName:Tg,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new L4e(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},rG="return floor(x);",V4e=tn({opSnippet:rG,packedOpSnippet:rG,cpuKernelImpl:hNe}),W4e={kernelName:ef,backendName:"webgl",kernelFunc:V4e},G4e=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,U4e=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,j4e=ks({opSnippet:G4e,packedOpSnippet:U4e,dtype:"int32"}),H4e={kernelName:tf,backendName:"webgl",kernelFunc:j4e},q4e=class{constructor(e){this.variableNames=["A"];let t=Us(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},K4e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Us(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},X4e={kernelName:Pw,backendName:"webgl",kernelFunc:Z4e},tx;function Z4e(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:o}=r,a=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,[l,u]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],p=[u,l,o];(i||a)&&(tx==null&&(tx=document.createElement("canvas").getContext("2d")),tx.canvas.width=l,tx.canvas.height=u,tx.drawImage(s,0,0,l,u),s=tx.canvas);let d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=ma.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);let f=be().getBool("WEBGL_PACK")?new K4e(p):new q4e(p),h=n.runWebGLProgram(f,[d],"int32");return n.disposeData(d.dataId),h}function Y4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=r,m=G.convertConv2DDataFormat(c),g=G.computeConv2DInfo(s.shape,o.shape,l,p,u,d,!1,m),x,y=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=jW({x:s,filter:o,convInfo:g,backend:n,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:h});else if(be().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)x=HW({x:s,filter:o,convInfo:g,backend:n,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:h});else{let A=a!=null,v=i!=null,w=f==="leakyrelu",k=f?M5(f,!1):null,I=new UW(g,A,k,v,w),N=[s,o];if(a&&N.push(a),i&&N.push(i),w){let T=n.makeTensorInfo([],"float32",E.createScalarValue(h,"float32"));N.push(T),y.push(T)}x=n.runWebGLProgram(I,N,"float32")}let b=qe({inputs:{x},backend:n,attrs:{shape:g.outShape}});return y.push(x),y.forEach(A=>n.disposeIntermediateTensorInfo(A)),b}var J4e={kernelName:Mf,backendName:"webgl",kernelFunc:Y4e};function Q4e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,h=[],m=c;m==null&&(m=[1,1]),E.assert(G.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=G.computeConv2DInfo(s.shape,o.shape,l,m,u,p,!0),x=be().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=d?M5(d,x):null,b=[s,o],A=a!=null,v=i!=null,w=d==="leakyrelu";if(A&&b.push(a),v&&b.push(i),w){let T=n.makeTensorInfo([],"float32",E.createScalarValue(f,"float32"));b.push(T),h.push(T)}let k;x?k=new YW(g,A,y,v,w):k=new ZW(g,A,y,v,w);let I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(k,b,"float32",I);return h.forEach(T=>n.disposeIntermediateTensorInfo(T)),N}var eRe={kernelName:zf,backendName:"webgl",kernelFunc:Q4e},tRe=class{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;let r=Dn(t.length),s=Dn(n.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${r} strides = ${r}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${o};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function nRe(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,o=s.shape,a=o[o.length-1],i=E.sizeFromShape(r.shape),[l,u,c,p]=G.prepareAndValidate(r,s),d=qe({inputs:{x:s},backend:n,attrs:{shape:[u,a]}}),f=qe({inputs:{x:r},backend:n,attrs:{shape:[E.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let x=n.readSync(s.dataId),y=n.bufferSync(r),b=mNe(x,y,r.dtype,u,a,c,p,r.shape,i);return n.makeTensorInfo(l,r.dtype,b.values)}let h=new tRe(a,p,[u,c]),m=n.runWebGLProgram(h,[f,d],f.dtype),g=qe({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var rRe={kernelName:Eg,backendName:"webgl",kernelFunc:nRe},sRe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Dn(this.rank),r=oRe(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function oRe(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("int(getIndices(resRC.x, resRC.z))"):r.push(`${n[s]}`);return r.join()}function sG(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:o}=t,{axis:a,batchDims:i}=r,l=E.parseAxisParam(a,s.shape)[0],u=G.segment_util.collectGatherOpShapeInfo(s,o,l,i),c=E.sizeFromShape(o.shape),p=[],d=qe({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=qe({inputs:{x:o},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});p.push(d),p.push(f);let h=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,o])||s.dtype==="string"){let y=n.bufferSync(f),b=n.bufferSync(d),A=gNe(b,y,h);return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(u.outputShape,A.dtype,A.values)}let m=new sRe(d.shape,h),g=n.runWebGLProgram(m,[d,f],d.dtype);p.push(g);let x=qe({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return p.forEach(y=>n.disposeIntermediateTensorInfo(y)),x}var aRe={kernelName:_g,backendName:"webgl",kernelFunc:sG},iRe="return float(a > b);",lRe=`
  return vec4(greaterThan(a, b));
`,uRe=ks({opSnippet:iRe,packedOpSnippet:lRe,cpuKernelImpl:xNe,dtype:"bool"}),cRe={kernelName:Rg,backendName:"webgl",kernelFunc:uRe},pRe="return float(a >= b);",dRe=`
  return vec4(greaterThanEqual(a, b));
`,fRe=ks({opSnippet:pRe,packedOpSnippet:dRe,dtype:"bool",cpuKernelImpl:yNe}),hRe={kernelName:rf,backendName:"webgl",kernelFunc:fRe};function mRe(e){let{inputs:t,backend:n}=e,{input:r}=t;return nG(r,!0,n)}var gRe={kernelName:gw,backendName:"webgl",kernelFunc:mRe},xRe="return float(!isnan(x) && !isinf(x));",yRe=tn({opSnippet:xRe,dtype:"bool"}),bRe={kernelName:Dg,backendName:"webgl",kernelFunc:yRe},ARe="return float(isinf(x));",vRe=tn({opSnippet:ARe,dtype:"bool"}),wRe={kernelName:$g,backendName:"webgl",kernelFunc:vRe},kRe="return float(isnan(x));",IRe=tn({opSnippet:kRe,dtype:"bool"}),CRe={kernelName:Fg,backendName:"webgl",kernelFunc:IRe},SRe="return float(a < b);",NRe=`
  return vec4(lessThan(a, b));
`,TRe=ks({opSnippet:SRe,packedOpSnippet:NRe,cpuKernelImpl:bNe,dtype:"bool"}),_Re={kernelName:Og,backendName:"webgl",kernelFunc:TRe},ERe="return float(a <= b);",RRe=`
  return vec4(lessThanEqual(a, b));
`,DRe=ks({opSnippet:ERe,packedOpSnippet:RRe,cpuKernelImpl:ANe,dtype:"bool"}),$Re={kernelName:Pg,backendName:"webgl",kernelFunc:DRe};function FRe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:o}=n,a=vNe(r,s,o);return t.makeTensorInfo([a.length],"float32",a)}var ORe={kernelName:yw,backendName:"webgl",kernelFunc:FRe},PRe=`if (x < 0.0) return NAN;
  return log(x);`,MRe=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,zRe=tn({opSnippet:PRe,packedOpSnippet:MRe,cpuKernelImpl:wNe}),LRe={kernelName:af,backendName:"webgl",kernelFunc:zRe},BRe="return log(1.0 + x);",VRe=tn({opSnippet:BRe}),WRe={kernelName:Mg,backendName:"webgl",kernelFunc:VRe},GRe="return float(a >= 1.0 && b >= 1.0);",URe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,jRe=ks({opSnippet:GRe,packedOpSnippet:URe,dtype:"bool"}),HRe={kernelName:zg,backendName:"webgl",kernelFunc:jRe},qRe="return float(!(x >= 1.0));",KRe=tn({opSnippet:qRe}),XRe={kernelName:W1,backendName:"webgl",kernelFunc:KRe},ZRe="return float(a >= 1.0 || b >= 1.0);",YRe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,JRe=ks({opSnippet:ZRe,packedOpSnippet:YRe,dtype:"bool"}),QRe={kernelName:G1,backendName:"webgl",kernelFunc:JRe},e7e=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];let o=t,a=e[3]-1;this.outputShape=e;let i,l=`float(${n}) + float(${r}) * sum`;s===.5?i=`inversesqrt(${l})`:s===1?i=`1.0/(${l})`:i=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${i};
        setOutput(val);
      }
    `}},t7e=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let o=t,a=e[3]-1;this.outputShape=e;let i,l=`float(${n}) + float(${r}) * sum`;s===.5?i=`inversesqrt(${l})`:s===1?i=`1.0/(${l})`:i=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${i};
        setOutput(result);
      }
    `}},n7e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:o,bias:a,alpha:i,beta:l}=r,u=be().getBool("WEBGL_PACK_NORMALIZATION")?new t7e(s.shape,o,a,i,l):new e7e(s.shape,o,a,i,l);return n.runWebGLProgram(u,[s],s.dtype)},r7e={kernelName:U1,backendName:"webgl",kernelFunc:n7e},s7e=class{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},o7e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s,y:o,dy:a}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=r,p=new s7e(s.shape,i,l,u,c);return n.runWebGLProgram(p,[s,o,a],s.dtype)},a7e={kernelName:bw,backendName:"webgl",kernelFunc:o7e};function i7e(e,t,n,r){let s=E.sizeFromShape(t),a=E.sizeFromShape(e.shape)/s,i=qe({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),l=xh(i,e.dtype,"max",r),u=qe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(l),u}function oG(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:o,keepDims:a}=r,i=s.shape.length,l=E.parseAxisParam(o,s.shape),u=l,c=G.getAxesPermutation(u,i),p=c!=null,d=n.shouldExecuteOnCPU([s]),f=s;if(p){if(d){let b=n.texData.get(f.dataId).values,A=new Array(i);for(let k=0;k<A.length;k++)A[k]=s.shape[c[k]];let v=OR(b,s.shape,s.dtype,c,A);f=n.makeTensorInfo(A,s.dtype);let w=n.texData.get(f.dataId);w.values=v}else f=z5(s,c,n);u=G.getInnerMostAxes(u.length,i)}G.assertAxesAreInnerMostDims("max",u,i);let[h,m]=G.computeOutAndReduceShapes(f.shape,u),g=h;a&&(g=G.expandShapeToKeepDim(h,l));let x;if(d){let b=n.texData.get(f.dataId).values,A=kNe(b,E.sizeFromShape(m),g,s.dtype);x=n.makeTensorInfo(g,s.dtype);let v=n.texData.get(x.dataId);v.values=A}else x=i7e(f,m,g,n);return p&&n.disposeIntermediateTensorInfo(f),x}var l7e={kernelName:lf,backendName:"webgl",kernelFunc:oG},u7e=kW+`
  return max(a, b);
`,c7e=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+P5+`
  return result;
`,p7e=ks({opSnippet:u7e,packedOpSnippet:c7e,cpuKernelImpl:INe}),d7e={kernelName:uf,backendName:"webgl",kernelFunc:p7e};function f7e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;j0(s,"maxPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,u=1;E.assert(G.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=G.computePool2DInfo(s.shape,o,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&E.arraysEqual(c.inShape,c.outShape))return Xo({inputs:{x:s},backend:n});let p=new sA(c,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}var h7e={kernelName:cf,backendName:"webgl",kernelFunc:f7e};function m7e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:a,pad:i,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],p=G.computePool3DInfo(s.shape,o,a,c,i,u,l),d=new MR(p,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}var g7e={kernelName:j1,backendName:"webgl",kernelFunc:m7e},x7e=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=s-1-e.padInfo.top,i=o-1-e.padInfo.left,l=s*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},y7e=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,i=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=i-1-e.padInfo.front,p=l-1-e.padInfo.top,d=u-1-e.padInfo.left,f=i*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${p}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${i};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function b7e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,a=o,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],d=G.computePool3DInfo(a.shape,i,l,p,u,c),f=new MR(d,"max",!0),h=n.runWebGLProgram(f,[a],a.dtype),m=new y7e(d),g=n.runWebGLProgram(m,[s,h],a.dtype);return n.disposeIntermediateTensorInfo(h),g}var A7e={kernelName:vw,backendName:"webgl",kernelFunc:b7e};function v7e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o,output:a}=t,i=o;j0([o,a],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,d=G.computePool2DInfo(i.shape,l,u,1,c,p),f=!0,h=new sA(d,"max",f),m=n.runWebGLProgram(h,[i],i.dtype),g=new x7e(d),x=n.runWebGLProgram(g,[s,m],i.dtype);return n.disposeIntermediateTensorInfo(m),x}var w7e={kernelName:Aw,backendName:"webgl",kernelFunc:v7e};function k7e(e,t,n,r){let s=new sA(n,"max",!1),o=r.runWebGLProgram(s,[e],"float32");s=new sA(n,"max",!0,!0,t);let a=r.runWebGLProgram(s,[e],"float32");return[o,a]}var I7e={kernelName:ww,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:o,pad:a,includeBatchInIndex:i}=t,l=n;E.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];E.assert(G.eitherStridesOrDilationsAreOne(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);let c=G.computePool2DInfo(r.shape,s,o,u,a),[p,d]=k7e(r,i,c,l);return[p,d]}};function C7e(e,t,n,r){let s=E.sizeFromShape(t),a=E.sizeFromShape(e.shape)/s,i=qe({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),l=xh(i,"float32","mean",r),u=qe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(l),u}var S7e={kernelName:pf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:s,axis:o}=t,a=n,i=r.shape.length,l=E.parseAxisParam(o,r.shape),u=l,c=G.getAxesPermutation(u,i),p=c!=null,d=a.shouldExecuteOnCPU([r]),f=[],h=r;if(p){if(d){let A=a.texData.get(h.dataId).values,v=new Array(i);for(let I=0;I<v.length;I++)v[I]=r.shape[c[I]];let w=OR(A,r.shape,r.dtype,c,v);h=a.makeTensorInfo(v,r.dtype);let k=a.texData.get(h.dataId);k.values=w}else h=z5(r,c,a);f.push(h),u=G.getInnerMostAxes(u.length,i)}G.assertAxesAreInnerMostDims("sum",u,i);let[m,g]=G.computeOutAndReduceShapes(h.shape,u),x=m;s&&(x=G.expandShapeToKeepDim(m,l));let y=C7e(h,g,x,a);for(let b of f)a.disposeIntermediateTensorInfo(b);return y}};function N7e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=s.shape.length,l=E.parseAxisParam(o,s.shape),u=l,c=G.getAxesPermutation(u,i),p=s;c!=null&&(p=Hs({inputs:{x:s},backend:n,attrs:{perm:c}}),u=G.getInnerMostAxes(u.length,s.shape.length)),G.assertAxesAreInnerMostDims("min",u,i);let[d,f]=G.computeOutAndReduceShapes(p.shape,u),h=E.sizeFromShape(f),m=qe({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}}),g=xh(m,m.dtype,"min",n),x;if(a){let y=G.expandShapeToKeepDim(d,l);x=qe({inputs:{x:g},backend:n,attrs:{shape:y}})}else x=qe({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(p),x}var T7e={kernelName:df,backendName:"webgl",kernelFunc:N7e},_7e=kW+`
  return min(a, b);
`,E7e=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+P5+`
  return result;
`,R7e=ks({opSnippet:_7e,packedOpSnippet:E7e,cpuKernelImpl:CNe}),D7e={kernelName:ff,backendName:"webgl",kernelFunc:R7e},$7e=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let r=e.length,s=Dn(r),o=t.map(u=>u[0]).join(","),a=t.map((u,c)=>u[0]+e[c]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${i}));
      }
    `}},F7e=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,h)=>f[0]+e[h]+f[1]);let r=e.length,s=Dn(r),o=t.map(f=>f[0]).join(","),a=t.map((f,h)=>f[0]+e[h]).join(","),i=js("rc",r),l=js("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,p=n==="reflect"?0:1,d="";if(r===1){let f=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${i[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{let f=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${i[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${i[r-2]} += 1;
        if(${i[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${i[r-1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}},O7e=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:s,mode:o}=n,a=be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new F7e(r.shape,s,o):new $7e(r.shape,s,o);return t.runWebGLProgram(a,[r],r.dtype)},P7e={kernelName:hf,backendName:"webgl",kernelFunc:O7e},M7e=`if (b == 0.0) return NAN;
  return mod(a, b);`,z7e=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+P5+`
  return result;
`,L7e=ks({opSnippet:M7e,packedOpSnippet:z7e}),B7e={kernelName:Lg,backendName:"webgl",kernelFunc:L7e},V7e=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},W7e=`
if (a == b) {
  return 1.0;
};
return a / b;`,G7e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,aG=ks({opSnippet:W7e,packedOpSnippet:G7e,checkOutOfBounds:!0}),U7e={kernelName:Yd,backendName:"webgl",kernelFunc:aG},iG="return a - b;",lG=ks({opSnippet:iG,packedOpSnippet:iG,supportsComplex:!0,cpuKernelImpl:VNe}),j7e={kernelName:Df,backendName:"webgl",kernelFunc:lG};function uG(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:o}=r,a=E.parseAxisParam([o],s.shape),i=oG({inputs:{x:s},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=G.expandShapeToKeepDim(i.shape,a),u=qe({inputs:{x:i},backend:n,attrs:{shape:l}}),c=lG({inputs:{a:s,b:u},backend:n}),p=QW({inputs:{x:c},backend:n}),d=L5({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:!1}}),f=qe({inputs:{x:d},backend:n,attrs:{shape:l}}),h=aG({inputs:{a:p,b:f},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),h}var H7e={kernelName:Ef,backendName:"webgl",kernelFunc:uG};function q7e(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:o,seed:a,normalized:i}=r,l=i?s:uG({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],p=new V7e(u,c,o),d=[[a]],f=n.runWebGLProgram(p,[l],"int32",d);return i||n.disposeIntermediateTensorInfo(l),f}var K7e={kernelName:kw,backendName:"webgl",kernelFunc:q7e},cG="return -x;";function X7e(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let o=n.texData.get(r.dataId),[a,i]=NNe(o.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}let s;return be().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Z0(r.shape,cG):s=new rp(r.shape,cG),n.runWebGLProgram(s,[r],r.dtype)}var Z7e={kernelName:Bg,backendName:"webgl",kernelFunc:X7e},Y7e=ll.nonMaxSuppressionV3Impl;function J7e(e){G.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(o.dataId),{selectedIndices:p}=Y7e(u,c,a,i,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var Q7e={kernelName:Wg,backendName:"webgl",kernelFunc:J7e},eDe=ll.nonMaxSuppressionV4Impl;function tDe(e){G.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),p=n.readSync(o.dataId),{selectedIndices:d,validOutputs:f}=eDe(c,p,a,i,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}var nDe={kernelName:Gg,backendName:"webgl",kernelFunc:tDe},rDe=ll.nonMaxSuppressionV5Impl;function sDe(e){G.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),p=n.readSync(o.dataId),d=a,f=i,h=l,m=u,{selectedIndices:g,selectedScores:x}=rDe(c,p,d,f,h,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var oDe={kernelName:Ug,backendName:"webgl",kernelFunc:sDe},aDe=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},iDe=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:o,onValue:a,offValue:i}=r,l=E.sizeFromShape(s.shape),u=new aDe(l,o,a,i),c=qe({inputs:{x:s},backend:n,attrs:{shape:[l]}}),p=n.runWebGLProgram(u,[c],s.dtype);n.disposeIntermediateTensorInfo(c);let d=[...s.shape,o],f=qe({inputs:{x:p},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(p),f},lDe={kernelName:gf,backendName:"webgl",kernelFunc:iDe};function U5(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=oA({inputs:{input:r},backend:n}),o=U5({inputs:{x:s},backend:n}),a=G5({inputs:{input:r},backend:n}),i=U5({inputs:{x:a},backend:n}),l=sp({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return aA({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var uDe={kernelName:u0,backendName:"webgl",kernelFunc:U5};function pG(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=oA({inputs:{input:r},backend:n}),o=pG({inputs:{x:s},backend:n}),a=G5({inputs:{input:r},backend:n}),i=U5({inputs:{x:a},backend:n}),l=sp({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return aA({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var cDe={kernelName:jg,backendName:"webgl",kernelFunc:pG};function pDe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return BR({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let o=t[0].shape,a=t[0].dtype;t.forEach(c=>{E.assertShapesMatch(o,c.shape,"All tensors passed to stack must have matching shapes"),E.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=t.map(c=>{let p=BR({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(p),p}),u=GW({inputs:l,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var dDe={kernelName:Hg,backendName:"webgl",kernelFunc:pDe},fDe=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let r=e.length,s=Dn(r),o=t.map(l=>l[0]).join(","),a=t.map((l,u)=>l[0]+e[u]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${i}));
        }
      }
    `}},hDe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,m)=>h[0]+e[m]+h[1]);let r=e.length,s=Dn(r),o=t.map(h=>h[0]).join(","),a=t.map((h,m)=>h[0]+e[m]).join(","),i=js("rc",r),l=js("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,p=[`${s} rc = outputLoc;`,`${i[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${i[r-2]} += 1;
       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${i[r-1]} += 1;
         if(${u}) {`],d=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="";for(let h=0,m=r===1?2:4;h<m;h++)f+=`
        ${p[h]}
        if (${d}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${c});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}},dG=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,constantValue:a}=r;if(E.sizeFromShape(s.shape)===0){let u=o.map((c,p)=>c[0]+s.shape[p]+c[1]);return aA({backend:n,attrs:{shape:u,value:a,dtype:s.dtype}})}let i=be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hDe(s.shape,o,a):new fDe(s.shape,o,a),l=[[a]];return n.runWebGLProgram(i,[s],s.dtype,l)},mDe={kernelName:xf,backendName:"webgl",kernelFunc:dG},gDe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,xDe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+P5+`
  return result;
`,yDe=ks({opSnippet:gDe,packedOpSnippet:xDe}),bDe={kernelName:yf,backendName:"webgl",kernelFunc:yDe};function ADe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=s.shape.length,l=[],u=E.parseAxisParam(o,s.shape),c=u,p=G.getAxesPermutation(c,i),d=s;p!=null&&(d=Hs({inputs:{x:s},backend:n,attrs:{perm:p}}),c=G.getInnerMostAxes(c.length,i),l.push(d)),G.assertAxesAreInnerMostDims("prod",c,i);let f;if(n.shouldExecuteOnCPU([d])){let h=n.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:x}=_Ne(d.shape,d.dtype,h,c);f=n.makeTensorInfo(g,x,m)}else{let[h,m]=G.computeOutAndReduceShapes(d.shape,c),g=E.sizeFromShape(m),x=qe({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),y=Ww(s.dtype),b=xh(x,y,"prod",n);f=qe({inputs:{x:b},backend:n,attrs:{shape:h}}),l.push(x),l.push(b)}if(a){l.push(f);let h=G.expandShapeToKeepDim(f.shape,u);f=qe({inputs:{x:f},backend:n,attrs:{shape:h}})}return l.forEach(h=>n.disposeIntermediateTensorInfo(h)),f}var vDe={kernelName:qg,backendName:"webgl",kernelFunc:ADe},fG=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:o,dtype:a}=n,i=ENe(r,s,o,a);return t.makeTensorInfo([i.length],a,i)},wDe={kernelName:H1,backendName:"webgl",kernelFunc:fG},kDe="return 1.0 / x;",IDe=tn({opSnippet:kDe}),CDe={kernelName:Kg,backendName:"webgl",kernelFunc:IDe},SDe=Ti+`
  return (x < 0.0) ? 0.0 : x;
`,NDe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,TDe=tn({opSnippet:SDe,packedOpSnippet:NDe}),_De={kernelName:Af,backendName:"webgl",kernelFunc:TDe},EDe=Ti+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,RDe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DDe=tn({opSnippet:EDe,packedOpSnippet:RDe}),$De={kernelName:wf,backendName:"webgl",kernelFunc:DDe},FDe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[o,a,i,l]=e;this.outputShape=[o,t,n,l];let u=[r&&t>1?a-1:a,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],p;s?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${i}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},ODe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[o,a,i,l]=e;this.outputShape=[o,t,n,l];let u=[r&&t>1?a-1:a,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],p;s?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${i}.0,
                                     ${i}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function PDe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:i}=r,[l,u]=i,c=be().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ODe(s.shape,l,u,o,a):new FDe(s.shape,l,u,o,a);return n.runWebGLProgram(c,[s],"float32")}var MDe={kernelName:vf,backendName:"webgl",kernelFunc:PDe},zDe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,o,a]=e,i=[n&&o>1?r-1:r,n&&a>1?s-1:s],l=[n&&o>1?o-1:o,n&&a>1?a-1:a],u=i[0]/l[0],c=i[1]/l[1],p=1/u,d=1/c,f=Math.ceil(p)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function LDe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:a}=r,i=new zDe(o.shape,s.shape,a);return n.runWebGLProgram(i,[o],o.dtype)}var BDe={kernelName:Sw,backendName:"webgl",kernelFunc:LDe},VDe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[o,a,i,l]=e;this.outputShape=[o,t,n,l];let u=[r&&t>1?a-1:a,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],p=r?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${i}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},WDe=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[o,a,i,l]=e;this.outputShape=[o,t,n,l];let u=[r&&t>1?a-1:a,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],p=r?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${i}.0,
                                     ${i}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function GDe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:i}=r,[l,u]=i,c=be().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new WDe(s.shape,l,u,o,a):new VDe(s.shape,l,u,o,a);return n.runWebGLProgram(c,[s],s.dtype)}var UDe={kernelName:q1,backendName:"webgl",kernelFunc:GDe},jDe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,o,a]=e,i=[n&&o>1?r-1:r,n&&a>1?s-1:s],l=[n&&o>1?o-1:o,n&&a>1?a-1:a],u=i[0]/l[0],c=i[1]/l[1],p=1/u,d=1/c,f=Math.ceil(p)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${i[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${i[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function HDe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:a}=r,i=new jDe(o.shape,s.shape,a);return n.runWebGLProgram(i,[o],o.dtype)}var qDe={kernelName:Cw,backendName:"webgl",kernelFunc:HDe},KDe=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,i)=>r(i)).join(","),o=Dn(n);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}},XDe=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=js("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Dn(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${i(r.slice())};
          if(${s}){
            result.g = ${l(r.slice())};
          }
          if(${o}) {
            result.b = ${u(r.slice())};
            if(${s}) {
              result.a = ${c(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function i(f){return p(f)}function l(f){return f[n-1]="("+f[n-1]+" + 1)",p(f)}function u(f){return f[n-2]="("+f[n-2]+" + 1)",p(f)}function c(f){return f[n-1]="("+f[n-1]+" + 1)",f[n-2]="("+f[n-2]+" + 1)",p(f)}function p(f){let h=e.map((x,y)=>d(y,f)),m=h.join(","),g=h.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function d(f,h){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${h[f]} - 1`:`${h[f]}`}}};function ZDe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:o}=r,a=s.shape.length,i=E.parseAxisParam(o,s.shape);if(a===0)return Xo({inputs:{x:s},backend:n});let l=be().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new XDe(s.shape,i):new KDe(s.shape,i);return n.runWebGLProgram(l,[s],s.dtype)}var YDe={kernelName:kf,backendName:"webgl",kernelFunc:ZDe},JDe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},QDe={kernelName:c0,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:o,center:a}=t,i=n,l=new JDe(r.shape,o),[u,c]=G.getImageCenter(a,r.shape[1],r.shape[2]),p=[[u,c,Math.sin(s),Math.cos(s)]];return i.runWebGLProgram(l,[r],r.dtype,p)}},e$e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,t$e=tn({opSnippet:e$e}),n$e={kernelName:If,backendName:"webgl",kernelFunc:t$e},r$e="return inversesqrt(x);",s$e=tn({opSnippet:r$e,cpuKernelImpl:RNe}),o$e={kernelName:Cf,backendName:"webgl",kernelFunc:s$e},hG=class{constructor(e,t,n,r,s,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;let i=Dn(s.length),l=Dn(o.length),u="";n===1?u="i":n===2&&(u="i, j");let c=`getIndices(${u})`,p="";r===1?p="i":r===2&&(p="i, coords[1]");let d=`getUpdates(${p})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${i} strides = ${i}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${c});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function a$e(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:o}=t,{shape:a}=r,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=G.calculateShapes(o,s,a),d=[p/u,u];if(p===0)return n.makeTensorInfo(a,s.dtype);let f=qe({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),h=qe({inputs:{x:o},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new hG(l,i,f.shape.length,h.shape.length,c,d),x=n.runWebGLProgram(g,[h,f,m],h.dtype),y=qe({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(m),y}var i$e={kernelName:Zg,backendName:"webgl",kernelFunc:a$e},l$e=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",r="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],l=[];for(let u=0;u<t.length;u++)l.push(`${a[u]}`),u<e&&i.push(`${a[u]}`);r=i.join(),s=l.join()}let o=Dn(n);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function u$e(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:o}=t,a=new l$e(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(a,[r,s,o],$a(s.dtype,o.dtype))}var c$e={kernelName:Yg,backendName:"webgl",kernelFunc:u$e},p$e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${G.SELU_SCALEALPHA};
  float scale = ${G.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,d$e=tn({opSnippet:p$e}),f$e={kernelName:Jg,backendName:"webgl",kernelFunc:d$e},mG="return 1.0 / (1.0 + exp(-1.0 * x));",h$e=tn({opSnippet:mG,packedOpSnippet:mG,cpuKernelImpl:DNe}),m$e={kernelName:Nf,backendName:"webgl",kernelFunc:h$e},g$e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,x$e=tn({opSnippet:g$e}),y$e={kernelName:t0,backendName:"webgl",kernelFunc:x$e},b$e=TW+`
  return sin(x);
`,A$e=tn({opSnippet:b$e}),v$e={kernelName:Sf,backendName:"webgl",kernelFunc:A$e},w$e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,k$e=tn({opSnippet:w$e}),I$e={kernelName:e0,backendName:"webgl",kernelFunc:k$e},C$e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,S$e=tn({opSnippet:C$e}),N$e={kernelName:n0,backendName:"webgl",kernelFunc:S$e},T$e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,paddings:a}=r;E.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=o.reduce((x,y)=>x*y),l=[[0,0]];l.push(...a);for(let x=1+o.length;x<s.shape.length;++x)l.push([0,0]);let u=[],c=dG({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),p=G.getReshaped(c.shape,o,i,!1),d=G.getPermuted(p.length,o.length,!1),f=G.getReshapedPermuted(c.shape,o,i,!1),h=qe({inputs:{x:c},backend:n,attrs:{shape:p}}),m=Hs({inputs:{x:h},backend:n,attrs:{perm:d}}),g=qe({inputs:{x:m},backend:n,attrs:{shape:f}});return u.push(c),u.push(h),u.push(m),u.forEach(x=>n.disposeIntermediateTensorInfo(x)),g},_$e={kernelName:r0,backendName:"webgl",kernelFunc:T$e};function E$e(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:o,defaultValue:a}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(o.dataId),c=n.readSync(a.dataId)[0],[p,d,f,h,m]=FNe(i,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],s.dtype,f),n.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var R$e={kernelName:Nw,backendName:"webgl",kernelFunc:E$e};function D$e(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:o}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);let a=Array.from(n.readSync(s.dataId)),i=n.readSync(r.dataId),l=Array.from(n.readSync(o.dataId)),[u,c,p]=ONe(i,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([p.length],o.dtype,new Int32Array(p))]}var $$e={kernelName:Tw,backendName:"webgl",kernelFunc:D$e};function F$e(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);let a=n.readSync(r.dataId),i=n.readSync(s.dataId),l=n.readSync(o.dataId),[u,c]=mW(a,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var O$e={kernelName:_w,backendName:"webgl",kernelFunc:F$e};function P$e(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);let a=n.readSync(r.dataId),i=n.readSync(s.dataId),l=n.readSync(o.dataId),[u,c]=mW(a,r.shape,r.dtype,i,l);return n.makeTensorInfo(c,r.dtype,u)}var M$e={kernelName:Ew,backendName:"webgl",kernelFunc:P$e};function z$e(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:a}=t,{outputShape:i}=r,{sliceRank:l,numUpdates:u,strides:c,outputSize:p}=G.calculateShapes(o,s,i),d=!1,f=new hG(u,l,s.shape.length,o.shape.length,c,[p,1],d),h=n.runWebGLProgram(f,[o,s,a],o.dtype),m=qe({inputs:{x:h},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),m}var L$e={kernelName:Rw,backendName:"webgl",kernelFunc:z$e};function B$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:o,axis:a}=r,i=E.parseAxisParam(a,s.shape)[0],l=G.prepareSplitSize(s,o,i),u=s.shape.length,c=new Array(u).fill(0),p=s.shape.slice();return l.map(d=>{let f=[...p];f[i]=d;let h=Q0({inputs:{x:s},backend:n,attrs:{begin:c,size:f}});return c[i]+=d,h})}var V$e={kernelName:s0,backendName:"webgl",kernelFunc:B$e},gG="return sqrt(x);",W$e=tn({opSnippet:gG,packedOpSnippet:gG,cpuKernelImpl:PNe}),G$e={kernelName:Tf,backendName:"webgl",kernelFunc:W$e},U$e="return x * x;",j$e=tn({opSnippet:U$e}),H$e={kernelName:K1,backendName:"webgl",kernelFunc:j$e},xG="return (a - b) * (a - b);",q$e=ks({opSnippet:xG,packedOpSnippet:xG}),K$e={kernelName:Rf,backendName:"webgl",kernelFunc:q$e};function X$e({inputs:e,attrs:t,backend:n}){let{x:r}=e,s=Ti+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,o=new rp(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}var Z$e={kernelName:Pc,backendName:"webgl",kernelFunc:X$e},Y$e=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,s=Dn(n.length),o=Dn(n.length),a="";if(r===1)a="coords * strides + begin";else{let i=0;a=n.map((l,u)=>(i++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${i-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function J$e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=r,{nonStrided:f,$begin:h,$strides:m,size:g,newShape:x,outShape:y}=Bs.sliceInfo(s.shape,o,a,i,l,u,c,p,d),b=qe({inputs:{x:s},backend:n,attrs:{shape:x}}),A;if(f){let w=Q0({inputs:{x:b},backend:n,attrs:{begin:h,size:g}});A=qe({inputs:{x:w},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(w)}else if(y.some(w=>w===0))A=n.makeTensorInfo(y,s.dtype,[]);else if(n.shouldExecuteOnCPU([b])){let I=n.texData.get(b.dataId).values,N=Wt(b.shape,b.dtype,I),T=MNe(y,N,m,h);A=n.makeTensorInfo(y,b.dtype,T.values)}else{let k=new Y$e(h,m,y);A=n.runWebGLProgram(k,[b],b.dtype)}let v=qe({inputs:{x:A},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(A),v}var Q$e={kernelName:o0,backendName:"webgl",kernelFunc:J$e};function e6e(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=t,d=n.readSync(c.dataId),f=n.readSync(p.dataId),[h,m]=zNe(d,f,s,o,a,i,l,u);return[n.makeTensorInfo([h.length],"string",h),n.makeTensorInfo(p.shape,"int32",m)]}var t6e={kernelName:Dw,backendName:"webgl",kernelFunc:e6e};function n6e(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:o,delimiter:a}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=n.readSync(o.dataId),l=n.readSync(a.dataId)[0],[u,c,p]=LNe(i,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var r6e={kernelName:$w,backendName:"webgl",kernelFunc:n6e};function s6e(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let a=n.readSync(o.dataId),i=BNe(a,s);return n.makeTensorInfo(o.shape,"int32",i)}var o6e={kernelName:Fw,backendName:"webgl",kernelFunc:s6e},a6e="return tan(x);",i6e=tn({opSnippet:a6e}),l6e={kernelName:$f,backendName:"webgl",kernelFunc:i6e},u6e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,c6e=tn({opSnippet:u6e}),p6e={kernelName:Ff,backendName:"webgl",kernelFunc:c6e},d6e=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;let r=Dn(this.rank),s=f6e(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function f6e(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}function yG(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){let l=n.readSync(s.dataId),u=s.dtype==="string"?l.map(d=>E.decodeString(d)):l,c=Wt(s.shape,s.dtype,u),p=WNe(c,o);return n.makeTensorInfo(p.shape,p.dtype,p.values)}let a=new d6e(s.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}var h6e={kernelName:Oc,backendName:"webgl",kernelFunc:yG},m6e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},g6e=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function yh(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function bG(e){let t=1;for(;t<e;)t*=2;return t}function x6e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:o,sorted:a}=r,i=be().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=be().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<i||o>l){let T=n.readSync(s.dataId),[_,R]=GNe(T,u,s.dtype,o,a);return[n.makeTensorInfo(_.shape,_.dtype,_.values),n.makeTensorInfo(R.shape,R.dtype,R.values)]}if(o===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,aA({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let p=n.texData.get(s.dataId),d=p!==null&&p.isPacked,f=d?n.unpackTensor(s):s,m=E.sizeFromShape(u)/c,g=qe({inputs:{x:f},attrs:{shape:[m,c]},backend:n});d&&yh(n,f);let x=bG(o),y=bG(c),b=null,A=()=>b===null?[g,g]:[g,b],v=(T,_,R)=>{let S=A(),F=new m6e(R),W=[[c],[b===null?1:0],[Number.NEGATIVE_INFINITY],[T],[_]],q=b;b=n.runWebGLProgram(F,S,"int32",W),yh(n,q)};for(let T=1;T<x;T*=2){let _=T*2;for(let R=T;R>=1;R/=2)v(_,R,[m,y])}for(let T=y;T>x;T/=2){let _=A(),R=new g6e([m,T/2]),F=[[c],[b===null?1:0],[x]],B=b;b=n.runWebGLProgram(R,_,"int32",F),yh(n,B);let W=x/2,q=W*2;for(let K=W;K>=1;K/=2)v(q,K,b.shape)}let w=b;b=Q0({inputs:{x:b},backend:n,attrs:{begin:0,size:[m,o]}}),yh(n,w);let k=sG({inputs:{x:g,indices:b},backend:n,attrs:{axis:1,batchDims:1}});yh(n,g);let I=u.slice(0,-1);I.push(o),w=b,b=qe({inputs:{x:b},attrs:{shape:I},backend:n}),yh(n,w);let N=k;return k=qe({inputs:{x:k},attrs:{shape:I},backend:n}),yh(n,N),[k,b]}var y6e={kernelName:a0,backendName:"webgl",kernelFunc:x6e},b6e=class{constructor(e,t,n,r,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;let a=n==="nearest"?1:2,i;switch(r){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${i} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function A6e(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:o}=t,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=r,[c,p,d,f]=s.shape,[h,m]=u!=null?u:[p,d],g=[c,h,m,f],x=new b6e(p,d,a,i,l,g);return n.runWebGLProgram(x,[s,o],"float32")}var v6e={kernelName:i0,backendName:"webgl",kernelFunc:A6e};function w6e(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:o}=t;j0(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=r.readSync(o.dataId),{outputValues:i,outputShape:l,indices:u}=UNe(a,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,i),r.makeTensorInfo([u.length],"int32",u)]}var k6e={kernelName:Ow,backendName:"webgl",kernelFunc:w6e};function I6e(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:o}=r;o<0&&(o+=s.shape.length);let a=s,i=a.shape.length,l=s.shape[o],u=new Array(i-1),c=0;for(let m=0;m<i;m++)m!==o&&(u[c++]=a.shape[m]);let p=[],d=new Array(i).fill(0),f=a.shape.slice();f[o]=1;let h=new Array(l);for(let m=0;m<h.length;m++){d[o]=m;let g=Q0({inputs:{x:a},backend:n,attrs:{begin:d,size:f}}),x=qe({inputs:{x:g},backend:n,attrs:{shape:u}});h[m]=x,p.push(g)}return p.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var C6e={kernelName:l0,backendName:"webgl",kernelFunc:I6e},S6e=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,s=e.inSize,o=e.numSegments,a=o*Math.ceil(s/n);this.outputShape=[r,a];let i="0.0",l="sumValue",u=Math.floor(n/4)*4,c=n%4,p=`
        sumValue += dot(values, segFilter);
    `,d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${i};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${l});
      }
    `}};function N6e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:o}=t,{numSegments:a}=r,i=s.shape.length,l=[],u=0,c=G.getAxesPermutation([u],i),p=s;c!=null&&(p=Hs({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(p),u=G.getInnerMostAxes(1,i)[0]);let d=G.segment_util.computeOutShape(p.shape,u,a),f=E.sizeFromShape([p.shape[u]]),h=qe({inputs:{x:p},backend:n,attrs:{shape:[-1,f]}});l.push(h);let m=Ww(s.dtype),g=(A,v,w,k,I)=>{let N=A.shape[0],T=A.shape[1],_=G.segment_util.segOpComputeOptimalWindowSize(T,I),R={windowSize:_,inSize:T,batchSize:N,numSegments:I},S=new S6e(R,v),F=n.compileAndRun(S,[A,w],k);if(l.push(F),F.shape[1]===I)return F;let B=fG({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),W=yG({inputs:{x:B},backend:n,attrs:{reps:[T/_]}});return l.push(B),l.push(W),g(F,v,W,k,I)},x=g(h,"unsortedSegmentSum",o,m,a),y=qe({inputs:{x},backend:n,attrs:{shape:d}}),b=y;if(c!=null){l.push(y);let A=G.getUndoAxesPermutation(c);b=Hs({inputs:{x:b},backend:n,attrs:{perm:A}})}return l.forEach(A=>n.disposeIntermediateTensorInfo(A)),b}var T6e={kernelName:X1,backendName:"webgl",kernelFunc:N6e},_6e=[r7e,a7e,GTe,jTe,KTe,YTe,QTe,n_e,s_e,a_e,c_e,d_e,m_e,y_e,C_e,v_e,T_e,D_e,E_e,P_e,z_e,B_e,U_e,Y_e,Q_e,oEe,iEe,pEe,hEe,ITe,bEe,_Ee,REe,kEe,OEe,MEe,$Ee,BEe,GEe,HEe,KEe,ZEe,QEe,o4e,i4e,t4e,c4e,f4e,m4e,b4e,k4e,N4e,E4e,R4e,D4e,F4e,P4e,z4e,B4e,W4e,H4e,X4e,J4e,eRe,rRe,aRe,cRe,hRe,kTe,gRe,xEe,bRe,wRe,CRe,STe,_Re,$Re,ORe,WRe,LRe,HRe,XRe,QRe,l7e,g7e,h7e,A7e,w7e,I7e,d7e,S7e,T7e,D7e,P7e,B7e,K7e,RTe,Z7e,Q7e,nDe,oDe,tEe,lDe,cDe,dDe,mDe,bDe,TTe,vDe,wDe,nEe,U7e,CDe,$De,_De,$Te,MDe,BDe,UDe,qDe,YDe,QDe,n$e,o$e,i$e,c$e,f$e,m$e,y$e,v$e,I$e,X_e,H7e,N$e,_$e,R$e,$$e,O$e,M$e,L$e,V$e,G$e,H$e,K$e,Z$e,Q$e,t6e,r6e,o6e,j7e,BTe,l6e,p6e,h6e,y6e,v6e,VTe,k6e,C6e,T6e,uDe];for(let e of _6e)Mc(e);var ko;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(ko||(ko={}));var iA;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(iA||(iA={}));var AG;function E6e(e){AG=e.wasm.cwrap(Pf,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function R6e(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o,bias:a,preluActivationWeights:i}=t;if(s.dtype!=="float32"||o.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r,d=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,h=0;if(a!=null){let I=n.dataIdMap.get(a.dataId);if(I.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${I.shape.length}.`);h=I.id}let m=i==null?0:n.dataIdMap.get(i.dataId).id,g=iA[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let x=l?s.shape[2]:s.shape[1],y=u?o.shape[1]:o.shape[2],b=s.shape[0],A=n.makeOutput([b,x,y],s.dtype),v=n.dataIdMap.get(A.dataId).id,w=new Uint8Array(new Int32Array(s.shape).buffer),k=new Uint8Array(new Int32Array(o.shape).buffer);return AG(d,w,s.shape.length,f,k,o.shape.length,l,u,g,h,m,p||0,v),A}var D6e={kernelName:Pf,backendName:"wasm",setupFunc:E6e,kernelFunc:R6e};function Is(e){let t;function n(s){t=s.wasm.cwrap(e,null,["number","number"])}function r(s){let{backend:o,inputs:{x:a}}=s,i=o.dataIdMap.get(a.dataId).id,l=o.makeOutput(a.shape,a.dtype),u=o.dataIdMap.get(l.dataId).id;return E.sizeFromShape(l.shape)===0||t(i,u),l}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var $6e=Is(cg);function qs(e,t,n){let r;function s(a){r=a.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function o(a){let{backend:i,inputs:l}=a,{a:u,b:c}=l,p=i.dataIdMap.get(u.dataId).id,d=i.dataIdMap.get(c.dataId).id,f=n!=null?n:u.dtype,h=G.assertAndGetBroadcastShape(u.shape,c.shape),m=i.makeOutput(h,f);if(E.sizeFromShape(h)===0)return m;let g=new Uint8Array(new Int32Array(u.shape).buffer),x=new Uint8Array(new Int32Array(c.shape).buffer),y=i.dataIdMap.get(m.dataId).id,b=()=>r(p,g,u.shape.length,d,x,c.shape.length,ko[u.dtype],y);if(t&&u.dtype==="float32")return b(),m;let A=G.getBroadcastDims(u.shape,h),v=G.getBroadcastDims(c.shape,h),w=A.every((I,N)=>I===N),k=v.every((I,N)=>I===N);if(w&&k)return b(),m;throw new Error(`Broadcasting along outer dims is not yet supported for ${u.dtype} ${e}.`)}return{kernelName:e,backendName:"wasm",setupFunc:s,kernelFunc:o}}var F6e=!0,O6e=qs($c,F6e),vG;function P6e(e){vG=e.wasm.cwrap(Ld,null,["array","number","number","number"])}function M6e(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(E.sizeFromShape(r.shape)===0)return r;let s=t.map(i=>n.dataIdMap.get(i.dataId).id),o=new Uint8Array(new Int32Array(s).buffer),a=n.dataIdMap.get(r.dataId).id;return vG(o,s.length,ko[r.dtype],a),r}var z6e={kernelName:Ld,backendName:"wasm",setupFunc:P6e,kernelFunc:M6e};function j5(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}var L6e={kernelName:sf,backendName:"wasm",kernelFunc:j5},wG;function B6e(e){wG=e.wasm.cwrap(Of,null,["number","array","number","number","number","array","number"])}function nx(e){let{inputs:t,backend:n,attrs:r}=e,[s,o]=W6e(t.x.shape,r.perm),a=!0;for(let h=0;h<o.length;h++)o[h]!==h&&(a=!1);let i=V6e(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(a){let h=j5({inputs:t,backend:n});return h.shape=i,h}let u=n.makeOutput(i,l.dtype),c=n.dataIdMap.get(l.dataId).id,p=n.dataIdMap.get(u.dataId).id,d=new Uint8Array(new Int32Array(o).buffer),f=new Uint8Array(new Int32Array(l.shape).buffer);return wG(c,f,l.shape.length,ko[l.dtype],p,d,o.length),u}function V6e(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function W6e(e,t){let n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);for(let s=0;s<r.length;++s){let o=-1;for(let a=0;a<r.length;++a)r[a]>=s&&(o===-1||r[o]>r[a])&&(o=a);r[o]=s}return[n,r]}var G6e={kernelName:Of,backendName:"wasm",kernelFunc:nx,setupFunc:B6e};function op(e,t,n){let r=e.shape,s=e.shape.length,o=E.parseAxisParam(t,r),a=o,i=G.getAxesPermutation(a,s),l=null,u=!1;if(i!=null){let c=new Array(s);for(let f=0;f<c.length;f++)c[f]=r[i[f]];a=G.getInnerMostAxes(a.length,s),l=nx({inputs:{x:e},attrs:{perm:i},backend:n});let p=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==p&&(u=!0)}return{transposed:l,originalAxes:o,axes:a,inputWasTransposed:u}}var kG;function U6e(e){kG=e.wasm.cwrap(fg,null,["number, number, number"])}function j6e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:o}=r,{x:a}=n,l=t.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:f}=op(a,s,t);if(f){let b=t.dataIdMap.get(c.dataId).id;u=c,l=b}let h=u.shape.length;G.assertAxesAreInnerMostDims("all",p,h);let[m,g]=G.computeOutAndReduceShapes(u.shape,p),x=E.sizeFromShape(g),y=t.makeOutput(m,a.dtype);if(E.sizeFromShape(u.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;kG(l,x,b)}if(f&&t.disposeData(c.dataId),o){let b=G.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var H6e={kernelName:fg,backendName:"wasm",setupFunc:U6e,kernelFunc:j6e},IG;function q6e(e){IG=e.wasm.cwrap(hg,null,["number, number, number"])}function K6e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:o}=r,{x:a}=n,l=t.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:f}=op(a,s,t);if(f){let b=t.dataIdMap.get(c.dataId).id;u=c,l=b}let h=u.shape.length;G.assertAxesAreInnerMostDims("any",p,h);let[m,g]=G.computeOutAndReduceShapes(u.shape,p),x=E.sizeFromShape(g),y=t.makeOutput(m,a.dtype);if(E.sizeFromShape(u.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;IG(l,x,b)}if(f&&t.disposeData(c.dataId),o){let b=G.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var X6e={kernelName:hg,backendName:"wasm",setupFunc:q6e,kernelFunc:K6e},CG;function Z6e(e){CG=e.wasm.cwrap(Bd,null,["number","number","number","number","number"])}function Y6e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s}=r,{x:o}=n,a=t.dataIdMap.get(o.dataId).id,i=a,l=o,{transposed:u,axes:c,inputWasTransposed:p}=op(o,s,t);if(p){let x=t.dataIdMap.get(u.dataId).id;x!==a&&(l=u,i=x)}let d=l.shape.slice(0,-1),f=t.makeOutput(d,"int32"),h=t.dataIdMap.get(f.dataId).id,m=E.sizeFromShape(f.shape),g=l.shape[c[0]];return CG(i,ko[l.dtype],m,g,h),p&&t.disposeData(u.dataId),f}var J6e={kernelName:Bd,backendName:"wasm",kernelFunc:Y6e,setupFunc:Z6e},SG;function Q6e(e){SG=e.wasm.cwrap(Vd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function eFe(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,o=r.dataIdMap.get(s.dataId).id,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=n,c=G.computePool2DInfo(s.shape,a,i,1,l,u),p=c.filterHeight,d=c.filterWidth,f=c.padInfo.top,h=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,x=c.strideHeight,y=c.strideWidth,b=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let A=r.makeOutput(c.outShape,"float32"),v=r.dataIdMap.get(A.dataId).id;return SG(o,s.shape[0],s.shape[1],s.shape[2],p,d,f,h,m,g,x,y,b,v),A}var tFe={kernelName:Vd,backendName:"wasm",setupFunc:Q6e,kernelFunc:eFe};function Io(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,o=E.sizeFromShape(r.shape),a=E.inferFromImplicitShape(s,o);return E.assert(o===E.sizeFromShape(a),()=>`new shape: ${a}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:a,dtype:r.dtype}}var nFe={kernelName:Xg,backendName:"wasm",kernelFunc:Io},NG;function rFe(e){NG=e.wasm.cwrap(Wd,null,["number","array","number","number","array","number","number","number","number"])}function sFe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o}=t,{transposeA:a,transposeB:i}=r;if(s.dtype!=="float32"||o.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=s.shape.length,u=o.shape.length,c=a?s.shape[l-2]:s.shape[l-1],p=i?o.shape[u-1]:o.shape[u-2],d=a?s.shape[l-1]:s.shape[l-2],f=i?o.shape[u-2]:o.shape[u-1],h=s.shape.slice(0,-2),m=o.shape.slice(0,-2),g=E.sizeFromShape(h),x=E.sizeFromShape(m),y=g===x||g===1||x===1;E.assert(l>=2&&u>=2&&y,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${m}).`);let A=(g>x?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([d,f]);E.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${a} and transposeB=${i} must match.`);let v=a?[g,c,d]:[g,d,c],w=i?[x,f,p]:[x,p,f],k=Io({inputs:{x:s},backend:n,attrs:{shape:v}}),I=Io({inputs:{x:o},backend:n,attrs:{shape:w}}),N=n.dataIdMap.get(k.dataId).id,T=n.dataIdMap.get(I.dataId).id,_=a?k.shape[2]:k.shape[1],R=i?I.shape[1]:I.shape[2],S=Math.max(g,x),F=n.makeOutput([S,_,R],k.dtype),B=n.dataIdMap.get(F.dataId).id,W=new Uint8Array(new Int32Array(k.shape).buffer),q=new Uint8Array(new Int32Array(I.shape).buffer);return NG(N,W,k.shape.length,T,q,I.shape.length,a,i,B),n.disposeData(k.dataId),n.disposeData(I.dataId),F.shape=A,F}var oFe={kernelName:Wd,backendName:"wasm",setupFunc:rFe,kernelFunc:sFe};function lA(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:s}=e,[o,a]=Bs.parseSliceParams(t,n,r),i=Bs.isSliceContinous(t.shape,o,a),l=s.readSync(t.dataId),u=s.makeOutput(a,t.dtype),c=E.computeStrides(t.shape),p=s.dataIdMap.get(u.dataId);if(i){let h=Bs.computeFlatOffset(o,c);return t.dtype==="string"?p.stringBytes=l.slice(h,h+E.sizeFromShape(a)):s.typedArrayFromHeap(u).set(l.subarray(h,h+E.sizeFromShape(a))),u}if(t.dtype==="string"){let h=v5(l,o,a,t.shape,t.dtype);return p.stringBytes=h,u}let d=s.typedArrayFromHeap(u),f=t.shape.length;if(f===2)aFe(l,c[0],d,o,a);else if(f===3)iFe(l,c[0],c[1],d,o,a);else if(f===4)lFe(l,c[0],c[1],c[2],d,o,a);else{let h=v5(l,o,a,t.shape,t.dtype);d.set(h)}return u}function aFe(e,t,n,r,s){let o=0,a=r[0],i=r[1],l=a+s[0];for(let u=a;u<l;u++){let c=u*t+i;n.set(e.subarray(c,c+s[1]),o),o+=s[1]}}function iFe(e,t,n,r,s,o){let a=0,i=s[0],l=s[1],u=s[2],c=i+o[0],p=l+o[1];for(let d=i;d<c;d++)for(let f=l;f<p;f++){let h=d*t+f*n+u;r.set(e.subarray(h,h+o[2]),a),a+=o[2]}}function lFe(e,t,n,r,s,o,a){let i=0,l=o[0],u=o[1],c=o[2],p=l+a[0],d=u+a[1],f=c+a[2],h=o[3];for(let m=l;m<p;m++)for(let g=u;g<d;g++)for(let x=c;x<f;x++){let y=m*t+g*n+x*r+h;s.set(e.subarray(y,y+a[3]),i),i+=a[3]}}var uFe={kernelName:Qg,backendName:"wasm",kernelFunc:lA};function cFe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,crops:a}=r,i=o.reduce((x,y)=>x*y),l=G.getReshaped(s.shape,o,i),u=G.getPermuted(l.length,o.length),c=G.getReshapedPermuted(s.shape,o,i),p=G.getSliceBeginCoords(a,o.length),d=G.getSliceSize(c,a,o.length),f=Io({inputs:{x:s},backend:n,attrs:{shape:l}}),h=nx({inputs:{x:f},backend:n,attrs:{perm:u}}),m=Io({inputs:{x:h},backend:n,attrs:{shape:c}}),g=lA({inputs:{x:m},backend:n,attrs:{begin:p,size:d}});return n.disposeData(f.dataId),n.disposeData(h.dataId),n.disposeData(f.dataId),g}var pFe={kernelName:Ag,backendName:"wasm",kernelFunc:cFe};function H5(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,s=r.makeOutput(t.shape,n),o=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(s).set(o),s}var dFe={kernelName:Gd,backendName:"wasm",kernelFunc:H5},fFe=Is(Ud),TG;function hFe(e){TG=e.wasm.cwrap(Fc,null,["number","number","number","number"])}function mFe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:o,clipValueMax:a}=r,i=n.dataIdMap.get(s.dataId).id,l=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(l.dataId).id;return TG(i,o,a,u),l}var gFe={kernelName:Fc,backendName:"wasm",setupFunc:hFe,kernelFunc:mFe};function _G(e){let{inputs:t,backend:n}=e,r=E.parseAxisParam(e.attrs.axis,t[0].shape)[0],s=G.computeOutShape(t.map(f=>f.shape),r),o=t.filter(f=>E.sizeFromShape(f.shape)>0);if(o.length===1)return j5({inputs:{x:o[0]},backend:n});let a=n.makeOutput(s,t[0].dtype);if(E.sizeFromShape(s)===0)return a;let i=o.map(f=>f.shape);if(G.assertParamsConsistent(i,r),o[0].dtype==="string"){let f=o.map(b=>{let A=E.sizeFromShape(b.shape.slice(r));return Io({inputs:{x:b},backend:n,attrs:{shape:[-1,A]}})}),h=f.map(b=>({vals:n.readSync(b.dataId),shape:b.shape}));s=G.computeOutShape(f.map(b=>b.shape),1);let m=f[0].shape[0]===1,g=uR(h,s,t[0].dtype,m),x=G.computeOutShape(o.map(b=>b.shape),r);a.shape=x;let y=n.dataIdMap.get(a.dataId);return y.stringBytes=G.fromStringArrayToUint8(g),f.forEach(b=>n.disposeData(b.dataId)),a}let l=E.sizeFromShape(o[0].shape.slice(0,r)),u=0,c=o.map(f=>{let h=E.sizeFromShape(f.shape.slice(r));return u+=h,h}),p=o.map(f=>n.typedArrayFromHeap(f)),d=n.typedArrayFromHeap(a);for(let f=0;f<l;f++){let h=f*u;for(let m=0;m<p.length;m++){let g=c[m],x=f*g,y=p[m].subarray(x,x+g);d.set(y,h),h+=g}}return a}var xFe={kernelName:vg,backendName:"wasm",kernelFunc:_G},EG;function yFe(e){EG=e.wasm.cwrap(jd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bFe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:o}=t,a=r.dataIdMap.get(s.dataId).id,i=r.dataIdMap.get(o.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:p,dataFormat:d}=n,f=G.convertConv2DDataFormat(d),h=G.computeConv2DInfo(s.shape,o.shape,l,u,c,p,!1,f),m=h.filterHeight,g=h.filterWidth,x=h.padInfo.top,y=h.padInfo.right,b=h.padInfo.bottom,A=h.padInfo.left,v=h.dilationHeight,w=h.dilationWidth,k=h.strideHeight,I=h.strideWidth,N=h.inChannels,T=h.outChannels,_=h.padInfo.type==="SAME"?1:0;if(h.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let R=r.makeOutput(h.outShape,"float32"),S=r.dataIdMap.get(R.dataId).id;return EG(a,s.shape[0],s.shape[1],s.shape[2],i,m,g,x,y,b,A,_,v,w,k,I,N,T,S),R}var AFe={kernelName:jd,backendName:"wasm",setupFunc:yFe,kernelFunc:bFe},RG;function vFe(e){RG=e.wasm.cwrap(Hd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wFe(e){let{backend:t,inputs:n,attrs:r}=e,{dy:s,filter:o}=n,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,p=1,d=G.convertConv2DDataFormat(l),f=G.computeConv2DInfo(c,o.shape,a,p,i,u,!1,d),{batchSize:h,filterHeight:m,filterWidth:g,inChannels:x,inHeight:y,inWidth:b,outChannels:A,outHeight:v,outWidth:w,strideHeight:k,strideWidth:I}=f,N=m-1-f.padInfo.top,T=g-1-f.padInfo.left,_=f.dataFormat==="channelsLast",R=E.computeStrides(f.inShape),S=E.computeStrides(s.shape),[F,B,W]=E.computeStrides(o.shape),q=R[0],K=_?R[1]:R[2],J=_?R[2]:1,Q=_?1:R[1],ee=S[0],ue=_?S[1]:S[2],re=_?S[2]:1,de=_?1:S[1],fe=t.makeOutput(f.inShape,"float32"),me=t.dataIdMap.get(fe.dataId).id,xe=t.dataIdMap.get(s.dataId).id,Ne=t.dataIdMap.get(o.dataId).id;return RG(xe,Ne,h,m,g,y,b,x,v,w,A,k,I,N,T,F,B,W,q,K,J,Q,ee,ue,re,de,me),fe}var kFe={kernelName:Hd,backendName:"wasm",setupFunc:vFe,kernelFunc:wFe},IFe=Is(qd),CFe=Is(Kd),VR;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(VR||(VR={}));var DG;function SFe(e){DG=e.wasm.cwrap(wg,null,["number","number","number","number","array","number","number","number","number","number"])}function NFe(e){let{backend:t,inputs:n,attrs:r}=e,{method:s,extrapolationValue:o,cropSize:a}=r,{image:i,boxes:l,boxInd:u}=n,c=l.shape[0],[p,d]=a,f=[c,p,d,i.shape[3]],h=t.dataIdMap.get(i.dataId),m;i.dtype!=="float32"&&(m=H5({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(m.dataId));let g=h.id,x=t.dataIdMap.get(l.dataId).id,y=t.dataIdMap.get(u.dataId).id,b=t.makeOutput(f,"float32"),A=t.dataIdMap.get(b.dataId).id,v=new Uint8Array(new Int32Array(i.shape).buffer);return DG(g,x,y,c,v,p,d,VR[s],o,A),m!=null&&t.disposeData(m.dataId),b}var TFe={kernelName:wg,backendName:"wasm",setupFunc:SFe,kernelFunc:NFe},$G;function _Fe(e){$G=e.wasm.cwrap(Xd,null,["number","number","number","number","number","number"])}function EFe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,exclusive:a,reverse:i}=r,l=s.shape.length;E.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);let u=G.getAxesPermutation([o],l),c=s;u!==null&&(c=nx({inputs:{x:s},attrs:{perm:u},backend:n}));let p=G.getInnerMostAxes(1,l)[0];G.assertAxesAreInnerMostDims("cumsum",[p],l);let d=n.makeOutput(c.shape,c.dtype),f=c.shape[p],h=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(d.dataId).id;$G(h,a?1:0,i?1:0,f,m,ko[s.dtype]);let g=d;if(u!==null){let x=G.getUndoAxesPermutation(u);g=nx({inputs:{x:d},attrs:{perm:x},backend:n}),n.disposeData(c.dataId),n.disposeData(d.dataId)}return g}var RFe={kernelName:Xd,backendName:"wasm",setupFunc:_Fe,kernelFunc:EFe},FG;function DFe(e){FG=e.wasm.cwrap(kg,null,["number","number","number","array","number","array","array","number","number"])}function $Fe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{blockSize:o,dataFormat:a}=r;E.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let i=s.shape[0],l=a==="NHWC"?s.shape[1]:s.shape[2],u=a==="NHWC"?s.shape[2]:s.shape[3],c=a==="NHWC"?s.shape[3]:s.shape[1],p=l*o,d=u*o,f=c/(o*o),h=a==="NHWC"?[i,p,d,f]:[i,f,p,d],m=t.makeOutput(h,"float32"),x=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(E.computeStrides(s.shape)).buffer),b=new Uint8Array(new Int32Array(h).buffer),A=new Uint8Array(new Int32Array(E.computeStrides(h)).buffer),v=t.dataIdMap.get(m.dataId).id;return FG(x,o,a==="NHWC"?1:0,y,s.shape.length-1,b,A,h.length,v),m}var FFe={kernelName:kg,backendName:"wasm",setupFunc:DFe,kernelFunc:$Fe},OG;function OFe(e){OG=e.wasm.cwrap(Zd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function PFe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:o}=t,a=r.dataIdMap.get(s.dataId).id,i=r.dataIdMap.get(o.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:p}=n,d=u==null?[1,1]:u,f=G.computeConv2DInfo(s.shape,o.shape,l,d,c,p,!0),h=f.filterHeight,m=f.filterWidth,g=f.padInfo.top,x=f.padInfo.right,y=f.padInfo.bottom,b=f.padInfo.left,A=f.dilationHeight,v=f.dilationWidth,w=f.strideHeight,k=f.strideWidth,I=f.inChannels,N=f.outChannels,T=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(f.outShape,"float32"),R=r.dataIdMap.get(_.dataId).id;return OG(a,s.shape[0],s.shape[1],s.shape[2],i,h,m,g,x,y,b,T,A,v,w,k,I,N,R),_}var MFe={kernelName:Zd,backendName:"wasm",setupFunc:OFe,kernelFunc:PFe},zFe=Is(Jd),LFe=!1,BFe=qs(Cg,LFe,"bool"),VFe=Is(Qd);function WR(e){let{inputs:t,attrs:n,backend:r}=e,{input:s}=t,{dim:o}=n,a=s.shape.length,i=s.shape.slice(),l=o;return o<0&&(E.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),i.splice(l,0,1),Io({inputs:{x:s},backend:r,attrs:{shape:i}})}var WFe={kernelName:Sg,backendName:"wasm",kernelFunc:WR};function PG(e){let{attrs:{shape:t,value:n,dtype:r},backend:s}=e,o=s.makeOutput(t,r);return s.typedArrayFromHeap(o).fill(n),o}var GFe={kernelName:V1,backendName:"wasm",kernelFunc:PG},MG;function UFe(e){MG=e.wasm.cwrap(Tg,null,["number","number","number","number","number","number"])}function jFe(e){let{inputs:t,backend:n}=e,{image:r}=t,s=n.makeOutput(r.shape,r.dtype),o=n.dataIdMap.get(r.dataId).id,a=n.dataIdMap.get(s.dataId).id,[i,l,u,c]=r.shape;return MG(o,i,l,u,c,a),s}var HFe={kernelName:Tg,backendName:"wasm",kernelFunc:jFe,setupFunc:UFe},qFe=Is(ef),KFe=!1,XFe=qs(tf,KFe),zG;function ZFe(e){zG=e.wasm.cwrap(nf,null,["number","number","number","number","number","number","number"])}function YFe(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:s}=r,{x:o,mean:a,variance:i,offset:l,scale:u}=n,c=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(i.dataId).id,f=l!=null?t.dataIdMap.get(l.dataId).id:0,h=u!=null?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(o.shape,o.dtype);if(E.sizeFromShape(o.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return zG(c,p,d,f,h,s,g),m}var JFe={kernelName:nf,backendName:"wasm",setupFunc:ZFe,kernelFunc:YFe},LG;function QFe(e){LG=e.wasm.cwrap(Mf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function e8e(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dataFormat:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=n,m=G.computeConv2DInfo(s.shape,o.shape,l,c,u,d),g=iA[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let x=r.dataIdMap.get(s.dataId).id,y=r.dataIdMap.get(o.dataId).id,b=m.outChannels,A=0;if(a!=null){let re=r.dataIdMap.get(a.dataId);if(re.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${re.shape.length}.`);if(re.shape[0]!==b)throw new Error(`FusedConv2D bias shape (${re.shape}) does not match the number of output channels (${b})`);A=re.id}let v=m.filterHeight,w=m.filterWidth,k=m.padInfo.top,I=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,R=m.dilationWidth,S=m.strideHeight,F=m.strideWidth,B=m.inChannels,W=m.padInfo.type==="SAME"?1:0,q=m.batchSize,K=m.inHeight,J=m.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let Q=r.makeOutput(m.outShape,"float32"),ee=r.dataIdMap.get(Q.dataId).id,ue=i==null?0:r.dataIdMap.get(i.dataId).id;return LG(x,q,K,J,y,v,w,A,k,I,N,T,W,_,R,S,F,B,b,g,ue,h||0,ee),Q}var t8e={kernelName:Mf,backendName:"wasm",setupFunc:QFe,kernelFunc:e8e},BG;function n8e(e){BG=e.wasm.cwrap(zf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function r8e(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dataFormat:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=n,m=G.computeConv2DInfo(s.shape,o.shape,l,c,u,d,!0),g=iA[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let x=r.dataIdMap.get(s.dataId).id,y=r.dataIdMap.get(o.dataId).id,b=m.outChannels,A=0;if(a!=null){let re=r.dataIdMap.get(a.dataId);if(re.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${re.shape.length}.`);if(re.shape[0]!==b)throw new Error(`FusedDepthwiseConv2D bias shape (${re.shape}) does not match the number of output channels (${b})`);A=re.id}let v=m.filterHeight,w=m.filterWidth,k=m.padInfo.top,I=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,R=m.dilationWidth,S=m.strideHeight,F=m.strideWidth,B=m.inChannels,W=m.padInfo.type==="SAME"?1:0,q=m.batchSize,K=m.inHeight,J=m.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let Q=r.makeOutput(m.outShape,"float32"),ee=r.dataIdMap.get(Q.dataId).id,ue=i==null?0:r.dataIdMap.get(i.dataId).id;return BG(x,q,K,J,y,v,w,A,k,I,N,T,W,_,R,S,F,B,b,g,ue,h||0,ee),Q}var s8e={kernelName:zf,backendName:"wasm",setupFunc:n8e,kernelFunc:r8e},VG;function o8e(e){VG=e.wasm.cwrap(Eg,null,["number","number","number","number","number","number","array","number"])}function a8e(e){let{backend:t,inputs:n}=e,{params:r,indices:s}=n,[o,a,i,l]=e_.prepareAndValidate(r,s),u=t.makeOutput(o,r.dtype);if(a===0)return u;let c=s.shape,p=c[c.length-1],f=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(l).buffer),x=t.dataIdMap.get(u.dataId).id;return VG(f,ko[r.dtype],m,a,p,i,g,x),u}var i8e={kernelName:Eg,backendName:"wasm",setupFunc:o8e,kernelFunc:a8e},WG;function l8e(e){WG=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function u8e(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,indices:o}=n,{axis:a,batchDims:i}=r,l=E.parseAxisParam(a,s.shape)[0],u=G.segment_util.collectGatherOpShapeInfo(s,o,l,i),c=Io({inputs:{x:s},attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]},backend:t}),p=E.sizeFromShape(o.shape),d=Io({inputs:{x:o},attrs:{shape:[u.batchSize,p/u.batchSize]},backend:t}),f=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize],h=t.makeOutput(f,s.dtype);if(E.sizeFromShape(s.shape)===0)return h;let m=c.shape.length-1,x=t.dataIdMap.get(c.dataId).id,b=t.dataIdMap.get(d.dataId).id,A=t.dataIdMap.get(h.dataId).id,v=new Uint8Array(new Int32Array(E.computeStrides(c.shape)).buffer),w=new Uint8Array(new Int32Array(E.computeStrides(f)).buffer);return WG(x,ko[s.dtype],v,m,b,u.batchSize,w,A),t.disposeData(c.dataId),t.disposeData(d.dataId),h.shape=u.outputShape,h}var c8e={kernelName:_g,backendName:"wasm",setupFunc:l8e,kernelFunc:u8e},p8e=!1,d8e=qs(Rg,p8e,"bool"),f8e=!1,h8e=qs(rf,f8e,"bool"),GG;function m8e(e){GG=e.wasm.cwrap(of,null,["number","number","number"])}function g8e(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,s=r.dataIdMap.get(t.dataId).id,o=r.makeOutput(t.shape,t.dtype);if(E.sizeFromShape(t.shape)!==0){let a=r.dataIdMap.get(o.dataId).id;GG(s,n,a)}return o}var x8e={kernelName:of,backendName:"wasm",setupFunc:m8e,kernelFunc:g8e},y8e=!1,b8e=qs(Og,y8e,"bool"),A8e=!1,v8e=qs(Pg,A8e,"bool"),w8e=Is(af),k8e=!1,I8e=qs(zg,k8e,"bool"),UG;function C8e(e){UG=e.wasm.cwrap(lf,null,["number, number, number"])}function S8e(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:s,keepDims:o}=r,{x:a}=n,l=t.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:f}=op(a,s,t);if(f){let b=t.dataIdMap.get(c.dataId).id;u=c,l=b}let h=u.shape.length;G.assertAxesAreInnerMostDims("max",p,h);let[m,g]=G.computeOutAndReduceShapes(u.shape,p),x=E.sizeFromShape(g),y=t.makeOutput(m,a.dtype);if(E.sizeFromShape(u.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;UG(l,x,b)}if(f&&t.disposeData(c.dataId),o){let b=G.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var N8e={kernelName:lf,backendName:"wasm",setupFunc:C8e,kernelFunc:S8e},T8e=!1,_8e=qs(uf,T8e),jG;function E8e(e){jG=e.wasm.cwrap(cf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function R8e(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,o=r.dataIdMap.get(s.dataId).id,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=n,c=G.computePool2DInfo(s.shape,a,i,1,l,u),p=c.filterHeight,d=c.filterWidth,f=c.padInfo.top,h=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,x=c.dilationHeight,y=c.dilationWidth,b=c.strideHeight,A=c.strideWidth,v=c.inChannels,w=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let k=r.makeOutput(c.outShape,"float32"),I=r.dataIdMap.get(k.dataId).id;return jG(o,s.shape[0],s.shape[1],s.shape[2],p,d,f,h,m,g,x,y,b,A,v,w,I),k}var D8e={kernelName:cf,backendName:"wasm",setupFunc:E8e,kernelFunc:R8e},HG;function $8e(e){HG=e.wasm.cwrap(pf,null,["number, number, number"])}function F8e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:o}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,l=i,u=a,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:f}=op(a,s,t),h=p;if(f){let A=t.dataIdMap.get(c.dataId).id;A!==i&&(u=c,l=A,h=G.getInnerMostAxes(h.length,u.shape.length))}G.assertAxesAreInnerMostDims("mean",h,u.shape.length);let[m,g]=G.computeOutAndReduceShapes(u.shape,h),x=E.sizeFromShape(g),y=u;u.dtype!=="float32"&&(y=H5({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(y.dataId).id);let b=t.makeOutput(m,"float32");if(E.sizeFromShape(u.shape)!==0){let A=t.dataIdMap.get(b.dataId).id;HG(l,x,A)}if(f&&t.disposeData(c.dataId),o){let A=G.expandShapeToKeepDim(b.shape,d);b.shape=A}return u.dtype!=="float32"&&t.disposeData(y.dataId),b}var O8e={kernelName:pf,backendName:"wasm",setupFunc:$8e,kernelFunc:F8e},qG;function P8e(e){qG=e.wasm.cwrap(df,null,["number, number, number"])}function M8e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:o}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,l=i,u=a,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:f}=op(a,s,t);if(f){let b=t.dataIdMap.get(c.dataId).id;b!==i&&(u=c,l=b)}let h=u.shape.length;G.assertAxesAreInnerMostDims("min",p,h);let[m,g]=G.computeOutAndReduceShapes(u.shape,p),x=E.sizeFromShape(g),y=t.makeOutput(m,u.dtype);if(E.sizeFromShape(u.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;qG(l,x,b)}if(f&&t.disposeData(c.dataId),o){let b=G.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var z8e={kernelName:df,backendName:"wasm",setupFunc:P8e,kernelFunc:M8e},L8e=!1,B8e=qs(ff,L8e),GR;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(GR||(GR={}));var KG;function V8e(e){KG=e.wasm.cwrap(hf,null,["number","array","number","number","array","array","number","number"])}function W8e(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:s}}=e,o=r.map((h,m)=>h[0]+t.shape[m]+h[1]),a=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(o,t.dtype),l=n.dataIdMap.get(i.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(h=>h[0]),p=r.map(h=>h[1]),d=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(p).buffer);return KG(a,u,t.shape.length,ko[t.dtype],d,f,GR[s],l),i}var G8e={kernelName:hf,backendName:"wasm",kernelFunc:W8e,setupFunc:V8e},U8e=!0,j8e=qs(mf,U8e),H8e=Is(Bg);function UR(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],s=n[1],o=n[2],a=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:s,pSelectedScores:o,pValidOutputs:a}}var XG;function q8e(e){XG=e.wasm.cwrap(Wg,"number",["number","number","number","number","number"])}function K8e(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:o,scoreThreshold:a}=r,{boxes:i,scores:l}=n,u=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(l.dataId).id,p=XG(u,c,o,s,a),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:m}=UR(t,p);return t.wasm._free(h),t.wasm._free(m),t.makeOutput([f],"int32",d)}var X8e={kernelName:Wg,backendName:"wasm",setupFunc:q8e,kernelFunc:K8e},ZG;function Z8e(e){ZG=e.wasm.cwrap(Gg,"number",["number","number","number","number","number","bool"])}function Y8e(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:o,scoreThreshold:a,padToMaxOutputSize:i}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,p=t.dataIdMap.get(u.dataId).id,d=ZG(c,p,o,s,a,i),{pSelectedIndices:f,selectedSize:h,pSelectedScores:m,pValidOutputs:g}=UR(t,d);t.wasm._free(m);let x=t.makeOutput([h],"int32",f),y=t.makeOutput([],"int32",g);return[x,y]}var J8e={kernelName:Gg,backendName:"wasm",setupFunc:Z8e,kernelFunc:Y8e},YG;function Q8e(e){YG=e.wasm.cwrap(Ug,"number",["number","number","number","number","number","number"])}function eOe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:o,scoreThreshold:a,softNmsSigma:i}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,p=t.dataIdMap.get(u.dataId).id,d=YG(c,p,o,s,a,i),{pSelectedIndices:f,selectedSize:h,pSelectedScores:m,pValidOutputs:g}=UR(t,d);t.wasm._free(g);let x=t.makeOutput([h],"int32",f),y=t.makeOutput([h],"float32",m);return[x,y]}var tOe={kernelName:Ug,backendName:"wasm",setupFunc:Q8e,kernelFunc:eOe},nOe=!1,rOe=qs(Vg,nOe,"bool"),JG;function sOe(e){JG=e.wasm.cwrap(gf,null,["number","number","number","number","number"])}function oOe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:o,onValue:a,offValue:i}=r,l=n.makeOutput([...s.shape,o],"int32"),u=n.dataIdMap.get(l.dataId).id,p=n.dataIdMap.get(s.dataId).id;return JG(p,o,a,i,u),l}var aOe={kernelName:gf,backendName:"wasm",setupFunc:sOe,kernelFunc:oOe};function iOe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var lOe={kernelName:jg,backendName:"wasm",kernelFunc:iOe};function uOe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return WR({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let o=t[0].shape,a=t[0].dtype;t.forEach(c=>{E.assertShapesMatch(o,c.shape,"All tensors passed to stack must have matching shapes"),E.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=t.map(c=>{let p=WR({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(p),p}),u=_G({inputs:l,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeData(c.dataId)),u}var cOe={kernelName:Hg,backendName:"wasm",kernelFunc:uOe},QG;function pOe(e){QG=e.wasm.cwrap(xf,null,["number","array","number","number","array","array","number","number"])}function dOe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:s}}=e,o=r.map((m,g)=>m[0]+t.shape[g]+m[1]);if(E.sizeFromShape(t.shape)===0)return PG({backend:n,attrs:{shape:o,value:s,dtype:t.dtype}});let a=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(o,t.dtype),u=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map(m=>m[0]),d=r.map(m=>m[1]),f=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(d).buffer);return QG(a,c,t.shape.length,ko[t.dtype],f,h,s,u),i}var eU={kernelName:xf,backendName:"wasm",kernelFunc:dOe,setupFunc:pOe},fOe=!1,hOe=qs(yf,fOe),tU;function mOe(e){tU=e.wasm.cwrap(bf,null,["number","number","number"])}function gOe(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,o=n.dataIdMap.get(r.dataId).id,a=n.dataIdMap.get(s.dataId).id,i=n.makeOutput(r.shape,"float32"),l=n.dataIdMap.get(i.dataId).id;return tU(o,a,l),i}var xOe={kernelName:bf,backendName:"wasm",setupFunc:mOe,kernelFunc:gOe},nU;function yOe(e){nU=e.wasm.cwrap(qg,null,["number","number","number","number"])}function bOe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:o}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,l=i,u=a,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:f}=op(a,s,t),h=p;if(f){let b=t.dataIdMap.get(c.dataId).id;b!==i&&(u=c,l=b,h=G.getInnerMostAxes(h.length,u.shape.length))}G.assertAxesAreInnerMostDims("prod",h,u.shape.length);let[m,g]=G.computeOutAndReduceShapes(u.shape,h),x=E.sizeFromShape(g),y=t.makeOutput(m,u.dtype);if(E.sizeFromShape(u.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;nU(l,x,ko[y.dtype],b)}if(f&&t.disposeData(c.dataId),o){let b=G.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var AOe={kernelName:qg,backendName:"wasm",setupFunc:yOe,kernelFunc:bOe},vOe=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:o,dtype:a}=n,i=dR(r,s,o,a),l=t.makeOutput([i.length],a);return t.typedArrayFromHeap(l).set(i),l},wOe={kernelName:H1,backendName:"wasm",kernelFunc:vOe},kOe=!0,IOe=qs(Yd,kOe),COe=Is(Af),SOe=Is(wf),rU;function NOe(e){rU=e.wasm.cwrap(vf,null,["number","number","number","number","number","number","number","number","number","number"])}function TOe(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:o,halfPixelCenters:a,size:i}=r,[l,u]=i,[c,p,d,f]=s.shape,h=[c,l,u,f],m=t.dataIdMap.get(s.dataId),g;m.dtype!=="float32"&&(g=H5({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let x=m.id,y=t.makeOutput(h,"float32");if(E.sizeFromShape(s.shape)===0)return y;let b=t.dataIdMap.get(y.dataId).id;return rU(x,c,p,d,f,l,u,o?1:0,a?1:0,b),g!=null&&t.disposeData(g.dataId),y}var _Oe={kernelName:vf,backendName:"wasm",setupFunc:NOe,kernelFunc:TOe},sU;function EOe(e){sU=e.wasm.cwrap(kf,null,["number","array","number","array","number","number"])}function ROe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:o}=r,a=E.parseAxisParam(o,s.shape);if(s.shape.length===0)return j5({inputs:{x:s},backend:n});let i=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(a).buffer),p=new Uint8Array(new Int32Array(s.shape).buffer);sU(l,c,a.length,p,s.shape.length,u);let d=Io({inputs:{x:i},attrs:{shape:s.shape},backend:n});return n.disposeData(i.dataId),d}var DOe={kernelName:kf,backendName:"wasm",kernelFunc:ROe,setupFunc:EOe},oU;function $Oe(e){oU=e.wasm.cwrap(c0,null,["number","number","number","number","number","number","number","number","array","number","number"])}function FOe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{radians:o,fillValue:a,center:i}=r,l=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(l.dataId).id,[p,d,f,h]=s.shape,[m,g]=G.getImageCenter(i,d,f),x=a===0,y=255,b=typeof a=="number"?[a,a,a,x?0:y]:[...a,y],A=new Uint8Array(new Int32Array(b).buffer);return oU(u,p,d,f,h,o,m,g,A,b.length,c),l}var OOe={kernelName:c0,backendName:"wasm",kernelFunc:FOe,setupFunc:$Oe},POe=Is(If),MOe=Is(Cf),aU;function zOe(e){aU=e.wasm.cwrap(Zg,null,["number","number","number","number","number","number","array","number","number"])}function LOe(e){let{backend:t,inputs:n,attrs:r}=e,{indices:s,updates:o}=n,{shape:a}=r,i=t.makeOutput(a,o.dtype);if(E.sizeFromShape(a)===0)return i;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:d}=t_.calculateShapes(o,s,a),h=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(o.dataId).id,x=new Uint8Array(new Int32Array(p).buffer),y=t.dataIdMap.get(i.dataId).id;return aU(h,g,ko[o.dtype],l,u,c,x,d,y),i}var BOe={kernelName:Zg,backendName:"wasm",setupFunc:zOe,kernelFunc:LOe},iU;function VOe(e){iU=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function WOe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:o}=t,a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,l=n.dataIdMap.get(o.dataId).id,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(u.dataId).id,p=r.shape.length,d=s.shape.length,f=p===0||p>1||d===1?1:E.sizeFromShape(s.shape.slice(1));return iU(a,i,l,f,c),u}var GOe={kernelName:Yg,backendName:"wasm",kernelFunc:WOe,setupFunc:VOe},lU;function UOe(e){lU=e.wasm.cwrap(Nf,null,["number","number"])}function jOe(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),o=t.dataIdMap.get(s.dataId).id;return E.sizeFromShape(s.shape)===0||lU(r,o),s}var HOe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:UOe,kernelFunc:jOe},qOe=Is(Sf),uU;function KOe(e){uU=e.wasm.cwrap(Ef,null,["number","number","number","number"])}function XOe(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,s=t.dataIdMap.get(n.dataId).id,o=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(o.dataId).id,i=n.shape[r],l=E.sizeFromShape(n.shape)/i;return E.sizeFromShape(o.shape)===0||uU(s,a,i,l),o}var ZOe={kernelName:Ef,backendName:"wasm",setupFunc:KOe,kernelFunc:XOe};function YOe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,paddings:a}=r,i=E.sizeFromShape(o),l=[[0,0]];l.push(...a);for(let w=1+o.length;w<s.shape.length;++w)l.push([0,0]);let u=eU.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=G.getReshaped(u.shape,o,i,!1),p=G.getPermuted(c.length,o.length,!1),d=G.getReshapedPermuted(u.shape,o,i,!1),m=Io({inputs:{x:u},backend:n,attrs:{shape:c}}),y=nx({inputs:{x:m},backend:n,attrs:{perm:p}}),v=Io({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeData(u.dataId),n.disposeData(m.dataId),n.disposeData(y.dataId),v}var JOe={kernelName:r0,backendName:"wasm",kernelFunc:YOe};function QOe(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{numOrSizeSplits:o,axis:a}=n,i=E.parseAxisParam(a,s.shape)[0],l=G.prepareSplitSize(s,o,i),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(p=>{let d=[...c];d[i]=p;let f=lA({inputs:{x:s},attrs:{begin:u,size:d},backend:r});return u[i]+=p,f})}var ePe={kernelName:s0,backendName:"wasm",kernelFunc:QOe},tPe=Is(Tf),nPe=Is(K1),rPe=!0,sPe=qs(Rf,rPe),cU;function oPe(e){cU=e.wasm.cwrap(Pc,null,["number","number","number"])}function aPe(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:s}=r,{x:o}=n,a=t.dataIdMap.get(o.dataId).id,i=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(i.dataId).id;return cU(a,s,l),i}var iPe={kernelName:Pc,backendName:"wasm",setupFunc:oPe,kernelFunc:aPe},pU;function lPe(e){pU=e.wasm.cwrap(o0,null,["number","array","number","array","array","array","array","array","number","number"])}function uPe(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{begin:o,end:a,strides:i}=r;i==null&&(i=new Array(o.length));let{beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=r,f=G.slice_util.maskToAxes(c);if(f.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(c!==0&&p!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(c!==0&&d!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let h=s.shape.length-o.length,m=G.slice_util.maskToAxes(p),g=s.shape.slice();m.forEach(_=>{o[_]=0,a[_]=1,g.splice(_,0,1)});let x=Io({inputs:{x:s},attrs:{shape:g},backend:t}),{begin:y,end:b,strides:A}=G.slice_util.getNormalizedAxes(x.shape,f,h,o,a,i,l,u,c);o=y,a=b,i=A;let v=G.slice_util.maskToAxes(d);v.forEach(_=>{a[_]=o[_]+1,i[_]=1});let w=G.slice_util.computeOutShape(o,a,i),k=w.filter((_,R)=>v.indexOf(R)===-1);if(i.every(_=>_===1)){let _=lA({inputs:{x},attrs:{begin:o,size:w},backend:t});t.disposeData(x.dataId);let R=Io({inputs:{x:_},attrs:{shape:k},backend:t});return t.disposeData(_.dataId),R}let N=t.makeOutput(k,"float32");if(!k.some(_=>_===0)){let _=t.dataIdMap.get(x.dataId).id,R=new Uint8Array(new Int32Array(E.computeStrides(x.shape)).buffer),S=new Uint8Array(new Int32Array(o).buffer),F=new Uint8Array(new Int32Array(a).buffer),B=new Uint8Array(new Int32Array(i).buffer),W=new Uint8Array(new Int32Array(k).buffer),q=new Uint8Array(new Int32Array(E.computeStrides(k)).buffer),K=t.dataIdMap.get(N.dataId).id;pU(_,R,x.shape.length,S,F,B,W,q,k.length,K)}t.disposeData(x.dataId);let T=Io({inputs:{x:N},attrs:{shape:k},backend:t});return t.disposeData(N.dataId),T}var cPe={kernelName:o0,backendName:"wasm",setupFunc:lPe,kernelFunc:uPe},pPe=!0,dPe=qs(Df,pPe),dU;function fPe(e){dU=e.wasm.cwrap(_f,null,["number, number, number"])}function hPe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:o}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,l=i,u=a,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:f}=op(a,s,t),h=p;if(f){let b=t.dataIdMap.get(c.dataId).id;b!==i&&(u=c,l=b,h=G.getInnerMostAxes(h.length,u.shape.length))}G.assertAxesAreInnerMostDims("sum",h,u.shape.length);let[m,g]=G.computeOutAndReduceShapes(u.shape,h),x=E.sizeFromShape(g),y=t.makeOutput(m,u.dtype);if(E.sizeFromShape(u.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;dU(l,x,b)}if(f&&t.disposeData(c.dataId),o){let b=G.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var mPe={kernelName:_f,backendName:"wasm",setupFunc:fPe,kernelFunc:hPe},gPe=Is($f),xPe=Is(Ff),fU;function yPe(e){fU=e.wasm.cwrap(Oc,null,["number","array","number","array","number","number"])}function bPe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,o=n.dataIdMap.get(s.dataId).id,{reps:a}=r,i=new Array(s.shape.length);for(let d=0;d<i.length;d++)i[d]=s.shape[d]*a[d];let l=new Uint8Array(new Int32Array(s.shape).buffer),u=new Uint8Array(new Int32Array(i).buffer),c=n.makeOutput(i,s.dtype),p=n.dataIdMap.get(c.dataId).id;return fU(o,l,s.shape.length,u,i.length,ko[c.dtype],p),c}var APe={kernelName:Oc,backendName:"wasm",setupFunc:yPe,kernelFunc:bPe},hU;function vPe(e){hU=e.wasm.cwrap(a0,null,["number","array","number","number","number","bool","number","number"])}var wPe=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:s,sorted:o}=n,a=t.dataIdMap.get(r.dataId).id,i=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=s;let u=t.makeOutput(l,r.dtype),c=t.dataIdMap.get(u.dataId).id,p=t.makeOutput(l,"int32"),d=t.dataIdMap.get(p.dataId).id;return hU(a,i,r.shape.length,ko[r.dtype],s,o,c,d),[u,p]},kPe={kernelName:a0,backendName:"wasm",setupFunc:vPe,kernelFunc:wPe},mU;function IPe(e){mU=e.wasm.cwrap(i0,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function CPe(e){let{backend:t,inputs:n,attrs:r}=e,{image:s,transforms:o}=n,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=r,[c,p,d,f]=s.shape,[h,m]=u!=null?u:[p,d],g=[c,h,m,f],x=new Uint8Array(new Int32Array(E.computeStrides(s.shape)).buffer),y=t.makeOutput(g,s.dtype),b=t.dataIdMap.get(y.dataId).id,v=t.dataIdMap.get(s.dataId).id,k=t.dataIdMap.get(o.dataId).id,I=a==="nearest"?1:2,N;switch(i){case"constant":N=1;break;case"reflect":N=2;break;case"wrap":N=3;break;case"nearest":N=4;break;default:N=1;break}return mU(v,k,o.shape[0]>1,c,h,m,f,d,p,x,s.shape.length-1,I,N,l,b),y}var SPe={kernelName:i0,backendName:"wasm",setupFunc:IPe,kernelFunc:CPe};function NPe(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:o}=r;o<0&&(o+=s.shape.length);let a=s.shape[o],i=s.shape.length,l=new Array(i-1),u=0;for(let f=0;f<i;f++)f!==o&&(l[u++]=s.shape[f]);let c=new Array(a),p=new Array(i).fill(0),d=s.shape.slice();d[o]=1;for(let f=0;f<c.length;f++)p[o]=f,c[f]=lA({inputs:{x:s},attrs:{begin:p,size:d},backend:n});return c.map(({dataId:f,dtype:h})=>({dataId:f,dtype:h,shape:l}))}var TPe={kernelName:l0,backendName:"wasm",kernelFunc:NPe};function _Pe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var EPe={kernelName:u0,backendName:"wasm",kernelFunc:_Pe},RPe=[$6e,O6e,z6e,H6e,X6e,J6e,tFe,oFe,pFe,dFe,fFe,gFe,xFe,AFe,kFe,IFe,CFe,TFe,RFe,FFe,MFe,zFe,BFe,VFe,WFe,GFe,HFe,qFe,XFe,D6e,JFe,t8e,s8e,i8e,c8e,d8e,h8e,L6e,x8e,b8e,v8e,w8e,I8e,N8e,_8e,D8e,O8e,z8e,B8e,G8e,j8e,H8e,X8e,J8e,tOe,rOe,aOe,lOe,cOe,eU,hOe,xOe,AOe,wOe,IOe,COe,SOe,nFe,_Oe,DOe,OOe,MOe,POe,BOe,GOe,HOe,qOe,uFe,ZOe,JOe,ePe,tPe,nPe,sPe,iPe,cPe,dPe,mPe,gPe,xPe,APe,kPe,SPe,G6e,TPe,EPe];for(let e of RPe)Mc(e);var jR=be();jR.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));jR.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(jR.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}});var gU=Pd($le()),DPe='var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}',$Pe=Pd(Fle()),xU=class extends $1{constructor(e){super();this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.init(),this.dataIdMap=new Xv(this,zo())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=E.now();return e(),{kernelMs:E.now()-t}}move(e,t,n,r,s){let o=this.dataIdNextNumber++;if(r==="string"){let u=t;this.dataIdMap.set(e,{id:o,stringBytes:u,shape:n,dtype:r,memoryOffset:null,refCount:s});return}let a=E.sizeFromShape(n),i=a*E.bytesPerElement(r),l=this.wasm._malloc(i);this.dataIdMap.set(e,{id:o,memoryOffset:l,shape:n,dtype:r,refCount:s}),this.wasm.tfjs.registerTensor(o,a,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,i),l)}async read(e){return this.readSync(e)}readSync(e){let{memoryOffset:t,dtype:n,shape:r,stringBytes:s}=this.dataIdMap.get(e);if(n==="string")return s;let o=this.wasm.HEAPU8.slice(t,t+E.sizeFromShape(r)*E.bytesPerElement(n));return PPe(o.buffer,n)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let r;if(n==null)r=this.write(null,e,t);else{let s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let o=E.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,o,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),o=E.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,s,o);case"int32":return new Int32Array(r,s,o);case"bool":return new Uint8Array(r,s,o);default:throw new Error(`Unknown dtype ${t}`)}}};function FPe(e){return(t,n)=>(E.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(s=>{WebAssembly.instantiate(s,t).then(o=>{n(o.instance,o.module)})})}),{})}function yU(e,t,n){if(q5!=null)return q5;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),cA!=null&&cA[r]!=null?cA[r]:n+r}async function OPe(){let[e,t]=await Promise.all([be().getAsync("WASM_HAS_SIMD_SUPPORT"),be().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let s={};s.locateFile=(i,l)=>{if(i.endsWith(".worker.js")){let u=DPe,c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return i.endsWith(".wasm")?yU(e,t,uA!=null?uA:l):l+i},HR&&(s.instantiateWasm=FPe(yU(e,t,uA!=null?uA:"")));let o=!1;s.onAbort=()=>{if(o||pA)return;pA=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let a;t&&e&&q5==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+gU.default.toString()],{type:"text/javascript"}),a=(0,gU.default)(s)):a=(0,$Pe.default)(s),a.then(i=>{o=!0,pA=!1;let l=null;i.tfjs={init:i.cwrap("init",null,[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",l,["number"]),dispose:i.cwrap("dispose",l,[])},n({wasm:i})})})}function PPe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var MPe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],q5=null,uA=null,cA={},pA=!1,HR=!1;function zPe(e,t=!1){if(i_("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),pA)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");q5=e,HR=t}function bU(e,t=!1){if(pA)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")uA=e;else{cA=e;let n=MPe.filter(r=>cA[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}HR=t}var LPe="3.9.0",BPe=2;y0("wasm",async()=>{let{wasm:e}=await OPe();return new xU(e)},BPe);var VPe="3.9.0",WPe="3.9.0",GPe="3.9.0",UPe="3.9.0",jPe="3.9.0",HPe="3.9.0",qPe="3.9.0",KPe="3.9.0",XPe={tfjs:VPe,"tfjs-core":WPe,"tfjs-data":GPe,"tfjs-layers":UPe,"tfjs-converter":jPe,"tfjs-backend-cpu":HPe,"tfjs-backend-webgl":qPe,"tfjs-backend-wasm":KPe};var qR="2.3.0";function YPe(e,t,n){let r=function(i,l,u){let c=new RegExp("\\b"+l+" \\w+ (\\w+)","ig");i.replace(c,(p,d)=>(u[d]=0,p))},s=function(i,l){let u=e.createShader(l);if(e.shaderSource(u,i),e.compileShader(u),!e.getShaderParameter(u,e.COMPILE_STATUS))throw new Error("filter: gl compile failed",e.getShaderInfoLog(u));return u};this.uniform={},this.attribute={};let o=s(t,e.VERTEX_SHADER),a=s(n,e.FRAGMENT_SHADER);if(this.id=e.createProgram(),e.attachShader(this.id,o),e.attachShader(this.id,a),e.linkProgram(this.id),!e.getProgramParameter(this.id,e.LINK_STATUS))throw new Error("filter: gl link failed",e.getProgramInfoLog(this.id));e.useProgram(this.id),r(t,"attribute",this.attribute);for(let i in this.attribute)this.attribute[i]=e.getAttribLocation(this.id,i);r(t,"uniform",this.uniform),r(n,"uniform",this.uniform);for(let i in this.uniform)this.uniform[i]=e.getUniformLocation(this.id,i)}function AU(e){e||(e={});let t=0,n=null,r=!1,s=-1,o=[null,null],a=[],i=-1,l=-1,u=null,c=null,p={},d=e.canvas||document.createElement("canvas"),f={},h={INTERMEDIATE:1},m=d.getContext("webgl");if(!m)throw new Error("filter: context failed");this.addFilter=function(v){let w=Array.prototype.slice.call(arguments,1),k=p[v];a.push({func:k,args:w})},this.reset=function(){a=[]};let g=function(v,w){if(!(v===i&&w===l)){if(d.width=v,i=v,d.height=w,l=w,!u){let k=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,-1,1,0,0,1,-1,1,1,1,1,1,0]);u=m.createBuffer(),m.bindBuffer(m.ARRAY_BUFFER,u),m.bufferData(m.ARRAY_BUFFER,k,m.STATIC_DRAW),m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0)}m.viewport(0,0,i,l),o=[null,null]}},x=function(v,w){let k=m.createFramebuffer();m.bindFramebuffer(m.FRAMEBUFFER,k);let I=m.createRenderbuffer();m.bindRenderbuffer(m.RENDERBUFFER,I);let N=m.createTexture();return m.bindTexture(m.TEXTURE_2D,N),m.texImage2D(m.TEXTURE_2D,0,m.RGBA,v,w,0,m.RGBA,m.UNSIGNED_BYTE,null),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,m.LINEAR),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,m.LINEAR),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,N,0),m.bindTexture(m.TEXTURE_2D,null),m.bindFramebuffer(m.FRAMEBUFFER,null),{fbo:k,texture:N}},y=function(v){return o[v]=o[v]||x(i,l),o[v]},b=function(v=null){var N,T;let w=null,k=null,I=!1;t===0?w=n:w=(N=y(s))==null?void 0:N.texture,t++,r&&!(v&h.INTERMEDIATE)?(k=null,I=t%2==0):(s=(s+1)%2,k=(T=y(s))==null?void 0:T.fbo),m.bindTexture(m.TEXTURE_2D,w),m.bindFramebuffer(m.FRAMEBUFFER,k),m.uniform1f(c.uniform.flipY,I?-1:1),m.drawArrays(m.TRIANGLES,0,6)};this.apply=function(v){if(g(v.width,v.height),t=0,n||(n=m.createTexture()),m.bindTexture(m.TEXTURE_2D,n),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,m.NEAREST),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,m.NEAREST),m.texImage2D(m.TEXTURE_2D,0,m.RGBA,m.RGBA,m.UNSIGNED_BYTE,v),a.length===0)return b(),d;for(let w=0;w<a.length;w++){r=w===a.length-1;let k=a[w];k.func.apply(this,k.args||[])}return d};let A=function(v){if(f[v])return c=f[v],m.useProgram(c.id),c;let w={};w.VERTEX_IDENTITY=["precision highp float;","attribute vec2 pos;","attribute vec2 uv;","varying vec2 vUv;","uniform float flipY;","void main(void) {","vUv = uv;","gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);","}"].join(`
`),w.FRAGMENT_IDENTITY=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","void main(void) {","gl_FragColor = texture2D(texture, vUv);","}"].join(`
`),c=new YPe(m,w.VERTEX_IDENTITY,v);let k=Float32Array.BYTES_PER_ELEMENT,I=4*k;return m.enableVertexAttribArray(c.attribute.pos),m.vertexAttribPointer(c.attribute.pos,2,m.FLOAT,!1,I,0*k),m.enableVertexAttribArray(c.attribute.uv),m.vertexAttribPointer(c.attribute.uv,2,m.FLOAT,!1,I,2*k),f[v]=c,c};p.colorMatrix=function(v){let w=new Float32Array(v);w[4]/=255,w[9]/=255,w[14]/=255,w[19]/=255;let k=w[18]===1&&w[3]===0&&w[8]===0&&w[13]===0&&w[15]===0&&w[16]===0&&w[17]===0&&w[19]===0?p.colorMatrix.SHADER.WITHOUT_ALPHA:p.colorMatrix.SHADER.WITH_ALPHA,I=A(k);m.uniform1fv(I.uniform.m,w),b()},p.colorMatrix.SHADER={},p.colorMatrix.SHADER.WITH_ALPHA=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","uniform float m[20];","void main(void) {","vec4 c = texture2D(texture, vUv);","gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];","gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];","gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];","gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];","}"].join(`
`),p.colorMatrix.SHADER.WITHOUT_ALPHA=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","uniform float m[20];","void main(void) {","vec4 c = texture2D(texture, vUv);","gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];","gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];","gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];","gl_FragColor.a = c.a;","}"].join(`
`),p.brightness=function(v){let w=(v||0)+1;p.colorMatrix([w,0,0,0,0,0,w,0,0,0,0,0,w,0,0,0,0,0,1,0])},p.saturation=function(v){let w=(v||0)*2/3+1,k=(w-1)*-.5;p.colorMatrix([w,k,k,0,0,k,w,k,0,0,k,k,w,0,0,0,0,0,1,0])},p.desaturate=function(){p.saturation(-1)},p.contrast=function(v){let w=(v||0)+1,k=-128*(w-1);p.colorMatrix([w,0,0,0,k,0,w,0,0,k,0,0,w,0,k,0,0,0,1,0])},p.negative=function(){p.contrast(-2)},p.hue=function(v){v=(v||0)/180*Math.PI;let w=Math.cos(v),k=Math.sin(v),I=.213,N=.715,T=.072;p.colorMatrix([I+w*(1-I)+k*-I,N+w*-N+k*-N,T+w*-T+k*(1-T),0,0,I+w*-I+k*.143,N+w*(1-N)+k*.14,T+w*-T+k*-.283,0,0,I+w*-I+k*-(1-I),N+w*-N+k*N,T+w*(1-T)+k*T,0,0,0,0,0,1,0])},p.desaturateLuminance=function(){p.colorMatrix([.2764723,.929708,.0938197,0,-37.1,.2764723,.929708,.0938197,0,-37.1,.2764723,.929708,.0938197,0,-37.1,0,0,0,1,0])},p.sepia=function(){p.colorMatrix([.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0])},p.brownie=function(){p.colorMatrix([.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0])},p.vintagePinhole=function(){p.colorMatrix([.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0])},p.kodachrome=function(){p.colorMatrix([1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0])},p.technicolor=function(){p.colorMatrix([1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0])},p.polaroid=function(){p.colorMatrix([1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0])},p.shiftToBGR=function(){p.colorMatrix([0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0])},p.convolution=function(v){let w=new Float32Array(v),k=1/i,I=1/l,N=A(p.convolution.SHADER);m.uniform1fv(N.uniform.m,w),m.uniform2f(N.uniform.px,k,I),b()},p.convolution.SHADER=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","uniform vec2 px;","uniform float m[9];","void main(void) {","vec4 c11 = texture2D(texture, vUv - px);","vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y));","vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y));","vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) );","vec4 c22 = texture2D(texture, vUv);","vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) );","vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) );","vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) );","vec4 c33 = texture2D(texture, vUv + px );","gl_FragColor = ","c11 * m[0] + c12 * m[1] + c22 * m[2] +","c21 * m[3] + c22 * m[4] + c23 * m[5] +","c31 * m[6] + c32 * m[7] + c33 * m[8];","gl_FragColor.a = c22.a;","}"].join(`
`),p.detectEdges=function(){p.convolution.call(this,[0,1,0,1,-4,1,0,1,0])},p.sobelX=function(){p.convolution.call(this,[-1,0,1,-2,0,2,-1,0,1])},p.sobelY=function(){p.convolution.call(this,[-1,-2,-1,0,0,0,1,2,1])},p.sharpen=function(v){let w=v||1;p.convolution.call(this,[0,-1*w,0,-1*w,1+4*w,-1*w,0,-1*w,0])},p.emboss=function(v){let w=v||1;p.convolution.call(this,[-2*w,-1*w,0,-1*w,1,1*w,0,1*w,2*w])},p.blur=function(v){let w=v/7/i,k=v/7/l,I=A(p.blur.SHADER);m.uniform2f(I.uniform.px,0,k),b(h.INTERMEDIATE),m.uniform2f(I.uniform.px,w,0),b()},p.blur.SHADER=["precision highp float;","varying vec2 vUv;","uniform sampler2D texture;","uniform vec2 px;","void main(void) {","gl_FragColor = vec4(0.0);","gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;","gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;","gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;","gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;","gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;","gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;","gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;","gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;","gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;","gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;","gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;","gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;","gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;","gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;","gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;","}"].join(`
`),p.pixelate=function(v){let w=v/i,k=v/l,I=A(p.pixelate.SHADER);m.uniform2f(I.uniform.size,w,k),b()},p.pixelate.SHADER=["precision highp float;","varying vec2 vUv;","uniform vec2 size;","uniform sampler2D texture;","vec2 pixelate(vec2 coord, vec2 size) {","return floor( coord / size ) * size;","}","void main(void) {","gl_FragColor = vec4(0.0);","vec2 coord = pixelate(vUv, size);","gl_FragColor += texture2D(texture, coord);","}"].join(`
`)}var Ee={browser:void 0,node:void 0,worker:void 0,platform:void 0,agent:void 0,initial:!0,backends:[],offscreen:void 0,tfjs:{version:void 0},wasm:{supported:void 0,backend:void 0,simd:void 0,multithread:void 0},webgl:{supported:void 0,backend:void 0,version:void 0,renderer:void 0},webgpu:{supported:void 0,backend:void 0,adapter:void 0},kernels:[],Canvas:void 0,Image:void 0,ImageData:void 0};async function JPe(){var n;Ee.backends=Object.keys(zo().registryFactory),Ee.wasm.supported=typeof WebAssembly!="undefined",Ee.wasm.backend=Ee.backends.includes("wasm"),Ee.wasm.supported&&Ee.wasm.backend&&gi()==="wasm"&&(Ee.wasm.simd=await be().getAsync("WASM_HAS_SIMD_SUPPORT"),Ee.wasm.multithread=await be().getAsync("WASM_HAS_MULTITHREAD_SUPPORT"));let e=Zo(100,100),t=e?e.getContext("webgl2"):void 0;if(Ee.webgl.supported=typeof t!="undefined",Ee.webgl.backend=Ee.backends.includes("webgl"),Ee.webgl.supported&&Ee.webgl.backend&&(gi()==="webgl"||gi()==="humangl")){let r=sl().gpgpu!=="undefined"?await sl().getGPGPUContext().gl:null;r&&(Ee.webgl.version=r.getParameter(r.VERSION),Ee.webgl.renderer=r.getParameter(r.RENDERER))}Ee.webgpu.supported=Ee.browser&&typeof navigator.gpu!="undefined",Ee.webgpu.backend=Ee.backends.includes("webgpu"),Ee.webgpu.supported&&(Ee.webgpu.adapter=(n=await navigator.gpu.requestAdapter())==null?void 0:n.name),Ee.kernels=zl(gi()).map(r=>r.kernelName.toLowerCase())}async function K5(){if(Ee.browser=typeof navigator!="undefined",Ee.node=typeof process!="undefined",Ee.worker=Ee.browser?typeof WorkerGlobalScope!="undefined":void 0,Ee.tfjs.version=qw,Ee.offscreen=typeof Ee.offscreen=="undefined"?typeof OffscreenCanvas!="undefined":Ee.offscreen,typeof navigator!="undefined"){let e=navigator.userAgent.match(/\(([^()]+)\)/g);if(e&&e[0]){let t=e[0].match(/\(([^()]+)\)/g);Ee.platform=t&&t[0]?t[0].replace(/\(|\)/g,""):"",Ee.agent=navigator.userAgent.replace(e[0],""),Ee.platform[1]&&(Ee.agent=Ee.agent.replace(e[1],"")),Ee.agent=Ee.agent.replace(/  /g," ")}}else typeof process!="undefined"&&(Ee.platform=`${process.platform} ${process.arch}`,Ee.agent=`NodeJS ${process.version}`);await JPe()}async function vU(e){Ee=os(Ee,e)}var X5=2048,wt,rr,$r;function Zo(e,t){let n;return Ee.browser?Ee.offscreen?n=new OffscreenCanvas(e,t):(n=document.createElement("canvas"),n.width=e,n.height=t):typeof Ee.Canvas!="undefined"?n=new Ee.Canvas(e,t):typeof globalThis.Canvas!="undefined"&&(n=new globalThis.Canvas(e,t)),n}function rx(e,t){let n;if(!e)return t.debug&&Ce("input is missing"),{tensor:null,canvas:null};if(!(e instanceof Vt)&&!(typeof Image!="undefined"&&e instanceof Image)&&!(typeof Ee.Canvas!="undefined"&&e instanceof Ee.Canvas)&&!(typeof globalThis.Canvas!="undefined"&&e instanceof globalThis.Canvas)&&!(typeof ImageData!="undefined"&&e instanceof ImageData)&&!(typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap)&&!(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement)&&!(typeof HTMLMediaElement!="undefined"&&e instanceof HTMLMediaElement)&&!(typeof HTMLVideoElement!="undefined"&&e instanceof HTMLVideoElement)&&!(typeof HTMLCanvasElement!="undefined"&&e instanceof HTMLCanvasElement)&&!(typeof OffscreenCanvas!="undefined"&&e instanceof OffscreenCanvas))throw new Error("input type is not recognized");if(e instanceof Vt){if(e.isDisposedInternal)throw new Error("input tensor is disposed");if(e.shape&&e.shape.length===4&&e.shape[0]===1&&e.shape[3]===3)n=mi(e);else throw new Error(`input tensor shape must be [1, height, width, 3] and instead was ${e.shape}`)}else{if(typeof e.readyState!="undefined"&&e.readyState<=2)return t.debug&&Ce("input stream is not ready"),{tensor:null,canvas:wt};let r=e.naturalWidth||e.videoWidth||e.width||e.shape&&e.shape[1]>0,s=e.naturalHeight||e.videoHeight||e.height||e.shape&&e.shape[2]>0;if(!r||!s)return t.debug&&Ce("cannot determine input dimensions"),{tensor:null,canvas:wt};let o=r,a=s;if(o>X5&&(o=X5,a=Math.trunc(o*s/r)),a>X5&&(a=X5,o=Math.trunc(a*r/s)),(t.filter.width||0)>0?o=t.filter.width:(t.filter.height||0)>0&&(o=r*((t.filter.height||0)/s)),(t.filter.height||0)>0?a=t.filter.height:(t.filter.width||0)>0&&(a=s*((t.filter.width||0)/r)),!o||!a)throw new Error("input cannot determine dimension");(!wt||(wt==null?void 0:wt.width)!==o||(wt==null?void 0:wt.height)!==a)&&(wt=Zo(o,a));let i=wt.getContext("2d");if(typeof ImageData!="undefined"&&e instanceof ImageData?i.putImageData(e,0,0):t.filter.flip&&typeof i.translate!="undefined"?(i.translate(r,0),i.scale(-1,1),i.drawImage(e,0,0,r,s,0,0,wt==null?void 0:wt.width,wt==null?void 0:wt.height),i.setTransform(1,0,0,1,0,0)):i.drawImage(e,0,0,r,s,0,0,wt==null?void 0:wt.width,wt==null?void 0:wt.height),t.filter.enabled&&Ee.webgl.supported){if((!$r||!rr||wt.width!==rr.width||(wt==null?void 0:wt.height)!==(rr==null?void 0:rr.height))&&(rr=Zo(wt==null?void 0:wt.width,wt==null?void 0:wt.height),(rr==null?void 0:rr.width)!==(wt==null?void 0:wt.width)&&(rr.width=wt==null?void 0:wt.width),(rr==null?void 0:rr.height)!==(wt==null?void 0:wt.height)&&(rr.height=wt==null?void 0:wt.height),$r=Ee.browser?new AU({canvas:rr}):null),!$r)return{tensor:null,canvas:wt};$r.reset(),$r.addFilter("brightness",t.filter.brightness),t.filter.contrast!==0&&$r.addFilter("contrast",t.filter.contrast),t.filter.sharpness!==0&&$r.addFilter("sharpen",t.filter.sharpness),t.filter.blur!==0&&$r.addFilter("blur",t.filter.blur),t.filter.saturation!==0&&$r.addFilter("saturation",t.filter.saturation),t.filter.hue!==0&&$r.addFilter("hue",t.filter.hue),t.filter.negative&&$r.addFilter("negative"),t.filter.sepia&&$r.addFilter("sepia"),t.filter.vintage&&$r.addFilter("brownie"),t.filter.sepia&&$r.addFilter("sepia"),t.filter.kodachrome&&$r.addFilter("kodachrome"),t.filter.technicolor&&$r.addFilter("technicolor"),t.filter.polaroid&&$r.addFilter("polaroid"),t.filter.pixelate!==0&&$r.addFilter("pixelate",t.filter.pixelate),$r.apply(wt)}else rr=wt,$r&&($r=null);if(!n){let l;if(rr.data){let u=[rr.height,rr.width,3];l=jw(rr.data,u,"float32")}else if(typeof ImageData!="undefined"&&rr instanceof ImageData)l=Mo?Mo.fromPixels(rr):null;else if(t.backend==="webgl"||t.backend==="humangl"){let u=Zo(o,a);u.width=o,u.height=a;let c=u.getContext("2d");c==null||c.drawImage(rr,0,0),console.log("PIXELS",u),l=Mo&&Ee.browser?Mo.fromPixels(u):null;try{l=Mo&&Ee.browser?Mo.fromPixels(u):null}catch(p){throw new Error("browser webgl error")}}else{let u=Zo(o,a);if(!u)return{tensor:null,canvas:wt};u.width=o,u.height=a;let c=u.getContext("2d");if(!c)return{tensor:null,canvas:wt};c.drawImage(rr,0,0);let p=c.getImageData(0,0,o,a);Mo&&Ee.browser?l=Mo.fromPixels(p):l=ce(()=>{let d=ls(Array.from(p.data),[o,a,4]),f=_r(d,4,2),h=vs([f[0],f[1],f[2]],2);return ie(h,[d.shape[0],d.shape[1],3])})}if(l){let u=Fe(l,"float32");n=kr(u,0),ye(l),ye(u)}else throw n=xr([1,o,a,3]),new Error("cannot create tensor from input")}}return{tensor:n,canvas:t.filter.return?rr:null}}var KR=0,wU=1;async function kU(e,t){if(e.cacheSensitivity===0)return!1;let n=32;if(!t.shape[1]||!t.shape[2])return!1;let r=ht.resizeBilinear(t,[Math.trunc(t.shape[1]/n),Math.trunc(t.shape[2]/n)]),s=await r.data();ye(r);let o=0;for(let l=0;l<s.length/3;l++)o+=s[3*l+2];let a=100*(Math.max(o,KR)/Math.min(o,KR)-1);KR=o;let i=a<Math.max(e.cacheSensitivity,wU);return wU=a>10*e.cacheSensitivity?0:a,i}var gl={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]},XR={count:468,mouth:13,symmetryLine:[13,gl.midwayBetweenEyes[0]]},dA={leftEye:0,rightEye:1,nose:2,mouth:3,leftEar:4,rightEar:5,symmetryLine:[3,2]},ZR=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]}],fA=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]],Ah=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255];var QPe=[127,234,132,58,172,150,149,148,152,377,378,379,397,288,361,454,356,70,63,105,66,107,336,296,334,293,300,168,6,195,4,98,97,2,326,327,33,160,158,133,153,144,362,385,387,263,373,380,57,40,37,0,267,270,287,321,314,17,84,91,78,81,13,311,308,402,14,178],e9e=[33,133,362,263,1,62,308,159,145,386,374,6,102,331,2,13,14,70,105,107,336,334,300,54,10,284,50,280,234,454,58,288,152],t9e=[33,133,362,263,1,78,308],SQe=QPe.map(e=>fA[e]),NQe=e9e.map(e=>fA[e]),TQe=t9e.map(e=>fA[e]);var IU=e=>({startPoint:gt(e,[0,0],[-1,2]),endPoint:gt(e,[0,2],[-1,2])});var hA=e=>[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])],Z5=e=>[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2],YR=(e,t)=>e?[Math.trunc(Math.max(0,e.startPoint[0])),Math.trunc(Math.max(0,e.startPoint[1])),Math.trunc(Math.min(t.shape[2]||0,e.endPoint[0])-Math.max(0,e.startPoint[0])),Math.trunc(Math.min(t.shape[1]||0,e.endPoint[1])-Math.max(0,e.startPoint[1]))]:[0,0,0,0],JR=(e,t)=>e?[e.startPoint[0]/(t.shape[2]||0),e.startPoint[1]/(t.shape[1]||0),(e.endPoint[0]-e.startPoint[0])/(t.shape[2]||0),(e.endPoint[1]-e.startPoint[1])/(t.shape[1]||0)]:[0,0,0,0],CU=(e,t)=>{let n=[e.startPoint[0]*t[0],e.startPoint[1]*t[1]],r=[e.endPoint[0]*t[0],e.endPoint[1]*t[1]];return{startPoint:n,endPoint:r}},QR=(e,t,n)=>{let r=t.shape[1],s=t.shape[2];return ht.cropAndResize(t,[[e.startPoint[1]/r,e.startPoint[0]/s,e.endPoint[1]/r,e.endPoint[0]/s]],[0],n)},mA=(e,t=1.5)=>{let n=Z5(e),r=hA(e),s=[t*r[0]/2,t*r[1]/2];return{startPoint:[n[0]-s[0],n[1]-s[1]],endPoint:[n[0]+s[0],n[1]+s[1]],landmarks:e.landmarks}},gA=e=>{let t=Z5(e),n=hA(e),r=Math.max(...n)/2;return{startPoint:[Math.round(t[0]-r),Math.round(t[1]-r)],endPoint:[Math.round(t[0]+r),Math.round(t[1]+r)],landmarks:e.landmarks}},Y5=e=>{let t=e.map(r=>r[0]),n=e.map(r=>r[1]);return{startPoint:[Math.min(...t),Math.min(...n)],endPoint:[Math.max(...t),Math.max(...n)],landmarks:e}},J5=[[1,0,0],[0,1,0],[0,0,1]],n9e=e=>e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI)),r9e=(e,t)=>n9e(Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]));var SU=(e,t)=>[[1,0,e],[0,1,t],[0,0,1]],vh=(e,t)=>{let n=0;for(let r=0;r<e.length;r++)n+=e[r]*t[r];return n},s9e=(e,t)=>{let n=[];for(let r=0;r<e.length;r++)n.push(e[r][t]);return n},NU=(e,t)=>{let n=[],r=e.length;for(let s=0;s<r;s++){n.push([]);for(let o=0;o<r;o++)n[s].push(vh(e[s],s9e(t,o)))}return n},TU=(e,t)=>{let n=Math.cos(e),r=Math.sin(e),s=[[n,-r,0],[r,n,0],[0,0,1]],o=SU(t[0],t[1]),a=NU(o,s),i=SU(-t[0],-t[1]);return NU(a,i)},o9e=e=>{let t=[[e[0][0],e[1][0]],[e[0][1],e[1][1]]],n=[e[0][2],e[1][2]],r=[-vh(t[0],n),-vh(t[1],n)];return[t[0].concat(r[0]),t[1].concat(r[1]),[0,0,1]]},a9e=(e,t)=>[vh(e,t[0]),vh(e,t[1])];function _U(e){let t={strides:[e/16,e/8],anchors:[2,6]},n=[];for(let r=0;r<t.strides.length;r++){let s=t.strides[r],o=Math.floor((e+s-1)/s),a=Math.floor((e+s-1)/s),i=t.anchors[r];for(let l=0;l<o;l++){let u=s*(l+.5);for(let c=0;c<a;c++){let p=s*(c+.5);for(let d=0;d<i;d++)n.push([p,u])}}}return n}function EU(e,t,n,r,s){let o=hA({startPoint:t.startPoint,endPoint:t.endPoint}),a=e.map(p=>[o[0]/s*(p[0]-s/2),o[1]/s*(p[1]-s/2),p[2]||0]),i=n!==0?TU(n,[0,0]):J5,l=n!==0?a.map(p=>[...a9e(p,i),p[2]]):a,u=n!==0?o9e(r):J5,c=[...Z5({startPoint:t.startPoint,endPoint:t.endPoint}),1];return l.map(p=>[Math.round(p[0]+vh(c,u[0])),Math.round(p[1]+vh(c,u[1])),Math.round(p[2]||0)])}function e7(e,t,n){let[r,s]=e.landmarks.length>=XR.count?XR.symmetryLine:dA.symmetryLine,o=r9e(e.landmarks[r],e.landmarks[s]),a=Z5({startPoint:e.startPoint,endPoint:e.endPoint}),i=[a[0]/t.shape[2],a[1]/t.shape[1]],l=ht.rotateWithOffset(t,o,0,i),u=TU(-o,a),c=QR({startPoint:e.startPoint,endPoint:e.endPoint},l,[n,n]),p=Me(c,255);return ye(c),ye(l),[o,u,p]}var RU=6,ya,t7=[],DU=null,ba=0,xA=()=>ba;async function $U(e){var t;return Ee.initial&&(ya=null),ya?e.debug&&Ce("cached model:",ya.modelUrl):(ya=await yn(an(e.modelBasePath,((t=e.face.detector)==null?void 0:t.modelPath)||"")),!ya||!ya.modelUrl?Ce("load model failed:",e.body.modelPath):e.debug&&Ce("load model:",ya.modelUrl)),ba=ya.inputs[0].shape?ya.inputs[0].shape[2]:0,ba===-1&&(ba=64),t7=_U(ba),DU=bi(t7),ya}function i9e(e){let t=gt(e,[0,1],[-1,2]),n=Re(t,DU),r=gt(e,[0,3],[-1,2]),s=Me(r,ba),o=Me(n,ba),a=Me(s,2),i=Ge(o,a),l=Re(o,a),u=te(i,ba),c=te(l,ba);return v0([u,c],1)}async function FU(e,t){var u,c,p,d;if(!e||e.isDisposedInternal||e.shape.length!==4||e.shape[1]<1||e.shape[2]<1)return{boxes:[]};let[n,r,s]=ce(()=>{let f=ht.resizeBilinear(e,[ba,ba]),h=Ge(Me(f,127.5),.5),m=ya==null?void 0:ya.execute(h),g;if(Array.isArray(m)){let A=m.sort((I,N)=>I.size-N.size),v=En([A[0],A[2]],2),w=En([A[1],A[3]],2),k=En([w,v],1);g=ln(k,0)}else g=ln(m);let x=i9e(g),y=gt(g,[0,0],[-1,1]),b=ln(xo(y));return[g,x,b]}),o=await ht.nonMaxSuppressionAsync(r,s,((u=t.face.detector)==null?void 0:u.maxDetected)||0,((c=t.face.detector)==null?void 0:c.iouThreshold)||0,((p=t.face.detector)==null?void 0:p.minConfidence)||0),a=await o.array();ye(o);let i=[],l=await s.data();for(let f=0;f<a.length;f++){let h=l[a[f]];if(h>(((d=t.face.detector)==null?void 0:d.minConfidence)||0)){let m=gt(r,[a[f],0],[1,-1]),g=ce(()=>ie(ln(gt(n,[a[f],RU-1],[1,-1])),[RU,-1]));i.push({box:IU(m),landmarks:g,anchor:t7[a[f]],confidence:h}),ye(m)}}return ye(n),ye(r),ye(s),{boxes:i,scaleFactor:[e.shape[2]/ba,e.shape[1]/ba]}}var La,ap=0,l9e=2.3,n7=gl.leftEyeLower0,r7=gl.rightEyeLower0,sx={leftBounds:[n7[0],n7[n7.length-1]],rightBounds:[r7[0],r7[r7.length-1]]},ox={upperCenter:3,lowerCenter:4,index:71,numCoordinates:76};async function OU(e){var t;return Ee.initial&&(La=null),La?e.debug&&Ce("cached model:",La.modelUrl):(La=await yn(an(e.modelBasePath,((t=e.face.iris)==null?void 0:t.modelPath)||"")),!La||!La.modelUrl?Ce("load model failed:",e.body.modelPath):e.debug&&Ce("load model:",La.modelUrl)),ap=La.inputs[0].shape?La.inputs[0].shape[2]:0,ap===-1&&(ap=64),La}function Q5(e,t,n,r){for(let s=0;s<ZR.length;s++){let{key:o,indices:a}=ZR[s],i=gl[`${n}${o}`];if(!r||r.includes(o))for(let l=0;l<a.length;l++){let u=a[l];e[i[l]]=[t[u][0],t[u][1],(t[u][2]+e[i[l]][2])/2]}}}var u9e=e=>{let t=e[sx.leftBounds[0]][2],n=e[sx.rightBounds[0]][2];return t-n},PU=(e,t,n,r,s=!1,o)=>{let a=gA(mA(Y5([e[n],e[r]]),l9e)),i=hA(a),l=ht.cropAndResize(t,[[a.startPoint[1]/o,a.startPoint[0]/o,a.endPoint[1]/o,a.endPoint[0]/o]],[0],[ap,ap]);if(s&&Ee.kernels.includes("flipleftright")){let u=ht.flipLeftRight(l);ye(l),l=u}return{box:a,boxSize:i,crop:l}},MU=(e,t,n,r=!1)=>{let s=[];for(let o=0;o<ox.numCoordinates;o++){let a=e[o*3],i=e[o*3+1],l=e[o*3+2];s.push([(r?1-a/ap:a/ap)*n[0]+t.startPoint[0],i/ap*n[1]+t.startPoint[1],l])}return{rawCoords:s,iris:s.slice(ox.index)}},zU=(e,t,n)=>{let r=e[gl[`${n}EyeUpper0`][ox.upperCenter]][2],s=e[gl[`${n}EyeLower0`][ox.lowerCenter]][2],o=(r+s)/2;return t.map((a,i)=>{let l=o;return i===2?l=r:i===4&&(l=s),[a[0],a[1],l]})};async function LU(e,t,n,r){if(!La)return n.debug&&Ce("face mesh iris detection requested, but model is not loaded"),e;let{box:s,boxSize:o,crop:a}=PU(e,t,sx.leftBounds[0],sx.leftBounds[1],!0,r),{box:i,boxSize:l,crop:u}=PU(e,t,sx.rightBounds[0],sx.rightBounds[1],!0,r),c=En([a,u]);ye(a),ye(u);let p=La.predict(c);ye(c);let d=await p.data();ye(p);let f=d.slice(0,ox.numCoordinates*3),{rawCoords:h,iris:m}=MU(f,s,o,!0),g=d.slice(ox.numCoordinates*3),{rawCoords:x,iris:y}=MU(g,i,l),b=u9e(e);Math.abs(b)<30?(Q5(e,h,"left",null),Q5(e,x,"right",null)):b<1?Q5(e,h,"left",["EyeUpper0","EyeLower0"]):Q5(e,x,"right",["EyeUpper0","EyeLower0"]);let A=zU(e,m,"left"),v=zU(e,y,"right");return e.concat(A).concat(v)}var xl=[],Ba=null,_i=0,s7=Number.MAX_SAFE_INTEGER,BU=0;async function VU(e,t){var o,a,i,l,u,c,p,d,f,h,m,g;if(!t.skipFrame||(BU!==((o=t.face.detector)==null?void 0:o.maxDetected)||!((a=t.face.mesh)==null?void 0:a.enabled))&&s7>(((i=t.face.detector)==null?void 0:i.skipFrames)||0)){let x=await FU(e,t);xl=[];for(let y of x.boxes){let b=await y.box.startPoint.data(),A=await y.box.endPoint.data(),v=await y.landmarks.array();xl.push({startPoint:b,endPoint:A,landmarks:v,confidence:y.confidence})}x.boxes.forEach(y=>ye([y.box.startPoint,y.box.endPoint,y.landmarks]));for(let y=0;y<xl.length;y++){let b=CU({startPoint:xl[y].startPoint,endPoint:xl[y].endPoint},x.scaleFactor),A=mA(b),v=gA(A);xl[y]={...v,confidence:xl[y].confidence,landmarks:xl[y].landmarks}}s7=0}else s7++;let n=[],r=[],s=0;for(let x of xl){let y=0,b,A={id:s++,mesh:[],meshRaw:[],box:[0,0,0,0],boxRaw:[0,0,0,0],score:0,boxScore:0,faceScore:0,annotations:{}};if(((l=t.face.detector)==null?void 0:l.rotation)&&((u=t.face.mesh)==null?void 0:u.enabled)&&Ee.kernels.includes("rotatewithoffset"))[y,b,A.tensor]=e7(x,e,_i);else{b=J5;let v=QR({startPoint:x.startPoint,endPoint:x.endPoint},e,((c=t.face.mesh)==null?void 0:c.enabled)?[_i,_i]:[xA(),xA()]);A.tensor=Me(v,255),ye(v)}if(A.boxScore=Math.round(100*x.confidence)/100,(p=t.face.mesh)==null?void 0:p.enabled)if(!Ba)t.debug&&Ce("face mesh detection requested, but model is not loaded");else{let[v,w,k]=Ba.execute(A.tensor);ye(v);let I=(await w.data())[0];ye(w);let N=ie(k,[-1,3]),T=await N.array();if(ye(k),ye(N),I<(((d=t.face.detector)==null?void 0:d.minConfidence)||1))x.confidence=I;else{((f=t.face.iris)==null?void 0:f.enabled)&&(T=await LU(T,A.tensor,t,_i)),A.mesh=EU(T,x,y,b,_i),A.meshRaw=A.mesh.map(_=>[_[0]/(e.shape[2]||0),_[1]/(e.shape[1]||0),(_[2]||0)/_i]),x={...mA(Y5(A.mesh),1.5),confidence:x.confidence};for(let _ of Object.keys(gl))A.annotations[_]=gl[_].map(R=>A.mesh[R]);((h=t.face.detector)==null?void 0:h.rotation)&&t.face.mesh.enabled&&((m=t.face.description)==null?void 0:m.enabled)&&Ee.kernels.includes("rotatewithoffset")&&(ye(A.tensor),[y,b,A.tensor]=e7(x,e,_i)),A.box=YR(x,e),A.boxRaw=JR(x,e),A.score=Math.round(100*I||100*x.confidence||0)/100,A.faceScore=Math.round(100*I)/100,x={...gA(x),confidence:x.confidence,faceConfidence:I}}}else{A.box=YR(x,e),A.boxRaw=JR(x,e),A.score=Math.round(100*x.confidence||0)/100,A.mesh=x.landmarks.map(v=>[(x.startPoint[0]+x.endPoint[0])/2+(x.endPoint[0]+x.startPoint[0])*v[0]/xA(),(x.startPoint[1]+x.endPoint[1])/2+(x.endPoint[1]+x.startPoint[1])*v[1]/xA()]),A.meshRaw=A.mesh.map(v=>[v[0]/(e.shape[2]||0),v[1]/(e.shape[1]||0),(v[2]||0)/_i]);for(let v of Object.keys(dA))A.annotations[v]=[A.mesh[dA[v]]]}n.push(A),r.push(x)}return((g=t.face.mesh)==null?void 0:g.enabled)&&(xl=r.filter(x=>{var y;return x.confidence>(((y=t.face.detector)==null?void 0:y.minConfidence)||0)})),BU=n.length,n}async function WU(e){var t;return Ee.initial&&(Ba=null),Ba?e.debug&&Ce("cached model:",Ba.modelUrl):(Ba=await yn(an(e.modelBasePath,((t=e.face.mesh)==null?void 0:t.modelPath)||"")),!Ba||!Ba.modelUrl?Ce("load model failed:",e.body.modelPath):e.debug&&Ce("load model:",Ba.modelUrl)),_i=Ba.inputs[0].shape?Ba.inputs[0].shape[2]:0,_i===-1&&(_i=64),Ba}var GU=Ah,UU=fA;var Ks,e3=[],jU=0,o7=Number.MAX_SAFE_INTEGER;async function HU(e){var n,r;let t=an(e.modelBasePath,((n=e.face.description)==null?void 0:n.modelPath)||"");return Ee.initial&&(Ks=null),Ks?e.debug&&Ce("cached model:",t):(Ks=await yn(t),Ks?e.debug&&Ce("load model:",t):Ce("load model failed:",((r=e.face.description)==null?void 0:r.modelPath)||"")),Ks}function a7(e){return ce(()=>{let n=e.image||e.tensor||e;if(!(n instanceof Vt))return null;let r=[[.05,.15,.85,.85]];if(!(Ks==null?void 0:Ks.inputs[0].shape))return null;let s=n.shape.length===3?ht.cropAndResize(kr(n,0),r,[0],[Ks.inputs[0].shape[2],Ks.inputs[0].shape[1]]):ht.cropAndResize(n,r,[0],[Ks.inputs[0].shape[2],Ks.inputs[0].shape[1]]);return te(s,255)})}async function i7(e,t,n,r){var s,o,a;return Ks?o7<(((s=t.face.description)==null?void 0:s.skipFrames)||0)&&t.skipFrame&&jU===r&&((o=e3[n])==null?void 0:o.age)&&((a=e3[n])==null?void 0:a.age)>0?(o7++,e3[n]):(o7=0,new Promise(async i=>{var p,d;let l=a7(e),u,c={age:0,gender:"unknown",genderScore:0,descriptor:[]};if(((p=t.face.description)==null?void 0:p.enabled)&&(u=await(Ks==null?void 0:Ks.predict(l))),ye(l),u){let f=await u.find(A=>A.shape[1]===1).data(),h=Math.trunc(200*Math.abs(f[0]-.5))/100;h>(((d=t.face.description)==null?void 0:d.minConfidence)||0)&&(c.gender=f[0]<=.5?"female":"male",c.genderScore=Math.min(.99,h));let m=xi(u.find(A=>A.shape[1]===100),1),g=(await m.data())[0];ye(m);let x=await u.find(A=>A.shape[1]===100).data();c.age=Math.round(x[g-1]>x[g+1]?10*g-100*x[g-1]:10*g+100*x[g+1])/10;let b=await u.find(A=>A.shape[1]===1024).data();c.descriptor=[...b],u.forEach(A=>ye(A))}e3[n]=c,jU=r,i(c)})):null}var c9e=["angry","disgust","fear","happy","sad","surprise","neutral"],Xr,t3=[],qU=0,l7=Number.MAX_SAFE_INTEGER,u7=[.2989,.587,.114];async function KU(e){var t;return Ee.initial&&(Xr=null),Xr?e.debug&&Ce("cached model:",Xr.modelUrl):(Xr=await yn(an(e.modelBasePath,((t=e.face.emotion)==null?void 0:t.modelPath)||"")),!Xr||!Xr.modelUrl?Ce("load model failed:",e.body.modelPath):e.debug&&Ce("load model:",Xr.modelUrl)),Xr}async function c7(e,t,n,r){var s;return Xr?l7<(((s=t.face.emotion)==null?void 0:s.skipFrames)||0)&&t.skipFrame&&qU===r&&t3[n]&&t3[n].length>0?(l7++,t3[n]):(l7=0,new Promise(async o=>{var g,x;let a=ht.resizeBilinear(e,[(Xr==null?void 0:Xr.inputs[0].shape)?Xr.inputs[0].shape[2]:0,(Xr==null?void 0:Xr.inputs[0].shape)?Xr.inputs[0].shape[1]:0],!1),[i,l,u]=_r(a,3,3);ye(a);let c=te(i,u7[0]),p=te(l,u7[1]),d=te(u,u7[2]);ye(i),ye(l),ye(u);let f=Yw([c,p,d]);ye(c),ye(p),ye(d);let h=ce(()=>te(Ge(f,.5),2));ye(f);let m=[];if((g=t.face.emotion)==null?void 0:g.enabled){let y=await(Xr==null?void 0:Xr.predict(h)),b=await y.data();ye(y);for(let A=0;A<b.length;A++)b[A]>(((x=t.face.emotion)==null?void 0:x.minConfidence)||0)&&m.push({score:Math.min(.99,Math.trunc(100*b[A])/100),emotion:c9e[A]});m.sort((A,v)=>v.score-A.score)}ye(h),t3[n]=m,qU=r,o(m)})):null}var yA=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],p9e=yA.length,bA=yA.reduce((e,t,n)=>(e[t]=n,e),{}),d9e=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]],aet=d9e.map(([e,t])=>[bA[e],bA[t]]),XU=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]];function ZU(e){let t=e.reduce(({maxX:n,maxY:r,minX:s,minY:o},{position:{x:a,y:i}})=>({maxX:Math.max(n,a),maxY:Math.max(r,i),minX:Math.min(s,a),minY:Math.min(o,i)}),{maxX:Number.NEGATIVE_INFINITY,maxY:Number.NEGATIVE_INFINITY,minX:Number.POSITIVE_INFINITY,minY:Number.POSITIVE_INFINITY});return[t.minX,t.minY,t.maxX-t.minX,t.maxY-t.minY]}function YU(e,[t,n],[r,s]){let o=t/r,a=n/s,i=(u,c)=>({id:c,score:u.score,boxRaw:[u.box[0]/s,u.box[1]/r,u.box[2]/s,u.box[3]/r],box:[Math.trunc(u.box[0]*a),Math.trunc(u.box[1]*o),Math.trunc(u.box[2]*a),Math.trunc(u.box[3]*o)],keypoints:u.keypoints.map(({score:p,part:d,position:f})=>({score:p,part:d,position:[Math.trunc(f.x*a),Math.trunc(f.y*o)],positionRaw:[f.x/r,f.y/r]}))});return e.map((u,c)=>i(u,c))}var p7=class{constructor(t,n){nt(this,"priorityQueue");nt(this,"numberOfElements");nt(this,"getElementValue");this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=n}enqueue(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)}dequeue(){let t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t}empty(){return this.numberOfElements===-1}size(){return this.numberOfElements+1}all(){return this.priorityQueue.slice(0,this.numberOfElements+1)}max(){return this.priorityQueue[0]}swim(t){for(;t>0&&this.less(Math.floor(t/2),t);)this.exchange(t,Math.floor(t/2)),t=Math.floor(t/2)}sink(t){for(;2*t<=this.numberOfElements;){let n=2*t;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(t,n))break;this.exchange(t,n),t=n}}getValueAt(t){return this.getElementValue(this.priorityQueue[t])}less(t,n){return this.getValueAt(t)<this.getValueAt(n)}exchange(t,n){let r=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[n],this.priorityQueue[n]=r}};function d7(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+p9e)}}function f7(e,t,n){let{heatmapY:r,heatmapX:s,id:o}=e,{y:a,x:i}=d7(r,s,o,n);return{x:e.heatmapX*t+i,y:e.heatmapY*t+a}}function h7(e,t,n){return e<t?t:e>n?n:e}function JU(e,t,n,r){let s=n-e,o=r-t;return s*s+o*o}function m7(e,t){return{x:e.x+t.x,y:e.y+t.y}}var Yo,f9e=["MobilenetV1/offset_2/BiasAdd","MobilenetV1/heatmap_2/BiasAdd","MobilenetV1/displacement_fwd_2/BiasAdd","MobilenetV1/displacement_bwd_2/BiasAdd"],n3=1,ax=16,h9e=50**2;function QU(e,t,n,r,s,o,a=2){let i=x=>({y:o.get(x.y,x.x,e),x:o.get(x.y,x.x,o.shape[2]/2+e)}),l=(x,y,b)=>({y:h7(Math.round(x.y/ax),0,y-1),x:h7(Math.round(x.x/ax),0,b-1)}),[u,c]=r.shape,p=l(t.position,u,c),d=i(p),h=m7(t.position,d);for(let x=0;x<a;x++){let y=l(h,u,c),b=d7(y.y,y.x,n,s);h=m7({x:y.x*ax,y:y.y*ax},{x:b.x,y:b.y})}let m=l(h,u,c),g=r.get(m.y,m.x,n);return{position:h,part:yA[n],score:g}}function m9e(e,t,n,r,s){let o=XU.map(([d,f])=>[bA[d],bA[f]]),a=o.map(([,d])=>d),i=o.map(([d])=>d),l=t.shape[2],u=a.length,c=new Array(l),p=f7(e.part,ax,n);c[e.part.id]={score:e.score,part:yA[e.part.id],position:p};for(let d=u-1;d>=0;--d){let f=a[d],h=i[d];c[f]&&!c[h]&&(c[h]=QU(d,c[f],h,t,n,s))}for(let d=0;d<u;++d){let f=i[d],h=a[d];c[f]&&!c[h]&&(c[h]=QU(d,c[f],h,t,n,r))}return c}function g9e(e,t,n,r,s){let[o,a]=s.shape,i=!0,l=Math.max(n-n3,0),u=Math.min(n+n3+1,o);for(let c=l;c<u;++c){let p=Math.max(r-n3,0),d=Math.min(r+n3+1,a);for(let f=p;f<d;++f)if(s.get(c,f,e)>t){i=!1;break}if(!i)break}return i}function x9e(e,t){let[n,r,s]=t.shape,o=new p7(n*r*s,({score:a})=>a);for(let a=0;a<n;++a)for(let i=0;i<r;++i)for(let l=0;l<s;++l){let u=t.get(a,i,l);u<e||g9e(l,u,a,i,t)&&o.enqueue({score:u,part:{heatmapY:a,heatmapX:i,id:l}})}return o}function ej(e,{x:t,y:n},r){return e.some(({keypoints:s})=>{var a;let o=(a=s[r])==null?void 0:a.position;return o?JU(n,t,o.y,o.x)<=h9e:!1})}function y9e(e,t){return t.reduce((r,{position:s,score:o},a)=>(ej(e,s,a)||(r+=o),r),0)/t.length}function b9e(e,t,n,r,s,o){let a=[],i=x9e(o,t);for(;a.length<s&&!i.empty();){let l=i.dequeue(),u=f7(l.part,ax,e);if(ej(a,u,l.part.id))continue;let c=m9e(l,t,e,n,r);c=c.filter(f=>f.score>o);let p=y9e(a,c),d=ZU(c);p>o&&a.push({keypoints:c,box:d,score:Math.round(100*p)/100})}return a}async function g7(e,t){let n=ce(()=>{if(!Yo.inputs[0].shape)return[];let a=ht.resizeBilinear(e,[Yo.inputs[0].shape[2],Yo.inputs[0].shape[1]]),i=Ge(Me(Fe(a,"float32"),127.5),1),u=Yo.execute(i,f9e).map(c=>ln(c,[0]));return u[1]=u[1].sigmoid(),u}),r=await Promise.all(n.map(a=>a.buffer()));for(let a of n)ye(a);let s=await b9e(r[0],r[1],r[2],r[3],t.body.maxDetected,t.body.minConfidence);return Yo.inputs[0].shape?YU(s,[e.shape[1],e.shape[2]],[Yo.inputs[0].shape[2],Yo.inputs[0].shape[1]]):[]}async function tj(e){return!Yo||Ee.initial?(Yo=await yn(an(e.modelBasePath,e.body.modelPath||"")),!Yo||!Yo.modelUrl?Ce("load model failed:",e.body.modelPath):e.debug&&Ce("load model:",Yo.modelUrl)):e.debug&&Ce("cached model:",Yo.modelUrl),Yo}function r3(e){return[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])]}function AA(e){return[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2]}function nj(e,t,n){let r=t.shape[1],s=t.shape[2],o=[[e.startPoint[1]/r,e.startPoint[0]/s,e.endPoint[1]/r,e.endPoint[0]/s]];return ht.cropAndResize(t,o,[0],n)}function rj(e,t){let n=[e.startPoint[0]*t[0],e.startPoint[1]*t[1]],r=[e.endPoint[0]*t[0],e.endPoint[1]*t[1]],s=e.palmLandmarks.map(o=>[o[0]*t[0],o[1]*t[1]]);return{startPoint:n,endPoint:r,palmLandmarks:s,confidence:e.confidence}}function s3(e,t=1.5){let n=AA(e),r=r3(e),s=[t*r[0]/2,t*r[1]/2],o=[n[0]-s[0],n[1]-s[1]],a=[n[0]+s[0],n[1]+s[1]];return{startPoint:o,endPoint:a,palmLandmarks:e.palmLandmarks}}function o3(e){let t=AA(e),n=r3(e),s=Math.max(...n)/2,o=[t[0]-s,t[1]-s],a=[t[0]+s,t[1]+s];return{startPoint:o,endPoint:a,palmLandmarks:e.palmLandmarks}}var sj=[{x:.015625,y:.015625},{x:.015625,y:.015625},{x:.046875,y:.015625},{x:.046875,y:.015625},{x:.078125,y:.015625},{x:.078125,y:.015625},{x:.109375,y:.015625},{x:.109375,y:.015625},{x:.140625,y:.015625},{x:.140625,y:.015625},{x:.171875,y:.015625},{x:.171875,y:.015625},{x:.203125,y:.015625},{x:.203125,y:.015625},{x:.234375,y:.015625},{x:.234375,y:.015625},{x:.265625,y:.015625},{x:.265625,y:.015625},{x:.296875,y:.015625},{x:.296875,y:.015625},{x:.328125,y:.015625},{x:.328125,y:.015625},{x:.359375,y:.015625},{x:.359375,y:.015625},{x:.390625,y:.015625},{x:.390625,y:.015625},{x:.421875,y:.015625},{x:.421875,y:.015625},{x:.453125,y:.015625},{x:.453125,y:.015625},{x:.484375,y:.015625},{x:.484375,y:.015625},{x:.515625,y:.015625},{x:.515625,y:.015625},{x:.546875,y:.015625},{x:.546875,y:.015625},{x:.578125,y:.015625},{x:.578125,y:.015625},{x:.609375,y:.015625},{x:.609375,y:.015625},{x:.640625,y:.015625},{x:.640625,y:.015625},{x:.671875,y:.015625},{x:.671875,y:.015625},{x:.703125,y:.015625},{x:.703125,y:.015625},{x:.734375,y:.015625},{x:.734375,y:.015625},{x:.765625,y:.015625},{x:.765625,y:.015625},{x:.796875,y:.015625},{x:.796875,y:.015625},{x:.828125,y:.015625},{x:.828125,y:.015625},{x:.859375,y:.015625},{x:.859375,y:.015625},{x:.890625,y:.015625},{x:.890625,y:.015625},{x:.921875,y:.015625},{x:.921875,y:.015625},{x:.953125,y:.015625},{x:.953125,y:.015625},{x:.984375,y:.015625},{x:.984375,y:.015625},{x:.015625,y:.046875},{x:.015625,y:.046875},{x:.046875,y:.046875},{x:.046875,y:.046875},{x:.078125,y:.046875},{x:.078125,y:.046875},{x:.109375,y:.046875},{x:.109375,y:.046875},{x:.140625,y:.046875},{x:.140625,y:.046875},{x:.171875,y:.046875},{x:.171875,y:.046875},{x:.203125,y:.046875},{x:.203125,y:.046875},{x:.234375,y:.046875},{x:.234375,y:.046875},{x:.265625,y:.046875},{x:.265625,y:.046875},{x:.296875,y:.046875},{x:.296875,y:.046875},{x:.328125,y:.046875},{x:.328125,y:.046875},{x:.359375,y:.046875},{x:.359375,y:.046875},{x:.390625,y:.046875},{x:.390625,y:.046875},{x:.421875,y:.046875},{x:.421875,y:.046875},{x:.453125,y:.046875},{x:.453125,y:.046875},{x:.484375,y:.046875},{x:.484375,y:.046875},{x:.515625,y:.046875},{x:.515625,y:.046875},{x:.546875,y:.046875},{x:.546875,y:.046875},{x:.578125,y:.046875},{x:.578125,y:.046875},{x:.609375,y:.046875},{x:.609375,y:.046875},{x:.640625,y:.046875},{x:.640625,y:.046875},{x:.671875,y:.046875},{x:.671875,y:.046875},{x:.703125,y:.046875},{x:.703125,y:.046875},{x:.734375,y:.046875},{x:.734375,y:.046875},{x:.765625,y:.046875},{x:.765625,y:.046875},{x:.796875,y:.046875},{x:.796875,y:.046875},{x:.828125,y:.046875},{x:.828125,y:.046875},{x:.859375,y:.046875},{x:.859375,y:.046875},{x:.890625,y:.046875},{x:.890625,y:.046875},{x:.921875,y:.046875},{x:.921875,y:.046875},{x:.953125,y:.046875},{x:.953125,y:.046875},{x:.984375,y:.046875},{x:.984375,y:.046875},{x:.015625,y:.078125},{x:.015625,y:.078125},{x:.046875,y:.078125},{x:.046875,y:.078125},{x:.078125,y:.078125},{x:.078125,y:.078125},{x:.109375,y:.078125},{x:.109375,y:.078125},{x:.140625,y:.078125},{x:.140625,y:.078125},{x:.171875,y:.078125},{x:.171875,y:.078125},{x:.203125,y:.078125},{x:.203125,y:.078125},{x:.234375,y:.078125},{x:.234375,y:.078125},{x:.265625,y:.078125},{x:.265625,y:.078125},{x:.296875,y:.078125},{x:.296875,y:.078125},{x:.328125,y:.078125},{x:.328125,y:.078125},{x:.359375,y:.078125},{x:.359375,y:.078125},{x:.390625,y:.078125},{x:.390625,y:.078125},{x:.421875,y:.078125},{x:.421875,y:.078125},{x:.453125,y:.078125},{x:.453125,y:.078125},{x:.484375,y:.078125},{x:.484375,y:.078125},{x:.515625,y:.078125},{x:.515625,y:.078125},{x:.546875,y:.078125},{x:.546875,y:.078125},{x:.578125,y:.078125},{x:.578125,y:.078125},{x:.609375,y:.078125},{x:.609375,y:.078125},{x:.640625,y:.078125},{x:.640625,y:.078125},{x:.671875,y:.078125},{x:.671875,y:.078125},{x:.703125,y:.078125},{x:.703125,y:.078125},{x:.734375,y:.078125},{x:.734375,y:.078125},{x:.765625,y:.078125},{x:.765625,y:.078125},{x:.796875,y:.078125},{x:.796875,y:.078125},{x:.828125,y:.078125},{x:.828125,y:.078125},{x:.859375,y:.078125},{x:.859375,y:.078125},{x:.890625,y:.078125},{x:.890625,y:.078125},{x:.921875,y:.078125},{x:.921875,y:.078125},{x:.953125,y:.078125},{x:.953125,y:.078125},{x:.984375,y:.078125},{x:.984375,y:.078125},{x:.015625,y:.109375},{x:.015625,y:.109375},{x:.046875,y:.109375},{x:.046875,y:.109375},{x:.078125,y:.109375},{x:.078125,y:.109375},{x:.109375,y:.109375},{x:.109375,y:.109375},{x:.140625,y:.109375},{x:.140625,y:.109375},{x:.171875,y:.109375},{x:.171875,y:.109375},{x:.203125,y:.109375},{x:.203125,y:.109375},{x:.234375,y:.109375},{x:.234375,y:.109375},{x:.265625,y:.109375},{x:.265625,y:.109375},{x:.296875,y:.109375},{x:.296875,y:.109375},{x:.328125,y:.109375},{x:.328125,y:.109375},{x:.359375,y:.109375},{x:.359375,y:.109375},{x:.390625,y:.109375},{x:.390625,y:.109375},{x:.421875,y:.109375},{x:.421875,y:.109375},{x:.453125,y:.109375},{x:.453125,y:.109375},{x:.484375,y:.109375},{x:.484375,y:.109375},{x:.515625,y:.109375},{x:.515625,y:.109375},{x:.546875,y:.109375},{x:.546875,y:.109375},{x:.578125,y:.109375},{x:.578125,y:.109375},{x:.609375,y:.109375},{x:.609375,y:.109375},{x:.640625,y:.109375},{x:.640625,y:.109375},{x:.671875,y:.109375},{x:.671875,y:.109375},{x:.703125,y:.109375},{x:.703125,y:.109375},{x:.734375,y:.109375},{x:.734375,y:.109375},{x:.765625,y:.109375},{x:.765625,y:.109375},{x:.796875,y:.109375},{x:.796875,y:.109375},{x:.828125,y:.109375},{x:.828125,y:.109375},{x:.859375,y:.109375},{x:.859375,y:.109375},{x:.890625,y:.109375},{x:.890625,y:.109375},{x:.921875,y:.109375},{x:.921875,y:.109375},{x:.953125,y:.109375},{x:.953125,y:.109375},{x:.984375,y:.109375},{x:.984375,y:.109375},{x:.015625,y:.140625},{x:.015625,y:.140625},{x:.046875,y:.140625},{x:.046875,y:.140625},{x:.078125,y:.140625},{x:.078125,y:.140625},{x:.109375,y:.140625},{x:.109375,y:.140625},{x:.140625,y:.140625},{x:.140625,y:.140625},{x:.171875,y:.140625},{x:.171875,y:.140625},{x:.203125,y:.140625},{x:.203125,y:.140625},{x:.234375,y:.140625},{x:.234375,y:.140625},{x:.265625,y:.140625},{x:.265625,y:.140625},{x:.296875,y:.140625},{x:.296875,y:.140625},{x:.328125,y:.140625},{x:.328125,y:.140625},{x:.359375,y:.140625},{x:.359375,y:.140625},{x:.390625,y:.140625},{x:.390625,y:.140625},{x:.421875,y:.140625},{x:.421875,y:.140625},{x:.453125,y:.140625},{x:.453125,y:.140625},{x:.484375,y:.140625},{x:.484375,y:.140625},{x:.515625,y:.140625},{x:.515625,y:.140625},{x:.546875,y:.140625},{x:.546875,y:.140625},{x:.578125,y:.140625},{x:.578125,y:.140625},{x:.609375,y:.140625},{x:.609375,y:.140625},{x:.640625,y:.140625},{x:.640625,y:.140625},{x:.671875,y:.140625},{x:.671875,y:.140625},{x:.703125,y:.140625},{x:.703125,y:.140625},{x:.734375,y:.140625},{x:.734375,y:.140625},{x:.765625,y:.140625},{x:.765625,y:.140625},{x:.796875,y:.140625},{x:.796875,y:.140625},{x:.828125,y:.140625},{x:.828125,y:.140625},{x:.859375,y:.140625},{x:.859375,y:.140625},{x:.890625,y:.140625},{x:.890625,y:.140625},{x:.921875,y:.140625},{x:.921875,y:.140625},{x:.953125,y:.140625},{x:.953125,y:.140625},{x:.984375,y:.140625},{x:.984375,y:.140625},{x:.015625,y:.171875},{x:.015625,y:.171875},{x:.046875,y:.171875},{x:.046875,y:.171875},{x:.078125,y:.171875},{x:.078125,y:.171875},{x:.109375,y:.171875},{x:.109375,y:.171875},{x:.140625,y:.171875},{x:.140625,y:.171875},{x:.171875,y:.171875},{x:.171875,y:.171875},{x:.203125,y:.171875},{x:.203125,y:.171875},{x:.234375,y:.171875},{x:.234375,y:.171875},{x:.265625,y:.171875},{x:.265625,y:.171875},{x:.296875,y:.171875},{x:.296875,y:.171875},{x:.328125,y:.171875},{x:.328125,y:.171875},{x:.359375,y:.171875},{x:.359375,y:.171875},{x:.390625,y:.171875},{x:.390625,y:.171875},{x:.421875,y:.171875},{x:.421875,y:.171875},{x:.453125,y:.171875},{x:.453125,y:.171875},{x:.484375,y:.171875},{x:.484375,y:.171875},{x:.515625,y:.171875},{x:.515625,y:.171875},{x:.546875,y:.171875},{x:.546875,y:.171875},{x:.578125,y:.171875},{x:.578125,y:.171875},{x:.609375,y:.171875},{x:.609375,y:.171875},{x:.640625,y:.171875},{x:.640625,y:.171875},{x:.671875,y:.171875},{x:.671875,y:.171875},{x:.703125,y:.171875},{x:.703125,y:.171875},{x:.734375,y:.171875},{x:.734375,y:.171875},{x:.765625,y:.171875},{x:.765625,y:.171875},{x:.796875,y:.171875},{x:.796875,y:.171875},{x:.828125,y:.171875},{x:.828125,y:.171875},{x:.859375,y:.171875},{x:.859375,y:.171875},{x:.890625,y:.171875},{x:.890625,y:.171875},{x:.921875,y:.171875},{x:.921875,y:.171875},{x:.953125,y:.171875},{x:.953125,y:.171875},{x:.984375,y:.171875},{x:.984375,y:.171875},{x:.015625,y:.203125},{x:.015625,y:.203125},{x:.046875,y:.203125},{x:.046875,y:.203125},{x:.078125,y:.203125},{x:.078125,y:.203125},{x:.109375,y:.203125},{x:.109375,y:.203125},{x:.140625,y:.203125},{x:.140625,y:.203125},{x:.171875,y:.203125},{x:.171875,y:.203125},{x:.203125,y:.203125},{x:.203125,y:.203125},{x:.234375,y:.203125},{x:.234375,y:.203125},{x:.265625,y:.203125},{x:.265625,y:.203125},{x:.296875,y:.203125},{x:.296875,y:.203125},{x:.328125,y:.203125},{x:.328125,y:.203125},{x:.359375,y:.203125},{x:.359375,y:.203125},{x:.390625,y:.203125},{x:.390625,y:.203125},{x:.421875,y:.203125},{x:.421875,y:.203125},{x:.453125,y:.203125},{x:.453125,y:.203125},{x:.484375,y:.203125},{x:.484375,y:.203125},{x:.515625,y:.203125},{x:.515625,y:.203125},{x:.546875,y:.203125},{x:.546875,y:.203125},{x:.578125,y:.203125},{x:.578125,y:.203125},{x:.609375,y:.203125},{x:.609375,y:.203125},{x:.640625,y:.203125},{x:.640625,y:.203125},{x:.671875,y:.203125},{x:.671875,y:.203125},{x:.703125,y:.203125},{x:.703125,y:.203125},{x:.734375,y:.203125},{x:.734375,y:.203125},{x:.765625,y:.203125},{x:.765625,y:.203125},{x:.796875,y:.203125},{x:.796875,y:.203125},{x:.828125,y:.203125},{x:.828125,y:.203125},{x:.859375,y:.203125},{x:.859375,y:.203125},{x:.890625,y:.203125},{x:.890625,y:.203125},{x:.921875,y:.203125},{x:.921875,y:.203125},{x:.953125,y:.203125},{x:.953125,y:.203125},{x:.984375,y:.203125},{x:.984375,y:.203125},{x:.015625,y:.234375},{x:.015625,y:.234375},{x:.046875,y:.234375},{x:.046875,y:.234375},{x:.078125,y:.234375},{x:.078125,y:.234375},{x:.109375,y:.234375},{x:.109375,y:.234375},{x:.140625,y:.234375},{x:.140625,y:.234375},{x:.171875,y:.234375},{x:.171875,y:.234375},{x:.203125,y:.234375},{x:.203125,y:.234375},{x:.234375,y:.234375},{x:.234375,y:.234375},{x:.265625,y:.234375},{x:.265625,y:.234375},{x:.296875,y:.234375},{x:.296875,y:.234375},{x:.328125,y:.234375},{x:.328125,y:.234375},{x:.359375,y:.234375},{x:.359375,y:.234375},{x:.390625,y:.234375},{x:.390625,y:.234375},{x:.421875,y:.234375},{x:.421875,y:.234375},{x:.453125,y:.234375},{x:.453125,y:.234375},{x:.484375,y:.234375},{x:.484375,y:.234375},{x:.515625,y:.234375},{x:.515625,y:.234375},{x:.546875,y:.234375},{x:.546875,y:.234375},{x:.578125,y:.234375},{x:.578125,y:.234375},{x:.609375,y:.234375},{x:.609375,y:.234375},{x:.640625,y:.234375},{x:.640625,y:.234375},{x:.671875,y:.234375},{x:.671875,y:.234375},{x:.703125,y:.234375},{x:.703125,y:.234375},{x:.734375,y:.234375},{x:.734375,y:.234375},{x:.765625,y:.234375},{x:.765625,y:.234375},{x:.796875,y:.234375},{x:.796875,y:.234375},{x:.828125,y:.234375},{x:.828125,y:.234375},{x:.859375,y:.234375},{x:.859375,y:.234375},{x:.890625,y:.234375},{x:.890625,y:.234375},{x:.921875,y:.234375},{x:.921875,y:.234375},{x:.953125,y:.234375},{x:.953125,y:.234375},{x:.984375,y:.234375},{x:.984375,y:.234375},{x:.015625,y:.265625},{x:.015625,y:.265625},{x:.046875,y:.265625},{x:.046875,y:.265625},{x:.078125,y:.265625},{x:.078125,y:.265625},{x:.109375,y:.265625},{x:.109375,y:.265625},{x:.140625,y:.265625},{x:.140625,y:.265625},{x:.171875,y:.265625},{x:.171875,y:.265625},{x:.203125,y:.265625},{x:.203125,y:.265625},{x:.234375,y:.265625},{x:.234375,y:.265625},{x:.265625,y:.265625},{x:.265625,y:.265625},{x:.296875,y:.265625},{x:.296875,y:.265625},{x:.328125,y:.265625},{x:.328125,y:.265625},{x:.359375,y:.265625},{x:.359375,y:.265625},{x:.390625,y:.265625},{x:.390625,y:.265625},{x:.421875,y:.265625},{x:.421875,y:.265625},{x:.453125,y:.265625},{x:.453125,y:.265625},{x:.484375,y:.265625},{x:.484375,y:.265625},{x:.515625,y:.265625},{x:.515625,y:.265625},{x:.546875,y:.265625},{x:.546875,y:.265625},{x:.578125,y:.265625},{x:.578125,y:.265625},{x:.609375,y:.265625},{x:.609375,y:.265625},{x:.640625,y:.265625},{x:.640625,y:.265625},{x:.671875,y:.265625},{x:.671875,y:.265625},{x:.703125,y:.265625},{x:.703125,y:.265625},{x:.734375,y:.265625},{x:.734375,y:.265625},{x:.765625,y:.265625},{x:.765625,y:.265625},{x:.796875,y:.265625},{x:.796875,y:.265625},{x:.828125,y:.265625},{x:.828125,y:.265625},{x:.859375,y:.265625},{x:.859375,y:.265625},{x:.890625,y:.265625},{x:.890625,y:.265625},{x:.921875,y:.265625},{x:.921875,y:.265625},{x:.953125,y:.265625},{x:.953125,y:.265625},{x:.984375,y:.265625},{x:.984375,y:.265625},{x:.015625,y:.296875},{x:.015625,y:.296875},{x:.046875,y:.296875},{x:.046875,y:.296875},{x:.078125,y:.296875},{x:.078125,y:.296875},{x:.109375,y:.296875},{x:.109375,y:.296875},{x:.140625,y:.296875},{x:.140625,y:.296875},{x:.171875,y:.296875},{x:.171875,y:.296875},{x:.203125,y:.296875},{x:.203125,y:.296875},{x:.234375,y:.296875},{x:.234375,y:.296875},{x:.265625,y:.296875},{x:.265625,y:.296875},{x:.296875,y:.296875},{x:.296875,y:.296875},{x:.328125,y:.296875},{x:.328125,y:.296875},{x:.359375,y:.296875},{x:.359375,y:.296875},{x:.390625,y:.296875},{x:.390625,y:.296875},{x:.421875,y:.296875},{x:.421875,y:.296875},{x:.453125,y:.296875},{x:.453125,y:.296875},{x:.484375,y:.296875},{x:.484375,y:.296875},{x:.515625,y:.296875},{x:.515625,y:.296875},{x:.546875,y:.296875},{x:.546875,y:.296875},{x:.578125,y:.296875},{x:.578125,y:.296875},{x:.609375,y:.296875},{x:.609375,y:.296875},{x:.640625,y:.296875},{x:.640625,y:.296875},{x:.671875,y:.296875},{x:.671875,y:.296875},{x:.703125,y:.296875},{x:.703125,y:.296875},{x:.734375,y:.296875},{x:.734375,y:.296875},{x:.765625,y:.296875},{x:.765625,y:.296875},{x:.796875,y:.296875},{x:.796875,y:.296875},{x:.828125,y:.296875},{x:.828125,y:.296875},{x:.859375,y:.296875},{x:.859375,y:.296875},{x:.890625,y:.296875},{x:.890625,y:.296875},{x:.921875,y:.296875},{x:.921875,y:.296875},{x:.953125,y:.296875},{x:.953125,y:.296875},{x:.984375,y:.296875},{x:.984375,y:.296875},{x:.015625,y:.328125},{x:.015625,y:.328125},{x:.046875,y:.328125},{x:.046875,y:.328125},{x:.078125,y:.328125},{x:.078125,y:.328125},{x:.109375,y:.328125},{x:.109375,y:.328125},{x:.140625,y:.328125},{x:.140625,y:.328125},{x:.171875,y:.328125},{x:.171875,y:.328125},{x:.203125,y:.328125},{x:.203125,y:.328125},{x:.234375,y:.328125},{x:.234375,y:.328125},{x:.265625,y:.328125},{x:.265625,y:.328125},{x:.296875,y:.328125},{x:.296875,y:.328125},{x:.328125,y:.328125},{x:.328125,y:.328125},{x:.359375,y:.328125},{x:.359375,y:.328125},{x:.390625,y:.328125},{x:.390625,y:.328125},{x:.421875,y:.328125},{x:.421875,y:.328125},{x:.453125,y:.328125},{x:.453125,y:.328125},{x:.484375,y:.328125},{x:.484375,y:.328125},{x:.515625,y:.328125},{x:.515625,y:.328125},{x:.546875,y:.328125},{x:.546875,y:.328125},{x:.578125,y:.328125},{x:.578125,y:.328125},{x:.609375,y:.328125},{x:.609375,y:.328125},{x:.640625,y:.328125},{x:.640625,y:.328125},{x:.671875,y:.328125},{x:.671875,y:.328125},{x:.703125,y:.328125},{x:.703125,y:.328125},{x:.734375,y:.328125},{x:.734375,y:.328125},{x:.765625,y:.328125},{x:.765625,y:.328125},{x:.796875,y:.328125},{x:.796875,y:.328125},{x:.828125,y:.328125},{x:.828125,y:.328125},{x:.859375,y:.328125},{x:.859375,y:.328125},{x:.890625,y:.328125},{x:.890625,y:.328125},{x:.921875,y:.328125},{x:.921875,y:.328125},{x:.953125,y:.328125},{x:.953125,y:.328125},{x:.984375,y:.328125},{x:.984375,y:.328125},{x:.015625,y:.359375},{x:.015625,y:.359375},{x:.046875,y:.359375},{x:.046875,y:.359375},{x:.078125,y:.359375},{x:.078125,y:.359375},{x:.109375,y:.359375},{x:.109375,y:.359375},{x:.140625,y:.359375},{x:.140625,y:.359375},{x:.171875,y:.359375},{x:.171875,y:.359375},{x:.203125,y:.359375},{x:.203125,y:.359375},{x:.234375,y:.359375},{x:.234375,y:.359375},{x:.265625,y:.359375},{x:.265625,y:.359375},{x:.296875,y:.359375},{x:.296875,y:.359375},{x:.328125,y:.359375},{x:.328125,y:.359375},{x:.359375,y:.359375},{x:.359375,y:.359375},{x:.390625,y:.359375},{x:.390625,y:.359375},{x:.421875,y:.359375},{x:.421875,y:.359375},{x:.453125,y:.359375},{x:.453125,y:.359375},{x:.484375,y:.359375},{x:.484375,y:.359375},{x:.515625,y:.359375},{x:.515625,y:.359375},{x:.546875,y:.359375},{x:.546875,y:.359375},{x:.578125,y:.359375},{x:.578125,y:.359375},{x:.609375,y:.359375},{x:.609375,y:.359375},{x:.640625,y:.359375},{x:.640625,y:.359375},{x:.671875,y:.359375},{x:.671875,y:.359375},{x:.703125,y:.359375},{x:.703125,y:.359375},{x:.734375,y:.359375},{x:.734375,y:.359375},{x:.765625,y:.359375},{x:.765625,y:.359375},{x:.796875,y:.359375},{x:.796875,y:.359375},{x:.828125,y:.359375},{x:.828125,y:.359375},{x:.859375,y:.359375},{x:.859375,y:.359375},{x:.890625,y:.359375},{x:.890625,y:.359375},{x:.921875,y:.359375},{x:.921875,y:.359375},{x:.953125,y:.359375},{x:.953125,y:.359375},{x:.984375,y:.359375},{x:.984375,y:.359375},{x:.015625,y:.390625},{x:.015625,y:.390625},{x:.046875,y:.390625},{x:.046875,y:.390625},{x:.078125,y:.390625},{x:.078125,y:.390625},{x:.109375,y:.390625},{x:.109375,y:.390625},{x:.140625,y:.390625},{x:.140625,y:.390625},{x:.171875,y:.390625},{x:.171875,y:.390625},{x:.203125,y:.390625},{x:.203125,y:.390625},{x:.234375,y:.390625},{x:.234375,y:.390625},{x:.265625,y:.390625},{x:.265625,y:.390625},{x:.296875,y:.390625},{x:.296875,y:.390625},{x:.328125,y:.390625},{x:.328125,y:.390625},{x:.359375,y:.390625},{x:.359375,y:.390625},{x:.390625,y:.390625},{x:.390625,y:.390625},{x:.421875,y:.390625},{x:.421875,y:.390625},{x:.453125,y:.390625},{x:.453125,y:.390625},{x:.484375,y:.390625},{x:.484375,y:.390625},{x:.515625,y:.390625},{x:.515625,y:.390625},{x:.546875,y:.390625},{x:.546875,y:.390625},{x:.578125,y:.390625},{x:.578125,y:.390625},{x:.609375,y:.390625},{x:.609375,y:.390625},{x:.640625,y:.390625},{x:.640625,y:.390625},{x:.671875,y:.390625},{x:.671875,y:.390625},{x:.703125,y:.390625},{x:.703125,y:.390625},{x:.734375,y:.390625},{x:.734375,y:.390625},{x:.765625,y:.390625},{x:.765625,y:.390625},{x:.796875,y:.390625},{x:.796875,y:.390625},{x:.828125,y:.390625},{x:.828125,y:.390625},{x:.859375,y:.390625},{x:.859375,y:.390625},{x:.890625,y:.390625},{x:.890625,y:.390625},{x:.921875,y:.390625},{x:.921875,y:.390625},{x:.953125,y:.390625},{x:.953125,y:.390625},{x:.984375,y:.390625},{x:.984375,y:.390625},{x:.015625,y:.421875},{x:.015625,y:.421875},{x:.046875,y:.421875},{x:.046875,y:.421875},{x:.078125,y:.421875},{x:.078125,y:.421875},{x:.109375,y:.421875},{x:.109375,y:.421875},{x:.140625,y:.421875},{x:.140625,y:.421875},{x:.171875,y:.421875},{x:.171875,y:.421875},{x:.203125,y:.421875},{x:.203125,y:.421875},{x:.234375,y:.421875},{x:.234375,y:.421875},{x:.265625,y:.421875},{x:.265625,y:.421875},{x:.296875,y:.421875},{x:.296875,y:.421875},{x:.328125,y:.421875},{x:.328125,y:.421875},{x:.359375,y:.421875},{x:.359375,y:.421875},{x:.390625,y:.421875},{x:.390625,y:.421875},{x:.421875,y:.421875},{x:.421875,y:.421875},{x:.453125,y:.421875},{x:.453125,y:.421875},{x:.484375,y:.421875},{x:.484375,y:.421875},{x:.515625,y:.421875},{x:.515625,y:.421875},{x:.546875,y:.421875},{x:.546875,y:.421875},{x:.578125,y:.421875},{x:.578125,y:.421875},{x:.609375,y:.421875},{x:.609375,y:.421875},{x:.640625,y:.421875},{x:.640625,y:.421875},{x:.671875,y:.421875},{x:.671875,y:.421875},{x:.703125,y:.421875},{x:.703125,y:.421875},{x:.734375,y:.421875},{x:.734375,y:.421875},{x:.765625,y:.421875},{x:.765625,y:.421875},{x:.796875,y:.421875},{x:.796875,y:.421875},{x:.828125,y:.421875},{x:.828125,y:.421875},{x:.859375,y:.421875},{x:.859375,y:.421875},{x:.890625,y:.421875},{x:.890625,y:.421875},{x:.921875,y:.421875},{x:.921875,y:.421875},{x:.953125,y:.421875},{x:.953125,y:.421875},{x:.984375,y:.421875},{x:.984375,y:.421875},{x:.015625,y:.453125},{x:.015625,y:.453125},{x:.046875,y:.453125},{x:.046875,y:.453125},{x:.078125,y:.453125},{x:.078125,y:.453125},{x:.109375,y:.453125},{x:.109375,y:.453125},{x:.140625,y:.453125},{x:.140625,y:.453125},{x:.171875,y:.453125},{x:.171875,y:.453125},{x:.203125,y:.453125},{x:.203125,y:.453125},{x:.234375,y:.453125},{x:.234375,y:.453125},{x:.265625,y:.453125},{x:.265625,y:.453125},{x:.296875,y:.453125},{x:.296875,y:.453125},{x:.328125,y:.453125},{x:.328125,y:.453125},{x:.359375,y:.453125},{x:.359375,y:.453125},{x:.390625,y:.453125},{x:.390625,y:.453125},{x:.421875,y:.453125},{x:.421875,y:.453125},{x:.453125,y:.453125},{x:.453125,y:.453125},{x:.484375,y:.453125},{x:.484375,y:.453125},{x:.515625,y:.453125},{x:.515625,y:.453125},{x:.546875,y:.453125},{x:.546875,y:.453125},{x:.578125,y:.453125},{x:.578125,y:.453125},{x:.609375,y:.453125},{x:.609375,y:.453125},{x:.640625,y:.453125},{x:.640625,y:.453125},{x:.671875,y:.453125},{x:.671875,y:.453125},{x:.703125,y:.453125},{x:.703125,y:.453125},{x:.734375,y:.453125},{x:.734375,y:.453125},{x:.765625,y:.453125},{x:.765625,y:.453125},{x:.796875,y:.453125},{x:.796875,y:.453125},{x:.828125,y:.453125},{x:.828125,y:.453125},{x:.859375,y:.453125},{x:.859375,y:.453125},{x:.890625,y:.453125},{x:.890625,y:.453125},{x:.921875,y:.453125},{x:.921875,y:.453125},{x:.953125,y:.453125},{x:.953125,y:.453125},{x:.984375,y:.453125},{x:.984375,y:.453125},{x:.015625,y:.484375},{x:.015625,y:.484375},{x:.046875,y:.484375},{x:.046875,y:.484375},{x:.078125,y:.484375},{x:.078125,y:.484375},{x:.109375,y:.484375},{x:.109375,y:.484375},{x:.140625,y:.484375},{x:.140625,y:.484375},{x:.171875,y:.484375},{x:.171875,y:.484375},{x:.203125,y:.484375},{x:.203125,y:.484375},{x:.234375,y:.484375},{x:.234375,y:.484375},{x:.265625,y:.484375},{x:.265625,y:.484375},{x:.296875,y:.484375},{x:.296875,y:.484375},{x:.328125,y:.484375},{x:.328125,y:.484375},{x:.359375,y:.484375},{x:.359375,y:.484375},{x:.390625,y:.484375},{x:.390625,y:.484375},{x:.421875,y:.484375},{x:.421875,y:.484375},{x:.453125,y:.484375},{x:.453125,y:.484375},{x:.484375,y:.484375},{x:.484375,y:.484375},{x:.515625,y:.484375},{x:.515625,y:.484375},{x:.546875,y:.484375},{x:.546875,y:.484375},{x:.578125,y:.484375},{x:.578125,y:.484375},{x:.609375,y:.484375},{x:.609375,y:.484375},{x:.640625,y:.484375},{x:.640625,y:.484375},{x:.671875,y:.484375},{x:.671875,y:.484375},{x:.703125,y:.484375},{x:.703125,y:.484375},{x:.734375,y:.484375},{x:.734375,y:.484375},{x:.765625,y:.484375},{x:.765625,y:.484375},{x:.796875,y:.484375},{x:.796875,y:.484375},{x:.828125,y:.484375},{x:.828125,y:.484375},{x:.859375,y:.484375},{x:.859375,y:.484375},{x:.890625,y:.484375},{x:.890625,y:.484375},{x:.921875,y:.484375},{x:.921875,y:.484375},{x:.953125,y:.484375},{x:.953125,y:.484375},{x:.984375,y:.484375},{x:.984375,y:.484375},{x:.015625,y:.515625},{x:.015625,y:.515625},{x:.046875,y:.515625},{x:.046875,y:.515625},{x:.078125,y:.515625},{x:.078125,y:.515625},{x:.109375,y:.515625},{x:.109375,y:.515625},{x:.140625,y:.515625},{x:.140625,y:.515625},{x:.171875,y:.515625},{x:.171875,y:.515625},{x:.203125,y:.515625},{x:.203125,y:.515625},{x:.234375,y:.515625},{x:.234375,y:.515625},{x:.265625,y:.515625},{x:.265625,y:.515625},{x:.296875,y:.515625},{x:.296875,y:.515625},{x:.328125,y:.515625},{x:.328125,y:.515625},{x:.359375,y:.515625},{x:.359375,y:.515625},{x:.390625,y:.515625},{x:.390625,y:.515625},{x:.421875,y:.515625},{x:.421875,y:.515625},{x:.453125,y:.515625},{x:.453125,y:.515625},{x:.484375,y:.515625},{x:.484375,y:.515625},{x:.515625,y:.515625},{x:.515625,y:.515625},{x:.546875,y:.515625},{x:.546875,y:.515625},{x:.578125,y:.515625},{x:.578125,y:.515625},{x:.609375,y:.515625},{x:.609375,y:.515625},{x:.640625,y:.515625},{x:.640625,y:.515625},{x:.671875,y:.515625},{x:.671875,y:.515625},{x:.703125,y:.515625},{x:.703125,y:.515625},{x:.734375,y:.515625},{x:.734375,y:.515625},{x:.765625,y:.515625},{x:.765625,y:.515625},{x:.796875,y:.515625},{x:.796875,y:.515625},{x:.828125,y:.515625},{x:.828125,y:.515625},{x:.859375,y:.515625},{x:.859375,y:.515625},{x:.890625,y:.515625},{x:.890625,y:.515625},{x:.921875,y:.515625},{x:.921875,y:.515625},{x:.953125,y:.515625},{x:.953125,y:.515625},{x:.984375,y:.515625},{x:.984375,y:.515625},{x:.015625,y:.546875},{x:.015625,y:.546875},{x:.046875,y:.546875},{x:.046875,y:.546875},{x:.078125,y:.546875},{x:.078125,y:.546875},{x:.109375,y:.546875},{x:.109375,y:.546875},{x:.140625,y:.546875},{x:.140625,y:.546875},{x:.171875,y:.546875},{x:.171875,y:.546875},{x:.203125,y:.546875},{x:.203125,y:.546875},{x:.234375,y:.546875},{x:.234375,y:.546875},{x:.265625,y:.546875},{x:.265625,y:.546875},{x:.296875,y:.546875},{x:.296875,y:.546875},{x:.328125,y:.546875},{x:.328125,y:.546875},{x:.359375,y:.546875},{x:.359375,y:.546875},{x:.390625,y:.546875},{x:.390625,y:.546875},{x:.421875,y:.546875},{x:.421875,y:.546875},{x:.453125,y:.546875},{x:.453125,y:.546875},{x:.484375,y:.546875},{x:.484375,y:.546875},{x:.515625,y:.546875},{x:.515625,y:.546875},{x:.546875,y:.546875},{x:.546875,y:.546875},{x:.578125,y:.546875},{x:.578125,y:.546875},{x:.609375,y:.546875},{x:.609375,y:.546875},{x:.640625,y:.546875},{x:.640625,y:.546875},{x:.671875,y:.546875},{x:.671875,y:.546875},{x:.703125,y:.546875},{x:.703125,y:.546875},{x:.734375,y:.546875},{x:.734375,y:.546875},{x:.765625,y:.546875},{x:.765625,y:.546875},{x:.796875,y:.546875},{x:.796875,y:.546875},{x:.828125,y:.546875},{x:.828125,y:.546875},{x:.859375,y:.546875},{x:.859375,y:.546875},{x:.890625,y:.546875},{x:.890625,y:.546875},{x:.921875,y:.546875},{x:.921875,y:.546875},{x:.953125,y:.546875},{x:.953125,y:.546875},{x:.984375,y:.546875},{x:.984375,y:.546875},{x:.015625,y:.578125},{x:.015625,y:.578125},{x:.046875,y:.578125},{x:.046875,y:.578125},{x:.078125,y:.578125},{x:.078125,y:.578125},{x:.109375,y:.578125},{x:.109375,y:.578125},{x:.140625,y:.578125},{x:.140625,y:.578125},{x:.171875,y:.578125},{x:.171875,y:.578125},{x:.203125,y:.578125},{x:.203125,y:.578125},{x:.234375,y:.578125},{x:.234375,y:.578125},{x:.265625,y:.578125},{x:.265625,y:.578125},{x:.296875,y:.578125},{x:.296875,y:.578125},{x:.328125,y:.578125},{x:.328125,y:.578125},{x:.359375,y:.578125},{x:.359375,y:.578125},{x:.390625,y:.578125},{x:.390625,y:.578125},{x:.421875,y:.578125},{x:.421875,y:.578125},{x:.453125,y:.578125},{x:.453125,y:.578125},{x:.484375,y:.578125},{x:.484375,y:.578125},{x:.515625,y:.578125},{x:.515625,y:.578125},{x:.546875,y:.578125},{x:.546875,y:.578125},{x:.578125,y:.578125},{x:.578125,y:.578125},{x:.609375,y:.578125},{x:.609375,y:.578125},{x:.640625,y:.578125},{x:.640625,y:.578125},{x:.671875,y:.578125},{x:.671875,y:.578125},{x:.703125,y:.578125},{x:.703125,y:.578125},{x:.734375,y:.578125},{x:.734375,y:.578125},{x:.765625,y:.578125},{x:.765625,y:.578125},{x:.796875,y:.578125},{x:.796875,y:.578125},{x:.828125,y:.578125},{x:.828125,y:.578125},{x:.859375,y:.578125},{x:.859375,y:.578125},{x:.890625,y:.578125},{x:.890625,y:.578125},{x:.921875,y:.578125},{x:.921875,y:.578125},{x:.953125,y:.578125},{x:.953125,y:.578125},{x:.984375,y:.578125},{x:.984375,y:.578125},{x:.015625,y:.609375},{x:.015625,y:.609375},{x:.046875,y:.609375},{x:.046875,y:.609375},{x:.078125,y:.609375},{x:.078125,y:.609375},{x:.109375,y:.609375},{x:.109375,y:.609375},{x:.140625,y:.609375},{x:.140625,y:.609375},{x:.171875,y:.609375},{x:.171875,y:.609375},{x:.203125,y:.609375},{x:.203125,y:.609375},{x:.234375,y:.609375},{x:.234375,y:.609375},{x:.265625,y:.609375},{x:.265625,y:.609375},{x:.296875,y:.609375},{x:.296875,y:.609375},{x:.328125,y:.609375},{x:.328125,y:.609375},{x:.359375,y:.609375},{x:.359375,y:.609375},{x:.390625,y:.609375},{x:.390625,y:.609375},{x:.421875,y:.609375},{x:.421875,y:.609375},{x:.453125,y:.609375},{x:.453125,y:.609375},{x:.484375,y:.609375},{x:.484375,y:.609375},{x:.515625,y:.609375},{x:.515625,y:.609375},{x:.546875,y:.609375},{x:.546875,y:.609375},{x:.578125,y:.609375},{x:.578125,y:.609375},{x:.609375,y:.609375},{x:.609375,y:.609375},{x:.640625,y:.609375},{x:.640625,y:.609375},{x:.671875,y:.609375},{x:.671875,y:.609375},{x:.703125,y:.609375},{x:.703125,y:.609375},{x:.734375,y:.609375},{x:.734375,y:.609375},{x:.765625,y:.609375},{x:.765625,y:.609375},{x:.796875,y:.609375},{x:.796875,y:.609375},{x:.828125,y:.609375},{x:.828125,y:.609375},{x:.859375,y:.609375},{x:.859375,y:.609375},{x:.890625,y:.609375},{x:.890625,y:.609375},{x:.921875,y:.609375},{x:.921875,y:.609375},{x:.953125,y:.609375},{x:.953125,y:.609375},{x:.984375,y:.609375},{x:.984375,y:.609375},{x:.015625,y:.640625},{x:.015625,y:.640625},{x:.046875,y:.640625},{x:.046875,y:.640625},{x:.078125,y:.640625},{x:.078125,y:.640625},{x:.109375,y:.640625},{x:.109375,y:.640625},{x:.140625,y:.640625},{x:.140625,y:.640625},{x:.171875,y:.640625},{x:.171875,y:.640625},{x:.203125,y:.640625},{x:.203125,y:.640625},{x:.234375,y:.640625},{x:.234375,y:.640625},{x:.265625,y:.640625},{x:.265625,y:.640625},{x:.296875,y:.640625},{x:.296875,y:.640625},{x:.328125,y:.640625},{x:.328125,y:.640625},{x:.359375,y:.640625},{x:.359375,y:.640625},{x:.390625,y:.640625},{x:.390625,y:.640625},{x:.421875,y:.640625},{x:.421875,y:.640625},{x:.453125,y:.640625},{x:.453125,y:.640625},{x:.484375,y:.640625},{x:.484375,y:.640625},{x:.515625,y:.640625},{x:.515625,y:.640625},{x:.546875,y:.640625},{x:.546875,y:.640625},{x:.578125,y:.640625},{x:.578125,y:.640625},{x:.609375,y:.640625},{x:.609375,y:.640625},{x:.640625,y:.640625},{x:.640625,y:.640625},{x:.671875,y:.640625},{x:.671875,y:.640625},{x:.703125,y:.640625},{x:.703125,y:.640625},{x:.734375,y:.640625},{x:.734375,y:.640625},{x:.765625,y:.640625},{x:.765625,y:.640625},{x:.796875,y:.640625},{x:.796875,y:.640625},{x:.828125,y:.640625},{x:.828125,y:.640625},{x:.859375,y:.640625},{x:.859375,y:.640625},{x:.890625,y:.640625},{x:.890625,y:.640625},{x:.921875,y:.640625},{x:.921875,y:.640625},{x:.953125,y:.640625},{x:.953125,y:.640625},{x:.984375,y:.640625},{x:.984375,y:.640625},{x:.015625,y:.671875},{x:.015625,y:.671875},{x:.046875,y:.671875},{x:.046875,y:.671875},{x:.078125,y:.671875},{x:.078125,y:.671875},{x:.109375,y:.671875},{x:.109375,y:.671875},{x:.140625,y:.671875},{x:.140625,y:.671875},{x:.171875,y:.671875},{x:.171875,y:.671875},{x:.203125,y:.671875},{x:.203125,y:.671875},{x:.234375,y:.671875},{x:.234375,y:.671875},{x:.265625,y:.671875},{x:.265625,y:.671875},{x:.296875,y:.671875},{x:.296875,y:.671875},{x:.328125,y:.671875},{x:.328125,y:.671875},{x:.359375,y:.671875},{x:.359375,y:.671875},{x:.390625,y:.671875},{x:.390625,y:.671875},{x:.421875,y:.671875},{x:.421875,y:.671875},{x:.453125,y:.671875},{x:.453125,y:.671875},{x:.484375,y:.671875},{x:.484375,y:.671875},{x:.515625,y:.671875},{x:.515625,y:.671875},{x:.546875,y:.671875},{x:.546875,y:.671875},{x:.578125,y:.671875},{x:.578125,y:.671875},{x:.609375,y:.671875},{x:.609375,y:.671875},{x:.640625,y:.671875},{x:.640625,y:.671875},{x:.671875,y:.671875},{x:.671875,y:.671875},{x:.703125,y:.671875},{x:.703125,y:.671875},{x:.734375,y:.671875},{x:.734375,y:.671875},{x:.765625,y:.671875},{x:.765625,y:.671875},{x:.796875,y:.671875},{x:.796875,y:.671875},{x:.828125,y:.671875},{x:.828125,y:.671875},{x:.859375,y:.671875},{x:.859375,y:.671875},{x:.890625,y:.671875},{x:.890625,y:.671875},{x:.921875,y:.671875},{x:.921875,y:.671875},{x:.953125,y:.671875},{x:.953125,y:.671875},{x:.984375,y:.671875},{x:.984375,y:.671875},{x:.015625,y:.703125},{x:.015625,y:.703125},{x:.046875,y:.703125},{x:.046875,y:.703125},{x:.078125,y:.703125},{x:.078125,y:.703125},{x:.109375,y:.703125},{x:.109375,y:.703125},{x:.140625,y:.703125},{x:.140625,y:.703125},{x:.171875,y:.703125},{x:.171875,y:.703125},{x:.203125,y:.703125},{x:.203125,y:.703125},{x:.234375,y:.703125},{x:.234375,y:.703125},{x:.265625,y:.703125},{x:.265625,y:.703125},{x:.296875,y:.703125},{x:.296875,y:.703125},{x:.328125,y:.703125},{x:.328125,y:.703125},{x:.359375,y:.703125},{x:.359375,y:.703125},{x:.390625,y:.703125},{x:.390625,y:.703125},{x:.421875,y:.703125},{x:.421875,y:.703125},{x:.453125,y:.703125},{x:.453125,y:.703125},{x:.484375,y:.703125},{x:.484375,y:.703125},{x:.515625,y:.703125},{x:.515625,y:.703125},{x:.546875,y:.703125},{x:.546875,y:.703125},{x:.578125,y:.703125},{x:.578125,y:.703125},{x:.609375,y:.703125},{x:.609375,y:.703125},{x:.640625,y:.703125},{x:.640625,y:.703125},{x:.671875,y:.703125},{x:.671875,y:.703125},{x:.703125,y:.703125},{x:.703125,y:.703125},{x:.734375,y:.703125},{x:.734375,y:.703125},{x:.765625,y:.703125},{x:.765625,y:.703125},{x:.796875,y:.703125},{x:.796875,y:.703125},{x:.828125,y:.703125},{x:.828125,y:.703125},{x:.859375,y:.703125},{x:.859375,y:.703125},{x:.890625,y:.703125},{x:.890625,y:.703125},{x:.921875,y:.703125},{x:.921875,y:.703125},{x:.953125,y:.703125},{x:.953125,y:.703125},{x:.984375,y:.703125},{x:.984375,y:.703125},{x:.015625,y:.734375},{x:.015625,y:.734375},{x:.046875,y:.734375},{x:.046875,y:.734375},{x:.078125,y:.734375},{x:.078125,y:.734375},{x:.109375,y:.734375},{x:.109375,y:.734375},{x:.140625,y:.734375},{x:.140625,y:.734375},{x:.171875,y:.734375},{x:.171875,y:.734375},{x:.203125,y:.734375},{x:.203125,y:.734375},{x:.234375,y:.734375},{x:.234375,y:.734375},{x:.265625,y:.734375},{x:.265625,y:.734375},{x:.296875,y:.734375},{x:.296875,y:.734375},{x:.328125,y:.734375},{x:.328125,y:.734375},{x:.359375,y:.734375},{x:.359375,y:.734375},{x:.390625,y:.734375},{x:.390625,y:.734375},{x:.421875,y:.734375},{x:.421875,y:.734375},{x:.453125,y:.734375},{x:.453125,y:.734375},{x:.484375,y:.734375},{x:.484375,y:.734375},{x:.515625,y:.734375},{x:.515625,y:.734375},{x:.546875,y:.734375},{x:.546875,y:.734375},{x:.578125,y:.734375},{x:.578125,y:.734375},{x:.609375,y:.734375},{x:.609375,y:.734375},{x:.640625,y:.734375},{x:.640625,y:.734375},{x:.671875,y:.734375},{x:.671875,y:.734375},{x:.703125,y:.734375},{x:.703125,y:.734375},{x:.734375,y:.734375},{x:.734375,y:.734375},{x:.765625,y:.734375},{x:.765625,y:.734375},{x:.796875,y:.734375},{x:.796875,y:.734375},{x:.828125,y:.734375},{x:.828125,y:.734375},{x:.859375,y:.734375},{x:.859375,y:.734375},{x:.890625,y:.734375},{x:.890625,y:.734375},{x:.921875,y:.734375},{x:.921875,y:.734375},{x:.953125,y:.734375},{x:.953125,y:.734375},{x:.984375,y:.734375},{x:.984375,y:.734375},{x:.015625,y:.765625},{x:.015625,y:.765625},{x:.046875,y:.765625},{x:.046875,y:.765625},{x:.078125,y:.765625},{x:.078125,y:.765625},{x:.109375,y:.765625},{x:.109375,y:.765625},{x:.140625,y:.765625},{x:.140625,y:.765625},{x:.171875,y:.765625},{x:.171875,y:.765625},{x:.203125,y:.765625},{x:.203125,y:.765625},{x:.234375,y:.765625},{x:.234375,y:.765625},{x:.265625,y:.765625},{x:.265625,y:.765625},{x:.296875,y:.765625},{x:.296875,y:.765625},{x:.328125,y:.765625},{x:.328125,y:.765625},{x:.359375,y:.765625},{x:.359375,y:.765625},{x:.390625,y:.765625},{x:.390625,y:.765625},{x:.421875,y:.765625},{x:.421875,y:.765625},{x:.453125,y:.765625},{x:.453125,y:.765625},{x:.484375,y:.765625},{x:.484375,y:.765625},{x:.515625,y:.765625},{x:.515625,y:.765625},{x:.546875,y:.765625},{x:.546875,y:.765625},{x:.578125,y:.765625},{x:.578125,y:.765625},{x:.609375,y:.765625},{x:.609375,y:.765625},{x:.640625,y:.765625},{x:.640625,y:.765625},{x:.671875,y:.765625},{x:.671875,y:.765625},{x:.703125,y:.765625},{x:.703125,y:.765625},{x:.734375,y:.765625},{x:.734375,y:.765625},{x:.765625,y:.765625},{x:.765625,y:.765625},{x:.796875,y:.765625},{x:.796875,y:.765625},{x:.828125,y:.765625},{x:.828125,y:.765625},{x:.859375,y:.765625},{x:.859375,y:.765625},{x:.890625,y:.765625},{x:.890625,y:.765625},{x:.921875,y:.765625},{x:.921875,y:.765625},{x:.953125,y:.765625},{x:.953125,y:.765625},{x:.984375,y:.765625},{x:.984375,y:.765625},{x:.015625,y:.796875},{x:.015625,y:.796875},{x:.046875,y:.796875},{x:.046875,y:.796875},{x:.078125,y:.796875},{x:.078125,y:.796875},{x:.109375,y:.796875},{x:.109375,y:.796875},{x:.140625,y:.796875},{x:.140625,y:.796875},{x:.171875,y:.796875},{x:.171875,y:.796875},{x:.203125,y:.796875},{x:.203125,y:.796875},{x:.234375,y:.796875},{x:.234375,y:.796875},{x:.265625,y:.796875},{x:.265625,y:.796875},{x:.296875,y:.796875},{x:.296875,y:.796875},{x:.328125,y:.796875},{x:.328125,y:.796875},{x:.359375,y:.796875},{x:.359375,y:.796875},{x:.390625,y:.796875},{x:.390625,y:.796875},{x:.421875,y:.796875},{x:.421875,y:.796875},{x:.453125,y:.796875},{x:.453125,y:.796875},{x:.484375,y:.796875},{x:.484375,y:.796875},{x:.515625,y:.796875},{x:.515625,y:.796875},{x:.546875,y:.796875},{x:.546875,y:.796875},{x:.578125,y:.796875},{x:.578125,y:.796875},{x:.609375,y:.796875},{x:.609375,y:.796875},{x:.640625,y:.796875},{x:.640625,y:.796875},{x:.671875,y:.796875},{x:.671875,y:.796875},{x:.703125,y:.796875},{x:.703125,y:.796875},{x:.734375,y:.796875},{x:.734375,y:.796875},{x:.765625,y:.796875},{x:.765625,y:.796875},{x:.796875,y:.796875},{x:.796875,y:.796875},{x:.828125,y:.796875},{x:.828125,y:.796875},{x:.859375,y:.796875},{x:.859375,y:.796875},{x:.890625,y:.796875},{x:.890625,y:.796875},{x:.921875,y:.796875},{x:.921875,y:.796875},{x:.953125,y:.796875},{x:.953125,y:.796875},{x:.984375,y:.796875},{x:.984375,y:.796875},{x:.015625,y:.828125},{x:.015625,y:.828125},{x:.046875,y:.828125},{x:.046875,y:.828125},{x:.078125,y:.828125},{x:.078125,y:.828125},{x:.109375,y:.828125},{x:.109375,y:.828125},{x:.140625,y:.828125},{x:.140625,y:.828125},{x:.171875,y:.828125},{x:.171875,y:.828125},{x:.203125,y:.828125},{x:.203125,y:.828125},{x:.234375,y:.828125},{x:.234375,y:.828125},{x:.265625,y:.828125},{x:.265625,y:.828125},{x:.296875,y:.828125},{x:.296875,y:.828125},{x:.328125,y:.828125},{x:.328125,y:.828125},{x:.359375,y:.828125},{x:.359375,y:.828125},{x:.390625,y:.828125},{x:.390625,y:.828125},{x:.421875,y:.828125},{x:.421875,y:.828125},{x:.453125,y:.828125},{x:.453125,y:.828125},{x:.484375,y:.828125},{x:.484375,y:.828125},{x:.515625,y:.828125},{x:.515625,y:.828125},{x:.546875,y:.828125},{x:.546875,y:.828125},{x:.578125,y:.828125},{x:.578125,y:.828125},{x:.609375,y:.828125},{x:.609375,y:.828125},{x:.640625,y:.828125},{x:.640625,y:.828125},{x:.671875,y:.828125},{x:.671875,y:.828125},{x:.703125,y:.828125},{x:.703125,y:.828125},{x:.734375,y:.828125},{x:.734375,y:.828125},{x:.765625,y:.828125},{x:.765625,y:.828125},{x:.796875,y:.828125},{x:.796875,y:.828125},{x:.828125,y:.828125},{x:.828125,y:.828125},{x:.859375,y:.828125},{x:.859375,y:.828125},{x:.890625,y:.828125},{x:.890625,y:.828125},{x:.921875,y:.828125},{x:.921875,y:.828125},{x:.953125,y:.828125},{x:.953125,y:.828125},{x:.984375,y:.828125},{x:.984375,y:.828125},{x:.015625,y:.859375},{x:.015625,y:.859375},{x:.046875,y:.859375},{x:.046875,y:.859375},{x:.078125,y:.859375},{x:.078125,y:.859375},{x:.109375,y:.859375},{x:.109375,y:.859375},{x:.140625,y:.859375},{x:.140625,y:.859375},{x:.171875,y:.859375},{x:.171875,y:.859375},{x:.203125,y:.859375},{x:.203125,y:.859375},{x:.234375,y:.859375},{x:.234375,y:.859375},{x:.265625,y:.859375},{x:.265625,y:.859375},{x:.296875,y:.859375},{x:.296875,y:.859375},{x:.328125,y:.859375},{x:.328125,y:.859375},{x:.359375,y:.859375},{x:.359375,y:.859375},{x:.390625,y:.859375},{x:.390625,y:.859375},{x:.421875,y:.859375},{x:.421875,y:.859375},{x:.453125,y:.859375},{x:.453125,y:.859375},{x:.484375,y:.859375},{x:.484375,y:.859375},{x:.515625,y:.859375},{x:.515625,y:.859375},{x:.546875,y:.859375},{x:.546875,y:.859375},{x:.578125,y:.859375},{x:.578125,y:.859375},{x:.609375,y:.859375},{x:.609375,y:.859375},{x:.640625,y:.859375},{x:.640625,y:.859375},{x:.671875,y:.859375},{x:.671875,y:.859375},{x:.703125,y:.859375},{x:.703125,y:.859375},{x:.734375,y:.859375},{x:.734375,y:.859375},{x:.765625,y:.859375},{x:.765625,y:.859375},{x:.796875,y:.859375},{x:.796875,y:.859375},{x:.828125,y:.859375},{x:.828125,y:.859375},{x:.859375,y:.859375},{x:.859375,y:.859375},{x:.890625,y:.859375},{x:.890625,y:.859375},{x:.921875,y:.859375},{x:.921875,y:.859375},{x:.953125,y:.859375},{x:.953125,y:.859375},{x:.984375,y:.859375},{x:.984375,y:.859375},{x:.015625,y:.890625},{x:.015625,y:.890625},{x:.046875,y:.890625},{x:.046875,y:.890625},{x:.078125,y:.890625},{x:.078125,y:.890625},{x:.109375,y:.890625},{x:.109375,y:.890625},{x:.140625,y:.890625},{x:.140625,y:.890625},{x:.171875,y:.890625},{x:.171875,y:.890625},{x:.203125,y:.890625},{x:.203125,y:.890625},{x:.234375,y:.890625},{x:.234375,y:.890625},{x:.265625,y:.890625},{x:.265625,y:.890625},{x:.296875,y:.890625},{x:.296875,y:.890625},{x:.328125,y:.890625},{x:.328125,y:.890625},{x:.359375,y:.890625},{x:.359375,y:.890625},{x:.390625,y:.890625},{x:.390625,y:.890625},{x:.421875,y:.890625},{x:.421875,y:.890625},{x:.453125,y:.890625},{x:.453125,y:.890625},{x:.484375,y:.890625},{x:.484375,y:.890625},{x:.515625,y:.890625},{x:.515625,y:.890625},{x:.546875,y:.890625},{x:.546875,y:.890625},{x:.578125,y:.890625},{x:.578125,y:.890625},{x:.609375,y:.890625},{x:.609375,y:.890625},{x:.640625,y:.890625},{x:.640625,y:.890625},{x:.671875,y:.890625},{x:.671875,y:.890625},{x:.703125,y:.890625},{x:.703125,y:.890625},{x:.734375,y:.890625},{x:.734375,y:.890625},{x:.765625,y:.890625},{x:.765625,y:.890625},{x:.796875,y:.890625},{x:.796875,y:.890625},{x:.828125,y:.890625},{x:.828125,y:.890625},{x:.859375,y:.890625},{x:.859375,y:.890625},{x:.890625,y:.890625},{x:.890625,y:.890625},{x:.921875,y:.890625},{x:.921875,y:.890625},{x:.953125,y:.890625},{x:.953125,y:.890625},{x:.984375,y:.890625},{x:.984375,y:.890625},{x:.015625,y:.921875},{x:.015625,y:.921875},{x:.046875,y:.921875},{x:.046875,y:.921875},{x:.078125,y:.921875},{x:.078125,y:.921875},{x:.109375,y:.921875},{x:.109375,y:.921875},{x:.140625,y:.921875},{x:.140625,y:.921875},{x:.171875,y:.921875},{x:.171875,y:.921875},{x:.203125,y:.921875},{x:.203125,y:.921875},{x:.234375,y:.921875},{x:.234375,y:.921875},{x:.265625,y:.921875},{x:.265625,y:.921875},{x:.296875,y:.921875},{x:.296875,y:.921875},{x:.328125,y:.921875},{x:.328125,y:.921875},{x:.359375,y:.921875},{x:.359375,y:.921875},{x:.390625,y:.921875},{x:.390625,y:.921875},{x:.421875,y:.921875},{x:.421875,y:.921875},{x:.453125,y:.921875},{x:.453125,y:.921875},{x:.484375,y:.921875},{x:.484375,y:.921875},{x:.515625,y:.921875},{x:.515625,y:.921875},{x:.546875,y:.921875},{x:.546875,y:.921875},{x:.578125,y:.921875},{x:.578125,y:.921875},{x:.609375,y:.921875},{x:.609375,y:.921875},{x:.640625,y:.921875},{x:.640625,y:.921875},{x:.671875,y:.921875},{x:.671875,y:.921875},{x:.703125,y:.921875},{x:.703125,y:.921875},{x:.734375,y:.921875},{x:.734375,y:.921875},{x:.765625,y:.921875},{x:.765625,y:.921875},{x:.796875,y:.921875},{x:.796875,y:.921875},{x:.828125,y:.921875},{x:.828125,y:.921875},{x:.859375,y:.921875},{x:.859375,y:.921875},{x:.890625,y:.921875},{x:.890625,y:.921875},{x:.921875,y:.921875},{x:.921875,y:.921875},{x:.953125,y:.921875},{x:.953125,y:.921875},{x:.984375,y:.921875},{x:.984375,y:.921875},{x:.015625,y:.953125},{x:.015625,y:.953125},{x:.046875,y:.953125},{x:.046875,y:.953125},{x:.078125,y:.953125},{x:.078125,y:.953125},{x:.109375,y:.953125},{x:.109375,y:.953125},{x:.140625,y:.953125},{x:.140625,y:.953125},{x:.171875,y:.953125},{x:.171875,y:.953125},{x:.203125,y:.953125},{x:.203125,y:.953125},{x:.234375,y:.953125},{x:.234375,y:.953125},{x:.265625,y:.953125},{x:.265625,y:.953125},{x:.296875,y:.953125},{x:.296875,y:.953125},{x:.328125,y:.953125},{x:.328125,y:.953125},{x:.359375,y:.953125},{x:.359375,y:.953125},{x:.390625,y:.953125},{x:.390625,y:.953125},{x:.421875,y:.953125},{x:.421875,y:.953125},{x:.453125,y:.953125},{x:.453125,y:.953125},{x:.484375,y:.953125},{x:.484375,y:.953125},{x:.515625,y:.953125},{x:.515625,y:.953125},{x:.546875,y:.953125},{x:.546875,y:.953125},{x:.578125,y:.953125},{x:.578125,y:.953125},{x:.609375,y:.953125},{x:.609375,y:.953125},{x:.640625,y:.953125},{x:.640625,y:.953125},{x:.671875,y:.953125},{x:.671875,y:.953125},{x:.703125,y:.953125},{x:.703125,y:.953125},{x:.734375,y:.953125},{x:.734375,y:.953125},{x:.765625,y:.953125},{x:.765625,y:.953125},{x:.796875,y:.953125},{x:.796875,y:.953125},{x:.828125,y:.953125},{x:.828125,y:.953125},{x:.859375,y:.953125},{x:.859375,y:.953125},{x:.890625,y:.953125},{x:.890625,y:.953125},{x:.921875,y:.953125},{x:.921875,y:.953125},{x:.953125,y:.953125},{x:.953125,y:.953125},{x:.984375,y:.953125},{x:.984375,y:.953125},{x:.015625,y:.984375},{x:.015625,y:.984375},{x:.046875,y:.984375},{x:.046875,y:.984375},{x:.078125,y:.984375},{x:.078125,y:.984375},{x:.109375,y:.984375},{x:.109375,y:.984375},{x:.140625,y:.984375},{x:.140625,y:.984375},{x:.171875,y:.984375},{x:.171875,y:.984375},{x:.203125,y:.984375},{x:.203125,y:.984375},{x:.234375,y:.984375},{x:.234375,y:.984375},{x:.265625,y:.984375},{x:.265625,y:.984375},{x:.296875,y:.984375},{x:.296875,y:.984375},{x:.328125,y:.984375},{x:.328125,y:.984375},{x:.359375,y:.984375},{x:.359375,y:.984375},{x:.390625,y:.984375},{x:.390625,y:.984375},{x:.421875,y:.984375},{x:.421875,y:.984375},{x:.453125,y:.984375},{x:.453125,y:.984375},{x:.484375,y:.984375},{x:.484375,y:.984375},{x:.515625,y:.984375},{x:.515625,y:.984375},{x:.546875,y:.984375},{x:.546875,y:.984375},{x:.578125,y:.984375},{x:.578125,y:.984375},{x:.609375,y:.984375},{x:.609375,y:.984375},{x:.640625,y:.984375},{x:.640625,y:.984375},{x:.671875,y:.984375},{x:.671875,y:.984375},{x:.703125,y:.984375},{x:.703125,y:.984375},{x:.734375,y:.984375},{x:.734375,y:.984375},{x:.765625,y:.984375},{x:.765625,y:.984375},{x:.796875,y:.984375},{x:.796875,y:.984375},{x:.828125,y:.984375},{x:.828125,y:.984375},{x:.859375,y:.984375},{x:.859375,y:.984375},{x:.890625,y:.984375},{x:.890625,y:.984375},{x:.921875,y:.984375},{x:.921875,y:.984375},{x:.953125,y:.984375},{x:.953125,y:.984375},{x:.984375,y:.984375},{x:.984375,y:.984375},{x:.03125,y:.03125},{x:.03125,y:.03125},{x:.09375,y:.03125},{x:.09375,y:.03125},{x:.15625,y:.03125},{x:.15625,y:.03125},{x:.21875,y:.03125},{x:.21875,y:.03125},{x:.28125,y:.03125},{x:.28125,y:.03125},{x:.34375,y:.03125},{x:.34375,y:.03125},{x:.40625,y:.03125},{x:.40625,y:.03125},{x:.46875,y:.03125},{x:.46875,y:.03125},{x:.53125,y:.03125},{x:.53125,y:.03125},{x:.59375,y:.03125},{x:.59375,y:.03125},{x:.65625,y:.03125},{x:.65625,y:.03125},{x:.71875,y:.03125},{x:.71875,y:.03125},{x:.78125,y:.03125},{x:.78125,y:.03125},{x:.84375,y:.03125},{x:.84375,y:.03125},{x:.90625,y:.03125},{x:.90625,y:.03125},{x:.96875,y:.03125},{x:.96875,y:.03125},{x:.03125,y:.09375},{x:.03125,y:.09375},{x:.09375,y:.09375},{x:.09375,y:.09375},{x:.15625,y:.09375},{x:.15625,y:.09375},{x:.21875,y:.09375},{x:.21875,y:.09375},{x:.28125,y:.09375},{x:.28125,y:.09375},{x:.34375,y:.09375},{x:.34375,y:.09375},{x:.40625,y:.09375},{x:.40625,y:.09375},{x:.46875,y:.09375},{x:.46875,y:.09375},{x:.53125,y:.09375},{x:.53125,y:.09375},{x:.59375,y:.09375},{x:.59375,y:.09375},{x:.65625,y:.09375},{x:.65625,y:.09375},{x:.71875,y:.09375},{x:.71875,y:.09375},{x:.78125,y:.09375},{x:.78125,y:.09375},{x:.84375,y:.09375},{x:.84375,y:.09375},{x:.90625,y:.09375},{x:.90625,y:.09375},{x:.96875,y:.09375},{x:.96875,y:.09375},{x:.03125,y:.15625},{x:.03125,y:.15625},{x:.09375,y:.15625},{x:.09375,y:.15625},{x:.15625,y:.15625},{x:.15625,y:.15625},{x:.21875,y:.15625},{x:.21875,y:.15625},{x:.28125,y:.15625},{x:.28125,y:.15625},{x:.34375,y:.15625},{x:.34375,y:.15625},{x:.40625,y:.15625},{x:.40625,y:.15625},{x:.46875,y:.15625},{x:.46875,y:.15625},{x:.53125,y:.15625},{x:.53125,y:.15625},{x:.59375,y:.15625},{x:.59375,y:.15625},{x:.65625,y:.15625},{x:.65625,y:.15625},{x:.71875,y:.15625},{x:.71875,y:.15625},{x:.78125,y:.15625},{x:.78125,y:.15625},{x:.84375,y:.15625},{x:.84375,y:.15625},{x:.90625,y:.15625},{x:.90625,y:.15625},{x:.96875,y:.15625},{x:.96875,y:.15625},{x:.03125,y:.21875},{x:.03125,y:.21875},{x:.09375,y:.21875},{x:.09375,y:.21875},{x:.15625,y:.21875},{x:.15625,y:.21875},{x:.21875,y:.21875},{x:.21875,y:.21875},{x:.28125,y:.21875},{x:.28125,y:.21875},{x:.34375,y:.21875},{x:.34375,y:.21875},{x:.40625,y:.21875},{x:.40625,y:.21875},{x:.46875,y:.21875},{x:.46875,y:.21875},{x:.53125,y:.21875},{x:.53125,y:.21875},{x:.59375,y:.21875},{x:.59375,y:.21875},{x:.65625,y:.21875},{x:.65625,y:.21875},{x:.71875,y:.21875},{x:.71875,y:.21875},{x:.78125,y:.21875},{x:.78125,y:.21875},{x:.84375,y:.21875},{x:.84375,y:.21875},{x:.90625,y:.21875},{x:.90625,y:.21875},{x:.96875,y:.21875},{x:.96875,y:.21875},{x:.03125,y:.28125},{x:.03125,y:.28125},{x:.09375,y:.28125},{x:.09375,y:.28125},{x:.15625,y:.28125},{x:.15625,y:.28125},{x:.21875,y:.28125},{x:.21875,y:.28125},{x:.28125,y:.28125},{x:.28125,y:.28125},{x:.34375,y:.28125},{x:.34375,y:.28125},{x:.40625,y:.28125},{x:.40625,y:.28125},{x:.46875,y:.28125},{x:.46875,y:.28125},{x:.53125,y:.28125},{x:.53125,y:.28125},{x:.59375,y:.28125},{x:.59375,y:.28125},{x:.65625,y:.28125},{x:.65625,y:.28125},{x:.71875,y:.28125},{x:.71875,y:.28125},{x:.78125,y:.28125},{x:.78125,y:.28125},{x:.84375,y:.28125},{x:.84375,y:.28125},{x:.90625,y:.28125},{x:.90625,y:.28125},{x:.96875,y:.28125},{x:.96875,y:.28125},{x:.03125,y:.34375},{x:.03125,y:.34375},{x:.09375,y:.34375},{x:.09375,y:.34375},{x:.15625,y:.34375},{x:.15625,y:.34375},{x:.21875,y:.34375},{x:.21875,y:.34375},{x:.28125,y:.34375},{x:.28125,y:.34375},{x:.34375,y:.34375},{x:.34375,y:.34375},{x:.40625,y:.34375},{x:.40625,y:.34375},{x:.46875,y:.34375},{x:.46875,y:.34375},{x:.53125,y:.34375},{x:.53125,y:.34375},{x:.59375,y:.34375},{x:.59375,y:.34375},{x:.65625,y:.34375},{x:.65625,y:.34375},{x:.71875,y:.34375},{x:.71875,y:.34375},{x:.78125,y:.34375},{x:.78125,y:.34375},{x:.84375,y:.34375},{x:.84375,y:.34375},{x:.90625,y:.34375},{x:.90625,y:.34375},{x:.96875,y:.34375},{x:.96875,y:.34375},{x:.03125,y:.40625},{x:.03125,y:.40625},{x:.09375,y:.40625},{x:.09375,y:.40625},{x:.15625,y:.40625},{x:.15625,y:.40625},{x:.21875,y:.40625},{x:.21875,y:.40625},{x:.28125,y:.40625},{x:.28125,y:.40625},{x:.34375,y:.40625},{x:.34375,y:.40625},{x:.40625,y:.40625},{x:.40625,y:.40625},{x:.46875,y:.40625},{x:.46875,y:.40625},{x:.53125,y:.40625},{x:.53125,y:.40625},{x:.59375,y:.40625},{x:.59375,y:.40625},{x:.65625,y:.40625},{x:.65625,y:.40625},{x:.71875,y:.40625},{x:.71875,y:.40625},{x:.78125,y:.40625},{x:.78125,y:.40625},{x:.84375,y:.40625},{x:.84375,y:.40625},{x:.90625,y:.40625},{x:.90625,y:.40625},{x:.96875,y:.40625},{x:.96875,y:.40625},{x:.03125,y:.46875},{x:.03125,y:.46875},{x:.09375,y:.46875},{x:.09375,y:.46875},{x:.15625,y:.46875},{x:.15625,y:.46875},{x:.21875,y:.46875},{x:.21875,y:.46875},{x:.28125,y:.46875},{x:.28125,y:.46875},{x:.34375,y:.46875},{x:.34375,y:.46875},{x:.40625,y:.46875},{x:.40625,y:.46875},{x:.46875,y:.46875},{x:.46875,y:.46875},{x:.53125,y:.46875},{x:.53125,y:.46875},{x:.59375,y:.46875},{x:.59375,y:.46875},{x:.65625,y:.46875},{x:.65625,y:.46875},{x:.71875,y:.46875},{x:.71875,y:.46875},{x:.78125,y:.46875},{x:.78125,y:.46875},{x:.84375,y:.46875},{x:.84375,y:.46875},{x:.90625,y:.46875},{x:.90625,y:.46875},{x:.96875,y:.46875},{x:.96875,y:.46875},{x:.03125,y:.53125},{x:.03125,y:.53125},{x:.09375,y:.53125},{x:.09375,y:.53125},{x:.15625,y:.53125},{x:.15625,y:.53125},{x:.21875,y:.53125},{x:.21875,y:.53125},{x:.28125,y:.53125},{x:.28125,y:.53125},{x:.34375,y:.53125},{x:.34375,y:.53125},{x:.40625,y:.53125},{x:.40625,y:.53125},{x:.46875,y:.53125},{x:.46875,y:.53125},{x:.53125,y:.53125},{x:.53125,y:.53125},{x:.59375,y:.53125},{x:.59375,y:.53125},{x:.65625,y:.53125},{x:.65625,y:.53125},{x:.71875,y:.53125},{x:.71875,y:.53125},{x:.78125,y:.53125},{x:.78125,y:.53125},{x:.84375,y:.53125},{x:.84375,y:.53125},{x:.90625,y:.53125},{x:.90625,y:.53125},{x:.96875,y:.53125},{x:.96875,y:.53125},{x:.03125,y:.59375},{x:.03125,y:.59375},{x:.09375,y:.59375},{x:.09375,y:.59375},{x:.15625,y:.59375},{x:.15625,y:.59375},{x:.21875,y:.59375},{x:.21875,y:.59375},{x:.28125,y:.59375},{x:.28125,y:.59375},{x:.34375,y:.59375},{x:.34375,y:.59375},{x:.40625,y:.59375},{x:.40625,y:.59375},{x:.46875,y:.59375},{x:.46875,y:.59375},{x:.53125,y:.59375},{x:.53125,y:.59375},{x:.59375,y:.59375},{x:.59375,y:.59375},{x:.65625,y:.59375},{x:.65625,y:.59375},{x:.71875,y:.59375},{x:.71875,y:.59375},{x:.78125,y:.59375},{x:.78125,y:.59375},{x:.84375,y:.59375},{x:.84375,y:.59375},{x:.90625,y:.59375},{x:.90625,y:.59375},{x:.96875,y:.59375},{x:.96875,y:.59375},{x:.03125,y:.65625},{x:.03125,y:.65625},{x:.09375,y:.65625},{x:.09375,y:.65625},{x:.15625,y:.65625},{x:.15625,y:.65625},{x:.21875,y:.65625},{x:.21875,y:.65625},{x:.28125,y:.65625},{x:.28125,y:.65625},{x:.34375,y:.65625},{x:.34375,y:.65625},{x:.40625,y:.65625},{x:.40625,y:.65625},{x:.46875,y:.65625},{x:.46875,y:.65625},{x:.53125,y:.65625},{x:.53125,y:.65625},{x:.59375,y:.65625},{x:.59375,y:.65625},{x:.65625,y:.65625},{x:.65625,y:.65625},{x:.71875,y:.65625},{x:.71875,y:.65625},{x:.78125,y:.65625},{x:.78125,y:.65625},{x:.84375,y:.65625},{x:.84375,y:.65625},{x:.90625,y:.65625},{x:.90625,y:.65625},{x:.96875,y:.65625},{x:.96875,y:.65625},{x:.03125,y:.71875},{x:.03125,y:.71875},{x:.09375,y:.71875},{x:.09375,y:.71875},{x:.15625,y:.71875},{x:.15625,y:.71875},{x:.21875,y:.71875},{x:.21875,y:.71875},{x:.28125,y:.71875},{x:.28125,y:.71875},{x:.34375,y:.71875},{x:.34375,y:.71875},{x:.40625,y:.71875},{x:.40625,y:.71875},{x:.46875,y:.71875},{x:.46875,y:.71875},{x:.53125,y:.71875},{x:.53125,y:.71875},{x:.59375,y:.71875},{x:.59375,y:.71875},{x:.65625,y:.71875},{x:.65625,y:.71875},{x:.71875,y:.71875},{x:.71875,y:.71875},{x:.78125,y:.71875},{x:.78125,y:.71875},{x:.84375,y:.71875},{x:.84375,y:.71875},{x:.90625,y:.71875},{x:.90625,y:.71875},{x:.96875,y:.71875},{x:.96875,y:.71875},{x:.03125,y:.78125},{x:.03125,y:.78125},{x:.09375,y:.78125},{x:.09375,y:.78125},{x:.15625,y:.78125},{x:.15625,y:.78125},{x:.21875,y:.78125},{x:.21875,y:.78125},{x:.28125,y:.78125},{x:.28125,y:.78125},{x:.34375,y:.78125},{x:.34375,y:.78125},{x:.40625,y:.78125},{x:.40625,y:.78125},{x:.46875,y:.78125},{x:.46875,y:.78125},{x:.53125,y:.78125},{x:.53125,y:.78125},{x:.59375,y:.78125},{x:.59375,y:.78125},{x:.65625,y:.78125},{x:.65625,y:.78125},{x:.71875,y:.78125},{x:.71875,y:.78125},{x:.78125,y:.78125},{x:.78125,y:.78125},{x:.84375,y:.78125},{x:.84375,y:.78125},{x:.90625,y:.78125},{x:.90625,y:.78125},{x:.96875,y:.78125},{x:.96875,y:.78125},{x:.03125,y:.84375},{x:.03125,y:.84375},{x:.09375,y:.84375},{x:.09375,y:.84375},{x:.15625,y:.84375},{x:.15625,y:.84375},{x:.21875,y:.84375},{x:.21875,y:.84375},{x:.28125,y:.84375},{x:.28125,y:.84375},{x:.34375,y:.84375},{x:.34375,y:.84375},{x:.40625,y:.84375},{x:.40625,y:.84375},{x:.46875,y:.84375},{x:.46875,y:.84375},{x:.53125,y:.84375},{x:.53125,y:.84375},{x:.59375,y:.84375},{x:.59375,y:.84375},{x:.65625,y:.84375},{x:.65625,y:.84375},{x:.71875,y:.84375},{x:.71875,y:.84375},{x:.78125,y:.84375},{x:.78125,y:.84375},{x:.84375,y:.84375},{x:.84375,y:.84375},{x:.90625,y:.84375},{x:.90625,y:.84375},{x:.96875,y:.84375},{x:.96875,y:.84375},{x:.03125,y:.90625},{x:.03125,y:.90625},{x:.09375,y:.90625},{x:.09375,y:.90625},{x:.15625,y:.90625},{x:.15625,y:.90625},{x:.21875,y:.90625},{x:.21875,y:.90625},{x:.28125,y:.90625},{x:.28125,y:.90625},{x:.34375,y:.90625},{x:.34375,y:.90625},{x:.40625,y:.90625},{x:.40625,y:.90625},{x:.46875,y:.90625},{x:.46875,y:.90625},{x:.53125,y:.90625},{x:.53125,y:.90625},{x:.59375,y:.90625},{x:.59375,y:.90625},{x:.65625,y:.90625},{x:.65625,y:.90625},{x:.71875,y:.90625},{x:.71875,y:.90625},{x:.78125,y:.90625},{x:.78125,y:.90625},{x:.84375,y:.90625},{x:.84375,y:.90625},{x:.90625,y:.90625},{x:.90625,y:.90625},{x:.96875,y:.90625},{x:.96875,y:.90625},{x:.03125,y:.96875},{x:.03125,y:.96875},{x:.09375,y:.96875},{x:.09375,y:.96875},{x:.15625,y:.96875},{x:.15625,y:.96875},{x:.21875,y:.96875},{x:.21875,y:.96875},{x:.28125,y:.96875},{x:.28125,y:.96875},{x:.34375,y:.96875},{x:.34375,y:.96875},{x:.40625,y:.96875},{x:.40625,y:.96875},{x:.46875,y:.96875},{x:.46875,y:.96875},{x:.53125,y:.96875},{x:.53125,y:.96875},{x:.59375,y:.96875},{x:.59375,y:.96875},{x:.65625,y:.96875},{x:.65625,y:.96875},{x:.71875,y:.96875},{x:.71875,y:.96875},{x:.78125,y:.96875},{x:.78125,y:.96875},{x:.84375,y:.96875},{x:.84375,y:.96875},{x:.90625,y:.96875},{x:.90625,y:.96875},{x:.96875,y:.96875},{x:.96875,y:.96875},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375}];var x7=class{constructor(t){nt(this,"model");nt(this,"anchors");nt(this,"anchorsTensor");nt(this,"inputSize");nt(this,"inputSizeTensor");nt(this,"doubleInputSizeTensor");this.model=t,this.anchors=sj.map(n=>[n.x,n.y]),this.anchorsTensor=bi(this.anchors),this.inputSize=this.model&&this.model.inputs&&this.model.inputs[0].shape?this.model.inputs[0].shape[2]:0,this.inputSizeTensor=Er([this.inputSize,this.inputSize]),this.doubleInputSizeTensor=Er([this.inputSize*2,this.inputSize*2])}normalizeBoxes(t){return ce(()=>{let n=gt(t,[0,0],[-1,2]),r=gt(t,[0,2],[-1,2]),s=Re(Me(n,this.inputSizeTensor),this.anchorsTensor),o=Me(r,this.doubleInputSizeTensor),a=te(Ge(s,o),this.inputSizeTensor),i=te(Re(s,o),this.inputSizeTensor);return v0([a,i],1)})}normalizeLandmarks(t,n){return ce(()=>{let r=Re(Me(ie(t,[-1,7,2]),this.inputSizeTensor),this.anchors[n]);return te(r,this.inputSizeTensor)})}async getBoxes(t,n){let r={};r.batched=this.model.predict(t),r.predictions=ln(r.batched),r.scores=ce(()=>ln(xo(gt(r.predictions,[0,0],[-1,1]))));let s=await r.scores.data();r.boxes=gt(r.predictions,[0,1],[-1,4]),r.norm=this.normalizeBoxes(r.boxes),r.nms=await ht.nonMaxSuppressionAsync(r.norm,r.scores,3*n.hand.maxDetected,n.hand.iouThreshold,n.hand.minConfidence);let o=await r.nms.array(),a=[];for(let i of o){let l=gt(r.norm,[i,0],[1,-1]),u=ce(()=>ie(this.normalizeLandmarks(gt(r.predictions,[i,5],[1,14]),i),[-1,2]));a.push({box:l,palmLandmarks:u,confidence:s[i]})}for(let i of Object.keys(r))ye(r[i]);return a}async estimateHandBounds(t,n){let r=t.shape[1],s=t.shape[2],o=ce(()=>Ge(Me(ht.resizeBilinear(t,[this.inputSize,this.inputSize]),127.5),1)),a=await this.getBoxes(o,n);ye(o);let i=[];if(!a||a.length===0)return i;for(let l of a){let u=await l.box.data(),c=u.slice(0,2),p=u.slice(2,4),d=await l.palmLandmarks.array();ye(l.box),ye(l.palmLandmarks),i.push(rj({startPoint:c,endPoint:p,palmLandmarks:d,confidence:l.confidence},[s/this.inputSize,r/this.inputSize]))}return i}};function A9e(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function oj(e,t){let n=Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]);return A9e(n)}var aj=(e,t)=>[[1,0,e],[0,1,t],[0,0,1]];function ip(e,t){let n=0;for(let r=0;r<e.length;r++)n+=e[r]*t[r];return n}function v9e(e,t){let n=[];for(let r=0;r<e.length;r++)n.push(e[r][t]);return n}function ij(e,t){let n=[],r=e.length;for(let s=0;s<r;s++){n.push([]);for(let o=0;o<r;o++)n[s].push(ip(e[s],v9e(t,o)))}return n}function y7(e,t){let n=Math.cos(e),r=Math.sin(e),s=[[n,-r,0],[r,n,0],[0,0,1]],o=aj(t[0],t[1]),a=ij(o,s),i=aj(-t[0],-t[1]);return ij(a,i)}function lj(e){let t=[[e[0][0],e[1][0]],[e[0][1],e[1][1]]],n=[e[0][2],e[1][2]],r=[-ip(t[0],n),-ip(t[1],n)];return[t[0].concat(r[0]),t[1].concat(r[1]),[0,0,1]]}function b7(e,t){return[ip(e,t[0]),ip(e,t[1])]}var w9e=5,uj=1.65,cj=[0,5,9,13,17,1,2],k9e=0,I9e=2,A7=class{constructor(t,n){nt(this,"handDetector");nt(this,"handPoseModel");nt(this,"inputSize");nt(this,"storedBoxes");nt(this,"skipped");nt(this,"detectedHands");this.handDetector=t,this.handPoseModel=n,this.inputSize=this.handPoseModel&&this.handPoseModel.inputs[0].shape?this.handPoseModel.inputs[0].shape[2]:0,this.storedBoxes=[],this.skipped=0,this.detectedHands=0}calculateLandmarksBoundingBox(t){let n=t.map(a=>a[0]),r=t.map(a=>a[1]),s=[Math.min(...n),Math.min(...r)],o=[Math.max(...n),Math.max(...r)];return{startPoint:s,endPoint:o}}getBoxForPalmLandmarks(t,n){let r=t.map(o=>b7([...o,1],n)),s=this.calculateLandmarksBoundingBox(r);return s3(o3(s),w9e)}getBoxForHandLandmarks(t){let n=this.calculateLandmarksBoundingBox(t),r=s3(o3(n),uj);r.palmLandmarks=[];for(let s=0;s<cj.length;s++)r.palmLandmarks.push(t[cj[s]].slice(0,2));return r}transformRawCoords(t,n,r,s){let o=r3(n),a=[o[0]/this.inputSize,o[1]/this.inputSize,(o[0]+o[1])/this.inputSize/2],i=t.map(f=>[a[0]*(f[0]-this.inputSize/2),a[1]*(f[1]-this.inputSize/2),a[2]*f[2]]),l=y7(r,[0,0]),u=i.map(f=>[...b7(f,l),f[2]]),c=lj(s),p=[...AA(n),1],d=[ip(p,c[0]),ip(p,c[1])];return u.map(f=>[Math.trunc(f[0]+d[0]),Math.trunc(f[1]+d[1]),Math.trunc(f[2])])}async estimateHands(t,n){let r=!1,s;(this.skipped===0||this.skipped>n.hand.skipFrames||!n.hand.landmarks||!n.skipFrame)&&(s=await this.handDetector.estimateHandBounds(t,n),this.skipped=0),n.skipFrame&&this.skipped++,s&&s.length>0&&(s.length!==this.detectedHands&&this.detectedHands!==n.hand.maxDetected||!n.hand.landmarks)&&(this.detectedHands=0,this.storedBoxes=[...s],this.storedBoxes.length>0&&(r=!0));let o=[];for(let a=0;a<this.storedBoxes.length;a++){let i=this.storedBoxes[a];if(!!i)if(n.hand.landmarks){let l=n.hand.rotation?oj(i.palmLandmarks[k9e],i.palmLandmarks[I9e]):0,u=AA(i),c=[u[0]/t.shape[2],u[1]/t.shape[1]],p=n.hand.rotation&&Ee.kernels.includes("rotatewithoffset")?ht.rotateWithOffset(t,l,0,c):t.clone(),d=y7(-l,u),f=r?this.getBoxForPalmLandmarks(i.palmLandmarks,d):i,h=nj(f,p,[this.inputSize,this.inputSize]),m=Me(h,255);ye(h),ye(p);let[g,x]=await this.handPoseModel.predict(m);ye(m);let y=(await g.data())[0];if(ye(g),y>=n.hand.minConfidence/4){let b=ie(x,[-1,3]),A=await b.array();ye(x),ye(b);let v=this.transformRawCoords(A,f,l,d),w=this.getBoxForHandLandmarks(v);this.storedBoxes[a]={...w,confidence:y};let k={landmarks:v,confidence:y,boxConfidence:i.confidence,fingerConfidence:y,box:{topLeft:w.startPoint,bottomRight:w.endPoint}};o.push(k)}else this.storedBoxes[a]=null;ye(x)}else{let l=s3(o3(i),uj),u={confidence:i.confidence,boxConfidence:i.confidence,fingerConfidence:0,box:{topLeft:l.startPoint,bottomRight:l.endPoint},landmarks:[]};o.push(u)}}return this.storedBoxes=this.storedBoxes.filter(a=>a!==null),this.detectedHands=o.length,o.length>n.hand.maxDetected&&(o.length=n.hand.maxDetected),o}};var Ut={thumb:0,index:1,middle:2,ring:3,pinky:4,all:[0,1,2,3,4],nameMapping:{0:"thumb",1:"index",2:"middle",3:"ring",4:"pinky"},pointsMapping:{0:[[0,1],[1,2],[2,3],[3,4]],1:[[0,5],[5,6],[6,7],[7,8]],2:[[0,9],[9,10],[10,11],[11,12]],3:[[0,13],[13,14],[14,15],[15,16]],4:[[0,17],[17,18],[18,19],[19,20]]},getName:e=>Ut.nameMapping[e],getPoints:e=>Ut.pointsMapping[e]},Co={none:0,half:1,full:2,nameMapping:{0:"none",1:"half",2:"full"},getName:e=>Co.nameMapping[e]},Gt={verticalUp:0,verticalDown:1,horizontalLeft:2,horizontalRight:3,diagonalUpRight:4,diagonalUpLeft:5,diagonalDownRight:6,diagonalDownLeft:7,nameMapping:{0:"verticalUp",1:"verticalDown",2:"horizontalLeft",3:"horizontalRight",4:"diagonalUpRight",5:"diagonalUpLeft",6:"diagonalDownRight",7:"diagonalDownLeft"},getName:e=>Gt.nameMapping[e]},a3=class{constructor(t){nt(this,"name");nt(this,"curls");nt(this,"directions");nt(this,"weights");nt(this,"weightsRelative");this.name=t,this.curls={},this.directions={},this.weights=[1,1,1,1,1],this.weightsRelative=[1,1,1,1,1]}addCurl(t,n,r){typeof this.curls[t]=="undefined"&&(this.curls[t]=[]),this.curls[t].push([n,r])}addDirection(t,n,r){this.directions[t]||(this.directions[t]=[]),this.directions[t].push([n,r])}setWeight(t,n){this.weights[t]=n;let r=this.weights.reduce((s,o)=>s+o,0);this.weightsRelative=this.weights.map(s=>s*5/r)}matchAgainst(t,n){let r=0;for(let s in t){let o=t[s],a=this.curls[s];if(typeof a=="undefined"){r+=this.weightsRelative[s];continue}for(let[i,l]of a)if(o===i){r+=l*this.weightsRelative[s];break}}for(let s in n){let o=n[s],a=this.directions[s];if(typeof a=="undefined"){r+=this.weightsRelative[s];continue}for(let[i,l]of a)if(o===i){r+=l*this.weightsRelative[s];break}}return r/10}};var lp=new a3("thumbs up");lp.addCurl(Ut.thumb,Co.none,1);lp.addDirection(Ut.thumb,Gt.verticalUp,1);lp.addDirection(Ut.thumb,Gt.diagonalUpLeft,.25);lp.addDirection(Ut.thumb,Gt.diagonalUpRight,.25);for(let e of[Ut.index,Ut.middle,Ut.ring,Ut.pinky])lp.addCurl(e,Co.full,1),lp.addDirection(e,Gt.horizontalLeft,1),lp.addDirection(e,Gt.horizontalRight,1);var Fr=new a3("victory");Fr.addCurl(Ut.thumb,Co.half,.5);Fr.addCurl(Ut.thumb,Co.none,.5);Fr.addDirection(Ut.thumb,Gt.verticalUp,1);Fr.addDirection(Ut.thumb,Gt.diagonalUpLeft,1);Fr.addCurl(Ut.index,Co.none,1);Fr.addDirection(Ut.index,Gt.verticalUp,.75);Fr.addDirection(Ut.index,Gt.diagonalUpLeft,1);Fr.addCurl(Ut.middle,Co.none,1);Fr.addDirection(Ut.middle,Gt.verticalUp,1);Fr.addDirection(Ut.middle,Gt.diagonalUpLeft,.75);Fr.addCurl(Ut.ring,Co.full,1);Fr.addDirection(Ut.ring,Gt.verticalUp,.2);Fr.addDirection(Ut.ring,Gt.diagonalUpLeft,1);Fr.addDirection(Ut.ring,Gt.horizontalLeft,.2);Fr.addCurl(Ut.pinky,Co.full,1);Fr.addDirection(Ut.pinky,Gt.verticalUp,.2);Fr.addDirection(Ut.pinky,Gt.diagonalUpLeft,1);Fr.addDirection(Ut.pinky,Gt.horizontalLeft,.2);Fr.setWeight(Ut.index,2);Fr.setWeight(Ut.middle,2);var pj=[lp,Fr];var C9e=.7,wh={HALF_CURL_START_LIMIT:60,NO_CURL_START_LIMIT:130,DISTANCE_VOTE_POWER:1.1,SINGLE_ANGLE_VOTE_POWER:.9,TOTAL_ANGLE_VOTE_POWER:1.6};function dj(e,t,n,r){let s=(t-r)/(e-n),o=Math.atan(s)*180/Math.PI;return o<=0?o=-o:o>0&&(o=180-o),o}function fj(e,t){if(!e||!t)return[0,0];let n=dj(e[0],e[1],t[0],t[1]);if(e.length===2)return n;let r=dj(e[1],e[2],t[1],t[2]);return[n,r]}function hj(e,t=1){let n=0,r=0,s=0;return e>=75&&e<=105?n=1*t:e>=25&&e<=155?r=1*t:s=1*t,[n,r,s]}function S9e(e,t,n){let r=e[0]-t[0],s=e[0]-n[0],o=t[0]-n[0],a=e[1]-t[1],i=e[1]-n[1],l=t[1]-n[1],u=e[2]-t[2],c=e[2]-n[2],p=t[2]-n[2],d=Math.sqrt(r*r+a*a+u*u),f=Math.sqrt(s*s+i*i+c*c),h=Math.sqrt(o*o+l*l+p*p),m=(h*h+d*d-f*f)/(2*h*d);m>1?m=1:m<-1&&(m=-1);let g=Math.acos(m);g=57.2958*g%180;let x;return g>wh.NO_CURL_START_LIMIT?x=Co.none:g>wh.HALF_CURL_START_LIMIT?x=Co.half:x=Co.full,x}function mj(e,t,n,r){let s;return r===Math.abs(e)?e>0?s=Gt.horizontalLeft:s=Gt.horizontalRight:r===Math.abs(t)?t>0?s=Gt.horizontalLeft:s=Gt.horizontalRight:n>0?s=Gt.horizontalLeft:s=Gt.horizontalRight,s}function gj(e,t,n,r){let s;return r===Math.abs(e)?e<0?s=Gt.verticalDown:s=Gt.verticalUp:r===Math.abs(t)?t<0?s=Gt.verticalDown:s=Gt.verticalUp:n<0?s=Gt.verticalDown:s=Gt.verticalUp,s}function N9e(e,t,n,r,s,o,a,i){let l,u=gj(e,t,n,r),c=mj(s,o,a,i);return u===Gt.verticalUp?c===Gt.horizontalLeft?l=Gt.diagonalUpLeft:l=Gt.diagonalUpRight:c===Gt.horizontalLeft?l=Gt.diagonalDownLeft:l=Gt.diagonalDownRight,l}function T9e(e,t,n,r){let s=e[0]-t[0],o=e[0]-n[0],a=t[0]-n[0],i=e[1]-t[1],l=e[1]-n[1],u=t[1]-n[1],c=Math.max(Math.abs(s),Math.abs(o),Math.abs(a)),p=Math.max(Math.abs(i),Math.abs(l),Math.abs(u)),d=0,f=0,h=0,m=p/(c+1e-5);m>1.5?d+=wh.DISTANCE_VOTE_POWER:m>.66?f+=wh.DISTANCE_VOTE_POWER:h+=wh.DISTANCE_VOTE_POWER;let g=Math.sqrt(s*s+i*i),x=Math.sqrt(o*o+l*l),y=Math.sqrt(a*a+u*u),b=Math.max(g,x,y),A=e[0],v=e[1],w=n[0],k=n[1];b===g?(w=n[0],k=n[1]):b===y&&(A=t[0],v=t[1]);let T=fj([A,v],[w,k]),_=hj(T,wh.TOTAL_ANGLE_VOTE_POWER);d+=_[0],f+=_[1],h+=_[2];for(let S of r){let F=hj(S,wh.SINGLE_ANGLE_VOTE_POWER);d+=F[0],f+=F[1],h+=F[2]}let R;return d===Math.max(d,f,h)?R=gj(l,i,u,p):h===Math.max(f,h)?R=mj(o,s,a,c):R=N9e(l,i,u,p,o,s,a,c),R}function xj(e){let t=[],n=[],r=[],s=[];if(!e)return{curls:r,directions:s};for(let o of Ut.all){let a=Ut.getPoints(o),i=[],l=[];for(let u of a){let c=e[u[0]],p=e[u[1]],d=fj(c,p),f=d[0],h=d[1];i.push(f),l.push(h)}t.push(i),n.push(l)}for(let o of Ut.all){let a=o===Ut.thumb?1:0,i=Ut.getPoints(o),l=e[i[a][0]],u=e[i[a+1][1]],c=e[i[3][1]],p=S9e(l,u,c),d=T9e(l,u,c,t[o].slice(a));r[o]=p,s[o]=d}return{curls:r,directions:s}}function i3(e){if(!e||e.length===0)return null;let t=xj(e),n={};for(let r of Ut.all)n[Ut.getName(r)]={curl:Co.getName(t.curls[r]),direction:Gt.getName(t.directions[r])};return n}function yj(e){let t=[];if(!e||e.length===0)return t;let n=xj(e);for(let r of pj){let s=r.matchAgainst(n.curls,n.directions);s>=C9e&&t.push({name:r.name,confidence:s})}return t}var bj={thumb:[1,2,3,4],index:[5,6,7,8],middle:[9,10,11,12],ring:[13,14,15,16],pinky:[17,18,19,20],palm:[0]},Yl,Jl,Aj;async function v7(e,t){let n=await Aj.estimateHands(e,t);if(!n)return[];let r=[];for(let s=0;s<n.length;s++){let o={};if(n[s].landmarks)for(let c of Object.keys(bj))o[c]=bj[c].map(p=>n[s].landmarks[p]);let a=n[s].landmarks,i=[Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,0,0],l=[0,0,0,0];if(a&&a.length>0){for(let c of a)c[0]<i[0]&&(i[0]=c[0]),c[1]<i[1]&&(i[1]=c[1]),c[0]>i[2]&&(i[2]=c[0]),c[1]>i[3]&&(i[3]=c[1]);i[2]-=i[0],i[3]-=i[1],l=[i[0]/(e.shape[2]||0),i[1]/(e.shape[1]||0),i[2]/(e.shape[2]||0),i[3]/(e.shape[1]||0)]}else i=n[s].box?[Math.trunc(Math.max(0,n[s].box.topLeft[0])),Math.trunc(Math.max(0,n[s].box.topLeft[1])),Math.trunc(Math.min(e.shape[2]||0,n[s].box.bottomRight[0])-Math.max(0,n[s].box.topLeft[0])),Math.trunc(Math.min(e.shape[1]||0,n[s].box.bottomRight[1])-Math.max(0,n[s].box.topLeft[1]))]:[0,0,0,0],l=[n[s].box.topLeft[0]/(e.shape[2]||0),n[s].box.topLeft[1]/(e.shape[1]||0),(n[s].box.bottomRight[0]-n[s].box.topLeft[0])/(e.shape[2]||0),(n[s].box.bottomRight[1]-n[s].box.topLeft[1])/(e.shape[1]||0)];let u=i3(a);r.push({id:s,score:Math.round(100*n[s].confidence)/100,boxScore:Math.round(100*n[s].boxConfidence)/100,fingerScore:Math.round(100*n[s].fingerConfidence)/100,label:"hand",box:i,boxRaw:l,keypoints:a,annotations:o,landmarks:u})}return r}async function w7(e){var n,r,s,o,a,i;Ee.initial&&(Yl=null,Jl=null),!Yl||!Jl?([Yl,Jl]=await Promise.all([e.hand.enabled?yn(an(e.modelBasePath,((n=e.hand.detector)==null?void 0:n.modelPath)||""),{fromTFHub:(((r=e.hand.detector)==null?void 0:r.modelPath)||"").includes("tfhub.dev")}):null,e.hand.landmarks?yn(an(e.modelBasePath,((s=e.hand.skeleton)==null?void 0:s.modelPath)||""),{fromTFHub:(((o=e.hand.skeleton)==null?void 0:o.modelPath)||"").includes("tfhub.dev")}):null]),e.hand.enabled&&(!Yl||!Yl.modelUrl?Ce("load model failed:",((a=e.hand.detector)==null?void 0:a.modelPath)||""):e.debug&&Ce("load model:",Yl.modelUrl),!Jl||!Jl.modelUrl?Ce("load model failed:",((i=e.hand.skeleton)==null?void 0:i.modelPath)||""):e.debug&&Ce("load model:",Jl.modelUrl))):(e.debug&&Ce("cached model:",Yl.modelUrl),e.debug&&Ce("cached model:",Jl.modelUrl));let t=new x7(Yl);return Aj=new A7(t,Jl),[Yl,Jl]}function l3(e,t,n){let r=[e.map(c=>c[0]),e.map(c=>c[1])],s=[Math.max(...r[0]),Math.min(...r[0]),Math.max(...r[1]),Math.min(...r[1])],o=[(s[0]+s[1])/2,(s[2]+s[3])/2],a=Math.max(o[0]-s[1],o[1]-s[3],-o[0]+s[0],-o[1]+s[2])*t,i=[Math.trunc(o[0]-a),Math.trunc(o[1]-a),Math.trunc(2*a),Math.trunc(2*a)],l=[i[0]/n[0],i[1]/n[1],i[2]/n[0],i[3]/n[1]],u=[l[1],l[0],l[3]+l[1],l[2]+l[0]];return{box:i,boxRaw:l,yxBox:u}}var vA=1.5,Cr=[null,null],_9e=["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],Ql=[[0,0],[0,0]],E9e=["hand","fist","pinch","point","face","tip","pinchtip"],k7=0,ix=[0,0],Ei={handBoxes:[],fingerBoxes:[],tmpBoxes:[]},vj={thumb:[1,2,3,4],index:[5,6,7,8],middle:[9,10,11,12],ring:[13,14,15,16],pinky:[17,18,19,20],palm:[0]};async function wj(e){var t;if(Ee.initial&&(Cr[0]=null),Cr[0])e.debug&&Ce("cached model:",Cr[0].modelUrl);else{lx(["tensorlistreserve","enter","tensorlistfromtensor","merge","loopcond","switch","exit","tensorliststack","nextiteration","tensorlistsetitem","tensorlistgetitem","reciprocal","shape","split","where"],e),Cr[0]=await yn(an(e.modelBasePath,((t=e.hand.detector)==null?void 0:t.modelPath)||""));let n=Object.values(Cr[0].modelSignature.inputs);Ql[0][0]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[1].size):0,Ql[0][1]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[2].size):0,!Cr[0]||!Cr[0].modelUrl?Ce("load model failed:",e.object.modelPath):e.debug&&Ce("load model:",Cr[0].modelUrl)}return Cr[0]}async function kj(e){var t;if(Ee.initial&&(Cr[1]=null),Cr[1])e.debug&&Ce("cached model:",Cr[1].modelUrl);else{Cr[1]=await yn(an(e.modelBasePath,((t=e.hand.skeleton)==null?void 0:t.modelPath)||""));let n=Object.values(Cr[1].modelSignature.inputs);Ql[1][0]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[1].size):0,Ql[1][1]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[2].size):0,!Cr[1]||!Cr[1].modelUrl?Ce("load model failed:",e.object.modelPath):e.debug&&Ce("load model:",Cr[1].modelUrl)}return Cr[1]}async function R9e(e,t){let n=[];if(!e||!Cr[0])return n;let r={},s=(e.shape[2]||1)/(e.shape[1]||1),o=Math.min(Math.round((e.shape[1]||0)/8)*8,512),a=Math.round(o*s/8)*8;r.resize=ht.resizeBilinear(e,[o,a]),r.cast=Fe(r.resize,"int32"),[r.rawScores,r.rawBoxes]=await Cr[0].executeAsync(r.cast,_9e),r.boxes=ln(r.rawBoxes,[0,2]),r.scores=ln(r.rawScores,[0]);let i=Vs(r.scores,1),l=0;for(let u=0;u<i.length;u++){if(u===4)continue;r.nms=await ht.nonMaxSuppressionAsync(r.boxes,i[u],t.hand.maxDetected,t.hand.iouThreshold,t.hand.minConfidence);let c=await r.nms.data();ye(r.nms);for(let p of Array.from(c)){let d=gt(r.boxes,p,1),f=[0,0,0,0];if(t.hand.landmarks){let b=await d.data(),A=[(b[0]+b[2])/2,(b[1]+b[3])/2],v=[+A[0]-b[0],+A[1]-b[1],-A[0]+b[2],-A[1]+b[3]];f=[A[0]-vA*v[0],A[1]-vA*v[1],A[0]+vA*v[2],A[1]+vA*v[3]]}else f=await d.data();let h=[f[1],f[0],f[3]-f[1],f[2]-f[0]],m=[Math.trunc(h[0]*ix[0]),Math.trunc(h[1]*ix[1]),Math.trunc(h[2]*ix[0]),Math.trunc(h[3]*ix[1])];ye(d);let g=gt(i[u],p,1),x=(await g.data())[0];ye(g);let y={id:l++,score:x,box:m,boxRaw:h,label:E9e[u],yxBox:f};n.push(y)}}return i.forEach(u=>ye(u)),Object.keys(r).forEach(u=>ye(r[u])),n.sort((u,c)=>c.score-u.score),n.length>(t.hand.maxDetected||1)&&(n.length=t.hand.maxDetected||1),n}async function I7(e,t,n){let r={id:t.id,score:Math.round(100*t.score)/100,boxScore:Math.round(100*t.score)/100,fingerScore:0,box:t.box,boxRaw:t.boxRaw,label:t.label,keypoints:[],landmarks:{},annotations:{}};if(e&&Cr[1]&&n.hand.landmarks){let s={};if(!t.yxBox)return r;s.crop=ht.cropAndResize(e,[t.yxBox],[0],[Ql[1][0],Ql[1][1]],"bilinear"),s.cast=Fe(s.crop,"float32"),s.div=Me(s.cast,255),[s.score,s.keypoints]=Cr[1].execute(s.div);let o=(await s.score.data())[0],a=(100-Math.trunc(100/(1+Math.exp(o))))/100;if(a>=(n.hand.minConfidence||0)){r.fingerScore=a,s.reshaped=ie(s.keypoints,[-1,3]);let i=await s.reshaped.array();r.keypoints=i.map(c=>[t.box[2]*c[0]/Ql[1][0]+t.box[0],t.box[3]*c[1]/Ql[1][1]+t.box[1],(t.box[2]+t.box[3])/2/Ql[1][0]*(c[2]||0)]);let l=l3(r.keypoints,vA,ix);t.box=l.box,t.boxRaw=l.boxRaw,t.yxBox=l.yxBox,r.box=t.box,r.landmarks=i3(r.keypoints);for(let c of Object.keys(vj))r.annotations[c]=vj[c].map(p=>r.landmarks&&r.keypoints[p]?r.keypoints[p]:null);Math.min(t.box[2]/(e.shape[2]||1),t.box[3]/(e.shape[1]||1))>.05&&Ei.tmpBoxes.push(t)}Object.keys(s).forEach(i=>ye(s[i]))}return r}async function C7(e,t){ix=[e.shape[2]||0,e.shape[1]||0];let n=[];return Ei.tmpBoxes=[],t.hand.landmarks||(Ei.fingerBoxes=Ei.handBoxes),t.skipFrame||(Ei.fingerBoxes=[]),k7<(t.hand.skipFrames||0)&&t.skipFrame?(k7++,n=await Promise.all(Ei.fingerBoxes.map(r=>I7(e,r,t)))):(k7=0,n=await Promise.all(Ei.fingerBoxes.map(r=>I7(e,r,t))),n.length!==t.hand.maxDetected&&(Ei.handBoxes=await R9e(e,t),n=await Promise.all(Ei.handBoxes.map(r=>I7(e,r,t))))),Ei.fingerBoxes=[...Ei.tmpBoxes],n}var D9e=1e-7,$9e=1e-4,ux=class{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},up=class{refCount(t){return Va("refCount")}incRef(t){return Va("incRef")}timerAvailable(){return!0}time(t){return Va("time")}read(t){return Va("read")}readSync(t){return Va("readSync")}numDataIds(){return Va("numDataIds")}disposeData(t,n){return Va("disposeData")}write(t,n,r){return Va("write")}move(t,n,r,s,o){return Va("move")}memory(){return Va("memory")}floatPrecision(){return Va("floatPrecision")}epsilon(){return this.floatPrecision()===32?D9e:$9e}dispose(){return Va("dispose")}};function Va(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Ij(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,u3(e,t,n)}function F9e(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,u3(e,n,r),u3(t,n,r)}function cx(e,t,n){return Math.max(e,Math.min(t,n))}function O9e(e){return e%2==0?e:e+1}function u3(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function P9e(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function M9e(e,t){let n=Math.random();return t*n+(1-n)*e}function z9e(e,t){let n=0;for(let r=0;r<e.length;r++){let s=Number(e[r])-Number(t[r]);n+=s*s}return n}function V(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function c3(e,t,n=""){V(Wa(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function wA(e){V(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function cp(e,t=[],n=!1){if(t==null&&(t=[]),Array.isArray(e)||Jo(e)&&!n)for(let r=0;r<e.length;++r)cp(e[r],t,n);else t.push(e);return t}function bn(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function L9e(e){return e.length===0}function Wa(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Jt(e){return e%1==0}function B9e(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function V9e(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function W9e(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Ij(t),t}function kh(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function G9e(e,t=r=>0,n){return new Promise((r,s)=>{let o=0,a=()=>{if(e()){r();return}o++;let i=t(o);if(n!=null&&o>=n){s();return}setTimeout(a,i)};a()})}function U9e(e,t){let n=1,r=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(e[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(e[o]<0)throw Error(`Shapes can not be < 0. Found ${e[o]} at dim ${o}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let s=e.slice();return s[r]=t/n,s}function Sr(e,t){let n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),V(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),V(e.every(r=>Jt(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function S7(e,t){let n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,o=t==null||s?null:Sr(t,e).sort(),a=0;for(let i=0;i<e.length;++i){if(o!=null){if(o[a]===i&&e[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(o[a]==null||o[a]>i)&&e[i]===1&&(n.push(e[i]),r.push(i)),o[a]<=i&&a++}e[i]!==1&&(n.push(e[i]),r.push(i))}return{newShape:n,keptDims:r}}function j9e(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else throw new Error(`Unknown data type ${e}`);return n}function N7(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function T7(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function _7(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function H9e(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Jo(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function p3(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function E7(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function px(e){return typeof e=="string"||e instanceof String}function Cj(e){return typeof e=="boolean"}function Sj(e){return typeof e=="number"}function dx(e){return Array.isArray(e)?dx(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":Sj(e)?"float32":px(e)?"string":Cj(e)?"bool":"float32"}function fx(e){return!!(e&&e.constructor&&e.call&&e.apply)}function hx(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function yl(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Nj(e,t,n,r=!1){let s=new Array;if(t.length===1){let o=t[0]*(r?2:1);for(let a=0;a<o;a++)s[a]=n[e+a]}else{let o=t[0],a=t.slice(1),i=a.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<o;l++)s[l]=Nj(e+l*i,a,n,r)}return s}function Ih(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((s,o)=>s*o)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Nj(0,e,t,n)}function kA(e,t){let n=mx(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function mx(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function q9e(e,t){let n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return Ih(e,new Float32Array(n));if(t==="int32")return Ih(e,new Int32Array(n));if(t==="bool")return Ih(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function IA(e){e.forEach(t=>{V(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function K9e(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function X9e(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function CA(e){return e&&e.then&&typeof e.then=="function"}function Aa(...e){he().getBool("IS_TEST")||he().getBool("PROD")||console.warn(...e)}function Z9e(...e){he().getBool("IS_TEST")||he().getBool("PROD")||console.log(...e)}var Tj="tfjsflags",d3=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Y9e,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&Aa(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`),this.platformName=t,this.platform=n}registerFlag(t,n,r){if(this.flagRegistry[t]={evaluationFn:n,setHook:r},this.urlFlags[t]!=null){let s=this.urlFlags[t];Aa(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let n=this.evaluateFlag(t);if(CA(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=this.getQueryParams(this.global.location.search);Tj in t&&t[Tj].split(",").forEach(r=>{let[s,o]=r.split(":");this.urlFlags[s]=Q9e(s,o)})}};function Y9e(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(J9e(t,r[0],r[1]),r.join("="))),t}function J9e(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Q9e(e,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function he(){return R7}var R7=null;function _j(e){R7=e}var D7;function $7(){if(D7==null){let e;if(typeof window!="undefined")e=window;else if(typeof global!="undefined")e=global;else if(typeof process!="undefined")e=process;else if(typeof self!="undefined")e=self;else throw new Error("Could not find a global object");D7=e}return D7}function eMe(){let e=$7();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function SA(e,t){let n=eMe();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var pp="Abs",eu="Acos",tu="Acosh",Ri="Add",dp="AddN",gx="All",xx="Any",fp="ArgMax",hp="ArgMin",nu="Asin",ru="Asinh",su="Atan",ou="Atanh",au="Atan2",mp="AvgPool",yx="AvgPoolGrad",gp="AvgPool3D",bx="AvgPool3DGrad",xp="BatchMatMul",yp="BatchToSpaceND",Ax="Bincount",Ej="BroadcastTo",f3="BroadcastArgs",bl="Cast",iu="Ceil",lu="ClipByValue",vx="Complex",bp="ComplexAbs",Ap="Concat",vp="Conv2D",wx="Conv2DBackpropFilter",wp="Conv2DBackpropInput",kp="Conv3D",kx="Conv3DBackpropFilterV2",Ix="Conv3DBackpropInputV2",uu="Cos",cu="Cosh",Ip="Cumsum",Cx="CropAndResize",Sx="DenseBincount",Nx="DepthToSpace",Cp="DepthwiseConv2dNative",Tx="DepthwiseConv2dNativeBackpropFilter",_x="DepthwiseConv2dNativeBackpropInput",h3="Diag",Sp="Dilation2D",NA="Dilation2DBackpropInput",TA="Dilation2DBackpropFilter",pu="RealDiv",Ex="Einsum",du="Elu",Rx="EluGrad",fu="Erf",Ch="Equal",hu="Exp",Np="ExpandDims",mu="Expm1",Dx="FFT",$x="Fill",Fx="FlipLeftRight",gu="Floor",xu="FloorDiv",Tp="FusedBatchNorm",_p="GatherV2",Ox="GatherNd",Sh="Greater",yu="GreaterEqual",Al="Identity",Px="IFFT",Mx="Imag",bu="IsFinite",Au="IsInf",vu="IsNan",Ep="LeakyRelu",Nh="Less",Th="LessEqual",zx="LinSpace",wu="Log",ku="Log1p",_h="LogicalAnd",Eh="LogicalNot",Rh="LogicalOr",Rj="LogSoftmax",Rp="LRN",Lx="LRNGrad",Dp="Max",Iu="Maximum",$p="MaxPool",Bx="MaxPoolGrad",Fp="MaxPool3D",Vx="MaxPool3DGrad",Wx="MaxPoolWithArgmax",Op="Mean",Pp="Min",Cu="Minimum",Mp="MirrorPad",Su="Mod",Gx="Multinomial",Nu="Multiply",zp="Neg",Dh="NotEqual",Ux="NonMaxSuppressionV3",jx="NonMaxSuppressionV4",Hx="NonMaxSuppressionV5",Lp="OnesLike",Bp="OneHot",Vp="Pack",Wp="PadV2";var Tu="Pow",Gp="Prelu",qx="Prod",Kx="Range",Xx="Real",_u="Reciprocal",Eu="Relu",Up="Reshape",jp="ResizeNearestNeighbor",Zx="ResizeNearestNeighborGrad",Hp="ResizeBilinear",Yx="ResizeBilinearGrad",Ru="Relu6",qp="Reverse",Du="Round",$u="Rsqrt",Jx="ScatterNd",Kp="Select",Fu="Selu",Xp="Slice",Ou="Sin",Pu="Sinh",Mu="Sign",zu="Sigmoid",Lu="Softplus",Bu="Sqrt",Zp="Sum",Yp="SpaceToBatchND",Jp="SplitV",Qp="Softmax",Qx="SparseFillEmptyRows",ey="SparseReshape",ty="SparseSegmentMean",ny="SparseSegmentSum",ry="SparseToDense",Vu="SquaredDifference",sy="Square",oy="StridedSlice",ay="StringNGrams",iy="StringSplit",ly="StringToHashBucketFast",Wu="Sub",Gu="Tan",Uu="Tanh",vl="Tile",uy="TopK",cy="Transform",ed="Transpose",py="Unique",td="Unpack",nd="UnsortedSegmentSum",rd="ZerosLike",ju="Step",Dj="FromPixels",dy="RotateWithOffset",$h="_FusedMatMul",Fh="FusedConv2D",Oh="FusedDepthwiseConv2D";var m3=SA("kernelRegistry",()=>new Map),F7=SA("gradRegistry",()=>new Map);function O7(e,t){let n=Fj(e,t);return m3.get(n)}function P7(e){return F7.get(e)}function M7(e){let t=m3.entries(),n=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[o,a]=s,[i]=o.split("_");i===e&&n.push(a)}return n}function g3(e){let{kernelName:t,backendName:n}=e,r=Fj(t,n);m3.has(r)&&Aa(`The kernel '${t}' for backend '${n}' is already registered`),m3.set(r,e)}function $j(e){let{kernelName:t}=e;F7.has(t)&&he().getBool("DEBUG")&&Aa(`Overriding the gradient for '${t}'`),F7.set(t,e)}function Fj(e,t){return`${t}_${e}`}var C={};dn(C,{arraysEqual:()=>Wa,assert:()=>V,assertNonNegativeIntegerDimensions:()=>IA,assertNonNull:()=>wA,assertShapesMatch:()=>c3,bytesFromStringArray:()=>E7,bytesPerElement:()=>p3,checkConversionForErrors:()=>T7,clamp:()=>cx,computeStrides:()=>yl,createScalarValue:()=>iMe,createShuffledIndices:()=>W9e,decodeString:()=>xy,distSquared:()=>z9e,encodeString:()=>gy,fetch:()=>uMe,fingerPrint64:()=>aMe,flatten:()=>cp,getArrayFromDType:()=>N7,getTypedArrayFromDType:()=>j9e,hasEncodingLoss:()=>H9e,hexToLong:()=>_A,indexToLoc:()=>X9e,inferDtype:()=>dx,inferFromImplicitShape:()=>U9e,isBoolean:()=>Cj,isFunction:()=>fx,isInt:()=>Jt,isNumber:()=>Sj,isPromise:()=>CA,isScalarShape:()=>L9e,isString:()=>px,isTypedArray:()=>Jo,isValidDtype:()=>_7,locToIndex:()=>K9e,makeOnesTypedArray:()=>kA,makeZerosNestedTypedArray:()=>q9e,makeZerosTypedArray:()=>mx,nearestDivisor:()=>hx,nearestLargerEven:()=>O9e,now:()=>Bh,parseAxisParam:()=>Sr,randUniform:()=>M9e,repeatedTry:()=>G9e,rightPad:()=>kh,shuffle:()=>Ij,shuffleCombo:()=>F9e,sizeFromShape:()=>bn,sizeToSquarishShape:()=>V9e,squeezeShape:()=>S7,sum:()=>P9e,swap:()=>u3,tanh:()=>B9e,toNestedArray:()=>Ih,toTypedArray:()=>my});var Hj=T1(jj());var zh=Hj.default||Hj;function _A(e){return zh.fromString(e,!0,16)}var qj=_A("c3a5c85c97cb3127"),Lh=_A("b492b66fbe98f273"),Xs=_A("9ae16a3b2f90404f");function B7(e){return e.xor(e.shru(47))}function Kj(e,t,n){let r=e.slice(t,t+n);return zh.fromBytes(Array.from(r),!0,!0)}function zn(e,t){return Kj(e,t,8)}function Xj(e,t){return Kj(e,t,4)}function fs(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function sd(e,t,n=_A("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function nMe(e,t,n,r,s,o){s=s.add(e),o=fs(o.add(s).add(r),21);let a=s;return s=s.add(t),s=s.add(n),o=o.add(fs(s,44)),[s.add(r),o.add(a)]}function y3(e,t,n,r){return nMe(zn(e,t),zn(e,t+8),zn(e,t+16),zn(e,t+24),n,r)}function rMe(e,t=e.length){if(t>=8){let n=Xs.add(t*2),r=zn(e,0).add(Xs),s=zn(e,t-8),o=fs(s,37).mul(n).add(r),a=fs(r,25).add(s).mul(n);return sd(o,a,n)}if(t>=4){let n=Xs.add(t*2),r=Xj(e,0);return sd(r.shl(3).add(t),Xj(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],s=e[t-1],o=n+(r<<8),a=t+(s<<2);return B7(Xs.mul(o).xor(qj.mul(a))).mul(Xs)}return Xs}function sMe(e,t=e.length){let n=Xs.add(t*2),r=zn(e,0).mul(Lh),s=zn(e,8),o=zn(e,t-8).mul(n),a=zn(e,t-16).mul(Xs);return sd(fs(r.add(s),43).add(fs(o,30)).add(a),r.add(fs(s.add(Xs),18)).add(o),n)}function oMe(e,t=e.length){let n=Xs.add(t*2),r=zn(e,0).mul(Xs),s=zn(e,8),o=zn(e,t-8).mul(n),a=zn(e,t-16).mul(Xs),i=fs(r.add(s),43).add(fs(o,30)).add(a),l=sd(i,r.add(fs(s.add(Xs),18)).add(o),n),u=zn(e,16).mul(n),c=zn(e,24),p=i.add(zn(e,t-32)).mul(n),d=l.add(zn(e,t-24)).mul(n);return sd(fs(u.add(c),43).add(fs(p,30)).add(d),u.add(fs(c.add(r),18)).add(p),n)}function aMe(e,t=e.length){let n=zh.fromNumber(81,!0);if(t<=32)return t<=16?rMe(e,t):sMe(e,t);if(t<=64)return oMe(e,t);let r=n,s=n.mul(Lh).add(113),o=B7(s.mul(Xs).add(113)).mul(Xs),a=[zh.UZERO,zh.UZERO],i=[zh.UZERO,zh.UZERO];r=r.mul(Xs).add(zn(e,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=fs(r.add(s).add(a[0]).add(zn(e,l+8)),37).mul(Lh),s=fs(s.add(a[1]).add(zn(e,l+48)),42).mul(Lh),r=r.xor(i[1]),s=s.add(a[0]).add(zn(e,l+40)),o=fs(o.add(i[0]),33).mul(Lh),a=y3(e,l,a[1].mul(Lh),r.add(i[0])),i=y3(e,l+32,o.add(i[1]),s.add(zn(e,l+16))),[o,r]=[r,o],l+=64;while(l!==u);let p=Lh.add(o.and(255).shl(1));return l=c,i[0]=i[0].add(t-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),r=fs(r.add(s).add(a[0]).add(zn(e,l+8)),37).mul(p),s=fs(s.add(a[1]).add(zn(e,l+48)),42).mul(p),r=r.xor(i[1].mul(9)),s=s.add(a[0].mul(9).add(zn(e,l+40))),o=fs(o.add(i[0]),33).mul(p),a=y3(e,l,a[1].mul(p),r.add(i[0])),i=y3(e,l+32,o.add(i[1]),s.add(zn(e,l+16))),[o,r]=[r,o],sd(sd(a[0],i[0],p).add(B7(s).mul(qj)).add(o),sd(a[1],i[1],p).add(r),p)}function iMe(e,t){return t==="string"?gy(e):my([e],t)}function lMe(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function my(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=cp(e)),he().getBool("DEBUG")&&T7(e,t),lMe(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Bh(){return he().platform.now()}function uMe(e,t){return he().platform.fetch(e,t)}function gy(e,t="utf-8"){return t=t||"utf-8",he().platform.encode(e,t)}function xy(e,t="utf-8"){return t=t||"utf-8",he().platform.decode(e,t)}var V7=class{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new Zj)}profileKernel(t,n,r){let s,o=()=>{s=r()},a,i=Bh();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(let u of s)u.dataSync();a=Promise.resolve({kernelMs:Bh()-i})}if(he().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){let c=s[u];c.data().then(p=>{cMe(p,c.dtype,t)})}return{kernelName:t,outputs:s,inputs:n,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:n,outputs:r,timeMs:s,inputs:o,extraInfo:a}=t;r.forEach(i=>{Promise.all([i.data(),s,a]).then(l=>{this.logger.logKernelProfile(n,i,l[0],l[1],o,l[2])})})}};function cMe(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}var Zj=class{logKernelProfile(t,n,r,s,o,a){let i=typeof s=="number"?kh(`${s}ms`,9):s.error,l=kh(t,25),u=n.rank,c=n.size,p=kh(n.shape.toString(),14),d="";for(let f in o){let h=o[f];if(h!=null){let m=h.shape||n.shape,g=m.length;d+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${i}	%c${u}D ${p}	%c${c}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function Yj(e,t,n){let r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],c=u.inputs;for(let p in c){let d=c[p],f=!1;for(let h=0;h<t.length;h++)if(r[d.id]){u.outputs.forEach(m=>r[m.id]=!0),f=!0,s[u.id]=!0;break}if(f)break}}let o={};o[n.id]=!0;let a={};for(let l=e.length-1;l>=0;l--){let u=e[l],c=u.inputs;for(let p=0;p<u.outputs.length;p++)if(o[u.outputs[p].id]){for(let d in c)o[c[d].id]=!0,a[u.id]=!0;break}}let i=[];for(let l=0;l<e.length;l++){let u=e[l];if(s[u.id]&&a[u.id]){let c={};for(let d in u.inputs){let f=u.inputs[d];r[f.id]&&(c[d]=f)}let p=Object.assign({},u);p.inputs=c,p.outputs=u.outputs,i.push(p)}}return i}function Jj(e,t,n,r){for(let s=t.length-1;s>=0;s--){let o=t[s],a=[];if(o.outputs.forEach(l=>{let u=e[l.id];u!=null?a.push(u):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);let i=o.gradient(a);for(let l in o.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);let u=n(()=>i[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=o.inputs[l];if(!Wa(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{let p=e[c.id];e[c.id]=r(p,u),p.dispose()}}}}var Qj=20,EA=3,W7=7;function eH(e,t,n,r){let s=yl(t),o=pMe(e,t,n,s),a=t.length,i=b3(e,t,n,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(i.map(u=>"    "+u).join(`
`)),l.join(`
`)}function pMe(e,t,n,r){let s=bn(t),o=r[r.length-1],a=new Array(o).fill(0),i=t.length,l=n==="complex64"?DA(e):e;if(i>1)for(let u=0;u<s/o;u++){let c=u*o;for(let p=0;p<o;p++)a[p]=Math.max(a[p],RA(l[c+p],0,n).length)}return a}function RA(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(W7))} + ${parseFloat(e[1].toFixed(W7))}j`:px(e)?r=`'${e}'`:n==="bool"?r=tH(e):r=parseFloat(e.toFixed(W7)).toString(),kh(r,t)}function tH(e){return e===0?"false":"true"}function b3(e,t,n,r,s,o=!0){let a=n==="complex64"?2:1,i=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=DA(e);return[RA(m[0],0,n)]}return n==="bool"?[tH(e[0])]:[e[0].toString()]}if(l===1){if(i>Qj){let g=EA*a,x=Array.from(e.slice(0,g)),y=Array.from(e.slice((i-EA)*a,i*a));return n==="complex64"&&(x=DA(x),y=DA(y)),["["+x.map((b,A)=>RA(b,s[A],n)).join(", ")+", ..., "+y.map((b,A)=>RA(b,s[i-EA+A],n)).join(", ")+"]"]}let m=n==="complex64"?DA(e):Array.from(e);return["["+m.map((g,x)=>RA(g,s[x],n)).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),p=r[0]*a,d=[];if(i>Qj){for(let m=0;m<EA;m++){let g=m*p,x=g+p;d.push(...b3(e.slice(g,x),u,n,c,s,!1))}d.push("...");for(let m=i-EA;m<i;m++){let g=m*p,x=g+p;d.push(...b3(e.slice(g,x),u,n,c,s,m===i-1))}}else for(let m=0;m<i;m++){let g=m*p,x=g+p;d.push(...b3(e.slice(g,x),u,n,c,s,m===i-1))}let f=l===2?",":"";d[0]="["+d[0]+f;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+f;let h=`,
`;for(let m=2;m<l;m++)h+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":h),d}function DA(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var sn=class{constructor(t,n,r){if(this.dtype=n,this.shape=t.slice(),this.size=bn(t),r!=null){let s=r.length;V(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||N7(n,this.size),this.strides=yl(t)}set(t,...n){n.length===0&&(n=[0]),V(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);let r=this.locToIndex(n);this.values[r]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(let s of t){if(s<0||s>=this.shape[n]){let o=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(t/this.strides[r]),t-=n[r]*this.strides[r];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return wl().makeTensor(this.values,this.shape,this.dtype)}},wl=null,yy=null,dMe=null;function nH(e){wl=e}function rH(e){yy=e}function sH(e){dMe=e}var Ot=class{constructor(t,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=bn(t),this.strides=yl(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return yy.buffer(this.shape,this.dtype,t)}bufferSync(){return yy.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return Ih(this.shape,t,this.dtype==="complex64")}arraySync(){return Ih(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let t=wl().read(this.dataId);if(this.dtype==="string"){let n=await t;try{return n.map(r=>xy(r))}catch(r){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();let t=wl().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>xy(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await wl().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(wl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return yy.print(this,t)}clone(){return this.throwIfDisposed(),yy.clone(this)}toString(t=!1){let n=this.dataSync();return eH(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),yy.cast(this,t)}variable(t=!0,n,r){return this.throwIfDisposed(),wl().makeVariable(this,t,n,r)}};Object.defineProperty(Ot,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Z(){return SA("Tensor",()=>Ot)}Z();var od=class extends Ot{constructor(t,n,r,s){super(t.shape,t.dtype,t.dataId,s);this.trainable=n,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Wa(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);wl().disposeTensor(this),this.dataId=t.dataId,wl().incRef(this,null)}dispose(){wl().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(od,Symbol.hasInstance,{value:e=>e instanceof Ot&&e.assign!=null&&e.assign instanceof Function});var Ha={};dn(Ha,{assertTypesMatch:()=>hMe,getTensorsInContainer:()=>$A,isTensorInList:()=>mMe,makeTypesMatch:()=>_t});var G7;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(G7||(G7={}));var U7;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(U7||(U7={}));var j7;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(j7||(j7={}));var H7;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(H7||(H7={}));var q7;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(q7||(q7={}));var fMe={float32:H7,int32:U7,bool:j7,complex64:q7};function Or(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return fMe[e][t]}function Vh(e){return Or(e,"int32")}function _t(e,t){if(e.dtype===t.dtype)return[e,t];let n=Or(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function hMe(e,t){V(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function mMe(e,t){return t.some(n=>n.id===e.id)}function $A(e){let t=[],n=new Set;return oH(e,t,n),t}function oH(e,t,n){if(e==null)return;if(e instanceof Ot){t.push(e);return}if(!gMe(e))return;let r=e;for(let s in r){let o=r[s];n.has(o)||(n.add(o),oH(o,t,n))}}function gMe(e){return Array.isArray(e)||typeof e=="object"}function K7(e){return e.kernelName!=null}var X7=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},Wh=class{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new X7}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(Aa(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new V7(this.backendInstance),!0}setupRegisteredKernels(){M7(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){M7(t).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof up)&&typeof r.then=="function"){let s=++this.pendingBackendInitId,o=r.then(a=>s<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Aa(`Initialization of backend ${t} failed`),Aa(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return Aa(`Initialization of backend ${t} failed`),Aa(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),s=r.backend,o=this.readSync(n),a=s.refCount(n);s.disposeData(n,!0),r.backend=t,t.move(n,o,r.shape,r.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,n,r){t();try{let s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return Wh.nextTensorId++}nextVariableId(){return Wh.nextVariableId++}clone(t){let n=z.runKernel(Al,{x:t}),r={x:t},s=a=>({x:()=>{let i="float32",l={x:a},u={dtype:i};return z.runKernel(bl,l,u)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,o,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,!(O7(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let s=this.backend.numDataIds(),o=0;r.forEach(l=>{o+=l.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=s-n-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[],s=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let l,u=K7(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(K7(t)){let{kernelName:h,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;let x=O7(h,this.backendName);V(x!=null,()=>`Cannot find registered kernel '${h}' for backend '${this.backendName}'`),i=()=>{let y=this.backend.numDataIds();l=x.kernelFunc({inputs:m,attrs:g,backend:this.backend});let b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,y,b);let A=b.map(v=>{if(v.rank!=null)return v;let{dataId:w,shape:k,dtype:I}=v;return this.makeTensorFromDataId(w,k,I)});if(s){let v=this.getTensorsForGradient(h,m,A);r=this.saveTensorsForBackwardMode(v)}return A}}else{let{forwardFunc:h}=t,m=g=>{!s||(r=g.map(x=>this.keep(this.clone(x))))};i=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>h(this.backend,m));let x=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,x),x}}let{inputs:c,attrs:p}=t,d=K7(t)?null:t.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(f=this.profiler.profileKernel(u,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),n=f.outputs)}),s&&this.addTapeNode(u,c,n,d,r,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(h=>c[h]!=null?c[h].shape:null),outputShapes:n.map(h=>h.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(t,n,r){let s=P7(t);if(s!=null){let o=s.inputsToSave||[],a=s.outputsToSave||[],i;s.saveAllInputs?(V(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(u=>n[u])):i=o.map(u=>n[u]);let l=r.filter((u,c)=>a[c]);return i.concat(l)}return[]}makeTensor(t,n,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=t;r==="string"&&px(t[0])&&(o=t.map(l=>gy(l)));let a=s.write(o,n,r),i=new Ot(n,r,a,this.nextTensorId());if(this.trackTensor(i,s),r==="string"){let l=this.state.tensorInfo.get(a),u=E7(o);this.state.numBytes+=u-l.bytes,l.bytes=u}return i}makeTensorFromDataId(t,n,r,s){r=r||"float32";let o=new Ot(n,r,t,this.nextTensorId());return this.trackTensor(o,s),o}makeVariable(t,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let o=new od(t,n,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*p3(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof od||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let r=t.size*p3(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,s,o,a){let i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:o},l=P7(t);l!=null&&(s=l.gradFunc),s!=null&&(i.gradient=u=>(u=u.map((c,p)=>{if(c==null){let d=r[p],f=mx(d.size,d.dtype);return this.makeTensor(f,d.shape,d.dtype)}return c}),s(u.length>1?u:u[0],o,a))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=$A(t),r=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){let a=this.state.activeScope.track[o];!a.kept&&!r.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(t,n,r,s=!1){if(V(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));V(o instanceof Ot,()=>"The result y returned by f() must be a tensor.");let a=Yj(this.state.activeTape,n,o);if(!s&&a.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[o.id]=r==null?xMe(o.shape):r,Jj(i,a,u=>this.tidy(u),yMe);let l=n.map(u=>i[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(t){return V(fx(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{V(n.every(i=>i instanceof Ot),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,s={};n.forEach((i,l)=>{s[l]=i});let o=(i,l)=>(r=t(...n,l),V(r.value instanceof Ot,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),V(fx(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),a=(i,l)=>{let u=r.gradFunc(i,l),c=Array.isArray(u)?u:[u];V(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),V(c.every(d=>d instanceof Ot),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((d,f)=>{p[f]=()=>d}),p};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){let n=Bh(),r=await this.backend.time(t);return r.wallMs=Bh()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new X7;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Wh.nextTensorId=0;Wh.nextVariableId=0;function xMe(e){let t=kA(bn(e),"float32");return z.makeTensor(t,e,"float32")}function Z7(){let e=$7();if(e._tfengine==null){let t=new d3(e);e._tfengine=new Wh(t)}return _j(e._tfengine.ENV),nH(()=>e._tfengine),e._tfengine}var z=Z7();function yMe(e,t){let n={a:e,b:t};return z.runKernel(Ri,n)}var Gh={};dn(Gh,{isBrowser:()=>Y7,isMobile:()=>AMe});function bMe(){return typeof navigator!="undefined"&&navigator!=null}function AMe(e){if(e||bMe()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Y7(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var $i=he();$i.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});$i.registerFlag("IS_BROWSER",()=>Y7());$i.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");$i.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));$i.registerFlag("PROD",()=>!1);$i.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>$i.getBool("DEBUG"));$i.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);$i.registerFlag("IS_TEST",()=>!1);$i.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);$i.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);function Uh(e,t){let n=e;if(Jo(e))return t==="string"?[]:[e.length];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Jo(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&he().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&aH(e,r,[]),r}function aH(e,t,n){if(n=n||[],!Array.isArray(e)&&!Jo(e)){V(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}V(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),V(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let s=0;s<e.length;++s)aH(e[s],r,n.concat(s))}function iH(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function O(e,t,n,r="numeric"){if(e instanceof Ot)return iH(r,e.dtype,t,n),e;let s=dx(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),iH(r,s,t,n),e==null||!Jo(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}let o=Uh(e,s);!Jo(e)&&!Array.isArray(e)&&(e=[e]);let i=s!=="string"?my(e,s):cp(e,[],!0);return z.makeTensor(i,o,s)}function A3(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((o,a)=>O(o,`${t}[${a}]`,n,r))}var vMe="__op";function L(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+vMe;let s=(...o)=>{z.startScope(n);try{let a=r(...o);return CA(a)&&console.error("Cannot return a Promise inside of tidy."),z.endScope(a),a}catch(a){throw z.endScope(null),a}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function wMe(e,t){let n=O(e,"real","complex"),r=O(t,"imag","complex");c3(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let s={real:n,imag:r};return z.runKernel(vx,s)}var ta=L({complex_:wMe});function ad(e,t,n,r){if(r==null&&(r=dx(e)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Jo(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){IA(t);let s=bn(t),o=bn(n);V(s===o,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${o}`);for(let a=0;a<n.length;++a){let i=n[a],l=a===n.length-1?i!==bn(t.slice(a)):!0;V(n[a]===t[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Jo(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?my(e,r):cp(e,[],!0),z.makeTensor(e,t,r)}function Zs(e,t,n){let r=Uh(e,n);return ad(e,t,r,n)}var FA={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var v3=4;async function lH(e,t){let n=[],r=[],s=Array.isArray(e)?e.map(a=>a.name):Object.keys(e);for(let a=0;a<s.length;++a){let i=s[a],l=Array.isArray(e)?e[a].tensor:e[i];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);let u={name:i,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(async p=>{let d=await l.bytes(),f=d.reduce((g,x)=>g+x.length,0)+v3*d.length,h=new Uint8Array(f),m=0;for(let g=0;g<d.length;g++){let x=d[g],y=new Uint8Array(new Uint32Array([x.length]).buffer);h.set(y,m),m+=v3,h.set(x,m),m+=x.length}p(h)});r.push(c)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}let o=await Promise.all(r);return{data:kMe(o),specs:n}}function w3(e,t){let n={},r,s=0;for(let o of t){let a=o.name,i=o.dtype,l=o.shape,u=bn(l),c;if("quantization"in o){let p=o.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${o.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${o.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=FA[p.dtype],f=e.slice(s,s+u*d),h=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(i==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(h.length);for(let m=0;m<h.length;m++){let g=h[m];c[m]=g*p.scale+p.min}}else if(p.dtype==="float16")r===void 0&&(r=NMe()),c=r(h);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(i==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(h.length);for(let m=0;m<h.length;m++){let g=h[m];c[m]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);s+=u*d}else if(i==="string"){let p=bn(o.shape);c=[];for(let d=0;d<p;d++){let f=new Uint32Array(e.slice(s,s+v3))[0];s+=v3;let h=new Uint8Array(e.slice(s,s+f));c.push(h),s+=f}}else{let p=FA[i],d=e.slice(s,s+u*p);if(i==="float32")c=new Float32Array(d);else if(i==="int32")c=new Int32Array(d);else if(i==="bool")c=new Uint8Array(d);else if(i==="complex64"){c=new Float32Array(d);let f=new Float32Array(c.length/2),h=new Float32Array(c.length/2);for(let x=0;x<f.length;x++)f[x]=c[x*2],h[x]=c[x*2+1];let m=Zs(f,l,"float32"),g=Zs(h,l,"float32");n[a]=ta(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);s+=u*p}i!=="complex64"&&(n[a]=Zs(c,l,i))}return n}function kMe(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(o=>{if(t+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});let r=new Uint8Array(t),s=0;return n.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}var J7=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function uH(e){return J7?Buffer.byteLength(e):new Blob([e]).size}function cH(e){if(J7)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function pH(e){if(J7){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function by(e){if(e.length===1)return e[0];let t=0;e.forEach(s=>{t+=s.byteLength});let n=new Uint8Array(t),r=0;return e.forEach(s=>{n.set(new Uint8Array(s),r),r+=s.byteLength}),n.buffer}function Q7(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function k3(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}async function Ay(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),e.weightsManifest!=null){let[r,s]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=s}return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),n}function kl(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:uH(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:uH(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function IMe(){let e=n=>{let r=n<<13,s=0;for(;(r&8388608)==0;)s-=8388608,r<<=1;return r&=~8388608,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function CMe(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function SMe(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function NMe(){let e=IMe(),t=CMe(),n=SMe();return r=>{let s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let a=0;a<r.length;a++){let i=r[a],l=e[n[i>>10]+(i&1023)]+t[i>>10];o[a]=l}return new Float32Array(s)}}var Cn=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Cn.instance==null&&(Cn.instance=new Cn),Cn.instance}static registerSaveRouter(t){Cn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Cn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Cn.getHandlers(t,"save")}static getLoadHandlers(t,n){return Cn.getHandlers(t,"load",n)}static getHandlers(t,n,r){let s=[];return(n==="load"?Cn.getInstance().loadRouters:Cn.getInstance().saveRouters).forEach(a=>{let i=a(t,r);i!==null&&s.push(i)}),s}},dH=e=>Cn.registerSaveRouter(e),fH=e=>Cn.registerLoadRouter(e),hH=e=>Cn.getSaveHandlers(e),mH=(e,t)=>Cn.getLoadHandlers(e,t);var eD="tensorflowjs",tD=1,jh="models_store",id="model_info_store";function gH(){if(!he().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window=="undefined"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function nD(e){let t=e.result;t.createObjectStore(jh,{keyPath:"modelPath"}),t.createObjectStore(id,{keyPath:"modelPath"})}var Hu=class{constructor(t){if(this.indexedDB=gH(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((r,s)=>{let o=this.indexedDB.open(eD,tD);o.onupgradeneeded=()=>nD(o),o.onsuccess=()=>{let a=o.result;if(n==null){let i=a.transaction(jh,"readonly"),u=i.objectStore(jh).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(u.result.modelArtifacts)},u.onerror=c=>(a.close(),s(u.error)),i.oncomplete=()=>a.close()}else{let i=kl(n),l=a.transaction(id,"readwrite"),u=l.objectStore(id),c=u.put({modelPath:this.modelPath,modelArtifactsInfo:i}),p;c.onsuccess=()=>{p=a.transaction(jh,"readwrite");let f=p.objectStore(jh).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i});f.onsuccess=()=>r({modelArtifactsInfo:i}),f.onerror=h=>{u=l.objectStore(id);let m=u.delete(this.modelPath);m.onsuccess=()=>(a.close(),s(f.error)),m.onerror=g=>(a.close(),s(f.error))}},c.onerror=d=>(a.close(),s(c.error)),l.oncomplete=()=>{p==null?a.close():p.oncomplete=()=>a.close()}}},o.onerror=a=>s(o.error)})}};Hu.URL_SCHEME="indexeddb://";var xH=e=>he().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Hu.URL_SCHEME)?TMe(e.slice(Hu.URL_SCHEME.length)):null;Cn.registerSaveRouter(xH);Cn.registerLoadRouter(xH);function TMe(e){return new Hu(e)}function _Me(e){return e.startsWith(Hu.URL_SCHEME)?e.slice(Hu.URL_SCHEME.length):e}var rD=class{constructor(){this.indexedDB=gH()}async listModels(){return new Promise((t,n)=>{let r=this.indexedDB.open(eD,tD);r.onupgradeneeded=()=>nD(r),r.onsuccess=()=>{let s=r.result,o=s.transaction(id,"readonly"),i=o.objectStore(id).getAll();i.onsuccess=()=>{let l={};for(let u of i.result)l[u.modelPath]=u.modelArtifactsInfo;t(l)},i.onerror=l=>(s.close(),n(i.error)),o.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(t){return t=_Me(t),new Promise((n,r)=>{let s=this.indexedDB.open(eD,tD);s.onupgradeneeded=()=>nD(s),s.onsuccess=()=>{let o=s.result,a=o.transaction(id,"readwrite"),i=a.objectStore(id),l=i.get(t),u;l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=i.delete(t),p=()=>{u=o.transaction(jh,"readwrite");let f=u.objectStore(jh).delete(t);f.onsuccess=()=>n(l.result.modelArtifactsInfo),f.onerror=h=>r(l.error)};c.onsuccess=p,c.onerror=d=>(p(),o.close(),r(l.error))}},l.onerror=c=>(o.close(),r(l.error)),a.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}};var qu="/",vy="tensorflowjs_models",yH="info",EMe="model_topology",RMe="weight_specs",DMe="weight_data",$Me="model_metadata";function bH(e){return{info:[vy,e,yH].join(qu),topology:[vy,e,EMe].join(qu),weightSpecs:[vy,e,RMe].join(qu),weightData:[vy,e,DMe].join(qu),modelMetadata:[vy,e,$Me].join(qu)}}function AH(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function FMe(e){let t=e.split(qu);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(qu)}function OMe(e){return e.startsWith(Ku.URL_SCHEME)?e.slice(Ku.URL_SCHEME.length):e}var Ku=class{constructor(t){if(!he().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=bH(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),s=kl(t);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,cH(t.weightData));let o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch(o){throw AH(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;let o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){let i=JSON.parse(o);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=pH(a),n}};Ku.URL_SCHEME="localstorage://";var vH=e=>he().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ku.URL_SCHEME)?PMe(e.slice(Ku.URL_SCHEME.length)):null;Cn.registerSaveRouter(vH);Cn.registerLoadRouter(vH);function PMe(e){return new Ku(e)}var sD=class{constructor(){V(he().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),V(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},n=vy+qu,r=qu+yH;for(let s=0;s<this.LS.length;++s){let o=this.LS.key(s);if(o.startsWith(n)&&o.endsWith(r)){let a=FMe(o);t[a]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){t=OMe(t);let n=bH(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);let r=JSON.parse(this.LS.getItem(n.info));return AH(n),r}};var wy="://",Ys=class{constructor(){this.managers={}}static getInstance(){return Ys.instance==null&&(Ys.instance=new Ys),Ys.instance}static registerManager(t,n){V(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(wy)&&(t=t.slice(0,t.indexOf(wy))),V(t.length>0,()=>"scheme must not be an empty string.");let r=Ys.getInstance();V(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=this.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(this.getInstance().managers)}};function I3(e){if(e.indexOf(wy)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ys.getSchemes().join(",")}`);return{scheme:e.split(wy)[0],path:e.split(wy)[1]}}async function wH(e,t,n=!1){V(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=Cn.getLoadHandlers(e);V(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),V(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let s=r[0],o=Cn.getSaveHandlers(t);V(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),V(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let a=o[0],i=I3(e).scheme,l=I3(e).path,u=i===I3(e).scheme,c=await s.load();n&&u&&await Ys.getManager(i).removeModel(l);let p=await a.save(c);return n&&!u&&await Ys.getManager(i).removeModel(l),p.modelArtifactsInfo}async function kH(){let e=Ys.getSchemes(),t={};for(let n of e){let r=await Ys.getManager(n).listModels();for(let s in r){let o=n+wy+s;t[o]=r[s]}}return t}async function IH(e){let t=I3(e);return Ys.getManager(t.scheme).removeModel(t.path)}async function CH(e,t){return wH(e,t,!1)}async function SH(e,t){return wH(e,t,!0)}var NH=class{fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}};if(he().get("IS_BROWSER")){he().setPlatform("browser",new NH);try{Ys.registerManager(Ku.URL_SCHEME,new sD)}catch(e){}try{Ys.registerManager(Hu.URL_SCHEME,new rD)}catch(e){}}var MMe={importFetch:()=>TH()},oD;var _H=class{constructor(){this.util=_c("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return he().global.fetch!=null?he().global.fetch(t,n):(oD==null&&(oD=MMe.importFetch()),oD(t,n))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}};he().get("IS_NODE")&&he().setPlatform("node",new _H);function et(e,t="float32",n){return t=t||"float32",IA(e),new sn(e,t,n)}function zMe(e,t){let n=O(e,"x","cast");if(!_7(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},s={dtype:t};return z.runKernel(bl,r,s)}var we=L({cast_:zMe});function LMe(e){let n={x:O(e,"x","clone","string_or_numeric")};return z.runKernel(Al,n)}var So=L({clone_:LMe});function EH(e,t=!1){console.log(e.toString(t))}Z7();var BMe={buffer:et,cast:we,clone:So,print:EH};rH(BMe);var na={};dn(na,{browserFiles:()=>$H,browserHTTPRequest:()=>PH,concatenateArrayBuffers:()=>by,copyModel:()=>CH,decodeWeights:()=>w3,encodeWeights:()=>lH,fromMemory:()=>zH,getLoadHandlers:()=>mH,getModelArtifactsForJSON:()=>Ay,getModelArtifactsInfoForJSON:()=>kl,getSaveHandlers:()=>hH,http:()=>N3,isHTTPScheme:()=>S3,listModels:()=>kH,loadWeights:()=>FH,moveModel:()=>SH,registerLoadRouter:()=>fH,registerSaveRouter:()=>dH,removeModel:()=>IH,weightsLoaderFactory:()=>lD,withSaveHandler:()=>LH});var VMe="model",WMe=".json",GMe=".weights.bin";function RH(e){return new Promise(t=>setTimeout(t)).then(e)}var ld=class{constructor(t){if(!he().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ld.URL_SCHEME)&&(t=t.slice(ld.URL_SCHEME.length)),(t==null||t.length===0)&&(t=VMe),this.modelJsonFileName=t+WMe,this.weightDataFileName=t+GMe}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=k3(t,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await RH(()=>a.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=n,await RH(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:kl(t)}}}};ld.URL_SCHEME="downloads://";var DH=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{let r=new FileReader;r.onload=s=>{let o=JSON.parse(s.target.result),a=o.modelTopology;if(a==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:a});return}let l=Ay(o,u=>this.loadWeights(u));t(l)},r.onerror=s=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(t){let n=[],r=[];for(let a of t)n.push(...a.weights),r.push(...a.paths);let s=this.checkManifestAndWeightFiles(t),o=r.map(a=>this.loadWeightsFile(a,s[a]));return Promise.all(o).then(a=>[n,by(a)])}loadWeightsFile(t,n){return new Promise((r,s)=>{let o=new FileReader;o.onload=a=>{let i=a.target.result;r(i)},o.onerror=a=>s(`Failed to weights data from file of path '${t}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){let n=[],r=this.weightsFiles.map(o=>Q7(o.name)),s={};for(let o of t)o.paths.forEach(a=>{let i=Q7(a);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),r.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);s[a]=this.weightsFiles[r.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}},UMe=e=>he().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ld.URL_SCHEME)?jMe(e.slice(ld.URL_SCHEME.length)):null;Cn.registerSaveRouter(UMe);function jMe(e="model"){return new ld(e)}function $H(e){return new DH(e)}function aD(e,t,n,r){a(e),n=n==null?0:n,r=r==null?1:r,i(n,r);let s=0,o=l=>(l.then(u=>{let c=n+ ++s/e.length*(r-n);return t(c),u}),l);function a(l){V(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function i(l,u){V(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),V(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),V(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(o))}async function iD(e,t){t==null&&(t={});let n=t.fetchFunc==null?he().platform.fetch:t.fetchFunc,r=e.map(p=>n(p,t.requestInit,{isBinary:!0})),s=0,o=.5,i=(t.onProgress==null?await Promise.all(r):await aD(r,t.onProgress,s,o)).map(p=>p.arrayBuffer()),l=.5,u=1;return t.onProgress==null?await Promise.all(i):await aD(i,t.onProgress,l,u)}async function FH(e,t="",n,r){return lD(a=>iD(a,{requestInit:r}))(e,t,n)}function lD(e){return async(t,n="",r)=>{let s=t.map(()=>!1),o={},a=r!=null?r.map(()=>!1):[],i=[];if(t.forEach((f,h)=>{let m=0;f.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,y=FA[x]*bn(g.shape),b=()=>{s[h]=!0,o[h]==null&&(o[h]=[]),o[h].push({manifestEntry:g,groupOffset:m,sizeBytes:y})};r!=null?r.forEach((A,v)=>{A===g.name&&(b(),a[v]=!0)}):b(),i.push(g.name),m+=y})}),!a.every(f=>f)){let f=r.filter((h,m)=>!a[m]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let l=s.reduce((f,h,m)=>(h&&f.push(m),f),[]),u=[];l.forEach(f=>{t[f].paths.forEach(h=>{let m=n+(n.endsWith("/")?"":"/")+h;u.push(m)})});let c=await e(u),p={},d=0;return l.forEach(f=>{let h=t[f].paths.length,m=0;for(let A=0;A<h;A++)m+=c[d+A].byteLength;let g=new ArrayBuffer(m),x=new Uint8Array(g),y=0;for(let A=0;A<h;A++){let v=new Uint8Array(c[d+A]);x.set(v,y),y+=v.byteLength}o[f].forEach(A=>{let v=g.slice(A.groupOffset,A.groupOffset+A.sizeBytes),w=w3(v,[A.manifestEntry]);for(let k in w)p[k]=w[k]}),d+=h}),p}}var HMe="application/octet-stream",qMe="application/json",C3=class{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(V(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=he().platform.fetch,V(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&V(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;let r=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],s=k3(t,r);n.body.append("model.json",new Blob([JSON.stringify(s)],{type:qMe}),"model.json"),t.weightData!=null&&n.body.append("model.weights.bin",new Blob([t.weightData],{type:HMe}),"model.weights.bin");let o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:kl(t),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch(o){let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Ay(n,o=>this.loadWeights(o))}async loadWeights(t){let n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=KMe(n),o=this.weightPathPrefix||r,a=[];for(let c of t)a.push(...c.weights);let i=[],l=[];for(let c of t)for(let p of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(p)):i.push(o+p+s);this.weightUrlConverter&&i.push(...await Promise.all(l));let u=await iD(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,by(u)]}};C3.URL_SCHEME_REGEX=/^https?:\/\//;function KMe(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function S3(e){return e.match(C3.URL_SCHEME_REGEX)!=null}var OH=(e,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>S3(r)):n=S3(e),n)return N3(e,t)}return null};Cn.registerSaveRouter(OH);Cn.registerLoadRouter(OH);function N3(e,t){return new C3(e,t)}function PH(e,t){return N3(e,t)}var T3=class{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}},MH=class{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}};function zH(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new T3(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new T3({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new T3({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function LH(e){return new MH(e)}function XMe(e,t,n=!1,r=!1){let s=O(e,"a","matMul"),o=O(t,"b","matMul");[s,o]=_t(s,o);let a={a:s,b:o},i={transposeA:n,transposeB:r};return z.runKernel(xp,a,i)}var Bt=L({matMul_:XMe});function ZMe(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let o={indices:O(e,"indices","oneHot","int32")},a={depth:t,onValue:n,offValue:r};return z.runKernel(Bp,o,a)}var ud=L({oneHot_:ZMe});function YMe(e,t){let n=O(e,"x","transpose");if(t==null&&(t=n.shape.map((o,a)=>a).reverse()),V(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(o=>{V(o>=0&&o<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let r={x:n},s={perm:t};return z.runKernel(ed,r,s)}var St=L({transpose_:YMe});function JMe(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(bn(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=t.shape,o=s[s.length-1],a=1;for(let p=0;p<s.length-1;++p)a*=s[p];let i=e.shape,l=s.slice();l.pop();let u=1;for(let p=o;p<n;++p)u*=i[p],l.push(i[p]);let c=[...yl(e.shape).map(p=>p/u),1].slice(0,o);return[l,a,u,c]}function BH(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(o+` update.rank != ${s+e.length-r}`);for(let a=0;a<s;++a)if(n.shape[a]!==t.shape[a])throw new Error(o+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<n.rank-s;++a)if(n.shape[a+s]!==e[a+r])throw new Error(o+` updates.shape[${a+s}] (${n.shape[a+s]}) != shape[${a+s}] (${e[a+s]})`)}function uD(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}BH(n,t,e)}function QMe(e,t,n){let r=t.shape.length,s=r>1?t.shape[r-1]:1,o=n.length,a=1;for(let p=s;p<o;++p)a*=n[p];let i=s<1?1:s,l=bn(t.shape)/i,u=[...yl(n.slice(0,s)),1],c=bn(n);return{sliceRank:s,numUpdates:l,sliceSize:a,strides:u,outputSize:c}}var Cs={};dn(Cs,{assertParamsValid:()=>eze,computeFlatOffset:()=>nze,computeOutShape:()=>VH,getNormalizedAxes:()=>jH,isSliceContinous:()=>tze,maskToAxes:()=>_3,parseSliceParams:()=>cD,sliceInfo:()=>rze,startForAxis:()=>XH,startIndicesWithElidedDims:()=>HH,stopForAxis:()=>ZH,stopIndicesWithElidedDims:()=>qH,stridesForAxis:()=>KH,stridesWithElidedDims:()=>WH});function eze(e,t,n){let r=e.shape.length;V(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),V(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)V(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function _3(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function VH(e,t,n){let r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function WH(e,t,n,r){let s=[...e];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)o===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function GH(e,t,n){return n<=e?n:n-(t-1)}function UH(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function jH(e,t,n,r,s,o,a,i,l){let u=e.length,c=new Array(u),p=new Array(u),d=new Array(u);if(t.length&&n>0){let f=t[0],h=n+1;c=HH(a,f,h,r,e),p=qH(i,f,h,s,e),d=WH(o,f,h,e)}else for(let f=0;f<u;f++)c[f]=XH(a,r,o,e,f,l),p[f]=ZH(i,s,o,e,f,l),d[f]=KH(o,f,l);return{begin:c,end:p,strides:d}}function HH(e,t,n,r,s){let o=[...s],a=UH(n,t);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{let l=GH(t,n,i),u=r[l];e&1<<l&&(u=0),o[i]=u}return o}function qH(e,t,n,r,s){let o=[...s],a=UH(n,t);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{let l=GH(t,n,i),u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[i]=u}for(let i=0;i<o.length;i++){let l=s[i];o[i]<0&&(o[i]+=l),o[i]=cx(0,o[i],s[i])}return o}function KH(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function XH(e,t,n,r,s,o){let a=t[s],i=n[s]||1;(e&1<<s||o&1<<s||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let l=r[s];return a<0&&(a+=l),a=cx(0,a,l-1),a}function ZH(e,t,n,r,s,o){let a=t[s],i=n[s]||1;(e&1<<s||o&1<<s||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let l=r[s];return a<0&&(a+=l),i>0?a=cx(0,a,l):a=cx(-1,a,l-1),a}function tze(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function nze(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function cD(e,t,n){let r,s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(a=>{V(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(s).fill(-1):typeof n=="number"?o=[n,...new Array(s-1).fill(-1)]:n.length<s?o=n.concat(new Array(s-n.length).fill(-1)):o=n,o=o.map((a,i)=>a>=0?a:(V(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),e.shape[i]-r[i])),[r,o]}function rze(e,t,n,r,s,o,a,i,l){let u=t.slice(),c=n.slice(),p=r;r==null&&(p=new Array(u.length));let d=_3(a);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(a!==0&&i!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(a!==0&&l!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let f=e.length-u.length,h=_3(i),m=e.slice();h.forEach(k=>{u[k]=0,c[k]=1,m.splice(k,0,1)});let{begin:g,end:x,strides:y}=jH(m,d,f,u,c,p,s,o,a);u=g,c=x,p=y;let b=_3(l);b.forEach(k=>{c[k]=u[k]+1,p[k]=1});let A=VH(u,c,p),v=A.filter((k,I)=>b.indexOf(I)===-1);return{nonStrided:p.every(k=>k===1),$begin:u,$end:c,$strides:p,size:A,newShape:m,outShape:v}}var ke={};dn(ke,{Serializable:()=>E3,SerializationMap:()=>Xu,registerClass:()=>No});var E3=class{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}},Xu=class{constructor(){this.classNameMap={}}static getMap(){return Xu.instance==null&&(Xu.instance=new Xu),Xu.instance}static register(t){Xu.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function No(e){V(e.className!=null,()=>"Class being registered does not have the static className property defined."),V(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),V(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Xu.register(e)}function sze(e){he().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}sH(sze);function Zu(){return z}function OA(){return z.memory()}function le(e,t){return z.tidy(e,t)}function ut(e){$A(e).forEach(n=>n.dispose())}function $n(e){return z.keep(e)}function R3(e,t,n=1){return z.registerBackend(e,t,n)}function YH(){return z.backend}function oze(e,t){let n=O(e,"a","add"),r=O(t,"b","add");[n,r]=_t(n,r);let s={a:n,b:r};return z.runKernel(Ri,s)}var Ie=L({add_:oze});function aze(e,t){let n=O(e,"a","floorDiv"),r=O(t,"b","floorDiv");[n,r]=_t(n,r);let s={a:n,b:r};return z.runKernel(xu,s)}var Hh=L({floorDiv_:aze});function ize(e,t){let n=O(e,"a","div"),r=O(t,"b","div");if([n,r]=_t(n,r),n.dtype==="int32"&&r.dtype==="int32")return Hh(n,r);let s={a:n,b:r},o={};return z.runKernel(pu,s,o)}var Pe=L({div_:ize});function lze(e,t){let n=O(e,"a","mul"),r=O(t,"b","mul");[n,r]=_t(n,r);let s={a:n,b:r};return z.runKernel(Nu,s)}var Y=L({mul_:lze});function uze(e){let t=O(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return z.runKernel(bp,n)}else{let n={x:t};return z.runKernel(pp,n)}}var sr=L({abs_:uze});function cze(e){let n={x:O(e,"x","acos")};return z.runKernel(eu,n)}var PA=L({acos_:cze});function pze(e){let n={x:O(e,"x","acosh")};return z.runKernel(tu,n)}var MA=L({acosh_:pze});function dze(e){V(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),V(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((s,o)=>O(s,`tensors${o}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!Wa(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return z.runKernel(dp,r)}var pD=L({addN_:dze});function fze(e,t=null,n=!1){let s={x:O(e,"x","all","bool")},o={axis:t,keepDims:n};return z.runKernel(gx,s,o)}var qh=L({all_:fze});function hze(e,t=null,n=!1){let s={x:O(e,"x","any","bool")},o={axis:t,keepDims:n};return z.runKernel(xx,s,o)}var cd=L({any_:hze});function mze(e,t=0){let r={x:O(e,"x","argMax")},s={axis:t};return z.runKernel(fp,r,s)}var Fi=L({argMax_:mze});function gze(e,t=0){let r={x:O(e,"x","argMin")},s={axis:t};return z.runKernel(hp,r,s)}var zA=L({argMin_:gze});function xze(e){let n={x:O(e,"x","asin")};return z.runKernel(nu,n)}var LA=L({asin_:xze});function yze(e){let n={x:O(e,"x","asinh")};return z.runKernel(ru,n)}var BA=L({asinh_:yze});function bze(e){let n={x:O(e,"x","atan")};return z.runKernel(su,n)}var VA=L({atan_:bze});function Aze(e,t){let n=O(e,"a","atan2"),r=O(t,"b","atan2");[n,r]=_t(n,r);let s={a:n,b:r};return z.runKernel(au,s)}var WA=L({atan2_:Aze});function vze(e){let n={x:O(e,"x","atanh")};return z.runKernel(ou,n)}var GA=L({atanh_:vze});function wze(e,t,n,r,s="NHWC",o){let a=e[3],i=[...t,a],l=QH(s);return Kh(e,i,n,o,r,null,null,l)}function dD(e,t,n,r,s,o,a="channelsLast"){let[i,l]=D3(t),u;if(a==="channelsLast")u=[i,l,e[3],e[3]];else if(a==="channelsFirst")u=[i,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${a}`);return Kh(e,u,n,r,s,o,!1,a)}function kze(e,t,n,r,s,o,a="NDHWC"){let[i,l,u]=hD(t),c,p;if(a==="NDHWC")p="channelsLast",c=[i,l,u,e[4],e[4]];else if(a==="NCDHW")p="channelsFirst",c=[i,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${a}`);return JH(e,c,n,r,s,!1,p,o)}function Kh(e,t,n,r,s,o,a=!1,i="channelsLast"){let[l,u,c,p]=[-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,p]=e;else if(i==="channelsFirst")[l,p,u,c]=e;else throw new Error(`Unknown dataFormat ${i}`);let[d,f,,h]=t,[m,g]=D3(n),[x,y]=D3(r),b=ky(d,x),A=ky(f,y),{padInfo:v,outHeight:w,outWidth:k}=Sze(s,u,c,m,g,b,A,o,i),I=a?h*p:h,N;return i==="channelsFirst"?N=[l,I,w,k]:i==="channelsLast"&&(N=[l,w,k,I]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:p,outHeight:w,outWidth:k,outChannels:I,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:f,effectiveFilterHeight:b,effectiveFilterWidth:A,dilationHeight:x,dilationWidth:y,inShape:e,outShape:N,filterShape:t}}function JH(e,t,n,r,s,o=!1,a="channelsLast",i){let[l,u,c,p,d]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,p,d]=e;else if(a==="channelsFirst")[l,d,u,c,p]=e;else throw new Error(`Unknown dataFormat ${a}`);let[f,h,m,,g]=t,[x,y,b]=hD(n),[A,v,w]=hD(r),k=ky(f,A),I=ky(h,v),N=ky(m,w),{padInfo:T,outDepth:_,outHeight:R,outWidth:S}=Nze(s,u,c,p,x,y,b,k,I,N,i),F=o?g*d:g,B;return a==="channelsFirst"?B=[l,F,_,R,S]:a==="channelsLast"&&(B=[l,_,R,S,F]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:p,inChannels:d,outDepth:_,outHeight:R,outWidth:S,outChannels:F,padInfo:T,strideDepth:x,strideHeight:y,strideWidth:b,filterDepth:f,filterHeight:h,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:A,dilationHeight:v,dilationWidth:w,inShape:e,outShape:B,filterShape:t}}function Ize(e,t,n,r,s){r==null&&(r=fD(e,t,n));let o=e[0],a=e[1],i=Xh((o-t+2*r)/n+1,s),l=Xh((a-t+2*r)/n+1,s);return[i,l]}function Cze(e,t,n,r,s,o){s==null&&(s=fD(e,t,r));let a=e[0],i=e[1],l=e[2],u=Xh((a-t+2*s)/r+1,o),c=Xh((i-t+2*s)/r+1,o),p=Xh((l-t+2*s)/r+1,o);return[u,c,p,n]}function fD(e,t,n,r=1){let s=ky(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function D3(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function hD(e){return typeof e=="number"?[e,e,e]:e}function ky(e,t){return t<=1?e:e+(e-1)*(t-1)}function Sze(e,t,n,r,s,o,a,i,l){let u,c,p;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let f=Ize([t,n],o,r,e,i);c=f[0],p=f[1]}else if(e==="same"){c=Math.ceil(t/r),p=Math.ceil(n/s);let d=Math.max(0,(c-1)*r+o-t),f=Math.max(0,(p-1)*s+a-n),h=Math.floor(d/2),m=d-h,g=Math.floor(f/2),x=f-g;u={top:h,bottom:m,left:g,right:x,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-o+1)/r),p=Math.ceil((n-a+1)/s);else if(typeof e=="object"){let d=l==="channelsLast"?e[1][0]:e[2][0],f=l==="channelsLast"?e[1][1]:e[2][1],h=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];u={top:d,bottom:f,left:h,right:m,type:d===0&&f===0&&h===0&&m===0?"VALID":"EXPLICIT"},c=Xh((t-o+d+f)/r+1,i),p=Xh((n-a+h+m)/s+1,i)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:p}}function Nze(e,t,n,r,s,o,a,i,l,u,c){let p,d,f,h;if(typeof e=="number"){p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let g=Cze([t,n,r,1],i,1,s,e,c);d=g[0],f=g[1],h=g[2]}else if(e==="same"){d=Math.ceil(t/s),f=Math.ceil(n/o),h=Math.ceil(r/a);let m=(d-1)*s+i-t,g=(f-1)*o+l-n,x=(h-1)*a+u-r,y=Math.floor(m/2),b=m-y,A=Math.floor(g/2),v=g-A,w=Math.floor(x/2),k=x-w;p={top:A,bottom:v,left:w,right:k,front:y,back:b,type:"SAME"}}else if(e==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-i+1)/s),f=Math.ceil((n-l+1)/o),h=Math.ceil((r-u+1)/a);else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:d,outHeight:f,outWidth:h}}function Xh(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function va(e){let[t,n,r]=D3(e);return t===1&&n===1&&r===1}function hs(e,t){return va(e)||va(t)}function QH(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Tze(e,t){let r={x:O(e,"x","reshape","string_or_numeric")},s={shape:t};return z.runKernel(Up,r,s)}var X=L({reshape_:Tze});function _ze(e,t,n,r,s){let o=O(e,"x","avgPool","float32"),a=1;V(hs(n,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let i=o,l=!1;o.rank===3&&(l=!0,i=X(o,[1,o.shape[0],o.shape[1],o.shape[2]])),V(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),s!=null&&V(Jt(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},p=z.runKernel(mp,u,c);return p=we(p,o.dtype),l?X(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Yu=L({avgPool_:_ze});function Eze(e,t,n,r,s,o="NDHWC"){let a=O(e,"x","avgPool3d","float32"),i=a,l=!1;a.rank===4&&(l=!0,i=X(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),V(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),V(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&V(Jt(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},p=z.runKernel(gp,u,c);return p=we(p,i.dtype),l?X(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var UA=L({avgPool3d_:Eze});function Rze(e,t=0){V(e.length>=1,()=>"Pass at least one tensor to concat");let n=A3(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return So(n[0]);let r=n,s={axis:t};return z.runKernel(Ap,r,s)}var on=L({concat_:Rze});function Dze(e){let n={x:O(e,"x","sigmoid")};return z.runKernel(zu,n)}var ra=L({sigmoid_:Dze});function $ze(e,t,n){let r=O(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s={x:r},o={begin:t,size:n};return z.runKernel(Xp,s,o)}var Tt=L({slice_:$ze});function Fze(e){let n={x:O(e,"x","tanh")};return z.runKernel(Uu,n)}var pd=L({tanh_:Fze});function Oze(e,t,n){let r=O(e,"x","batchToSpaceND"),s=t.reduce((i,l)=>i*l);V(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),V(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),V(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let o={x:r},a={blockShape:t,crops:n};return z.runKernel(yp,o,a)}var Ju=L({batchToSpaceND_:Oze});function eq(e){let t;return e.rank===0||e.rank===1?t=X(e,[1,1,1,e.size]):e.rank===2?t=X(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=X(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function Pze(e,t,n,r,s,o){o==null&&(o=.001);let a=O(e,"x","batchNorm"),i=O(t,"mean","batchNorm"),l=O(n,"variance","batchNorm"),u;s!=null&&(u=O(s,"scale","batchNorm"));let c;r!=null&&(c=O(r,"offset","batchNorm")),V(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),V(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),V(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:eq(a),scale:u,offset:c,mean:i,variance:l},f={varianceEpsilon:o},h=z.runKernel(Tp,d,f);return X(h,a.shape)}var qa=L({batchNorm_:Pze});function Mze(e,t,n,r,s,o){let a=O(e,"x","batchNorm"),i=O(t,"mean","batchNorm"),l=O(n,"variance","batchNorm"),u;s!=null&&(u=O(s,"scale","batchNorm"));let c;return r!=null&&(c=O(r,"offset","batchNorm")),V(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),V(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),V(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&V(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&V(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),qa(a,i,l,c,u,o)}var mD=L({batchNorm2d_:Mze});function zze(e,t,n,r,s,o){let a=O(e,"x","batchNorm"),i=O(t,"mean","batchNorm"),l=O(n,"variance","batchNorm"),u;s!=null&&(u=O(s,"scale","batchNorm"));let c;return r!=null&&(c=O(r,"offset","batchNorm")),V(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),V(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),V(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&V(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&V(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),qa(a,i,l,c,u,o)}var gD=L({batchNorm3d_:zze});function Lze(e,t,n,r,s,o){let a=O(e,"x","batchNorm"),i=O(t,"mean","batchNorm"),l=O(n,"variance","batchNorm"),u;s!=null&&(u=O(s,"scale","batchNorm"));let c;return r!=null&&(c=O(r,"offset","batchNorm")),V(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),V(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),V(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&V(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&V(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),qa(a,i,l,c,u,o)}var xD=L({batchNorm4d_:Lze});function Bze(e,t,n){let r=O(e,"x","bincount"),s=O(t,"weights","bincount");V(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),V(n>=0,()=>`size must be non-negative, but got ${n}.`),V(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);let o={x:r,weights:s},a={size:n};return z.runKernel(Ax,o,a)}var jA=L({bincount_:Bze});function Vze(e,t){let n=O(e,"s0","broadcastArgs","int32"),r=O(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let s={s0:n,s1:r};return z.runKernel(f3,s)}var yD=L({broadcastArgs_:Vze});function Wze(e,t){let n=O(e,"broadcastTo","x"),r=n.shape;if(t.some(u=>!(u>0)||u%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=X(n,u)}let s=n.shape,o=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])o[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return So(n);let i={x:n},l={reps:o};return z.runKernel(vl,i,l)}var Qu=L({broadcastTo_:Wze});function Gze(e){let n={x:O(e,"x","ceil")};return z.runKernel(iu,n)}var HA=L({ceil_:Gze});function Uze(e,t,n){let r=O(e,"x","clipByValue");V(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`);let s={x:r},o={clipValueMin:t,clipValueMax:n};return z.runKernel(lu,s,o)}var Pr=L({clipByValue_:Uze});function jze(e){return on(e,0)}var bD=L({concat1d_:jze});function Hze(e,t){return on(e,t)}var AD=L({concat2d_:Hze});function qze(e,t){return on(e,t)}var vD=L({concat3d_:qze});function Kze(e,t){return on(e,t)}var wD=L({concat4d_:Kze});function Xze(e,t,n,r,s="NHWC",o=[1,1],a){let i=O(e,"x","conv2d"),l=O(t,"filter","conv2d"),u=i,c=!1;i.rank===3&&(c=!0,u=X(i,[1,i.shape[0],i.shape[1],i.shape[2]])),V(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),V(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),a!=null&&V(Jt(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);let p=s==="NHWC"?u.shape[3]:u.shape[1];V(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),V(hs(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let d={x:u,filter:l},f={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a},h=z.runKernel(vp,d,f);return c?X(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Js=L({conv2d_:Xze});function Zze(e,t,n,r,s="NWC",o=1,a){let i=O(e,"x","conv1d"),l=O(t,"filter","conv1d"),u=i,c=!1;i.rank===2&&(c=!0,u=X(i,[1,i.shape[0],i.shape[1]])),V(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),V(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),a!=null&&V(Jt(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),V(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),V(hs(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),V(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let p=X(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=X(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Js(d,p,[1,n],r,"NHWC",[1,o],a);return c?X(g,[g.shape[2],g.shape[3]]):X(g,[g.shape[0],g.shape[2],g.shape[3]])}var Zh=L({conv1d_:Zze});function Yze(e,t,n,r,s,o="NHWC",a){V(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,l=t,u=!1;t.rank===3&&(u=!0,l=X(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),V(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),V(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),V(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=o==="NHWC"?i[3]:i[1],p=o==="NHWC"?l.shape[3]:l.shape[1];V(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),V(p===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`),a!=null&&V(Jt(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let d={dy:l,filter:n},f={strides:r,pad:s,dataFormat:o,dimRoundingMode:a,inputShape:i},h=z.runKernel(wp,d,f);return u?X(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Iy=L({conv2DBackpropInput_:Yze});function Jze(e,t,n,r,s,o){let a=O(e,"x","conv2dTranspose"),i=O(t,"filter","conv2dTranspose");return Iy(n,a,i,r,s,"NHWC",o)}var Yh=L({conv2dTranspose_:Jze});function Qze(e,t,n,r,s="NDHWC",o=[1,1,1]){let a=O(e,"x","conv3d"),i=O(t,"filter","conv3d"),l=a,u=!1;a.rank===4&&(u=!0,l=X(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),V(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),V(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),V(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),V(hs(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),V(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);let c={x:l,filter:i},p={strides:n,pad:r,dataFormat:s,dilations:o},d=z.runKernel(kp,c,p);return u?X(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var qA=L({conv3d_:Qze});function eLe(e,t,n,r,s){V(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,a=t,i=!1;t.rank===4&&(i=!0,a=X(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);let l=o[4],u=a.shape[4];V(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),V(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),V(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),V(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),V(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let c={dy:a,filter:n},p={pad:s,strides:r,inputShape:o},d=z.runKernel(Ix,c,p);return i?X(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var $3=L({conv3DBackpropInput_:eLe});function tLe(e,t,n,r,s){let o=O(e,"x","conv3dTranspose"),a=O(t,"filter","conv3dTranspose");return $3(n,o,a,r,s)}var kD=L({conv3dTranspose_:tLe});function nLe(e){let n={x:O(e,"x","cos")};return z.runKernel(uu,n)}var ec=L({cos_:nLe});function rLe(e){let n={x:O(e,"x","cosh")};return z.runKernel(cu,n)}var Jh=L({cosh_:rLe});function sLe(e,t=0,n=!1,r=!1){let o={x:O(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return z.runKernel(Ip,o,a)}var Qh=L({cumsum_:sLe});function oLe(e,t,n,r=!1){let s=O(e,"x","denseBincount"),o=O(t,"weights","denseBincount");V(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),V(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),V(n>=0,()=>`size must be non-negative, but got ${n}.`),V(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);let a={x:s,weights:o},i={size:n,binaryOutput:r};return z.runKernel(Sx,a,i)}var ID=L({denseBincount_:oLe});function aLe(e,t,n="NHWC"){let r=O(e,"x","depthToSpace"),s=n==="NHWC"?r.shape[1]:r.shape[2],o=n==="NHWC"?r.shape[2]:r.shape[3],a=n==="NHWC"?r.shape[3]:r.shape[1];V(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),V(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t} for depthToSpace with input shape
        ${r.shape}`),V(a%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${r.shape}`);let i={x:r},l={blockSize:t,dataFormat:n};return z.runKernel(Nx,i,l)}var KA=L({depthToSpace_:aLe});function iLe(e,t,n,r,s="NHWC",o=[1,1],a){let i=O(e,"x","depthwiseConv2d"),l=O(t,"filter","depthwiseConv2d"),u=i,c=!1;i.rank===3&&(c=!0,u=X(i,[1,i.shape[0],i.shape[1],i.shape[2]])),V(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),V(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),V(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),a!=null&&V(Jt(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);let p={x:u,filter:l},d={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a},f=z.runKernel(Cp,p,d);return c?X(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Oi=L({depthwiseConv2d_:iLe});function lLe(e,t,n,r,s=[1,1],o="NHWC"){let a=O(e,"x","dilation2d"),i=O(t,"filter","dilation2d");V(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),V(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),V(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=a,u=!1;a.rank===3&&(l=X(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);let c={x:l,filter:i},p={strides:n,pad:r,dilations:s},d=z.runKernel(Sp,c,p);return u?X(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var XA=L({dilation2d_:lLe});function uLe(e,t){let n=e.length,r=[];for(let s=0;s<n;s++){let o=n-1-s,a=e[o]||1;(t[t.length-1-s]||1)>1&&a===1&&r.unshift(o)}return r}function An(e,t){let n=[];for(let r=0;r<t.length;r++){let s=e[e.length-r-1],o=t.length-r-1,a=t[o];(s==null||s===1&&a>1)&&n.unshift(o)}return n}function kt(e,t){let n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let o=e[e.length-s-1];o==null&&(o=1);let a=t[t.length-s-1];if(a==null&&(a=1),o===1)n.unshift(a);else if(a===1)n.unshift(o);else if(o!==a){let i=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(i)}else n.unshift(o)}return n}function cLe(e,t){let n=O(e,"a","equal","string_or_numeric"),r=O(t,"b","equal","string_or_numeric");[n,r]=_t(n,r),kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Ch,s)}var Ss=L({equal_:cLe});function pLe(e,t,n){let r=O(t,"a","where"),s=O(n,"b","where"),o=O(e,"condition","where","bool"),a=kt(kt(o.shape,r.shape),s.shape),i=Qu(o,a),l=Qu(r,a),u=Qu(s,a),c={condition:i,t:l,e:u};return z.runKernel(Kp,c)}var Sn=L({where_:pLe});function dLe(e){let n={x:O(e,"x","zerosLike")};return z.runKernel(rd,n)}var Ye=L({zerosLike_:dLe});function fLe(e,t){let n=O(e,"a","div"),r=O(t,"b","div");[n,r]=_t(n,r);let s=Pe(n,r),o=Ye(s),a=Ss(r,o);return Sn(a,o,s)}var ZA=L({divNoNan_:fLe});function hLe(e,t){let n=O(e,"t1","dot"),r=O(t,"t2","dot");V((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let s=n.rank===1?n.size:n.shape[1],o=r.rank===1?r.size:r.shape[0];if(V(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),n.rank===1&&r.rank===1){let a=X(n,[1,-1]),i=X(r,[-1,1]),l=Bt(a,i);return X(l,[])}else if(n.rank===1&&r.rank===2){let a=X(n,[1,-1]),i=X(r,[r.shape[0],r.shape[1]]),l=Bt(a,i);return X(l,[l.size])}else if(n.rank===2&&r.rank===1){let a=X(r,[-1,1]),i=Bt(n,a);return X(i,[i.size])}else{let a=X(r,[r.shape[0],r.shape[1]]);return Bt(n,a)}}var tq=L({dot_:hLe});function mLe(e,...t){let n=t.map((s,o)=>O(s,`tensors${o}`,"einsum")),r={equation:e};return z.runKernel(Ex,n,r)}var CD=L({einsum_:mLe});function gLe(e){let n={x:O(e,"x","elu")};return z.runKernel(du,n)}var Pi=L({elu_:gLe});function xLe(e){let t=O(e,"x","erf");V(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=we(t,"float32"));let n={x:t};return z.runKernel(fu,n)}var YA=L({erf_:xLe});function yLe(e){let n={x:O(e,"x","exp")};return z.runKernel(hu,n)}var Zr=L({exp_:yLe});function bLe(e,t=0){let n=O(e,"x","expandDims","string_or_numeric");V(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},s={dim:t};return z.runKernel(Np,r,s)}var Mr=L({expandDims_:bLe});function ALe(e){let n={x:O(e,"x","expm1")};return z.runKernel(mu,n)}var JA=L({expm1_:ALe});function vLe(e,t){let n=O(e,"x","tile","string_or_numeric");V(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},s={reps:t};return z.runKernel(vl,r,s)}var Yr=L({tile_:vLe});function wLe(e,t,n,r="float32"){t==null&&(t=e);let s=et([e,t],r),o=e<=t?e:t;for(let i=0;i<o;++i)s.set(1,i,i);let a=X(s.toTensor(),[e,t]);if(n==null)return a;if(n.length===1)return Yr(Mr(a,0),[n[0],1,1]);if(n.length===2)return Yr(Mr(Mr(a,0),0),[n[0],n[1],1,1]);if(n.length===3)return Yr(Mr(Mr(Mr(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Cy=L({eye_:wLe});function tc(e,t,n){let r={shape:e,value:t,dtype:n};return z.runKernel($x,{},r)}function kLe(e){let n={x:O(e,"x","floor")};return z.runKernel(gu,n)}var Mi=L({floor_:kLe});function ILe(e,t,n=0,r=0){let s=O(e,"x","gather"),o=O(t,"indices","gather","int32"),a={x:s,indices:o},i={axis:n,batchDims:r};return z.runKernel(_p,a,i)}var Il=L({gather_:ILe});function CLe(e,t){let n=O(e,"a","greater","string_or_numeric"),r=O(t,"b","greater","string_or_numeric");[n,r]=_t(n,r),kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Sh,s)}var qn=L({greater_:CLe});function SLe(e,t){let n=O(e,"a","greaterEqual","string_or_numeric"),r=O(t,"b","greaterEqual","string_or_numeric");[n,r]=_t(n,r),kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(yu,s)}var To=L({greaterEqual_:SLe});function NLe(e){let n={input:O(e,"input","imag")};return z.runKernel(Mx,n)}var em=L({imag_:NLe});function TLe(e){let n={x:O(e,"x","isFinite")};return z.runKernel(bu,n)}var SD=L({isFinite_:TLe});function _Le(e){let n={x:O(e,"x","isInf")};return z.runKernel(Au,n)}var ND=L({isInf_:_Le});function ELe(e){let n={x:O(e,"x","isNaN")};return z.runKernel(vu,n)}var QA=L({isNaN_:ELe});function RLe(e,t=.2){let r={x:O(e,"x","leakyRelu")},s={alpha:t};return z.runKernel(Ep,r,s)}var nc=L({leakyRelu_:RLe});function DLe(e,t){let n=O(e,"a","less","string_or_numeric"),r=O(t,"b","less","string_or_numeric");[n,r]=_t(n,r),kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Nh,s)}var tm=L({less_:DLe});function $Le(e,t){let n=O(e,"a","lessEqual","string_or_numeric"),r=O(t,"b","lessEqual","string_or_numeric");[n,r]=_t(n,r),kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Th,s)}var _o=L({lessEqual_:$Le});function TD(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return z.runKernel(zx,{},r)}function FLe(e,t=5,n=1,r=1,s=.5){let o=O(e,"x","localResponseNormalization");V(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),V(Jt(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=X(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let l={x:a},u={depthRadius:t,bias:n,alpha:r,beta:s},c=z.runKernel(Rp,l,u);return i?X(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var e2=L({localResponseNormalization_:FLe});function OLe(e){let n={x:O(e,"x","log")};return z.runKernel(wu,n)}var Ns=L({log_:OLe});function PLe(e){let n={x:O(e,"x","log1p")};return z.runKernel(ku,n)}var nm=L({log1p_:PLe});function _D(e,t){V(fx(e),()=>"The f passed in variableGrads(f) must be a function"),V(t==null||Array.isArray(t)&&t.every(u=>u instanceof od),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let u in z.registeredVariables)t.push(z.registeredVariables[u])}let r=n?t.filter(u=>!u.trainable):null,s=t.length;t=t.filter(u=>u.trainable),V(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let o=!0,{value:a,grads:i}=z.gradients(e,t,null,o);V(i.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),V(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let l={};return t.forEach((u,c)=>{i[c]!=null&&(l[u.name]=i[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:a,grads:l}}function wa(e){return z.customGrad(e)}function MLe(e){let n={x:O(e,"x","neg")};return z.runKernel(zp,n)}var jt=L({neg_:MLe});function zLe(e){let n={x:O(e,"x","softplus")};return z.runKernel(Lu,n)}var Ka=L({softplus_:zLe});function LLe(e){let t=O(e,"x","logSigmoid");return wa(r=>({value:jt(Ka(jt(r))),gradFunc:a=>Y(a,ra(jt(r)))}))(t)}var ED=L({logSigmoid_:LLe});function BLe(e,t=null,n=!1){let s={x:O(e,"x","max")},o={reductionIndices:t,keepDims:n};return z.runKernel(Dp,s,o)}var ms=L({max_:BLe});function VLe(e,t){let n=O(e,"a","sub"),r=O(t,"b","sub");[n,r]=_t(n,r);let s={a:n,b:r};return z.runKernel(Wu,s)}var je=L({sub_:VLe});function WLe(e,t=null,n=!1){let r=O(e,"x","sum");r.dtype==="bool"&&(r=we(r,"int32"));let s={x:r},o={axis:t,keepDims:n};return z.runKernel(Zp,s,o)}var ze=L({sum_:WLe});function GLe(e,t=-1){let n=O(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return wa((s,o)=>{let a=!0,i=ms(s,t,!0),l=je(s,i),u=je(we(l,"float32"),Ns(ze(Zr(l),t,a)));return o([u]),{value:u,gradFunc:(p,d)=>{let[f]=d,h=!0,m=Zr(f);return je(p,Y(ze(p,t,h),m))}}})(n)}var rm=L({logSoftmax_:GLe});function RD(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function nq(e,t,n){let r=e.length+t.length,s=[],o=0,a=0;for(let i=0;i<r;i++)n.indexOf(i)===-1?s.push(e[o++]):s.push(t[a++]);return s}function DD(e,t){let n=[],r=e.length;for(let o=0;o<r;o++)t.indexOf(o)===-1&&n.push(e[o]);let s=t.map(o=>e[o]);return[n,s]}function Cl(e,t){let n=t.map(r=>1);return nq(e,n,t)}function ULe(e,t,n){V(RD(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function $D(e,t){if(RD(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function t2(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function jLe(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function HLe(e,t=null,n=!1){let r=O(e,"x","logSumExp"),s=Sr(t,r.shape),o=ms(r,s,!0),a=je(r,o),i=Zr(a),l=ze(i,s),u=Ns(l),c=Ie(X(o,u.shape),u);if(n){let p=Cl(c.shape,s);return X(c,p)}return c}var rq=L({logSumExp_:HLe});function qLe(e,t){let n=O(e,"a","logicalAnd","bool"),r=O(t,"b","logicalAnd","bool");kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(_h,s)}var gs=L({logicalAnd_:qLe});function KLe(e){let n={x:O(e,"x","logicalNot","bool")};return z.runKernel(Eh,n)}var rc=L({logicalNot_:KLe});function XLe(e,t){let n=O(e,"a","logicalOr","bool"),r=O(t,"b","logicalOr","bool");kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Rh,s)}var sm=L({logicalOr_:XLe});function ZLe(e,t){let n=O(e,"a","logicalXor","bool"),r=O(t,"b","logicalXor","bool");return kt(n.shape,r.shape),gs(sm(e,t),rc(gs(e,t)))}var sq=L({logicalXor_:ZLe});function YLe(e,t,n,r,s){let o=O(e,"x","maxPool"),a=1,i=o,l=!1;o.rank===3&&(l=!0,i=X(o,[1,o.shape[0],o.shape[1],o.shape[2]])),V(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),V(hs(n,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),s!=null&&V(Jt(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},p=z.runKernel($p,u,c);return l?X(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var sc=L({maxPool_:YLe});function JLe(e,t=[1,1,1],n,r,s,o="NDHWC"){let a=O(e,"x","maxPool3d"),i=a,l=!1;a.rank===4&&(l=!0,i=X(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),V(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),V(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&V(Jt(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:o},p=z.runKernel(Fp,u,c);return l?X(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var n2=L({maxPool3d_:JLe});function QLe(e,t,n,r,s=!1){let a={x:O(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},l=z.runKernel(Wx,a,i);return{result:l[0],indexes:l[1]}}var FD=L({maxPoolWithArgmax_:QLe});function eBe(e,t){let n=O(e,"a","maximum"),r=O(t,"b","maximum");[n,r]=_t(n,r),n.dtype==="bool"&&(n=we(n,"int32"),r=we(r,"int32")),kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Iu,s)}var Qs=L({maximum_:eBe});function tBe(e,t=null,n=!1){let s={x:O(e,"x","mean")},o={axis:t,keepDims:n};return z.runKernel(Op,s,o)}var Nn=L({mean_:tBe});function fn(e,t="float32"){if(t==="complex64"){let r=fn(e,"float32"),s=fn(e,"float32");return ta(r,s)}let n=mx(bn(e),t);return z.makeTensor(n,e,t)}function eo(e,t="float32"){if(t==="complex64"){let r=eo(e,"float32"),s=fn(e,"float32");return ta(r,s)}let n=kA(bn(e),t);return z.makeTensor(n,e,t)}function nBe(e,t=null,n=!1){let s={x:O(e,"x","min")},o={axis:t,keepDims:n};return z.runKernel(Pp,s,o)}var dd=L({min_:nBe});function rBe(e,t){let n=O(e,"a","minimum"),r=O(t,"b","minimum");[n,r]=_t(n,r),n.dtype==="bool"&&(n=we(n,"int32"),r=we(r,"int32")),kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Cu,s)}var oc=L({minimum_:rBe});function sBe(e,t,n){V(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=O(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");V(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=n==="reflect"?1:0;for(let i=0;i<r.rank;i++)V(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),V(t[i][0]>=0&&t[i][0]<=r.shape[i]-s&&t[i][1]>=0&&t[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);let o={paddings:t,mode:n},a={x:r};return z.runKernel(Mp,a,o)}var r2=L({mirrorPad_:sBe});function oBe(e,t){let n=O(e,"a","mod"),r=O(t,"b","mod");[n,r]=_t(n,r);let s={a:n,b:r};return z.runKernel(Su,s)}var s2=L({mod_:oBe});function aBe(e){let t=O(e,"x","square"),n={};return z.runKernel("Square",{x:t},n)}var Nt=L({square_:aBe});function iBe(e,t=null,n=!1){e=O(e,"x","moments");let r=Sr(t,e.shape),s=Nn(e,r,n),o=s.shape;n||(o=Cl(s.shape,r));let a=Nt(je(we(e,"float32"),X(s,o))),i=Nn(a,r,n);return{mean:s,variance:i}}var Sy=L({moments_:iBe});function lBe(e,t,n,r=!1){let s=O(e,"logits","multinomial"),o=s.size,a=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);n=n||Math.random();let l={logits:a===1?X(s,[1,-1]):s},u={numSamples:t,seed:n,normalized:r},c=z.runKernel(Gx,l,u);return a===1?X(c,[c.size]):c}var OD=L({multinomial_:lBe});function uBe(e,t){let n=O(e,"a","notEqual","string_or_numeric"),r=O(t,"b","notEqual","string_or_numeric");[n,r]=_t(n,r),kt(n.shape,r.shape);let s={a:n,b:r};return z.runKernel(Dh,s)}var Sl=L({notEqual_:uBe});function cBe(e){let n={x:O(e,"x","onesLike")};return z.runKernel(Lp,n)}var Nr=L({onesLike_:cBe});function pBe(e,t,n=0){let r=O(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:n},o={x:r};return z.runKernel(Wp,o,s)}var zi=L({pad_:pBe});function dBe(e,t,n){let r=O(e,"x","spaceToBatchND");V(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),V(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),V(r.shape.reduce((a,i,l)=>l>0&&l<=t.length?a&&(i+n[l-1][0]+n[l-1][1])%t[l-1]==0:a,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:r},o={blockShape:t,paddings:n};return z.runKernel(Yp,s,o)}var ac=L({spaceToBatchND_:dBe});function fBe(e,t,n,r,s,o){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");let a=O(e,"x","maxPool"),i=a,l=!1;a.rank===3&&(l=!0,i=X(a,[1,a.shape[0],a.shape[1],a.shape[2]])),V(hs(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);let u=dD(i.shape,t,o,s,r),c=[u.dilationHeight,u.dilationWidth],p;r==="same"?p=mBe([u.filterHeight,u.filterWidth],c):p=[[0,0],[0,0]];let d=c[0]===1&&c[1]===1,[f,h]=hBe([u.inHeight,u.inWidth],c,p),m=d?r:"valid",g=d?i:ac(i,c,f),y=(n==="avg"?()=>Yu(g,t,o,m):()=>sc(g,t,o,m))(),b=d?y:Ju(y,c,h);return l?X(b,[b.shape[1],b.shape[2],b.shape[3]]):b}function hBe(e,t,n){let r=n.map(c=>c[0]),s=n.map(c=>c[1]),o=e.concat(r,s),a=t.map((c,p)=>(c-o[p]%c)%c),i=s.map((c,p)=>c+a[p]),l=t.map((c,p)=>[r[p],i[p]]),u=t.map((c,p)=>[0,a[p]]);return[l,u]}function mBe(e,t){let r=e.map((a,i)=>a+(a-1)*(t[i]-1)).map(a=>a-1),s=r.map(a=>Math.floor(a/2)),o=r.map((a,i)=>a-s[i]);return r.map((a,i)=>[s[i],o[i]])}var oq=L({pool_:fBe});function gBe(e,t){let n=O(e,"base","pow"),r=O(t,"exp","pow");[n,r]=_t(n,r);let s={a:n,b:r};return z.runKernel(Tu,s)}var Eo=L({pow_:gBe});function xBe(e,t){let n=O(e,"x","prelu"),r=O(t,"alpha","prelu"),s={x:n,alpha:r};return z.runKernel(Gp,s)}var ic=L({prelu_:xBe});function yBe(e,t=null,n=!1){let r=O(e,"x","prod");r.dtype==="bool"&&(r=we(r,"int32"));let s={x:r},o={axis:t,keepDims:n};return z.runKernel(qx,s,o)}var om=L({prod_:yBe});var UD=T1(GD());var o2=class{constructor(t,n,r,s,o){this.mean=t,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=o||Math.random();this.random=UD.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let s=this.nextVal;return this.nextVal=NaN,s}let t,n,r=!1;for(;!r;){let s,o,a;do s=2*this.random()-1,o=2*this.random()-1,a=s*s+o*o;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*s*i,n=this.mean+this.stdDev*o*i,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}};var jD=class{constructor(t=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=UD.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function CBe(e,t=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let o=new o2(t,n,r,!1,s),a=et(e,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}var O3=L({randomNormal_:CBe});function SBe(e,t=0,n=1,r="float32",s){let o=et(e,r),a=new jD(t,n,null,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}var Li=L({randomUniform_:SBe});function lc(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let s={start:e,stop:t,step:n,dtype:r};return z.runKernel(Kx,{},s)}function NBe(e){let n={input:O(e,"input","real")};return z.runKernel(Xx,n)}var fd=L({real_:NBe});function TBe(e){let n={x:O(e,"x","reciprocal")};return z.runKernel(_u,n)}var a2=L({reciprocal_:TBe});function _Be(e){let n={x:O(e,"x","relu")};return z.runKernel(Eu,n)}var to=L({relu_:_Be});function EBe(e){let n={x:O(e,"x","relu6")};return z.runKernel(Ru,n)}var im=L({relu6_:EBe});function RBe(e,t){let r={x:O(e,"x","reverse")},s={dims:t};return z.runKernel(qp,r,s)}var no=L({reverse_:RBe});function DBe(e){let n={x:O(e,"x","round")};return z.runKernel(Du,n)}var lm=L({round_:DBe});function $Be(e){let n={x:O(e,"x","rsqrt")};return z.runKernel($u,n)}var um=L({rsqrt_:$Be});function Ke(e,t){if((Jo(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Jo(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ad(e,[],[],t)}function FBe(e){let n={x:O(e,"x","selu")};return z.runKernel(Fu,n)}var cm=L({selu_:FBe});function OBe(e,t,n,r,s,o=[1,1],a="NHWC"){let i=O(e,"x","separableConv2d"),l=O(t,"depthwiseFilter","separableConv2d"),u=O(n,"pointwiseFilter","separableConv2d"),c=i,p=!1;if(i.rank===3&&(p=!0,c=X(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");V(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),V(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),V(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),V(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),V(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let d=l.shape[2],f=l.shape[3];V(u.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${u.shape[2]}.`);let h=Oi(c,l,r,s,a,o),g=Js(h,u,1,"valid",a);return p?X(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var i2=L({separableConv2d_:OBe});async function PBe(e,t){let n=O(e,"x","setdiff1d"),r=O(t,"y","setdiff1d");V(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),V(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),V(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await n.data(),o=await r.data(),a=new Set(o),i=0;for(let c=0;c<s.length;c++)a.has(s[c])||i++;let l=new sn([i],n.dtype),u=new sn([i],"int32");for(let c=0,p=0;c<s.length;c++)a.has(s[c])||(l.values[p]=s[c],u.values[p]=c,p++);return[l.toTensor(),u.toTensor()]}var HD=PBe;function MBe(e){let n={x:O(e,"x","sign")};return z.runKernel(Mu,n)}var l2=L({sign_:MBe});function zBe(e){let n={x:O(e,"x","sin")};return z.runKernel(Ou,n)}var pm=L({sin_:zBe});function LBe(e){let n={x:O(e,"x","sinh")};return z.runKernel(Pu,n)}var dm=L({sinh_:LBe});function BBe(e,t,n){let r=O(e,"x","slice1d");return V(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Tt(r,[t],[n])}var u2=L({slice1d_:BBe});function VBe(e,t,n){let r=O(e,"x","slice2d");return V(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Tt(r,t,n)}var P3=L({slice2d_:VBe});function WBe(e,t,n){let r=O(e,"x","slice3d");return V(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Tt(r,t,n)}var c2=L({slice3d_:WBe});function GBe(e,t,n){let r=O(e,"x","slice4d");return V(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Tt(r,t,n)}var Ny=L({slice4d_:GBe});function UBe(e,t=-1){let n=O(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},s={dim:t};return z.runKernel(Qp,r,s)}var uc=L({softmax_:UBe});function jBe(e){V(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return z.runKernel(Dx,t)}var fm=L({fft_:jBe});function HBe(e){V(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return z.runKernel(Px,t)}var hd=L({ifft_:HBe});function qBe(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let s=X(e,[n,t]);r=hd(s)}else{let s=[n,2*(t-1)],o=X(fd(e),[n,t]),a=X(em(e),[n,t]),i=no(Tt(o,[0,1],[n,t-2]),1),l=Y(no(Tt(a,[0,1],[n,t-2]),1),Ke(-1)),u=on([o,i],1),c=on([a,l],1),p=X(ta(u,c),[s[0],s[1]]);r=hd(p)}if(r=fd(r),e.rank===3&&e.shape[0]!==0){let s=r,o=e.shape[0];r=X(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}var p2=L({irfft_:qBe});function KBe(e,t,n=0){let s={x:O(e,"x","split")},o={numOrSizeSplits:t,axis:n};return z.runKernel(Jp,s,o)}var yr=L({split_:KBe});function XBe(e,t){V(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,s;if(t!=null&&t<n){let h=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=Tt(e,h,m),n=t}else if(t!=null&&t>n){let h=e.shape.map(m=>m);h[e.shape.length-1]=t-n,s=on([e,fn(h)],e.shape.length-1),n=t}else s=e;let o=Ye(s),a=X(ta(s,o),[r,n]),i=fm(a),l=Math.floor(n/2)+1,u=fd(i),c=em(i),p=yr(u,[l,n-l],u.shape.length-1),d=yr(c,[l,n-l],c.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,X(ta(p[0],d[0]),f)}var d2=L({rfft_:XBe});function ZBe(e){let n={x:O(e,"x","sqrt")};return z.runKernel(Bu,n)}var hn=L({sqrt_:ZBe});function YBe(e,t){let n=O(e,"a","squaredDifference"),r=O(t,"b","squaredDifference");[n,r]=_t(n,r),kt(n.shape,r.shape);let s={a:n,b:r},o={};return z.runKernel(Vu,s,o)}var f2=L({squaredDifference_:YBe});function JBe(e,t){let n=O(e,"x","squeeze");return X(n,S7(n.shape,t).newShape)}var ro=L({squeeze_:JBe});function QBe(e,t=0){let n=A3(e,"tensors","stack","string_or_numeric");V(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&V(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,s={axis:t};return z.runKernel(Vp,r,s)}var or=L({stack_:QBe});function eVe(e,t=0){let r={x:O(e,"x","step")},s={alpha:t};return z.runKernel(ju,r,s)}var Bi=L({step_:eVe});function tVe(e,t,n,r,s=0,o=0,a=0,i=0,l=0){let c={x:O(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};return z.runKernel(oy,c,p)}var h2=L({stridedSlice_:tVe});function nVe(e){let n={x:O(e,"x","tan")};return z.runKernel(Gu,n)}var m2=L({tan_:nVe});function Kn(e,t){wA(e);let n=Uh(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ad(e,null,n,t)}function g2(e,t,n){if(wA(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=Uh(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ad(e,t,r,n)}function rVe(e,t=1,n=!0){let r=O(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let o={x:r},a={k:t,sorted:n},[i,l]=z.runKernel(uy,o,a);return{values:i,indices:l}}var x2=L({topk_:rVe});function sVe(e,t=0,n=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let o=new o2(t,n,r,!0,s),a=et(e,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}var hm=L({truncatedNormal_:sVe});function oVe(e,t=0){let n=O(e,"x","unique","string_or_numeric");V(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},s={axis:t},[o,a]=z.runKernel(py,r,s);return{values:o,indices:a}}var Ty=L({unique_:oVe});function aVe(e,t,n){let r=O(e,"x","unsortedSegmentSum"),s=O(t,"segmentIds","unsortedSegmentSum","int32");V(Jt(n),()=>"numSegments must be of dtype int");let o={x:r,segmentIds:s},a={numSegments:n};return z.runKernel(nd,o,a)}var M3=L({unsortedSegmentSum_:aVe});function iVe(e,t=0){let n=O(e,"x","unstack","string_or_numeric");V(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},s={axis:t};return z.runKernel(td,r,s)}var zr=L({unstack_:iVe});function qD(e,t=!0,n,r){return z.makeVariable(e,t,n,r)}function z3(e,t){let n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);let r=et(e,"int32"),s=et([n.length,e.length],"int32");for(let o=0;o<n.length;o++){let a=r.indexToLoc(n[o]),i=o*e.length;s.values.set(a,i)}return s.toTensor()}async function lVe(e){let t=O(e,"condition","whereAsync","bool"),n=await t.data(),r=z3(t.shape,n);return e!==t&&t.dispose(),r}var KD=lVe;function uVe(e,t="euclidean",n=null,r=!1){e=O(e,"x","norm");let s=Aq(e,t,n),o=s.shape;if(r){let a=Sr(n,e.shape);o=Cl(s.shape,a)}return X(s,o)}function Aq(e,t,n=null){if(e.rank===0)return sr(e);if(e.rank!==1&&n===null)return Aq(X(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ze(sr(e),n);if(t===1/0)return ms(sr(e),n);if(t===-1/0)return dd(sr(e),n);if(t==="euclidean"||t===2)return hn(ze(Eo(sr(e),Ke(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ms(ze(sr(e),n[0]),n[1]-1);if(t===1/0)return ms(ze(sr(e),n[1]),n[0]);if(t===-1/0)return dd(ze(sr(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return hn(ze(Nt(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var _y=L({norm_:uVe});function cVe(e,t,n){let r=O(e,"indices","scatterND","int32"),s=O(t,"updates","scatterND");uD(s,r,n);let o={indices:r,updates:s},a={shape:n};return z.runKernel(Jx,o,a)}var vq=L({scatterND_:cVe});function wq(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let s=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);let a=t.size;if(!(t.rank===0||t.rank===1&&a===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function pVe(e,t,n,r=0){let s=O(e,"sparseIndices","sparseToDense","int32"),o=O(t,"sparseValues","sparseToDense"),a=O(r,"defaultValue","sparseToDense",o.dtype);wq(s,o,n,a);let i={sparseIndices:s,sparseValues:o,defaultValue:a},l={outputShape:n};return z.runKernel(ry,i,l)}var L3=L({sparseToDense_:pVe});function dVe(e,t){let n=O(t,"indices","gatherND","int32"),s={params:O(e,"x","gatherND","string_or_numeric"),indices:n};return z.runKernel(Ox,s)}var kq=L({gatherND_:dVe});function Iq(e,t){if(t==null)return e.shape.slice();if(Wa(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function fVe(e,t,n,r){let s=O(e,"x","dropout");if(V(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),V(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Ot?s.clone():s;let o=Iq(s,n),a=1-t,i=Pe(Mi(Ie(Li(o,0,1,"float32",r),a)),a);return Y(s,i)}var Cq=L({dropout_:fVe});var Xa={};dn(Xa,{conv2d:()=>Sq,depthwiseConv2d:()=>Nq,matMul:()=>Tq});function hVe(e,t,n,r,s,o="NHWC",a){let i=e;e.rank===3&&(i=X(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=X(t,[1,t.shape[0],t.shape[1],t.shape[2]])),V(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),V(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),V(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=o==="NHWC"?i.shape[3]:i.shape[1],c=o==="NHWC"?l.shape[3]:l.shape[1];V(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),V(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),a!=null&&V(Jt(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let p={x:i,dy:l},d={strides:r,pad:s,dataFormat:o,dimRoundingMode:a,filterShape:n};return z.runKernel(wx,p,d)}var Ey=L({conv2DBackpropFilter_:hVe});function mm(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return Y(e,Bi(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function gm(e,t){let n=t,r=An(e.shape,t.shape);return r.length>0&&(n=ze(n,r)),X(n,e.shape)}function xm(e,t,n,r){if(t==="linear")return e;if(t==="relu")return to(e);if(t==="elu")return Pi(e);if(t==="relu6")return im(e);if(t==="prelu")return ic(e,n);if(t==="leakyrelu")return nc(e,r);if(t==="sigmoid")return ra(e);throw new Error(`Unknown fused activation ${t}.`)}var ym=(e,t)=>!(e>0)||t==="linear";function mVe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",ym(z.state.gradientDepth,l)===!1){let v=Js(e,t,n,r,s,o,a);return i!=null&&(v=Ie(v,i)),xm(v,l,u,c)}let p=O(e,"x","conv2d"),d=O(t,"filter","conv2d"),f=p,h=!1;p.rank===3&&(h=!0,f=X(p,[1,p.shape[0],p.shape[1],p.shape[2]])),V(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),V(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),a!=null&&V(Jt(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),V(f.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${d.shape[2]}.`),V(hs(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),V(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);let m=Kh(f.shape,d.shape,n,o,r,a),g;i!=null&&(g=O(i,"bias","fused conv2d"),[g]=_t(g,p),kt(m.outShape,g.shape));let x;u!=null&&(x=O(u,"prelu weights","fused conv2d"));let y=(v,w)=>{let[k,I,N,T]=w,_=mm(v,N,l);V(va(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);let R=Iy(I.shape,_,k,n,r),S=Ey(I,_,k.shape,n,r),F=[R,S];if(T!=null){let B=gm(T,_);F.push(B)}return F},b={x:f,filter:d,bias:g,preluActivationWeights:x},A={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?wa((w,k,I)=>{let N=z.runKernel(Fh,b,A);return I([k,w,N]),h&&(N=X(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:y}})(f,d):wa((w,k,I,N)=>{let T=z.runKernel(Fh,b,A);return N([k,w,T,I]),h&&(T=X(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:y}})(f,d,g)}var Sq=L({fusedConv2d_:mVe});function gVe(e,t,n,r,s,o=[1,1],a){let i=e;e.rank===3&&(i=X(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=X(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:i,dy:l},c={strides:r,pad:s,dimRoundingMode:a,dilations:o,filterShape:n};return z.runKernel(Tx,u,c)}var B3=L({depthwiseConv2dNativeBackpropFilter_:gVe});function xVe(e,t,n,r,s,o=[1,1],a){let i=t,l=!1;t.rank===3&&(l=!0,i=X(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:i,filter:n},c={strides:r,pad:s,dimRoundingMode:a,dilations:o,inputShape:e},p=z.runKernel(_x,u,c);return l?X(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var V3=L({depthwiseConv2dNativeBackpropInput_:xVe});function yVe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(ym(z.state.gradientDepth,l)===!1){let v=Oi(e,t,n,r,s,o,a);return i!=null&&(v=Ie(v,i)),xm(v,l,u,c)}let p=O(e,"x","depthwiseConv2d"),d=O(t,"filter","depthwiseConv2d"),f=p,h=!1;p.rank===3&&(h=!0,f=X(p,[1,p.shape[0],p.shape[1],p.shape[2]])),V(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),V(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),V(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),V(hs(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),a!=null&&V(Jt(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`);let m=Kh(f.shape,d.shape,n,o,r,a,!0),g;i!=null&&(g=O(i,"bias","fused conv2d"),[g]=_t(g,p),kt(m.outShape,g.shape));let x;u!=null&&(x=O(u,"prelu weights","fused depthwiseConv2d"));let y=(v,w)=>{V(va(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[k,I,N,T]=w,_=mm(v,N,l),R=V3(I.shape,_,k,n,r,o,a),S=B3(I,_,k.shape,n,r,o,a);if(T!=null){let F=gm(g,_);return[R,S,F]}return[R,S]},b={x:f,filter:d,bias:g,preluActivationWeights:x},A={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?wa((w,k,I)=>{let N=z.runKernel(Oh,b,A);return I([k,w,N]),h&&(N=X(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:y}})(f,d):wa((w,k,I,N)=>{let T=z.runKernel(Oh,b,A);return N([k,w,T,I]),h&&(T=X(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:y}})(f,d,g)}var Nq=L({fusedDepthwiseConv2d_:yVe});function bVe({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i}){if(ym(z.state.gradientDepth,o)===!1){let T=Bt(e,t,n,r);return s!=null&&(T=Ie(T,s)),xm(T,o,a,i)}let l=O(e,"a","fused matMul"),u=O(t,"b","fused matMul");[l,u]=_t(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=bn(h),x=bn(m);V(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),V(Wa(h,m),()=>`Error in fused matMul: outer dimensions (${h}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),V(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);let y=l.shape.slice(0,-2).concat([d,f]),b=n?X(l,[g,c,d]):X(l,[g,d,c]),A=r?X(u,[x,f,p]):X(u,[x,p,f]),v;s!=null&&(v=O(s,"bias","fused matMul"),[v]=_t(v,l),kt(y,v.shape));let w;a!=null&&(w=O(a,"prelu weights","fused matMul"));let k=(T,_)=>{let[R,S,F,B]=_,W=mm(X(T,F.shape),F,o),q,K;if(!n&&!r?(q=Bt(W,S,!1,!0),K=Bt(R,W,!0,!1)):!n&&r?(q=Bt(W,S,!1,!1),K=Bt(W,R,!0,!1)):n&&!r?(q=Bt(S,W,!1,!0),K=Bt(R,W,!1,!1)):(q=Bt(S,W,!0,!0),K=Bt(W,R,!0,!0)),s!=null){let J=gm(B,W);return[q,K,J]}else return[q,K]},I={a:b,b:A,bias:v,preluActivationWeights:w},N={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:i};return s==null?wa((_,R,S)=>{let F=z.runKernel($h,I,N);return S([_,R,F]),{value:X(F,y),gradFunc:k}})(b,A):wa((_,R,S,F)=>{let B=z.runKernel($h,I,N);return F([_,R,B,S]),{value:X(B,y),gradFunc:k}})(b,A,v)}var Tq=L({fusedMatMul_:bVe});function AVe(e,t,n,r,s="bilinear",o=0){let a=O(e,"image","cropAndResize"),i=O(t,"boxes","cropAndResize","float32"),l=O(n,"boxInd","cropAndResize","int32"),u=i.shape[0];V(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),V(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),V(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),V(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),V(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),V(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let c={image:a,boxes:i,boxInd:l},p={method:s,extrapolationValue:o,cropSize:r};return z.runKernel(Cx,c,p)}var _q=L({cropAndResize_:AVe});function vVe(e){let t=O(e,"image","flipLeftRight","float32");V(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return z.runKernel(Fx,n,{})}var Eq=L({flipLeftRight_:vVe});function wVe(e){let t=O(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];V(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),V(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Yr(t,s)}var Rq=L({grayscaleToRGB_:wVe});function kVe(e,t,n=0,r=.5){let s=O(e,"image","rotateWithOffset","float32");V(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let o={image:s},a={radians:t,fillValue:n,center:r};return z.runKernel(dy,o,a)}var Dq=L({rotateWithOffset_:kVe});function Za(e,t,n,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);let a=e.shape[0];return n=Math.min(n,a),V(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),V(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),V(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),V(t.rank===1,()=>"scores must be a 1D tensor"),V(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),V(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}function IVe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let o=O(e,"boxes","nonMaxSuppression"),a=O(t,"scores","nonMaxSuppression"),i=Za(o,a,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return z.runKernel(Ux,{boxes:o,scores:a},l)}var $q=L({nonMaxSuppression_:IVe});function Fq(e,t,n){let r=CVe(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function CVe(e,t,n){return NVe(e,t,n||SVe)}function SVe(e,t){return e>t?1:e<t?-1:0}function NVe(e,t,n){let r=0,s=e.length,o=0,a=!1;for(;r<s;){o=r+(s-r>>>1);let i=n(t,e[o]);i>0?r=o+1:(s=o,a=!i)}return a?r:-r-1}function W3(e,t,n,r,s){return XD(e,t,n,r,s,0)}function G3(e,t,n,r,s,o){return XD(e,t,n,r,s,0,!1,o,!0)}function U3(e,t,n,r,s,o){return XD(e,t,n,r,s,o,!0)}function XD(e,t,n,r,s,o,a=!1,i=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(Oq);let c=o>0?-.5/o:0,p=[],d=[];for(;p.length<n&&u.length>0;){let g=u.pop(),{score:x,boxIndex:y,suppressBeginIndex:b}=g;if(x<s)break;let A=!1;for(let v=p.length-1;v>=b;--v){let w=TVe(e,y,p[v]);if(w>=r){A=!0;break}if(g.score=g.score*_Ve(r,c,w),g.score<=s)break}g.suppressBeginIndex=p.length,A||(g.score===x?(p.push(y),d.push(g.score)):g.score>s&&Fq(u,g,Oq))}let f=p.length,h=n-f;i&&h>0&&(p.push(...new Array(h).fill(0)),d.push(...new Array(h).fill(0)));let m={selectedIndices:p};return a&&(m.selectedScores=d),l&&(m.validOutputs=f),m}function TVe(e,t,n){let r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),o=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),p=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),f=(i-o)*(l-a),h=(p-u)*(d-c);if(f<=0||h<=0)return 0;let m=Math.max(o,u),g=Math.max(a,c),x=Math.min(i,p),y=Math.min(l,d),b=Math.max(x-m,0)*Math.max(y-g,0);return b/(f+h-b)}function _Ve(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function Oq(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function EVe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let o=O(e,"boxes","nonMaxSuppressionAsync"),a=O(t,"scores","nonMaxSuppressionAsync"),i=Za(o,a,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;let l=await Promise.all([o.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:p}=W3(u,c,n,r,s);return o!==e&&o.dispose(),a!==t&&a.dispose(),Kn(p,"int32")}var Pq=EVe;function RVe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){let a=O(e,"boxes","nonMaxSuppression"),i=O(t,"scores","nonMaxSuppression"),l=Za(a,i,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;let u={boxes:a,scores:i},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},p=z.runKernel(Hx,u,c);return{selectedIndices:p[0],selectedScores:p[1]}}var Mq=L({nonMaxSuppressionWithScore_:RVe});async function DVe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){let a=O(e,"boxes","nonMaxSuppressionAsync"),i=O(t,"scores","nonMaxSuppressionAsync"),l=Za(a,i,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;let u=await Promise.all([a.data(),i.data()]),c=u[0],p=u[1],{selectedIndices:d,selectedScores:f}=U3(c,p,n,r,s,o);return a!==e&&a.dispose(),i!==t&&i.dispose(),{selectedIndices:Kn(d,"int32"),selectedScores:Kn(f)}}var zq=DVe;function $Ve(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){let a=O(e,"boxes","nonMaxSuppression"),i=O(t,"scores","nonMaxSuppression"),l=Za(a,i,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,d={boxes:a,scores:i},f={maxOutputSize:u,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:o},h=z.runKernel(jx,d,f);return{selectedIndices:h[0],validOutputs:h[1]}}var Lq=L({nonMaxSuppressionPadded_:$Ve});async function FVe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){let a=O(e,"boxes","nonMaxSuppressionAsync"),i=O(t,"scores","nonMaxSuppressionAsync"),l=Za(a,i,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,[d,f]=await Promise.all([a.data(),i.data()]),{selectedIndices:h,validOutputs:m}=G3(d,f,u,c,p,o);return a!==e&&a.dispose(),i!==t&&i.dispose(),{selectedIndices:Kn(h,"int32"),validOutputs:Ke(m,"int32")}}var Bq=FVe;function OVe(e,t,n=!1,r=!1){let s=O(e,"images","resizeBilinear");V(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),V(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),V(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=X(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,i={images:o},l={alignCorners:n,halfPixelCenters:r,size:t},u=z.runKernel(Hp,i,l);return a?X(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var j3=L({resizeBilinear_:OVe});function PVe(e,t,n=!1,r=!1){let s=O(e,"images","resizeNearestNeighbor");V(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),V(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),V(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),V(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=X(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,i={images:o},l={alignCorners:n,halfPixelCenters:r,size:t},u=z.runKernel(jp,i,l);return a?X(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var H3=L({resizeNearestNeighbor_:PVe});function MVe(e,t="binary",n=!1,r=.5){let s=O(e,"image","threshold"),o=.2989,a=.587,i=.114,l=s.shape[0]*s.shape[1],u=Y(Kn([r]),255),c,p,d,f;if(V(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),V(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),V(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),V(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,p,d]=yr(s,[1,1,1],-1);let g=Y(c,o),x=Y(p,a),y=Y(d,i);f=Ie(Ie(g,x),y)}else f=e;if(t==="otsu"){let g=jA(we(lm(f),"int32"),Zs([]),256);u=zVe(g,l)}let h=n?_o(f,u):qn(f,u);return we(Y(h,255),"int32")}function zVe(e,t){let n=Kn([-1]),r=Kn([0]),s=Kn([0]),o,a,i,l,u,c;for(let p=0;p<e.size-1;p++){o=Tt(e,0,p+1),a=Tt(e,p+1),u=Pe(ze(o),t),c=Pe(ze(a),t);let d=ze(Y(o,lc(0,o.size)));i=Pe(d,ze(o));let f=tc(a.shape,o.size),h=Ie(lc(0,a.size),f),m=Y(a,h);l=Pe(ze(m),ze(a));let g=je(i,l),x=je(i,l),y=Y(u,c);s=Y(Y(y,g),x);let b=qn(s,r);r=Sn(b,s,r),n=Sn(b,Kn([p]),n)}return n}var Vq=L({threshold_:MVe});function LVe(e,t,n="nearest",r="constant",s=0,o){let a=O(e,"image","transform","float32"),i=O(t,"transforms","transform","float32");V(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),V(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),V(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);let l={image:a,transforms:i},u={interpolation:n,fillMode:r,fillValue:s,outputShape:o};return z.runKernel(cy,l,u)}var Wq=L({transform_:LVe});function BVe(e,t,n){V(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),V(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);let r=O(e,"a","bandPart");V(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[o,a]=r.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);t<0&&(t=o),n<0&&(n=a);let i=X(lc(0,o,1,"int32"),[-1,1]),l=lc(0,a,1,"int32"),u=je(i,l),c=gs(_o(u,Ke(+t,"int32")),To(u,Ke(-n,"int32"))),p=fn([o,a],r.dtype);return X(or(zr(X(r,[-1,o,a])).map(d=>Sn(c,d,p))),s)}var Gq=L({bandPart_:BVe});function VVe(e){let t;if(Array.isArray(e)){t=!1,V(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=e[0].shape[0];for(let o=1;o<e.length;++o)V(e[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[o].shape[0]} vs. ${s})`)}else t=!0,e=yr(e,e.shape[0],0).map(s=>ro(s,[0]));V(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let s=0;s<e.length;++s)n.push(z.tidy(()=>{let o=r[s];if(s>0)for(let a=0;a<s;++a){let i=Y(ze(Y(n[a],o)),n[a]);o=je(o,i)}return Pe(o,_y(o,"euclidean"))}));return t?or(n,0):n}var Uq=L({gramSchmidt_:VVe});function WVe(e,t=!1){if(V(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return jq(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=zr(X(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],o=[];r.forEach(l=>{let[u,c]=jq(l,t);s.push(u),o.push(c)});let a=X(or(s,0),e.shape),i=X(or(o,0),e.shape);return[a,i]}}function jq(e,t=!1){return z.tidy(()=>{V(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],s=Cy(n),o=So(e),a=g2([[1]],[1,1]),i=So(a),l=n>=r?r:n;for(let u=0;u<l;++u){let c=o,p=i,d=s;[i,o,s]=z.tidy(()=>{let f=Tt(o,[u,u],[n-u,1]),h=_y(f),m=Tt(o,[u,u],[1,1]),g=Sn(qn(m,0),g2([[-1]]),g2([[1]])),x=je(m,Y(g,h)),y=Pe(f,x);y.shape[0]===1?i=So(a):i=on([a,Tt(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);let b=jt(Pe(Bt(g,x),h)),A=Tt(o,[u,0],[n-u,r]),v=Y(b,i),w=St(i);if(u===0)o=je(A,Bt(v,Bt(w,A)));else{let N=je(A,Bt(v,Bt(w,A)));o=on([Tt(o,[0,0],[u,r]),N],0)}let k=St(v),I=Tt(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=je(I,Bt(Bt(I,i),k));else{let N=je(I,Bt(Bt(I,i),k));s=on([Tt(s,[0,0],[n,u]),N],1)}return[i,o,s]}),ut([c,p,d])}return!t&&n>r&&(s=Tt(s,[0,0],[n,r]),o=Tt(o,[0,0],[r,r])),[s,o]})}var Hq=L({qr_:WVe});function GVe(e,t,n,r){let s=O(e,"indices","sparseFillEmptyRows"),o=O(t,"values","sparseFillEmptyRows"),a=O(n,"denseShape","sparseFillEmptyRows"),i=O(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let l={indices:s,values:o,denseShape:a,defaultValue:i},u=z.runKernel(Qx,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var qq=L({sparseFillEmptyRows_:GVe});function UVe(e,t,n){let r=O(e,"inputIndices","sparseReshape"),s=O(t,"inputShape","sparseReshape"),o=O(n,"newShape","sparseReshape");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);let a={inputIndices:r,inputShape:s,newShape:o},i=z.runKernel(ey,a);return{outputIndices:i[0],outputShape:i[1]}}var Kq=L({sparseReshape_:UVe});function jVe(e,t,n){let r=O(e,"data","sparseSegmentMean"),s=O(t,"indices","sparseSegmentMean"),o=O(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);let a={data:r,indices:s,segmentIds:o};return z.runKernel(ty,a)}var Xq=L({sparseSegmentMean_:jVe});function HVe(e,t,n){let r=O(e,"data","sparseSegmentSum"),s=O(t,"indices","sparseSegmentSum"),o=O(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);let a={data:r,indices:s,segmentIds:o};return z.runKernel(ny,a)}var Zq=L({sparseSegmentSum_:HVe});function qVe(e,t,n,r,s,o,a,i){let l=O(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=O(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:a,preserveShortSequences:i},p={data:l,dataSplits:u},d=z.runKernel(ay,p,c);return{nGrams:d[0],nGramsSplits:d[1]}}var Yq=L({stringNGrams_:qVe});function KVe(e,t,n=!0){let r=O(e,"input","stringSplit","string"),s=O(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);let o={skipEmpty:n},a={input:r,delimiter:s},i=z.runKernel(iy,a,o);return{indices:i[0],values:i[1],shape:i[2]}}var Jq=L({stringSplit_:KVe});function XVe(e,t){let n=O(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let s={input:n};return z.runKernel(ly,s,r)}var Qq=L({stringToHashBucketFast_:XVe});var so={flipLeftRight:Eq,grayscaleToRGB:Rq,resizeNearestNeighbor:H3,resizeBilinear:j3,rotateWithOffset:Dq,cropAndResize:_q,nonMaxSuppression:$q,nonMaxSuppressionAsync:Pq,nonMaxSuppressionWithScore:Mq,nonMaxSuppressionWithScoreAsync:zq,nonMaxSuppressionPadded:Lq,nonMaxSuppressionPaddedAsync:Bq,threshold:Vq,transform:Wq},eK={bandPart:Gq,gramSchmidt:Uq,qr:Hq};var y2={sparseFillEmptyRows:qq,sparseReshape:Kq,sparseSegmentMean:Xq,sparseSegmentSum:Zq},q3={stringNGrams:Yq,stringSplit:Jq,stringToHashBucketFast:Qq};var Fs=class extends E3{minimize(t,n=!1,r){let{value:s,grads:o}=this.computeGradients(t,r);if(r!=null){let a=r.map(i=>({name:i.name,tensor:o[i.name]}));this.applyGradients(a)}else this.applyGradients(o);return ut(o),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return _D(t,n)}dispose(){this.iterations_!=null&&ut(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ke(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(Fs,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var b2=class extends Fs{constructor(t,n,r=null){super();this.learningRate=t,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=z.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{let o=z.registeredVariables[r],a=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:le(()=>Ye(o).variable(a))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:le(()=>Ye(o).variable(a))});let i=Array.isArray(t)?t[s].tensor:t[r];if(i==null)return;let l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;le(()=>{let c=Ie(Y(l,this.rho),Y(Nt(i),1-this.rho)),p=Y(Pe(hn(Ie(u,this.epsilon)),hn(Ie(l,this.epsilon))),i),d=Ie(Y(u,this.rho),Y(Nt(p),1-this.rho));l.assign(c),u.assign(d);let f=Ie(Y(p,-this.learningRate),o);o.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ut(this.accumulatedGrads.map(t=>t.variable)),ut(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=t.length/2,r=!1;this.accumulatedGrads=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}};b2.className="Adadelta";No(b2);var A2=class extends Fs{constructor(t,n=.1){super();this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{let o=z.registeredVariables[r];if(this.accumulatedGrads[s]==null){let l=!1;this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:le(()=>tc(o.shape,this.initialAccumulatorValue).variable(l))}}let a=Array.isArray(t)?t[s].tensor:t[r];if(a==null)return;let i=this.accumulatedGrads[s].variable;le(()=>{let l=Ie(i,Nt(a));i.assign(l);let u=Ie(Y(Pe(a,hn(Ie(l,z.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ut(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=!1;this.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}};A2.className="Adagrad";No(A2);var v2=class extends Fs{constructor(t,n,r,s=null){super();this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],le(()=>{this.accBeta1=Ke(n).variable(),this.accBeta2=Ke(r).variable()}),s==null&&(this.epsilon=z.backend.epsilon())}applyGradients(t){let n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);le(()=>{let r=je(1,this.accBeta1),s=je(1,this.accBeta2);n.forEach((o,a)=>{let i=z.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:le(()=>Ye(i).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:le(()=>Ye(i).variable(l))});let u=Array.isArray(t)?t[a].tensor:t[o];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,p=this.accumulatedSecondMoment[a].variable,d=Ie(Y(c,this.beta1),Y(u,1-this.beta1)),f=Ie(Y(p,this.beta2),Y(Nt(u),1-this.beta2)),h=Pe(d,r),m=Pe(f,s);c.assign(d),p.assign(f);let g=Ie(Y(Pe(h,Ie(hn(m),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(Y(this.accBeta1,this.beta1)),this.accBeta2.assign(Y(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ut(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&ut(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),le(()=>{this.accBeta1.assign(Eo(this.beta1,this.iterations_+1)),this.accBeta2.assign(Eo(this.beta2,this.iterations_+1))});let n=t.length/2,r=!1;this.accumulatedFirstMoment=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}};v2.className="Adam";No(v2);var w2=class extends Fs{constructor(t,n,r,s=null,o=0){super();this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],le(()=>{this.iteration=Ke(0).variable(),this.accBeta1=Ke(n).variable()}),s==null&&(this.epsilon=z.backend.epsilon())}applyGradients(t){let n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);le(()=>{let r=je(1,this.accBeta1),s=Pe(-this.learningRate,Ie(Y(this.iteration,this.decay),1));n.forEach((o,a)=>{let i=z.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Ye(i).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:Ye(i).variable(l)});let u=Array.isArray(t)?t[a].tensor:t[o];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,p=this.accumulatedWeightedInfNorm[a].variable,d=Ie(Y(c,this.beta1),Y(u,1-this.beta1)),f=Y(p,this.beta2),h=sr(u),m=Qs(f,h);c.assign(d),p.assign(m);let g=Ie(Y(Pe(s,r),Pe(d,Ie(m,this.epsilon))),i);i.assign(g)}),this.iteration.assign(Ie(this.iteration,1)),this.accBeta1.assign(Y(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ut(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&ut(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}};w2.className="Adamax";No(w2);var bm=class extends Fs{constructor(t){super();this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{let o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;let a=z.registeredVariables[r];le(()=>{let i=Ie(Y(this.c,o),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=$n(Ke(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}};bm.className="SGD";No(bm);var k2=class extends bm{constructor(t,n,r=!1){super(t);this.learningRate=t,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=Ke(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{let o=z.registeredVariables[r];if(this.accumulations[s]==null){let l=!1;this.accumulations[s]={originalName:`${r}/momentum`,variable:le(()=>Ye(o).variable(l))}}let a=this.accumulations[s].variable,i=Array.isArray(t)?t[s].tensor:t[r];i!=null&&le(()=>{let l,u=Ie(Y(this.m,a),i);this.useNesterov?l=Ie(Y(this.c,Ie(i,Y(u,this.m))),o):l=Ie(Y(this.c,u),o),a.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ut(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=!1;this.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}};k2.className="Momentum";No(k2);var I2=class extends Fs{constructor(t,n=.9,r=0,s=null,o=!1){super();if(this.learningRate=t,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=z.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{let o=z.registeredVariables[r],a=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:le(()=>Ye(o).variable(a))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:le(()=>Ye(o).variable(a))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:le(()=>Ye(o).variable(a))});let i=Array.isArray(t)?t[s].tensor:t[r];if(i==null)return;let l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;le(()=>{let c=Ie(Y(l,this.decay),Y(Nt(i),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[s].variable,d=Ie(Y(p,this.decay),Y(i,1-this.decay)),f=Pe(Y(i,this.learningRate),hn(je(c,Ie(Nt(d),this.epsilon)))),h=Ie(Y(u,this.momentum),f);l.assign(c),p.assign(d),u.assign(h);let m=je(o,h);o.assign(m)}else{let p=Ie(Y(l,this.decay),Y(Nt(i),1-this.decay)),d=Ie(Y(u,this.momentum),Pe(Y(i,this.learningRate),hn(Ie(p,this.epsilon))));l.assign(p),u.assign(d);let f=je(o,d);o.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ut(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ut(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&ut(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=this.centered?t.length/3:t.length/2,r=!1;this.accumulatedMeanSquares=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}};I2.className="RMSProp";No(I2);var cc=class{static sgd(t){return new bm(t)}static momentum(t,n,r=!1){return new k2(t,n,r)}static rmsprop(t,n=.9,r=0,s=null,o=!1){return new I2(t,n,r,s,o)}static adam(t=.001,n=.9,r=.999,s=null){return new v2(t,n,r,s)}static adadelta(t=.001,n=.95,r=null){return new b2(t,n,r)}static adamax(t=.002,n=.9,r=.999,s=null,o=0){return new w2(t,n,r,s,o)}static adagrad(t,n=.1){return new A2(t,n)}};var Am={sgd:cc.sgd,momentum:cc.momentum,adadelta:cc.adadelta,adagrad:cc.adagrad,rmsprop:cc.rmsprop,adamax:cc.adamax,adam:cc.adam};var ZVe=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:e=>e())();function C2(){return new Promise(e=>ZVe(()=>e()))}var M={};dn(M,{ERF_A1:()=>iWe,ERF_A2:()=>lWe,ERF_A3:()=>uWe,ERF_A4:()=>cWe,ERF_A5:()=>pWe,ERF_P:()=>aWe,PARALLELIZE_THRESHOLD:()=>K3,SELU_SCALE:()=>YD,SELU_SCALEALPHA:()=>ZD,applyActivation:()=>xm,assertAndGetBroadcastShape:()=>kt,assertAxesAreInnerMostDims:()=>ULe,assertParamsConsistent:()=>YVe,assignToTypedArray:()=>xWe,axesAreInnerMostDims:()=>RD,calculateShapes:()=>QMe,checkEinsumDimSizes:()=>kWe,combineLocations:()=>nq,complexWithEvenIndex:()=>hWe,complexWithOddIndex:()=>mWe,computeConv2DInfo:()=>Kh,computeConv3DInfo:()=>JH,computeDefaultPad:()=>fD,computeDilation2DInfo:()=>wze,computeOptimalWindowSize:()=>QVe,computeOutAndReduceShapes:()=>DD,computeOutShape:()=>JVe,computePool2DInfo:()=>dD,computePool3DInfo:()=>kze,convertConv2DDataFormat:()=>QH,decodeEinsumEquation:()=>vWe,eitherStridesOrDilationsAreOne:()=>hs,expandShapeToKeepDim:()=>Cl,exponent:()=>bWe,exponents:()=>yWe,fromStringArrayToUint8:()=>DWe,fromUint8ToStringArray:()=>RWe,getAxesPermutation:()=>$D,getBroadcastDims:()=>uLe,getComplexWithIndex:()=>gWe,getEinsumComputePath:()=>IWe,getEinsumPermutation:()=>wWe,getFusedBiasGradient:()=>gm,getFusedDyActivation:()=>mm,getImageCenter:()=>eWe,getInnerMostAxes:()=>jLe,getPermuted:()=>nWe,getReductionAxes:()=>An,getReshaped:()=>tWe,getReshapedPermuted:()=>rWe,getSliceBeginCoords:()=>sWe,getSliceSize:()=>oWe,getUndoAxesPermutation:()=>t2,isIdentityPermutation:()=>CWe,log:()=>Z9e,mergeRealAndImagArrays:()=>dWe,prepareAndValidate:()=>JMe,prepareSplitSize:()=>NWe,segment_util:()=>QD,shouldFuse:()=>ym,slice_util:()=>Cs,splitRealAndImagArrays:()=>fWe,tupleValuesAreOne:()=>va,upcastType:()=>Or,validateInput:()=>uD,validateUpdateShape:()=>BH,warn:()=>Aa});function YVe(e,t){let n=e[0].length;e.forEach((s,o)=>{V(s.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),V(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((s,o)=>{for(let a=0;a<n;a++)V(a===t||s[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function JVe(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var K3=30;function QVe(e){return e<=K3?e:hx(e,Math.floor(Math.sqrt(e)))}function eWe(e,t,n){let r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}function tWe(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);let o=t.length;for(let a=0;a<o;++a)s=s.concat([e[a+1]/t[a],t[a]]);s=s.concat(e.slice(o+1))}return s}function nWe(e,t,n=!0){let r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],o=[];for(let a=1;a<e;++a)a>=t*2+1||a%2==1?o.push(a):s.push(a);r.push(...s),r.push(0),r.push(...o)}return r}function rWe(e,t,n,r=!0){let s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?r?s.push(t[o-1]*e[o]):s.push(e[o]/t[o-1]):s.push(e[o]);return s}function sWe(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function oWe(e,t,n){let r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var ZD=1.7580993408473768,YD=1.0507009873554805;var aWe=.3275911,iWe=.254829592,lWe=-.284496736,uWe=1.421413741,cWe=-1.453152027,pWe=1.061405429;function dWe(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function fWe(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function hWe(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function mWe(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function gWe(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function xWe(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function yWe(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){let o=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function bWe(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}var JD="->",AWe=/->/g,tK=",",nK="...";function vWe(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(AWe,"").length)/JD.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${JD}").`);let[r,s]=e.split(JD);V(r.indexOf(nK)===-1,()=>`The ellipsis notation ("${nK}") is not supported yet.`);let o=r.split(tK),a=o.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let d=0;d<s.length;++d){let f=s[d];if(!o.some(h=>h.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);i.indexOf(f)===-1&&i.push(f)}for(let d=0;d<r.length;++d){let f=r[d];i.indexOf(f)===-1&&f!==tK&&i.push(f)}let l=new Array(o.length);for(let d=0;d<a;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let f=0;f<o[d].length;++f)l[d].push(i.indexOf(o[d][f]))}let u=i.length,c=s.length,p=[];for(let d=c;d<u;++d)p.push(d);return{allDims:i,summedDims:p,idDims:l}}function wWe(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;let r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function kWe(e,t,n){let r=new Array(e);for(let s=0;s<n.length;++s){let o=n[s].shape;for(let a=0;a<t[s].length;++a)r[t[s][a]]===void 0?r[t[s][a]]=o[a]:V(r[t[s][a]]===o[a],()=>`Expected dimension ${r[t[s][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function IWe(e,t){let n=e,r=[],s=0;e.length===0&&n.push(-1),s=e.length+1;for(let a=0;a<s;++a)r.push([]);let o=[];for(let a=0;a<n.length;++a){let i=n[a],l=SWe(t,i);for(let u of l)o.indexOf(u)===-1&&(r[a].push(u),o.push(u))}return{path:n,steps:r}}function CWe(e){return e.every((t,n)=>t===n)}function SWe(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function NWe(e,t,n=0){let r=[];if(typeof t=="number")V(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let s=t.reduce((a,i)=>(i===-1&&(a+=1),a),0);V(s<=1,()=>"There should be only one negative value in split array.");let o=t.indexOf(-1);if(o!==-1){let a=t.reduce((i,l)=>l>0?i+l:i);t[o]=e.shape[n]-a}V(e.shape[n]===t.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}var QD={};dn(QD,{collectGatherOpShapeInfo:()=>EWe,computeOutShape:()=>_We,segOpComputeOptimalWindowSize:()=>TWe});function TWe(e,t){let n=!1,r;for(e<=K3?(r=e,n=!0):r=hx(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=hx(e,r+1);return r}function _We(e,t,n){let r=[],s=e.length;for(let o=0;o<s;o++)o!==t?r.push(e[o]):r.push(n);return r}function EWe(e,t,n,r){let s=t.shape.length,o=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let p=0;p<r;++p)if(e.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${e.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let a=e.shape[n],i=[],l=1,u=1,c=1;for(let p=0;p<r;++p)i.push(e.shape[p]),l*=e.shape[p];for(let p=r;p<n;p++)i.push(e.shape[p]),u*=e.shape[p];for(let p=r;p<s;p++)i.push(t.shape[p]);for(let p=n+1;p<o;p++)i.push(e.shape[p]),c*=e.shape[p];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:i}}function RWe(e){try{return e.map(t=>xy(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function DWe(e){return e.map(t=>gy(t))}var Ts={};dn(Ts,{nonMaxSuppressionV3Impl:()=>W3,nonMaxSuppressionV4Impl:()=>G3,nonMaxSuppressionV5Impl:()=>U3,whereImpl:()=>z3});var X3={kernelName:pp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,Bi(we(n,"float32"),-1))}}};var rK={kernelName:eu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Nt(we(n,"float32")),s=hn(je(Ke(1),r));return jt(Pe(e,s))}}}};var sK={kernelName:tu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=hn(je(Nt(we(n,"float32")),1));return Pe(e,r)}}}};var oK={kernelName:Ri,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=kt(n.shape,r.shape);return{a:()=>{let i=e,l=An(n.shape,s);return l.length>0&&(i=ze(i,l)),X(i,n.shape)},b:()=>{let i=e,l=An(r.shape,s);return l.length>0&&(i=ze(i,l)),X(i,r.shape)}}}};var aK={kernelName:dp,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}};var iK={kernelName:fp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ye(n)}}};var lK={kernelName:hp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ye(n)}}};var uK={kernelName:nu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pe(e,hn(je(Ke(1),Nt(we(n,"float32")))))}}};var cK={kernelName:ru,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=hn(Ie(Ke(1),Nt(we(n,"float32"))));return Pe(e,r)}}}};var pK={kernelName:au,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=kt(n.shape,r.shape);return{a:()=>{let i=Ie(Nt(n),Nt(r)),l=Y(e,Pe(r,i)),u=An(n.shape,s);return u.length>0&&(l=ze(l,u)),X(l,n.shape)},b:()=>{let i=Ie(Nt(n),Nt(r)),l=jt(Y(e,Pe(n,i))),u=An(r.shape,s);return u.length>0&&(l=ze(l,u)),X(l,r.shape)}}}};var dK={kernelName:su,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pe(e,Ie(Nt(we(n,"float32")),1))}}};var fK={kernelName:ou,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pe(e,je(Ke(1),Nt(we(n,"float32"))))}}};function $We(e,t,n,r,s,o){let a=O(e,"dy","avgPool3dGrad"),i=O(t,"input","avgPool3dGrad"),l=a,u=i,c=!1;i.rank===4&&(c=!0,l=X(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=X(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),V(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),V(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),o!=null&&V(Jt(s),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);let p={dy:l,input:u},d={filterSize:n,strides:r,pad:s,dimRoundingMode:o},f=z.runKernel(bx,p,d);return c?X(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var hK=L({avgPool3dGrad_:$We});var mK={kernelName:gp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:i}=n;return{x:()=>hK(e,r,s,o,a,i)}}};function FWe(e,t,n,r,s){let o=O(e,"dy","avgPoolGrad"),a=O(t,"input","avgPoolGrad");V(a.rank===o.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${o.rank})`);let i=a,l=o,u=!1;a.rank===3&&(u=!0,i=X(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=X(o,[1,o.shape[0],o.shape[1],o.shape[2]])),V(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),V(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let c={dy:l,input:i},p={filterSize:n,strides:r,pad:s},d=z.runKernel(yx,c,p);return u?X(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var gK=L({avgPoolGrad_:FWe});var xK={kernelName:mp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:o,pad:a}=n;return{x:()=>gK(e,r,s,o,a)}}};var yK={kernelName:xp,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,s]=t,{transposeA:o,transposeB:a}=n;return!o&&!a?{a:()=>Bt(e,s,!1,!0),b:()=>Bt(r,e,!0,!1)}:!o&&a?{a:()=>Bt(e,s,!1,!1),b:()=>Bt(e,r,!0,!1)}:o&&!a?{a:()=>Bt(s,e,!1,!0),b:()=>Bt(r,e,!1,!1)}:{a:()=>Bt(s,e,!0,!0),b:()=>Bt(e,r,!0,!0)}}};var bK={kernelName:yp,gradFunc:(e,t,n)=>{let{blockShape:r,crops:s}=n;return{x:()=>ac(e,r,s)}}};var AK={kernelName:Ej,gradFunc:(e,t,n)=>{let r=n,s=r.inputShape,o=r.shape,a=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])a[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);let i=[];for(let l=0;l<a.length;l++)a[l]>1&&i.push(l);return{x:()=>ze(e,i,!0)}}};var vK={kernelName:bl,gradFunc:e=>({x:()=>e.clone()})};var wK={kernelName:iu,gradFunc:e=>({x:()=>Ye(e)})};var kK={kernelName:lu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:s,clipValueMax:o}=n;return{x:()=>Sn(gs(To(r,s),_o(r,o)),e,Ye(e))}}};var IK={kernelName:bp,inputsToSave:["x"],gradFunc:X3.gradFunc};var CK={kernelName:Ap,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(l=>l.shape),{axis:s}=n,o=Sr(s,t[0].shape)[0],a=r.map(l=>l[o]);return yr(e,a,o).map(l=>()=>l)}};var SK={kernelName:vp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{dilations:o,strides:a,pad:i,dataFormat:l}=n;return V(va(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>Iy(r.shape,e,s,a,i,l),filter:()=>Ey(r,e,s.shape,a,i,l)}}};var NK={kernelName:wp,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{strides:o,pad:a,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>Js(e,s,o,a,i,1,l),filter:()=>Ey(e,r,s.shape,o,a,i,l)}}};function OWe(e,t,n,r,s){let o=e;e.rank===4&&(o=X(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let a=t;a.rank===4&&(a=X(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),V(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),V(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),V(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),V(o.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${n[3]}.`),V(a.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`);let i={x:o,dy:a},l={strides:r,pad:s,filterShape:n};return z.runKernel(kx,i,l)}var TK=L({conv3DBackpropFilter_:OWe});var _K={kernelName:kp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:o}=n;V(va(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[a,i]=t;return{x:()=>$3(a.shape,e,i,s,o),filter:()=>TK(a,e,i.shape,s,o)}}};var EK={kernelName:uu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(jt(pm(we(n,"float32"))),e)}}};var RK={kernelName:cu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(dm(we(n,"float32")),e)}}};var DK={kernelName:Ip,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s,exclusive:o,reverse:a}=n;return{x:()=>{let i=$D([s],r.rank),l=Qh(e,s,o,!a);return i!=null&&(l=St(l,i)),l}}}};var $K={kernelName:Cp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:o,dimRoundingMode:a}=n,i=r==null?[1,1]:r;V(va(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[l,u]=t;return V(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),V(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),V(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),V(hs(s,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${i}'.`),a!=null&&V(Jt(o),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`),{x:()=>V3(l.shape,e,u,s,o,i,a),filter:()=>B3(l,e,u.shape,s,o,i,a)}}};var FK={kernelName:Sp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,o={x:r,filter:s,dy:e},a={x:r,filter:s,dy:e};return{x:()=>z.runKernel(NA,o,n),filter:()=>z.runKernel(TA,a,n)}}};var OK={kernelName:du,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>z.runKernel(Rx,r)}}};var PK={kernelName:fu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=Y(Zr(jt(Nt(n))),2/Math.sqrt(Math.PI));return{x:()=>Y(e,r)}}};var MK={kernelName:hu,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,n)}}};var zK={kernelName:Np,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>X(e,n.shape)}}};var LK={kernelName:mu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,Zr(n))}}};var BK={kernelName:gu,gradFunc:e=>({x:()=>Ye(e)})};var VK={kernelName:xu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=kt(n.shape,r.shape);return{a:()=>{let i=Pe(e,we(r,"float32")),l=An(n.shape,s);return l.length>0?X(ze(i,l),n.shape):i},b:()=>{let i=Y(e,we(n,"float32")),l=An(r.shape,s);l.length>0&&(i=X(ze(i,l),r.shape));let u=Nt(r);return jt(Pe(i,we(u,"float32")))}}}};var WK={kernelName:Tp,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[s,o,a,i]=t,l=i==null?Ke(1):i,u=An(o.shape,s.shape),c=[];if(o.rank===1){for(let A=0;A<s.shape.length-1;++A)c.push(s.shape[A]);c.push(1)}let p=je(s,o),d=Y(e,l),f=um(Ie(a,Ke(r))),h=Y(Y(Y(f,f),f),Ke(-.5));return{x:()=>o.rank===1?X(Y(Y(e,Yr(X(f,[1,1,1,o.shape[0]]),c)),l),s.shape):X(Y(Y(e,f),l),s.shape),mean:()=>{let A=Y(Y(f,Ke(-1)),d);return o.rank===1&&(A=ze(A,u)),X(A,o.shape)},variance:()=>{let A=Y(Y(h,p),d);return o.rank===1&&(A=ze(A,u)),X(A,o.shape)},scale:()=>{let A=Y(p,f),v=Y(e,A);return o.rank===1&&(v=ze(v,u)),X(v,o.shape)},offset:()=>{let A=e;return o.rank===1&&(A=ze(A,u)),X(A,o.shape)}}}};var GK={kernelName:_p,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,s]=t,{axis:o}=n,a=Sr(o,r.shape)[0];return{x:()=>{let l=r.shape,u=s.size,c=l.slice(0,a),p=c.length,d=l.slice(o,l.length).slice(1),f=d.length,h=UK(0,p),m=UK(p+1,p+1+f),g=jK([c,[u],d]),x=X(e,g),y=X(s,[u]),b=jK([[p],h,m]),A=St(x,b),v=M3(A,y,r.shape[a]),w=t2(b);return v=St(v,w),v},indices:()=>s}}};function UK(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function jK(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var HK={kernelName:yu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Ye(n),b:()=>Ye(r)}}};var qK={kernelName:Al,gradFunc:e=>({x:()=>we(e,"float32")})};var KK={kernelName:bu,gradFunc:e=>({x:()=>Ye(e)})};var XK={kernelName:Au,gradFunc:e=>({x:()=>Ye(e)})};var ZK={kernelName:vu,gradFunc:e=>({x:()=>Ye(e)})};var YK={kernelName:Ep,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:s}=n,o=qn(r,0);return{x:()=>Sn(o,e,Y(e,s))}}};var JK={kernelName:ku,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pe(e,Ie(n,1))}}};var QK={kernelName:wu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pe(e,we(n,"float32"))}}};var eX={kernelName:Rj,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n;return{logits:()=>{let o=!0,a=Zr(r);return je(e,Y(ze(e,s,o),a))}}}};function PWe(e,t,n,r=5,s=1,o=1,a=.5){let i={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:o,beta:a};return z.runKernel(Lx,i,l)}var tX=L({localResponseNormalizationBackprop_:PWe});var nX={kernelName:Rp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{depthRadius:o,bias:a,alpha:i,beta:l}=n;return{x:()=>tX(r,s,e,o,a,i,l)}}};function Z3(e,t,n,r){return t.rank<n.rank&&(t=X(t,Cl(t.shape,r))),e.rank<n.rank&&(e=X(e,Cl(e.shape,r))),{x:()=>Y(e,we(Ss(n,t),e.dtype))}}var e$={kernelName:Dp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:s}=r,o=t[0],a=t[1],i=Sr(s,o.shape),l=Z3(e,a,o,i);return{x:()=>l.x()}}};var rX={kernelName:Iu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Y(e,we(To(n,r),"float32")),b:()=>Y(e,we(tm(n,r),"float32"))}}};function MWe(e,t,n,r,s,o,a){let i=O(e,"dy","maxPool3dGrad"),l=O(t,"input","maxPool3dGrad"),u=O(n,"output","maxPool3dGrad"),c=i,p=l,d=u,f=!1;l.rank===4&&(f=!0,c=X(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),p=X(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=X(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),V(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),V(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),V(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),a!=null&&V(Jt(o),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let h={dy:c,input:p,output:d},m={filterSize:r,strides:s,pad:o,dimRoundingMode:a},g=z.runKernel(Vx,h,m);return f?X(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var sX=L({maxPool3dGrad_:MWe});var oX={kernelName:Fp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=n;return{x:()=>sX(e,r,s,o,a,i,l)}}};function zWe(e,t,n,r,s,o,a){let i=O(e,"dy","maxPoolGrad"),l=O(t,"input","maxPoolGrad"),u=O(n,"output","maxPoolGrad");V(l.rank===i.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`),V(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),V(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),a!=null&&V(Jt(o),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let c={dy:i,input:l,output:u},p={filterSize:r,strides:s,pad:o,dimRoundingMode:a};return z.runKernel(Bx,c,p)}var aX=L({maxPoolGrad_:zWe});var iX={kernelName:$p,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:o,strides:a,pad:i}=n;return{x:()=>aX(e,r,s,o,a,i)}}};var lX={kernelName:Op,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,o=Sr(s,r.shape),i=DD(r.shape,o)[1],l=bn(i);return{x:()=>{let c=r.shape.slice();o.forEach(f=>{c[f]=1});let p=X(e,c);return Pe(Y(p,eo(r.shape,"float32")),l)}}}};var uX={kernelName:Pp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:s}=r,[o,a]=t,i=Sr(s,o.shape),l=Z3(e,a,o,i);return{x:()=>l.x()}}};var cX={kernelName:Cu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Y(e,we(_o(n,r),"float32")),b:()=>Y(e,we(qn(n,r),"float32"))}}};var pX={kernelName:Mp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,o=s.map(a=>a[0]);return{x:()=>Tt(e,o,r.shape)}}};var dX={kernelName:Su,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=kt(n.shape,r.shape);return{a:()=>{let i=An(n.shape,s);return i.length>0?X(ze(e,i),n.shape):e},b:()=>{let i=Y(e,jt(Mi(Pe(n,r)))),l=An(r.shape,s);return l.length>0?X(ze(i,l),r.shape):i}}}};var fX={kernelName:Nu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=kt(n.shape,r.shape);return{a:()=>{let i=Y(e,we(r,"float32")),l=An(n.shape,s);return l.length>0?X(ze(i,l),n.shape):i},b:()=>{let i=Y(e,we(n,"float32")),l=An(r.shape,s);return l.length>0?X(ze(i,l),r.shape):i}}}};var hX={kernelName:zp,gradFunc:e=>({x:()=>jt(e)})};var mX={kernelName:Bp,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>fn(n.shape,"float32")}}};var gX={kernelName:Lp,gradFunc:e=>({x:()=>Ye(e)})};var xX={kernelName:Vp,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return zr(e,r).map(o=>()=>o)}};var t$={kernelName:Wp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,o=s.map(a=>a[0]);return{x:()=>Tt(e,o,r.shape)}}};var yX={kernelName:Tu,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,s]=t,o=n,a=r,i=kt(o.shape,a.shape);return{a:()=>{let c=we(a,"float32"),p=Y(e,Y(c,Eo(o,je(c,Ke(1))))),d=An(o.shape,i);return d.length>0&&(p=ze(p,d)),X(p,o.shape)},b:()=>{let c=qn(o,0),p=Sn(c,Ns(o),Ye(o)),d=Y(e,Y(s,p)),f=An(a.shape,i);return f.length>0&&(d=ze(d,f)),X(d,a.shape)}}}};var bX={kernelName:Gp,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,s=qn(n,0);return{x:()=>Sn(s,e,Y(e,r)),alpha:()=>{let o=Sn(s,Ye(e),Y(e,n)),a=An(r.shape,e.shape);return a.length>0&&(o=ze(o,a)),X(o,r.shape)}}}};var AX={kernelName:pu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=kt(n.shape,r.shape);return{a:()=>{let i=Pe(e,we(r,"float32")),l=An(n.shape,s);return l.length>0?X(ze(i,l),n.shape):i},b:()=>{let i=Y(e,we(n,"float32")),l=An(r.shape,s);l.length>0&&(i=X(ze(i,l),r.shape));let u=Nt(r);return jt(Pe(i,we(u,"float32")))}}}};var vX={kernelName:_u,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pe(e,jt(Nt(n)))}}};var wX={kernelName:Ru,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=Y(_o(n,6),Bi(n));return{x:()=>Y(e,we(r,"float32"))}}};var kX={kernelName:Eu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,we(Bi(n),"float32"))}}};var IX={kernelName:Up,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>X(e,n.shape)}}};var CX={kernelName:Hp,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>z.runKernel(Yx,s,n)}}};var SX={kernelName:jp,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>z.runKernel(Zx,s,n)}}};var NX={kernelName:qp,gradFunc:(e,t,n)=>{let{dims:r}=n,s=Sr(r,e.shape);return{x:()=>no(e,s)}}};var TX={kernelName:Du,gradFunc:e=>({x:()=>Ye(e)})};var _X={kernelName:$u,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>jt(Pe(e,Y(Eo(n,1.5),2)))}}};var EX={kernelName:Kp,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>we(Ye(n),"float32"),t:()=>Y(e,we(n,e.dtype)),e:()=>Y(e,we(rc(n),e.dtype))}}};var RX={kernelName:Fu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=qn(n,Ke(0)),s=Ke(ZD),o=Ke(YD),a=Y(e,o),i=Y(Y(e,s),Zr(we(n,"float32")));return Sn(r,a,i)}}}};var DX={kernelName:zu,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,Y(n,je(Ke(1),n)))}}};var $X={kernelName:Mu,gradFunc:e=>({x:()=>Ye(e)})};var FX={kernelName:Ou,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(ec(we(n,"float32")),e)}}};var OX={kernelName:Pu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(Jh(we(n,"float32")),e)}}};var PX={kernelName:Xp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:s,size:o}=n,a=r.shape,[i,l]=cD(r,s,o),u=[];for(let c=0;c<e.rank;c++)u.push([i[c],a[c]-i[c]-l[c]]);return{x:()=>zi(e,u)}}};var MX={kernelName:Qp,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:s}=n,o=!0,a=Y(e,r);return{logits:()=>je(a,Y(ze(a,[s],o),r))}}};var zX={kernelName:Lu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,ra(n))}}};var n$={kernelName:Yp,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:s}=n;return{x:()=>Ju(e,r,s)}}};var r$={kernelName:Jp,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>on(e,r)}}};var LX={kernelName:Bu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pe(e,Y(hn(we(n,"float32")),2))}}};var BX={kernelName:sy,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(e,Y(we(n,"float32"),2))}}};var VX={kernelName:Vu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Ke(2);return{a:()=>Y(e,Y(s,je(n,r))),b:()=>Y(e,Y(s,je(r,n)))}}};var WX={kernelName:ju,gradFunc:e=>({x:()=>Ye(e)})};var GX={kernelName:Wu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=kt(n.shape,r.shape);return{a:()=>{let i=e,l=An(n.shape,s);return l.length>0&&(i=ze(i,l)),X(i,n.shape)},b:()=>{let i=e,l=An(r.shape,s);return l.length>0&&(i=ze(i,l)),X(jt(i),r.shape)}}}};var UX={kernelName:Zp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,s=r.shape.slice(),{axis:o}=n;Sr(o,r.shape).forEach(u=>{s[u]=1});let i=X(e,s),l=Y(i,eo(r.shape,"float32"));return{x:()=>l}}};var jX={kernelName:Gu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Pe(e,Nt(ec(n)))}}};var HX={kernelName:Uu,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Y(je(Ke(1),Nt(n)),e)}}};var qX={kernelName:vl,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:s}=n;return{x:()=>{let a=Ye(r);if(r.rank===1)for(let i=0;i<s[0];++i)a=Ie(a,Tt(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let l=0;l<s[1];++l)a=Ie(a,Tt(e,[i*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)a=Ie(a,Tt(e,[i*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)a=Ie(a,Tt(e,[i*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return a}}}};var KX={kernelName:ed,gradFunc:(e,t,n)=>{let r=n,{perm:s}=r,o=t2(s);return{x:()=>St(e,o)}}};var XX={kernelName:td,gradFunc:(e,t,n)=>{let r=n,{axis:s}=r;return{value:()=>or(e,s)}}};var ZX={kernelName:nd,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>LWe(e,n)}}};function LWe(e,t){let n=Qs(t,Ye(t)),r=Il(e,n),s=To(t,Ke(0,"int32")),o=r.rank-s.rank;for(let i=0;i<o;++i)s=Mr(s,i+1);s=gs(s,eo(r.shape,"bool"));let a=Ye(r);return Sn(s,r,a)}var YX={kernelName:rd,gradFunc:e=>({x:()=>Ye(e)})};var BWe=[X3,rK,sK,oK,aK,iK,lK,uK,cK,pK,dK,fK,mK,xK,yK,bK,AK,vK,wK,kK,IK,CK,NK,SK,_K,EK,RK,DK,$K,FK,AX,OK,PK,MK,zK,LK,VK,BK,WK,GK,HK,qK,KK,XK,ZK,YK,JK,QK,eX,nX,e$,e$,rX,oX,iX,lX,uX,cX,pX,dX,fX,hX,mX,gX,xX,t$,t$,yX,bX,vX,wX,kX,IX,CX,SX,NX,TX,_X,EX,RX,DX,$X,FX,OX,PX,MX,zX,n$,n$,r$,r$,LX,VX,BX,WX,GX,UX,jX,HX,qX,KX,XX,ZX,YX];for(let e of BWe)$j(e);Z().prototype.abs=function(){return this.throwIfDisposed(),sr(this)};Z().prototype.acos=function(){return this.throwIfDisposed(),PA(this)};Z().prototype.acosh=function(){return this.throwIfDisposed(),MA(this)};Z().prototype.add=function(e){return this.throwIfDisposed(),Ie(this,e)};Z().prototype.all=function(e,t){return this.throwIfDisposed(),qh(this,e,t)};Z().prototype.any=function(e,t){return this.throwIfDisposed(),cd(this,e,t)};Z().prototype.argMax=function(e){return this.throwIfDisposed(),Fi(this,e)};Z().prototype.argMin=function(e){return this.throwIfDisposed(),zA(this,e)};Z().prototype.asScalar=function(){return this.throwIfDisposed(),V(this.size===1,()=>"The array must have only 1 element."),X(this,[])};Z().prototype.asType=function(e){return this.throwIfDisposed(),we(this,e)};Z().prototype.as1D=function(){return this.throwIfDisposed(),X(this,[this.size])};Z().prototype.as2D=function(e,t){return this.throwIfDisposed(),X(this,[e,t])};Z().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),X(this,[e,t,n])};Z().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),X(this,[e,t,n,r])};Z().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),X(this,[e,t,n,r,s])};Z().prototype.asin=function(){return this.throwIfDisposed(),LA(this)};Z().prototype.asinh=function(){return this.throwIfDisposed(),BA(this)};Z().prototype.atan=function(){return this.throwIfDisposed(),VA(this)};Z().prototype.atan2=function(e){return this.throwIfDisposed(),WA(this,e)};Z().prototype.atanh=function(){return this.throwIfDisposed(),GA(this)};Z().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Yu(this,e,t,n,r)};Z().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Ju(this,e,t)};Z().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),qa(this,e,t,n,r,s)};Z().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Qu(this,e)};Z().prototype.cast=function(e){return this.throwIfDisposed(),we(this,e)};Z().prototype.ceil=function(){return this.throwIfDisposed(),HA(this)};Z().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Pr(this,e,t)};Z().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ot&&(e=[e]),on([this,...e],t)};Z().prototype.conv1d=function(e,t,n,r,s,o){return this.throwIfDisposed(),Zh(this,e,t,n,r,s,o)};Z().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Yh(this,e,t,n,r,s)};Z().prototype.conv2d=function(e,t,n,r,s,o){return this.throwIfDisposed(),Js(this,e,t,n,r,s,o)};Z().prototype.cos=function(){return this.throwIfDisposed(),ec(this)};Z().prototype.cosh=function(){return this.throwIfDisposed(),Jh(this)};Z().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Qh(this,e,t,n)};Z().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),KA(this,e,t)};Z().prototype.depthwiseConv2d=function(e,t,n,r,s,o){return this.throwIfDisposed(),Oi(this,e,t,n,r,s,o)};Z().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),XA(this,e,t,n,r,s)};Z().prototype.divNoNan=function(e){return this.throwIfDisposed(),ZA(this,e)};Z().prototype.div=function(e){return this.throwIfDisposed(),Pe(this,e)};Z().prototype.dot=function(e){return this.throwIfDisposed(),tq(this,e)};Z().prototype.elu=function(){return this.throwIfDisposed(),Pi(this)};Z().prototype.equal=function(e){return this.throwIfDisposed(),Ss(this,e)};Z().prototype.erf=function(){return this.throwIfDisposed(),YA(this)};Z().prototype.exp=function(){return this.throwIfDisposed(),Zr(this)};Z().prototype.expandDims=function(e){return this.throwIfDisposed(),Mr(this,e)};Z().prototype.expm1=function(){return this.throwIfDisposed(),JA(this)};Z().prototype.fft=function(){return this.throwIfDisposed(),fm(this)};Z().prototype.flatten=function(){return this.throwIfDisposed(),X(this,[this.size])};Z().prototype.floor=function(){return this.throwIfDisposed(),Mi(this)};Z().prototype.floorDiv=function(e){return this.throwIfDisposed(),Hh(this,e)};Z().prototype.gather=function(e,t){return this.throwIfDisposed(),Il(this,e,t)};Z().prototype.greaterEqual=function(e){return this.throwIfDisposed(),To(this,e)};Z().prototype.greater=function(e){return this.throwIfDisposed(),qn(this,e)};Z().prototype.ifft=function(){return this.throwIfDisposed(),hd(this)};Z().prototype.irfft=function(){return this.throwIfDisposed(),p2(this)};Z().prototype.isFinite=function(){return this.throwIfDisposed(),SD(this)};Z().prototype.isInf=function(){return this.throwIfDisposed(),ND(this)};Z().prototype.isNaN=function(){return this.throwIfDisposed(),QA(this)};Z().prototype.leakyRelu=function(e){return this.throwIfDisposed(),nc(this,e)};Z().prototype.lessEqual=function(e){return this.throwIfDisposed(),_o(this,e)};Z().prototype.less=function(e){return this.throwIfDisposed(),tm(this,e)};Z().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),e2(this,e,t,n,r)};Z().prototype.logSigmoid=function(){return this.throwIfDisposed(),ED(this)};Z().prototype.logSoftmax=function(e){return this.throwIfDisposed(),rm(this,e)};Z().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),rq(this,e,t)};Z().prototype.log=function(){return this.throwIfDisposed(),Ns(this)};Z().prototype.log1p=function(){return this.throwIfDisposed(),nm(this)};Z().prototype.logicalAnd=function(e){return this.throwIfDisposed(),gs(this,e)};Z().prototype.logicalNot=function(){return this.throwIfDisposed(),rc(this)};Z().prototype.logicalOr=function(e){return this.throwIfDisposed(),sm(this,e)};Z().prototype.logicalXor=function(e){return this.throwIfDisposed(),sq(this,e)};Z().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Bt(this,e,t,n)};Z().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),sc(this,e,t,n,r)};Z().prototype.max=function(e,t){return this.throwIfDisposed(),ms(this,e,t)};Z().prototype.maximum=function(e){return this.throwIfDisposed(),Qs(this,e)};Z().prototype.mean=function(e,t){return this.throwIfDisposed(),Nn(this,e,t)};Z().prototype.min=function(e,t){return this.throwIfDisposed(),dd(this,e,t)};Z().prototype.minimum=function(e){return this.throwIfDisposed(),oc(this,e)};Z().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),r2(this,e,t)};Z().prototype.mod=function(e){return this.throwIfDisposed(),s2(this,e)};Z().prototype.mul=function(e){return this.throwIfDisposed(),Y(this,e)};Z().prototype.neg=function(){return this.throwIfDisposed(),jt(this)};Z().prototype.norm=function(e,t,n){return this.throwIfDisposed(),_y(this,e,t,n)};Z().prototype.notEqual=function(e){return this.throwIfDisposed(),Sl(this,e)};Z().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),ud(this,e,t,n)};Z().prototype.onesLike=function(){return this.throwIfDisposed(),Nr(this)};Z().prototype.pad=function(e,t){return this.throwIfDisposed(),zi(this,e,t)};Z().prototype.pool=function(e,t,n,r,s){return this.throwIfDisposed(),oq(this,e,t,n,r,s)};Z().prototype.pow=function(e){return this.throwIfDisposed(),Eo(this,e)};Z().prototype.prelu=function(e){return this.throwIfDisposed(),ic(this,e)};Z().prototype.prod=function(e,t){return this.throwIfDisposed(),om(this,e,t)};Z().prototype.reciprocal=function(){return this.throwIfDisposed(),a2(this)};Z().prototype.relu=function(){return this.throwIfDisposed(),to(this)};Z().prototype.relu6=function(){return this.throwIfDisposed(),im(this)};Z().prototype.reshapeAs=function(e){return this.throwIfDisposed(),X(this,e.shape)};Z().prototype.reshape=function(e){return this.throwIfDisposed(),X(this,e)};Z().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),j3(this,e,t,n)};Z().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),H3(this,e,t,n)};Z().prototype.reverse=function(e){return this.throwIfDisposed(),no(this,e)};Z().prototype.rfft=function(){return this.throwIfDisposed(),d2(this)};Z().prototype.round=function(){return this.throwIfDisposed(),lm(this)};Z().prototype.rsqrt=function(){return this.throwIfDisposed(),um(this)};Z().prototype.selu=function(){return this.throwIfDisposed(),cm(this)};Z().prototype.separableConv2d=function(e,t,n,r,s,o){return this.throwIfDisposed(),i2(this,e,t,n,r,s,o)};Z().prototype.sigmoid=function(){return this.throwIfDisposed(),ra(this)};Z().prototype.sign=function(){return this.throwIfDisposed(),l2(this)};Z().prototype.sin=function(){return this.throwIfDisposed(),pm(this)};Z().prototype.sinh=function(){return this.throwIfDisposed(),dm(this)};Z().prototype.slice=function(e,t){return this.throwIfDisposed(),Tt(this,e,t)};Z().prototype.softmax=function(e){return this.throwIfDisposed(),uc(this,e)};Z().prototype.softplus=function(){return this.throwIfDisposed(),Ka(this)};Z().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),ac(this,e,t)};Z().prototype.split=function(e,t){return this.throwIfDisposed(),yr(this,e,t)};Z().prototype.sqrt=function(){return this.throwIfDisposed(),hn(this)};Z().prototype.square=function(){return this.throwIfDisposed(),Nt(this)};Z().prototype.squaredDifference=function(e){return this.throwIfDisposed(),f2(this,e)};Z().prototype.squeeze=function(e){return this.throwIfDisposed(),ro(this,e)};Z().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Ot?[this,e]:[this,...e];return or(n,t)};Z().prototype.step=function(e){return this.throwIfDisposed(),Bi(this,e)};Z().prototype.stridedSlice=function(e,t,n,r,s,o,a,i){return this.throwIfDisposed(),h2(this,e,t,n,r,s,o,a,i)};Z().prototype.sub=function(e){return this.throwIfDisposed(),je(this,e)};Z().prototype.sum=function(e,t){return this.throwIfDisposed(),ze(this,e,t)};Z().prototype.tan=function(){return this.throwIfDisposed(),m2(this)};Z().prototype.tanh=function(){return this.throwIfDisposed(),pd(this)};Z().prototype.tile=function(e){return this.throwIfDisposed(),Yr(this,e)};Z().prototype.toBool=function(){return this.throwIfDisposed(),we(this,"bool")};Z().prototype.toFloat=function(){return this.throwIfDisposed(),we(this,"float32")};Z().prototype.toInt=function(){return this.throwIfDisposed(),we(this,"int32")};Z().prototype.topk=function(e,t){return this.throwIfDisposed(),x2(this,e,t)};Z().prototype.transpose=function(e){return this.throwIfDisposed(),St(this,e)};Z().prototype.unique=function(e){return this.throwIfDisposed(),Ty(this,e)};Z().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),M3(this,e,t)};Z().prototype.unstack=function(e){return this.throwIfDisposed(),zr(this,e)};Z().prototype.where=function(e,t){return this.throwIfDisposed(),Sn(e,this,t)};Z().prototype.zerosLike=function(){return this.throwIfDisposed(),Ye(this)};var s$;function br(){return s$==null&&(s$=YH().epsilon()),s$}function oo(){return"channelsLast"}var sa=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,sa.prototype)}},Os=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Os.prototype)}},ne=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,ne.prototype)}},st=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,st.prototype)}},S2=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,S2.prototype)}};function Ya(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function ka(e,t){if(!e)throw new S2(t)}function o$(e,t){let n=0;for(let r of e)r===t&&n++;return n}function Jr(e){return e.length===1?e[0]:e}function mn(e){return Array.isArray(e)?e:[e]}function Ja(e){let n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function pc(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var Qa={};function Ry(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function a$(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>a$(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:a$(r))}}}function Nl(e,t={},n={},r="object",s=!1){if(typeof e=="string"){let o=e,a;if(o in n)a=n[o];else if(o in Qa)a=Qa[o];else if(a=t[o],a==null)throw new ne(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let o=e;if(o.className==null||o.config==null)throw new ne(`${r}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);let a=o.className,i,l;if(a in n?[i,l]=n[a]:a in Qa?[i,l]=Qa.className:a in t&&([i,l]=t[a]),i==null)throw new ne(`Unknown ${r}: ${a}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let f of Object.keys(Qa))u[f]=Qa[f];for(let f of Object.keys(n))u[f]=n[f];let c=o.config;c.customObjects=u;let p=Object.assign({},Qa);for(let f of Object.keys(n))Qa[f]=n[f];a$(o.config);let d=l(i,o.config,n,s);return Qa=Object.assign({},p),d}else{let u=Object.assign({},Qa);for(let p of Object.keys(n))Qa[p]=n[p];let c=new i(o.config);return Qa=Object.assign({},u),c}}}function VWe(e,t){return e<t?-1:e>t?1:0}function N2(e,t){return-1*VWe(e,t)}function ei(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function JX(e){if(e==null)throw new ne(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Tl(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new ne(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function Y3(e,t,n=0,r=1/0){return ka(n>=0),ka(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function ar(e,t){Array.isArray(e)?(C.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>ar(n,`element ${r+1} of ${t}`))):C.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${QX(e)}.`)}function QX(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>QX(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function eZ(e,t){let n=C.now(),r;return(...o)=>{let a=C.now();return a-n<t||(n=a,r=e(...o)),r}}function J3(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}function i$(e,t){return le(()=>hn(ze(Y(e,e),t,!0)))}var Dy=class extends ke.Serializable{getConfig(){return{}}},Q3=class extends Dy{constructor(t){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return le(()=>{let n=i$(t,this.axis),r=Pr(n,0,this.maxValue);return Y(t,Pe(r,Ie(br(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Q3.className="MaxNorm";ke.registerClass(Q3);var eI=class extends Dy{constructor(t){super();this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return le(()=>Pe(t,Ie(br(),i$(t,this.axis))))}getConfig(){return{axis:this.axis}}};eI.className="UnitNorm";ke.registerClass(eI);var tI=class extends Dy{apply(t){return to(t)}};tI.className="NonNeg";ke.registerClass(tI);var nI=class extends Dy{constructor(t){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return le(()=>{let n=i$(t,this.axis),r=Ie(Y(this.rate,Pr(n,this.minValue,this.maxValue)),Y(1-this.rate,n));return Y(t,Pe(r,Ie(br(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};nI.className="MinMaxNorm";ke.registerClass(nI);var tZ={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ln(e){return Ry(e)}function nZ(e,t={}){return Nl(e,ke.SerializationMap.getMap().classNameMap,t,"constraint")}function Bn(e){if(e==null)return null;if(typeof e=="string"){let n={className:e in tZ?tZ[e]:e,config:{}};return nZ(n)}else return e instanceof Dy?e:nZ(e)}var rZ=["channelsFirst","channelsLast"],sZ=["nearest","bilinear"],oZ=["valid","same","causal"],aZ=["max","avg"],iZ=["sum","mul","concat","ave"];var $y=new Map;function Fn(e){Tl(rZ,"DataFormat",e)}function lZ(e){Tl(sZ,"InterpolationFormat",e)}function ao(e){Tl(oZ,"PaddingMode",e)}function l$(e){Tl(aZ,"PoolMode",e)}var T2=[],uZ="/";function Vi(e,t){T2.push(e);try{let n=t();return T2.pop(),n}catch(n){throw T2.pop(),n}}function GWe(){return T2.length===0?"":T2.join(uZ)+uZ}function rI(e){if(!cZ(e))throw new Error("Not a valid tensor name: '"+e+"'");return GWe()+e}function sI(e){if(!cZ(e))throw new Error("Not a valid tensor name: '"+e+"'");$y.has(e)||$y.set(e,0);let t=$y.get(e);if($y.set(e,$y.get(e)+1),t>0){let n=`${e}_${t}`;return $y.set(n,1),n}else return e}var UWe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function cZ(e){return!!e.match(UWe)}function pZ(e){return e===parseInt(e.toString(),10)}function ti(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function vm(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function Wi(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function Ps(e,t){if(t<e)throw new ne(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function wm(e,t){return we(e,t)}function dc(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),X(e,n)}function dZ(e,t){return le(()=>{if(e.shape.length!==2)throw new ne(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=dc(e,1);return oI(n,[1,t,1])})}function fZ(e){let t=[ti(e.shape)];return X(e,t)}function hZ(e){if(e.rank<=1)throw new ne(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],ti(e.shape,1)];return X(e,t)}function fc(e,t,n){return le(()=>{switch(e.rank){case 1:return u2(e,t,n);case 2:return P3(e,[t,0],[n,e.shape[1]]);case 3:return c2(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Ny(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Tt(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Tt(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new ne(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function u$(e,t,n){return le(()=>{switch(e.rank){case 1:return u2(e,t,n);case 2:return P3(e,[0,t],[e.shape[0],n]);case 3:return c2(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Ny(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ne(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function _2(e,t,n,r){return le(()=>{switch(e.rank){case 1:return u2(e,t,n);case 2:switch(r){case 1:return fc(e,t,n);case 2:return u$(e,t,n);default:throw new ne(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return fc(e,t,n);case 2:return c2(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return u$(e,t,n);default:throw new ne(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return fc(e,t,n);case 2:return Ny(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Ny(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return u$(e,t,n);default:throw new ne(`The axis is not within the rank of the tensor ${r}`)}default:throw new ne(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Fy(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),on(e,t)}function c$(e,t){switch(e.rank){case 1:return bD([e,t]);case 2:return AD([e,t],0);case 3:return vD([e,t],0);case 4:return wD([e,t],0);default:throw new ne(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function oI(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ne(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Yr(e,t)}function Oy(e,t=0,n=1,r,s){return O3(e,t,n,r,s)}function ni(e,t,n,r){if(e.rank<2||t.rank<2)throw new st(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=e.shape.slice(-1)[0],o=t.shape.slice(-2)[0];if(s!==o)throw new st(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2){let s=!1,o=!1;return Xa.matMul({a:e,b:t,transposeA:s,transposeB:o,bias:r?p$(e.rank,r,oo()):null,activation:n})}else{let s=e.shape.slice(),o=s.pop();e=X(e,[-1,o]);let a=t.shape.slice(),i=a.pop(),l=a.pop(),u=[...a,i],c=Array.from({length:t.rank},(h,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=X(St(t,c),[l,-1]);let p=[...s,...u],d=!1,f=!1;return X(Xa.matMul({a:e,b:t,transposeA:d,transposeB:f,bias:r?p$(e.rank,r,oo()):null,activation:n}),p)}}function aI(e,t,n){return le(()=>(Array.isArray(t)?t=Kn(t,"int32"):t=we(t,"int32"),Il(e,t,n)))}function km(e){return Y(e,e)}function p$(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new ne(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?X(t,[1,r[0],1,1,1]):X(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?X(t,[1,1,1,1,r[0]]):X(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?X(t,[1,r[0],1,1]):X(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?X(t,[1,1,1,r[0]]):X(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?X(t,[1,r[0],1]):X(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?X(t,[1,1,r[0]]):X(t,[1].concat(r))}else if(e<3)return t;throw new ne(`Unsupported input rank by biasAdd: ${t.rank}`)}function io(e,t,n){return le(()=>(n==null&&(n=oo()),Fn(n),Ie(e,p$(e.rank,t,n))))}function mZ(e,t=1){if(t!==1)throw new st(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Pi(e)}function gZ(e){return le(()=>Pe(e,Ie(sr(e),1)))}function iI(e,t,n,r){return le(()=>Cq(e,t,n,r))}function xZ(e){return le(()=>{let t=Ie(.5,Y(.2,e));return Pr(t,0,1)})}function md(e,t,n=!1){return n?e():t()}var yZ=["fanIn","fanOut","fanAvg"],bZ=["normal","uniform","truncatedNormal"];function jWe(e){Tl(yZ,"FanMode",e)}function HWe(e){Tl(bZ,"Distribution",e)}var Ro=class extends ke.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},lI=class extends Ro{apply(t,n){return fn(t,n)}};lI.className="Zeros";ke.registerClass(lI);var Py=class extends Ro{apply(t,n){return eo(t,n)}};Py.className="Ones";ke.registerClass(Py);var uI=class extends Ro{constructor(t){super();if(typeof t!="object")throw new ne(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new ne(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return le(()=>Y(Ke(this.value),eo(t,n)))}getConfig(){return{value:this.value}}};uI.className="Constant";ke.registerClass(uI);var cI=class extends Ro{constructor(t){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return Li(t,this.minval,this.maxval,n)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};cI.className="RandomUniform";ke.registerClass(cI);var pI=class extends Ro{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new st(`randomNormal does not support dType ${n}.`);return Oy(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};pI.className="RandomNormal";ke.registerClass(pI);var dI=class extends Ro{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new st(`truncatedNormal does not support dType ${n}.`);return hm(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};dI.className="TruncatedNormal";ke.registerClass(dI);var fI=class extends Ro{constructor(t){super();this.gain=t.gain!=null?t.gain:1}apply(t,n){return le(()=>{if(t.length!==2||t[0]!==t[1])throw new ne("Identity matrix initializer can only be used for 2D square matrices.");return Y(this.gain,Cy(t[0]))})}getConfig(){return{gain:this.gain}}};fI.className="Identity";ke.registerClass(fI);function qWe(e,t="channelsLast"){let n,r;if(Fn(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let s=ti(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){let s=ti(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{let s=ti(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}var lo=class extends Ro{constructor(t){super();if(t.scale<0)throw new ne(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,jWe(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,HWe(this.distribution),this.seed=t.seed}apply(t,n){let r=qWe(t),s=r[0],o=r[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,s):this.mode==="fanOut"?a/=Math.max(1,o):a/=Math.max(1,(s+o)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new st(`${this.getClassName()} does not support dType ${n}.`);return hm(t,0,i,n,this.seed)}else{let i=Math.sqrt(3*a);return Li(t,-i,i,n)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};lo.className="VarianceScaling";ke.registerClass(lo);var E2=class extends lo{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return lo.className}};E2.className="GlorotUniform";ke.registerClass(E2);var R2=class extends lo{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return lo.className}};R2.className="GlorotNormal";ke.registerClass(R2);var D2=class extends lo{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return lo.className}};D2.className="HeNormal";ke.registerClass(D2);var $2=class extends lo{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return lo.className}};$2.className="HeUniform";ke.registerClass($2);var F2=class extends lo{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return lo.className}};F2.className="LeCunNormal";ke.registerClass(F2);var O2=class extends lo{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return lo.className}};O2.className="LeCunNormal";ke.registerClass(O2);var hI=class extends Ro{constructor(t){super();if(this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new st("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,n){return le(()=>{if(t.length<2)throw new st("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let r=t[0]>t[1]?[t[1],t[0]]:t,s=Oy(r,0,1,"float32"),o=eK.gramSchmidt(s);return t[0]>t[1]&&(o=St(o)),Y(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}};hI.className="Orthogonal";ke.registerClass(hI);var AZ={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function vZ(e,t={}){return Nl(e,ke.SerializationMap.getMap().classNameMap,t,"initializer")}function vn(e){return Ry(e)}function un(e){if(typeof e=="string"){let t=e in AZ?AZ[e]:e;if(t==="GlorotNormal")return new R2;if(t==="GlorotUniform")return new E2;if(t==="HeNormal")return new D2;if(t==="HeUniform")return new $2;if(t==="LeCunNormal")return new F2;if(t==="LeCunUniform")return new O2;{let n={};return n.className=t,n.config={},vZ(n)}}else return e instanceof Ro?e:vZ(e)}var XWe=0;function mI(){return XWe++}var gI={};function gd(e=""){return e in gI||(gI[e]=0),gI[e]+=1,e+gI[e].toString()}function xI(e){return Array.isArray(e)&&Array.isArray(e[0])}function My(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function bt(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new ne(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Ft(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new ne(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function zy(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}var wZ="Variable",yI=class{constructor(t,n="float32",r=wZ,s=!0,o=null){this.dtype=n==null?"float32":n,this.shape=t.shape,this.id=mI(),r=r==null?wZ:r,this.originalName=rI(r),this.name=sI(this.originalName),this.trainable_=s,this.constraint=o,this.val=qD(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),ZWe(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function ZWe(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function P2(e){return e.map(t=>t.read())}function Ly(e){e.forEach(t=>{t[0].write(t[1])})}var wn=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},uo=class{constructor(t,n,r,s,o,a,i){this.dtype=t,this.shape=n,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=i,this.id=mI(),a!=null&&(this.originalName=rI(a),this.name=sI(this.originalName)),this.rank=n.length}},YWe=0,xd=class{constructor(t,n){this.callArgs=n,this.id=YWe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let r of t.inboundLayers)r!=null&&r.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let n of this.inboundLayers)n!=null?t.push(n.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},JWe=0,It=class extends ke.Serializable{constructor(t={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=JWe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){let r=this.getClassName();n=Ja(r)+"_"+gd(r)}if(this.name=n,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let r;if(t.batchInputShape!=null)r=t.batchInputShape;else if(t.inputShape!=null){let o=null;t.batchSize!=null&&(o=t.batchSize),r=[o].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;s==null&&(s=t.inputDType),s==null&&(s="float32"),this.dtype=s}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0)throw new Os(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=t)throw new ne(`Asked to get ${n} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Jr(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Jr(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new sa(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new sa(`Layer ${this.name} is not connected, no input to return.`);return Jr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new sa(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new sa(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Jr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(n=>n.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=mn(t),this.inputSpec==null||this.inputSpec.length===0)return;let n=mn(this.inputSpec);if(t.length!==n.length)throw new ne(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){let s=t[r],o=n[r];if(o==null)continue;let a=s.rank;if(o.ndim!=null&&a!==o.ndim)throw new ne(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new ne(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new ne(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&s.dtype!==o.dtype)throw new ne(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){let i=s.shape;for(let l in o.axes){let u=Number(l),c=o.axes[l],p=u>=0?i[u]:i[i.length+u];if(c!=null&&[c,null].indexOf(p)===-1)throw new ne(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${i}.`)}}if(o.shape!=null)for(let i=0;i<o.shape.length;++i){let l=o.shape[i],u=s.shape[i];if(l!=null&&u!=null&&l!==u)throw new ne(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(t,n){return t}invokeCallHook(t,n){this._callHook!=null&&this._callHook(t,n)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{},this.assertNotDisposed();let r=mn(t),s=!0;for(let a of r)if(!(a instanceof uo)){s=!1;break}let o=!0;for(let a of r)if(a instanceof uo){o=!1;break}if(s===o)throw new ne("Arguments to apply() must be all SymbolicTensors or all Tensors");return Vi(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let a=[];for(let i of mn(t))a.push(i.shape);this.build(Jr(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let a=this.call(t,n),i=mn(a),l=[];for(let u of i)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(a=Jr(l),this.activityRegularizer!=null)throw new st("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=QWe(t),i=this.computeOutputShape(a),l,u=eGe(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?l=i.map((c,p)=>new uo(u,c,this,mn(t),n,this.name,p)):l=new uo(u,i,this,mn(t),n,this.name),this.addInboundNode(t,l,null,null,a,i,n),this._refCount++,this.activityRegularizer!=null)throw new st("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&t[s]!=null&&t[s]!==r&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new sa(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let n of this.inboundNodes){let r=JSON.stringify(n.outputShapes);t.indexOf(r)===-1&&t.push(r)}if(t.length===1){let n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new sa(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Os(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zy(this.weights)}build(t){this.built=!0}getWeights(t=!1){return P2(t?this.trainableWeights:this.weights)}setWeights(t){le(()=>{let n=this.weights;if(n.length!==t.length)throw new ne(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${n.length} weights. Provided weights: ${t}...`);if(n.length===0)return;let r=[],s=P2(n);for(let o=0;o<s.length;++o){let a=s[o],i=n[o],l=t[o];if(!C.arraysEqual(a.shape,l.shape))throw new ne(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);r.push([i,l])}Ly(r)})}addWeight(t,n,r,s,o,a,i){if(this._addedWeightNames.indexOf(t)!==-1)throw new ne(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=un("zeros"));let l=s.apply(n,r),u=new yI(l,r,t,a,i);return l.dispose(),o!=null&&this.addLoss(()=>o.apply(u.read())),a==null&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=mn(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}addInboundNode(t,n,r,s,o,a,i=null){let l=mn(t);n=mn(n),r=mn(r),s=mn(s),o=My(o),a=My(a);let u=[],c=[],p=[];for(let d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),p.push(d.tensorIndex);new xd({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:p,inputTensors:l,outputTensors:n,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:a},i);for(let d=0;d<n.length;d++)n[d].sourceLayer=this,n[d].nodeIndex=this.inboundNodes.length-1,n[d].tensorIndex=d}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount==0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function QWe(e){e=mn(e);let t=[];for(let n of e)t.push(n.shape);return Jr(t)}function eGe(e){return"float32"}function d$(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let o=0;o<r.inboundLayers.length;o++){let a=r.inputTensors[o],i=r.inboundLayers[o],l=r.nodeIndices[o],u=d$(a,i,l);for(let c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}var hc=class extends It{constructor(t){super({dtype:t.dtype,name:t.name!=null?t.name:gd("input").toString()});if(t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new ne("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(n==null){if(t.inputShape==null)throw new ne("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new ne("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let r=t.dtype||"float32";this.batchInputShape=n,this.dtype=r,this.inputSpec=[{shape:n}];let s=new uo(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new xd({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new ne(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};hc.className="InputLayer";ke.registerClass(hc);function f$(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new ne("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new hc({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}async function mc(e){if(e==null)return;let t=[],n=[],r=[];for(let s in e){let o=e[s];if(typeof o!="number"){let a=o;t.push(a.data()),n.push(s),r.push(a)}}if(t.length>0){let s=await Promise.all(t);for(let o=0;o<s.length;++o)e[n[o]]=s[o][0];ut(r)}}function bI(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var kZ;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(kZ||(kZ={}));var tGe=125,Im=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},h$=class{constructor(t,n=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(let n of this.callbacks)n.setParams(t)}setModel(t){for(let n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){n==null&&(n={});for(let r of this.callbacks)await r.onEpochBegin(t,n)}async onEpochEnd(t,n){n==null&&(n={});for(let r of this.callbacks)await r.onEpochEnd(t,n)}async onBatchBegin(t,n){n==null&&(n={});for(let r of this.callbacks)await r.onBatchBegin(t,n)}async onBatchEnd(t,n){n==null&&(n={});for(let r of this.callbacks)await r.onBatchEnd(t,n)}async onTrainBegin(t){t==null&&(t={});for(let n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let n of this.callbacks)await n.onTrainEnd(t)}},IZ=class extends Im{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){n==null&&(n={});let r=n.size==null?0:n.size;this.seen+=r;for(let s in n){let o=n[s];if(typeof o=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+o*r;else{let a;s in this.totals?a=this.totals[s]:this.totals[s]=0;let i=le(()=>Ie(this.totals[s],Y(o,r)));this.totals[s]=i,a!=null&&a.dispose()}}}async onEpochEnd(t,n){if(n!=null)for(let r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?n[r]=this.totals[r]/this.seen:le(()=>{let s=Y(Pe(1,this.seen),this.totals[r]);n[r]=s,this.totals[r].dispose(),$n(n[r])}))}},m$=class extends Im{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){n==null&&(n={}),this.epoch.push(t);for(let r in n)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(n[r])}async syncData(){let t=[],n=[],r=[];for(let o in this.history){let a=this.history[o];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let l=a[i];t.push(l.data()),n.push(o),r.push(i)}}let s=await Promise.all(t);for(let o=0;o<s.length;++o)this.history[n[o]][r[o]].dispose(),this.history[n[o]][r[o]]=s[o][0]}},g$=class extends Im{constructor(t,n){super();if(this.currentEpoch=0,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=tGe),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");C.isNumber(this.yieldEvery)&&(this.maybeWait=eZ(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,r){let s=[];this.yield!=null&&(await mc(r),s.push(this.yield(t,n,r))),s.push(C2()),await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t,this.epochBegin!=null&&(await mc(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){let r=[];this.epochEnd!=null&&(await mc(n),r.push(this.epochEnd(t,n))),this.yieldEvery==="epoch"&&r.push(C2()),await Promise.all(r)}async onBatchBegin(t,n){this.batchBegin!=null&&(await mc(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){let r=[];this.batchEnd!=null&&(await mc(n),r.push(this.batchEnd(t,n))),this.yieldEvery==="batch"?r.push(C2()):C.isNumber(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(r)}async onTrainBegin(t){this.trainBegin!=null&&(await mc(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await mc(t),await this.trainEnd(t))}};function AI(e,t){return e==null&&(e={}),e instanceof Im?[e]:Array.isArray(e)&&e[0]instanceof Im?e:mn(e).map(r=>new g$(r,t))}var oa=class{constructor(){}static registerCallbackConstructor(t,n){C.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),oa.checkForDuplicate(n),oa.constructors[t]==null&&(oa.constructors[t]=[]),oa.constructors[t].push(n)}static checkForDuplicate(t){for(let n in oa.constructors)oa.constructors[+n].forEach(s=>{if(s===t)throw new ne("Duplicate callback constructor.")})}static clear(){oa.constructors={}}static createCallbacks(t){let n=[];for(let r in oa.constructors){let s=+r;t>=s&&n.push(...oa.constructors[s])}return n.map(r=>new r)}};oa.constructors={};function vI(e,t,n,r,s,o,a,i,l){let u=new m$,c=[new IZ,...oa.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);let p=new h$(c);return p.setParams({epochs:n,initialEpoch:r,samples:s,steps:o,batchSize:a,verbose:t,doValidation:i,metrics:l}),{callbackList:p,history:u}}function aa(e,t={},n=!1){return Nl(e,ke.SerializationMap.getMap().classNameMap,t,"layer",n)}function M2(e,t){return le(()=>{e.dtype!=="float32"&&(e=we(e,"float32"));let n=ze(km(e),t,!0),r=tc(n.shape,br()),s=hn(Qs(n,r));return Pe(e,s)})}function Cm(e,t){return le(()=>Nn(km(je(t,e)),-1))}function z2(e,t){return le(()=>Nn(sr(je(t,e)),-1))}function L2(e,t){return le(()=>{let n=je(e,t),r=Pr(sr(e),br(),Number.MAX_VALUE),s=sr(Pe(n,r));return Y(100,Nn(s,-1))})}function nGe(e,t){return le(()=>{let n=Pr(t,br(),Number.MAX_VALUE),r=Ns(Ie(1,n)),s=Pr(e,br(),Number.MAX_VALUE),o=Ns(Ie(1,s));return Nn(km(je(r,o)),-1)})}function rGe(e,t){return le(()=>{let n=Qs(0,je(1,Y(e,t)));return Nn(km(n),-1)})}function sGe(e,t){return le(()=>{let n=Qs(0,je(1,Y(e,t)));return Nn(n,-1)})}function oGe(e,t){return le(()=>{let n=ze(Y(e,t),-1),r=ms(Y(je(1,e),t),-1);return Qs(0,Ie(1,je(r,n)))})}function aGe(e,t){return le(()=>{let n=Math.log(2),r=je(t,e),s=je(Ie(r,Ka(Y(-2,r))),n);return Nn(s,-1)})}function Sm(e,t,n=!1){return le(()=>{if(n)t=uc(t);else{let r=ze(t,t.shape.length-1,!0);t=Pe(t,r)}return t=Pr(t,br(),1-br()),jt(ze(Y(we(e,"float32"),Ns(t)),t.shape.length-1))})}function By(e,t,n=!1){return le(()=>{let r=we(Mi(fZ(e)),"int32");t=Pr(t,br(),1-br());let s=t.shape,o=X(ud(r,s[s.length-1]),s);return Sm(o,t,n)})}function iGe(e,t){if(!C.arraysEqual(e.shape,t.shape))throw new ne(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return le(()=>{let n=to(t),r=jt(sr(t));return Ie(je(n,Y(t,e)),nm(Zr(r)))})}function Vy(e,t){return le(()=>{let n;return n=Pr(t,br(),1-br()),n=Ns(Pe(n,je(1,n))),Nn(iGe(e,n),-1)})}function lGe(e,t){return le(()=>{let n=Pr(e,br(),1),r=Pr(t,br(),1);return ze(Y(e,Ns(Pe(n,r))),-1)})}function uGe(e,t){return le(()=>{let n=Ns(Ie(br(),t));return Nn(je(t,Y(e,n)),-1)})}function wI(e,t){return le(()=>{let n=M2(e,-1),r=M2(t,-1),s=Y(n,r);return jt(ze(s,-1))})}var B2={meanSquaredError:Cm,meanAbsoluteError:z2,meanAbsolutePercentageError:L2,meanSquaredLogarithmicError:nGe,squaredHinge:rGe,hinge:sGe,categoricalHinge:oGe,logcosh:aGe,categoricalCrossentropy:Sm,sparseCategoricalCrossentropy:By,binaryCrossentropy:Vy,kullbackLeiblerDivergence:lGe,poisson:uGe,cosineProximity:wI};function kI(e){if(typeof e=="string"){if(e in B2)return B2[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ne(t)}else return e}function II(e,t){return le(()=>{let n=Y(.5,Nr(t)),r=wm(qn(t,n),e.dtype);return Nn(Ss(e,r),-1)})}function CI(e,t){return le(()=>wm(Ss(Fi(e,-1),Fi(t,-1)),"float32"))}function cGe(e,t){return le(()=>we(ze(gs(Ss(e,1),Ss(t,1))),"float32"))}function pGe(e,t){return le(()=>we(ze(gs(Ss(e,0),Ss(t,1))),"float32"))}function CZ(e,t){return le(()=>{let n=cGe(e,t),r=pGe(e,t),s=Ie(n,r);return we(Sn(qn(s,0),Pe(n,s),0),"float32")})}function x$(e,t){return Vy(e,t)}function y$(e,t){return e.rank===t.rank&&(e=ro(e,[e.rank-1])),t=Fi(t,-1),t.dtype!==e.dtype&&(t=we(t,e.dtype)),we(Ss(e,t),"float32")}var dGe=Cm,fGe=Cm,hGe=z2,mGe=z2,gGe=L2,xGe=L2,SI=Sm,yGe=wI,b$=By,NI={binaryAccuracy:II,categoricalAccuracy:CI,precision:CZ,categoricalCrossentropy:SI,sparseCategoricalCrossentropy:b$,mse:dGe,MSE:fGe,mae:hGe,MAE:mGe,mape:gGe,MAPE:xGe,cosine:yGe};function SZ(e){if(typeof e=="string"&&e in NI)return NI[e];if(typeof e!="string"&&e!=null)return e;throw new ne(`Unknown metric ${e}`)}function V2(e){if(ka(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(B2))if(B2[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(NI))if(NI[n]===e){t=n;break}return t!==void 0?t:e.name}}function NZ(e){let t={Adagrad:()=>Am.adagrad(.01),Adadelta:()=>Am.adadelta(1,.95,br()),Adam:()=>Am.adam(.001,.9,.999,br()),Adamax:()=>Am.adamax(.002,.9,.999,br(),0),RMSProp:()=>Am.rmsprop(.001,.9,0,br()),SGD:()=>Am.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ne(`Unknown Optimizer ${e}`)}var TZ=1*1024*1024;function A$(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!v$(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>TZ&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${TZ}.`)}}function v$(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!v$(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!v$(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function _Z(e,t,n,r=console.log){let s=AGe(e),o=["Layer (type)","Output shape","Param #"];s?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let a;if(!s){o.push("Receives inputs"),a=[];for(let c in e.nodesByDepth)a.push(...e.nodesByDepth[c])}r("_".repeat(t)),TI(o,n,r),r("=".repeat(t));let i=e.layers;for(let c=0;c<i.length;++c)s?vGe(i[c],n,r):wGe(i[c],n,a,r),r((c===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=bGe(e),u=zy(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function bGe(e){let t;return e.collectedTrainableWeights!=null?t=zy(e.collectedTrainableWeights):t=zy(e.trainableWeights),t}function AGe(e){let t=!0,n=[],r=[];for(let s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(let s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of e.layers){let o=!1;for(let a of s.inboundNodes)if(r.indexOf(a)!==-1)if(o){t=!1;break}else o=!0;if(!t)break}return t}function TI(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function vGe(e,t,n){let r;try{r=JSON.stringify(e.outputShape)}catch(i){r="multiple"}let s=e.name,o=e.getClassName(),a=[`${s} (${o})`,r,e.countParams().toString()];TI(a,t,n)}function wGe(e,t,n,r){let s;try{s=JSON.stringify(e.outputShape)}catch(c){s="multiple"}let o=[];for(let c of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(c)===-1))for(let p=0;p<c.inboundLayers.length;++p){let d=c.inboundLayers[p].name,f=c.nodeIndices[p],h=c.tensorIndices[p];o.push(`${d}[${f}][${h}]`)}let a=e.name,i=e.getClassName(),l=o.length===0?"":o[0],u=[`${a} (${i})`,s,e.countParams().toString(),l];TI(u,t,r);for(let c=1;c<o.length;++c)TI(["","","",o[c]],t,r)}function EZ(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function W2(e,t){if(e===null)return null;if(typeof e=="string")return pc(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let o=e[s];EZ(t,s,o)?n.push(o):n.push(W2(o,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{let o=pc(r);n[o]=W2(s,o)}}return n}}function _I(e,t){if(e==null)return null;if(typeof e=="string")return Ja(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let o=e[s];EZ(t,s,o)?n.push(o):n.push(_I(o,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r],o=Ja(r);(r==="name"||r==="className")&&typeof s=="string"?n[o]=s:n[o]=_I(s,r)}return n}}var Wy="3.9.0";function kGe(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return we(t,e.dtype)}catch(n){throw new ne(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Gi=class{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Gi)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=kGe(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new ne(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof uo){if(this.id2Value[t.id]==null)throw new ne(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new ne(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof uo){if(this.id2Value[t.id]==null)throw new ne(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new ne(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&ut(this.id2Mask)}},w$={},RZ={};function Nm(e,t,n,r){let s=n==null?!1:n.training,o=Array.isArray(e),a=o?e:[e],i=a.map(h=>h.name),l=[],u=t.names();for(let h of i)u.indexOf(h)!==-1?l.push(t.getValue(h)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c=i.join(",")+"|"+t.names().join(","),p,d;if(w$[c]==null){let h=IGe(a,t);p=h.sorted,d=h.recipientCounts,w$[c]=p,RZ[c]=d}p=w$[c],d={},s||Object.assign(d,RZ[c]);let f=new Gi(t);for(let h=0;h<p.length;++h){if(r!=null){let N=OA().numTensors;N>r.maxNumTensors&&(r.maxNumTensors=N),N<r.minNumTensors&&(r.minNumTensors=N)}let m=p[h],g=m.sourceLayer;if(g instanceof hc)continue;let x=[],y=[],b=[],A=!1;for(let N of m.inputs){let T=f.getValue(N),_=f.getMask(N);x.push(T),y.push(_),_!=null&&(A=!0),s||(d[N.name]--,d[N.name]===0&&!t.hasKey(N)&&i.indexOf(N.name)===-1&&!T.isDisposed&&N.sourceLayer.stateful!==!0&&b.push(T))}A&&(n=n||{},n.mask=y[0]);let v=mn(g.apply(x,n)),w=null;g.supportsMasking&&(w=g.computeMask(x,y));let k=SGe(m),I=Array.isArray(k)?k:[k];for(let N=0;N<I.length;++N){f.hasKey(I[N])||f.add(I[N],v[N],Array.isArray(w)?w[0]:w);let T=i.indexOf(I[N].name);T!==-1&&(l[T]=v[N])}s||ut(b)}return f.disposeMasks(),o?l:l[0]}function IGe(e,t){C.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let s=DZ(e[0],t);n=s.sorted,r=s.recipientMap}else{let s=new Set;for(let o of e){let{sorted:a,recipientMap:i}=DZ(o,t);for(let l of a)s.has(l.name)||(n.push(l),s.add(l.name));for(let l in i)r[l]==null&&(r[l]=new Set),i[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:CGe(r)}}function CGe(e){let t={};for(let n in e)t[n]=e[n].size;return t}function DZ(e,t){let n=new Set,r=[],s={};for(let i of t.names())n.add(i);let o=[],a=[];for(o.push(e);o.length>0;){let i=o[o.length-1];if(n.has(i.name)){o.pop();continue}let l=a[a.length-1]===o.length-1;if(i.inputs.length===0||l)o.pop(),r.push(i),n.add(i.name),l&&a.pop();else{a.push(o.length-1);for(let u of i.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(i.name),!n.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function SGe(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var Ia=class extends It{constructor(t){super({});if(this.containerNodes=new Set,this.name=t.name,this.name==null){let y=this.getClassName().toLowerCase();this.name=gd(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],ei(this.inputs).length!==this.inputs.length)throw new ne(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);ei(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let b=y.sourceLayer,A=y.nodeIndex,v=y.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(A),this.outputLayersTensorIndices.push(v)}for(let y of this.inputs){let b=y.sourceLayer,A=y.nodeIndex,v=y.tensorIndex;ka(A===0,"input layer has >1 nodes"),ka(v===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(A),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let b=this.inputLayers[y];if(!(b instanceof hc))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);let n={},r={},s={},o={},a={},i=[],l=(y,b,A,v,w,k)=>{(v==null||w==null||k==null)&&(v=y.sourceLayer,w=y.nodeIndex,k=y.tensorIndex);let I=v.inboundNodes[w];if(A.indexOf(I)!==-1)throw new Os(`The tensor ${y.name} at layer "${v.name}" is part of a cycle.`);if(b.indexOf(I)!==-1)return;this.containerNodes.add(Ia.nodeKey(v,w)),v.id in a||(a[v.id]=Object.keys(a).length),A.indexOf(I)===-1&&A.push(I);let N=I.inboundLayers.length;for(let T=0;T<N;T++){let _=I.inputTensors[T],R=I.inboundLayers[T],S=I.nodeIndices[T],F=I.tensorIndices[T];l(_,b,A,R,S,F)}for(b.push(I);A.indexOf(I)>=0;)A.splice(A.indexOf(I),1);i.push(I)},u=[],c=[];for(let y of this.outputs)l(y,u,c);let p=i.slice().reverse();for(let y of p){r[y.id]=y,y.id in n||(n[y.id]=0);let b=n[y.id],A=s[y.outboundLayer.id]==null?0:s[y.outboundLayer.id];b=Math.max(b,A),s[y.outboundLayer.id]=b,o[y.outboundLayer.id]=y.outboundLayer,n[y.id]=b;for(let v=0;v<y.inboundLayers.length;v++){let w=y.inboundLayers[v],k=y.nodeIndices[v],I=w.inboundNodes[k],N=n[I.id]==null?0:n[I.id];n[I.id]=Math.max(b+1,N),r[I.id]=I}}let d={};for(let y in n){let b=n[y];b in d||(d[b]=[]),d[b].push(r[y])}let f={};for(let y in s){let b=s[y];b in f||(f[b]=[]),f[b].push(o[y])}let h=Object.keys(f).map(y=>parseInt(y,10)).sort(N2);this.layers=[];for(let y of h){let b=f[y];b.sort((A,v)=>{let w=a[A.id],k=a[v.id];return w<k?-1:w>k?1:0});for(let A of b)A instanceof Ia&&this.internalContainerRefs.push(A),this.layers.push(A)}this.layersByDepth=f,h=Object.keys(d).map(y=>parseInt(y,10)).sort(N2);let m=this.inputs.slice(),g=[];for(let y of h)for(let b of d[y]){let A=b.outboundLayer;if(A!=null){for(let v of b.inputTensors)if(m.indexOf(v)===-1)throw new Os(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${A.name}". The following previous layers were accessed without issue: ${g}`);for(let v of b.outputTensors)m.push(v);g.push(A.name)}}this.nodesByDepth=d;let x=this.layers.map(y=>y.name);for(let y of x){let b=x.filter(A=>A===y).length;if(b!==1)throw new Os(`The name "${y}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new xd({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ne("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},s=0;for(let a of this.layers)for(let i of a.weights){if(r[i.originalName]!=null)throw new ne(`Duplicate weight name: ${i.originalName}`);r[i.originalName]=i,s++}let o=[];for(let a in t){let i=a;if(r[a]==null){let l=a.split("/");i=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(r[i]!=null)o.push([r[i],t[a]]);else if(n)throw new ne(`Provided weight data has no target variable: ${a}`);delete r[i]}if(n){let a=[];for(let i in r)a.push(i);if(a.length>0)throw new ne(`${a.length} of ${s} weights are not set: ${a}`)}Ly(o)}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${Wy}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=_I(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return le(()=>{t=mn(t);let r=new Gi;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Nm(this.outputs,r,n)})}computeMask(t,n){return le(()=>{t=mn(t);let r;return n==null?r=Ya(null,t.length):r=mn(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=My(t);if(n.length!==this.inputLayers.length)throw new ne(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let i=0;i<n.length;i++){let l=this.inputLayers[i],u=n[i],c=l.name+"_0_0";r[c]=u}let s=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(N2);if(s.length>1)for(let i of s){let l=this.nodesByDepth[i];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;let p=[];for(let m=0;m<u.inboundLayers.length;m++){let g=u.inboundLayers[m],x=u.nodeIndices[m],y=u.tensorIndices[m],b=`${g.name}_${x}_${y}`,A=r[b];p.push(A)}let d=c.computeOutputShape(Jr(p)),f=My(d),h=c.inboundNodes.indexOf(u);for(let m=0;m<f.length;m++){let g=`${c.name}_${h}_${m}`;r[g]=f[m]}}}let o=[],a=[];for(let i=0;i<this.outputLayers.length;i++){let l=this.outputLayers[i],u=this.outputLayersNodeIndices[i],c=this.outputLayersTensorIndices[i],p=`${l.name}_${u}_${c}`;a.push(p)}for(let i=0;i<a.length;i++){let l=a[i];ka(l in r),o.push(r[l])}return Jr(o)}runInternalGraph(t,n){n==null&&(n=Ya(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=t[l],p=n[l];r[u.id]=[c,p]}let s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(N2);for(let l of s){let u=this.nodesByDepth[l];for(let c of u){let p=c.outboundLayer,d=c.inputTensors,f=c.outputTensors,h=new Array;for(let m of d)m.id in r&&h.push(r[m.id]);if(h.length===d.length){let m={},g,x,y,b;if(c.callArgs!=null&&(m=c.callArgs),h.length===1){let[A,v]=h[0];m.mask==null&&(m.mask=v),y=mn(p.call(A,m)),b=mn(p.computeMask(A,v)),g=[A],x=[v]}else g=h.map(A=>A[0]),x=h.map(A=>A[1]),m.mask==null&&(m.mask=x),y=mn(p.call(g,m)),b=mn(p.computeMask(g,x));if(p.activityRegularizer)throw new st("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let A=0;A<f.length;++A){let v=f[A],w=y[A],k=b[A];r[v.id]=[w,k]}}}}let o=[],a=[],i=[];for(let l of this.outputs){ka(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=r[l.id];i.push(u.shape),o.push(u),a.push(c)}return[o,a,i]}buildNodeConversionMap(t){let n={},r;for(let s of this.layers){r=s instanceof Ia?1:0;for(let o=0;o<s.inboundNodes.length;o++){let a=Ia.nodeKey(s,o);this.containerNodes.has(a)&&(n[a]=r,r+=1)}}return n}getLayer(t,n){if(n!=null){if(this.layers.length<=n)throw new ne(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}else if(t==null)throw new ne("Provide either a layer name or layer index");for(let r of this.layers)if(r.name===t)return r;throw new ne(`No such layer: ${t}`)}calculateLosses(){return le(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let s=Ia.nodeKey(n,r);this.containerNodes.has(s)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let a of this.layers){let i=a.getClassName(),l=a.getConfig(),u=[];for(let p=0;p<a.inboundNodes.length;p++){let d=a.inboundNodes[p],f=Ia.nodeKey(a,p),h={};if(this.containerNodes.has(f)){if(d.callArgs)try{JSON.stringify(d.callArgs),h=d.callArgs}catch(m){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(d.inboundLayers.length>0){let m=[];for(let g=0;g<d.inboundLayers.length;g++){let x=d.inboundLayers[g],y=d.nodeIndices[g],b=d.tensorIndices[g],A=Ia.nodeKey(x,y),v=n[A];v==null&&(v=0),m.push([x.name,v,b,h])}u.push(m)}}}let c={};c.name=a.name,c.className=i,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;let s=[];for(let a=0;a<this.inputLayers.length;a++){let i=this.inputLayers[a],l=this.inputLayersNodeIndices[a],u=Ia.nodeKey(i,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let p=this.inputLayersTensorIndices[a];s.push([i.name,c,p])}t.inputLayers=s;let o=[];for(let a=0;a<this.outputLayers.length;a++){let i=this.outputLayers[a],l=this.outputLayersNodeIndices[a],u=Ia.nodeKey(i,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let p=this.outputLayersTensorIndices[a];o.push([i.name,c,p])}return t.outputLayers=o,t}static fromConfig(t,n,r={},s=!1){let o={},a={};function i(g,x){g.name in a?a[g.name].push(x):a[g.name]=[x]}function l(g,x){let y=[],b;for(let A of x){let v=A[0],w=A[1],k=A[2];if(b=A[3]==null?{}:A[3],!(v in o)){i(g,x);return}let I=o[v];if(I.inboundNodes.length<=w){i(g,x);return}let N=I.inboundNodes[w];y.push(N.outputTensors[k])}y.length>0&&g.apply(Jr(y),b)}function u(g){let x=g.name,y=aa(g,n.customObjects!=null?n.customObjects:{});y.setFastWeightInitDuringBuild(s),o[x]=y,g.inboundNodes.forEach(A=>{if(!(A instanceof Array))throw new ne(`Corrupted configuration, expected array for nodeData: ${A}`);i(y,A)})}let c=n.name,p=n.layers;for(let g of p)u(g);for(;!JX(a);)for(let g of p){let x=o[g.name];if(x.name in a){let y=a[x.name];delete a[x.name];for(let b of y)l(x,b)}}let d=[],f=[],h=n.inputLayers;for(let g of h){let x=g[0],y=g[1],b=g[2];ka(x in o);let v=o[x].inboundNodes[y].outputTensors;d.push(v[b])}let m=n.outputLayers;for(let g of m){let x=g[0],y=g[1],b=g[2];ka(x in o);let v=o[x].inboundNodes[y].outputTensors;f.push(v[b])}return new t({inputs:d,outputs:f,name:c})}get stateful(){if(this._stateful)throw new ne("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){le(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function NGe(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let s=[];return t.forEach(o=>{o in e?s.push(e[o]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function EI(e,t){return NGe(e,t,"classWeight")}async function RI(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){let s=le(()=>{if(e.shape.length===1)return So(e);if(e.shape.length===2){if(e.shape[1]>1)return Fi(e,1);if(e.shape[1]===1)return X(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await s.data());ut(s);let a=[];return o.forEach(i=>{if(n[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(n[i])}),Kn(a,"float32")}else return null}function $Z(e,t){return Y(e,t)}var TGe=32;function FZ(e,t){let n,r,s=t;n=s.xs,r=s.ys,C.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let o=OZ("input",e.inputNames,n),a=OZ("output",e.outputNames,r),i=o[0].shape[0];C.assert(o.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),C.assert(a.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<o.length;l++)C.assert(o[l].shape[0]===i,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${o[l].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);for(let l=0;l<a.length;l++)C.assert(a[l].shape[0]===i,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${a[l].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);return{xs:o,ys:a}}function OZ(e,t,n){if(n instanceof Ot)return[n];if(Array.isArray(n))return C.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let s of t){if(n[s]==null)throw new ne(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function _Ge(e){if(e.length===3)throw new st("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function PZ(e,t,n){let r=n.batchesPerEpoch!=null;if(C.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),C.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),C.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),C.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),C.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let s=n.validationData!=null,o,a;if(s)if(MZ(n.validationData))C.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=_Ge(n.validationData);o=g.xs,a=g.ys}let i=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;s?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();let c=AI(n.callbacks,n.yieldEvery),p=n.verbose==null?1:n.verbose,{callbackList:d,history:f}=vI(c,p,n.epochs,null,null,EGe(t,n),null,s,u);d.setModel(e),e.history=f,await d.onTrainBegin(),e.stopTraining_=!1;let h=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;h<n.epochs;){let g={};await d.onEpochBegin(h);let x=0,y=0;for(r||(m=await t.iterator());r?x<n.batchesPerEpoch:!0;){let b=await m.next();if(r&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){let{xs:A,ys:v}=FZ(e,b.value),w={};w.batch=y,w.size=A[0].shape[0],await d.onBatchBegin(y,w);let k=[];if(n.classWeight!=null){let T=EI(n.classWeight,e.outputNames);for(let _=0;_<T.length;++_)k.push(await RI(v[_],null,T[_]))}let I=A.concat(v).concat(k),N=i(I);ut(I);for(let T=0;T<l.length;++T){let _=l[T],R=N[T];w[_]=R,$n(R)}await d.onBatchEnd(y,w),bI(w),y++,x++}if(r?x>=n.batchesPerEpoch:b.done){if(s){let A;MZ(n.validationData)?A=mn(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):A=mn(e.evaluate(o,a,{batchSize:n.validationBatchSize==null?TGe:n.validationBatchSize,verbose:0}));for(let v=0;v<e.metricsNames.length;++v)g[`val_${e.metricsNames[v]}`]=A[v]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(h,g),h++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function EGe(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function MZ(e){return typeof e.iterator=="function"}function RGe(e){return typeof e.next=="function"}async function zZ(e,t,n){n=n||{};let r=n.batches!=null,s=e.testFunction,o=[];if(n.verbose>0)throw new st("Verbose mode is not implemented yet.");C.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let a=RGe(t)?t:await t.iterator(),i=0,l=0;for(;r?l<n.batches:!0;){let u=await a.next();if(o=le(()=>{if(u.value){let{xs:c,ys:p}=FZ(e,u.value),d=c.concat(p),f=le(()=>s(d));if(ut(d),l===0)for(let m=0;m<f.length;++m)o.push(Ke(0));let h=d[0].shape[0];for(let m=0;m<f.length;++m){let g=f[m],x=o[m];o[m]=le(()=>Ie(o[m],Y(h,g))),l>0&&ut(x)}ut(f),i+=h,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){let c=o[u];o[u]=Pe(o[u],i),ut(c)}return Jr(o)}function DI(e){C.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Gy(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>fc(r,t,n-t)):fc(e,t,n-t)}function $I(e,t){return le(()=>e==null?null:Array.isArray(e)?e.map(n=>$I(n,t)):aI(e,t.dtype==="int32"?t:we(t,"int32")))}function FI(e,t){let n=[],r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}async function DGe(e,t,n,r,s,o,a,i,l,u,c,p,d,f,h){s==null&&(s=32),o==null&&(o=1),c==null&&(c=!0),d==null&&(d=0);let m=!1;if(l!=null&&u!=null&&(m=!0),h!=null&&(m=!0,f==null))throw new ne("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=e.checkNumSamples(n,s,f,"steps_per_epoch"),x;g!=null&&(x=Ps(0,g)),a==null&&(a=1);let{callbackList:y,history:b}=vI(i,a,o,d,g,f,s,m,p);y.setModel(e),e.history=b,await y.onTrainBegin(),e.stopTraining_=!1;for(let A=d;A<o;++A){await y.onEpochBegin(A);let v={};if(f!=null)throw new st("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new st("batch shuffling is not implemneted yet");c&&C.shuffle(x);let w=Kn(x),k=FI(g,s);for(let I=0;I<k.length;++I){let N={};if(await y.onBatchBegin(I,N),le(()=>{let T=k[I][0],_=k[I][1],R=fc(w,T,_-T);N.batch=I,N.size=_-T;let S=$I(n,R),F=t(S);for(let B=0;B<r.length;++B){let W=r[B],q=F[B];N[W]=q,$n(q)}if(I===k.length-1&&m){let B=e.testLoop(l,u,s);for(let W=0;W<r.length;++W){let q=r[W],K=B[W];$n(K),v["val_"+q]=K}}}),await y.onBatchEnd(I,N),bI(N),e.stopTraining_)break}w.dispose()}if(await y.onEpochEnd(A,v),e.stopTraining_)break}return await y.onTrainEnd(),await e.history.syncData(),e.history}async function LZ(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;let s,o,a,i,l,u,c;try{let p=r.batchSize==null?32:r.batchSize;DI(p);let d=!1,f=await e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,d,p);s=f[0],o=f[1],c=f[2];let h=!1,m;if(r.validationData!=null&&r.validationData.length>0){if(h=!0,r.validationData.length===2)a=r.validationData[0],i=r.validationData[1];else throw r.validationData.length===3?new st("validationData including sample weights is not supported yet."):new ne(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);let k=!0,I=await e.standardizeUserData(a,i,null,null,k,p);l=I[0],u=I[1],m=l.concat(u)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){h=!0;let k=Math.floor(s[0].shape[0]*(1-r.validationSplit)),I=s[0].shape[0];l=Gy(s,k,I),s=Gy(s,0,k),u=Gy(o,k,I),o=Gy(o,0,k),m=l.concat(u)}else r.validationSteps!=null&&(h=!0);let g=s.concat(o).concat(c);e.checkTrainableWeightsConsistency();let x=e.makeTrainFunction(),y=e.getDedupedMetricsNames(),b,A;h?(e.makeTestFunction(),b=e.testFunction,A=y.slice().concat(y.map(k=>"val_"+k))):(b=null,m=[],A=y.slice());let v=AI(r.callbacks,r.yieldEvery);return await DGe(e,x,g,y,p,r.epochs,r.verbose,v,b,m,r.shuffle,A,r.initialEpoch,null,null)}finally{e.isTraining=!1,yd(s,t),yd(o,n),yd(l,a),yd(u,i),c!=null&&ut(c)}}function k$(e){let t=[];e instanceof Ot&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(dc(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function yd(e,t){if(e==null)return;let n=[];if(t instanceof Ot)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(let s in t){let o=t[s];n.push(o.id)}let r=[];if(e instanceof Ot)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(let s in e){let o=e[s];n.indexOf(o.id)===-1&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function $Ge(e){return e instanceof Ot}function I$(e){return Array.isArray(e)}function BZ(e){return!$Ge(e)&&!I$(e)}function VZ(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let a=!1;if(I$(e)&&e.length>0)a=!0;else if(BZ(e)){for(let i in e)if(e.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new ne(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(a=>null);let o;if(BZ(e)){e=e,o=[];for(let a of t){if(e[a]==null)throw new ne(`No data provided for "${a}". Need data for each key in: ${t}`);o.push(e[a])}}else if(I$(e)){if(e=e,e.length!==t.length)throw new ne(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);o=e}else{if(e=e,t.length>1)throw new ne(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);o=[e]}if(o=k$(o),n!=null)for(let a=0;a<t.length;++a){if(n[a]==null)continue;let i=o[a];if(i.shape.length!==n[a].length)throw new ne(`Error when checking ${s}: expected ${t[a]} to have ${n[a].length} dimension(s). but got array with shape ${i.shape}`);for(let l=0;l<n[a].length;++l){if(l===0&&!r)continue;let u=i.shape[l],c=n[a][l];if(c!=null&&c>=0&&u!==c)throw new ne(`${s} expected a batch of elements where each example has shape [${n[a].slice(1,n[a].length)}] (i.e.,tensor shape [*,${n[a].slice(1,n[a].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return o}function FGe(e,t,n){let r=ei(e.map(o=>o.shape[0]));r.sort();let s=ei(t.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new ne(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(o=>o.shape))}`);if(s.length>1)throw new ne(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!C.arraysEqual(r,s))throw new ne(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function OGe(e,t,n){let r=[Cm,Vy,Sm];for(let s=0;s<e.length;++s){let o=e[s],a=t[s],i=n[s];if(a!=null){if(a===Sm&&o.shape[o.shape.length-1]===1)throw new ne(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(a)!==-1){let l=o.shape.slice(1),u=i.slice(1);for(let c=0;c<l.length;++c){let p=l[c],d=u[c];if(d!=null&&p!==d)throw new ne(`A target Tensor with shape ${o.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function WZ(e,t,n,r=!0,s=""){let o;if(Array.isArray(e)){if(e.length!==t.length)throw new ne(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);o=e}else{if(t.length>1)throw new ne(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);o=[e]}if(n!=null)for(let a=0;a<t.length;++a){if(n[a]==null)continue;let i=o[a];if(i.shape.length!==n[a].length)throw new ne(`Error when checking ${s}: expected ${t[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let l=0;l<n[a].length;++l){if(l===0&&!r)continue;let u=i.shape[l],c=n[a][l];if(c!=null&&c!==u)throw new ne(`Error when checking ${s}: expected ${t[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function PGe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let s of t){let o=n.hasOwnProperty(s)?n[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}var MGe="layers-model",Ui=class extends Ia{constructor(t){super(t);this.isTraining=!1}summary(t,n,r=console.log){if(!this.built)throw new ne("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");_Z(this,t,n,r)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=NZ(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Fs))throw new ne("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let a in t.loss)if(this.outputNames.indexOf(a)===-1)throw new ne(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)t.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),n.push(kI(t.loss[a]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new ne(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);n=t.loss.map(i=>kI(i))}else{let a=kI(t.loss);this.outputs.forEach(i=>{n.push(a)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let r=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Vi("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(r.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let s=PGe(t.metrics,this.outputNames),o=(a,i,l)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([l,a])};Vi("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(r.indexOf(a)!==-1)continue;let i=s[a];(u=>{let c="",p,d,f;for(let h of u){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===Vy?["accuracy","acc"].indexOf(h)!==-1?d=II:["crossentropy","ce"].indexOf(h)!==-1&&(d=x$):this.lossFunctions[a]===By?["accuracy","acc"].indexOf(h)!==-1?d=y$:["crossentropy","ce"].indexOf(h)!==-1&&(d=b$):["accuracy","acc"].indexOf(h)!==-1?d=CI:["crossentropy","ce"].indexOf(h)!==-1&&(d=SI);let x;["accuracy","acc"].indexOf(h)!==-1?x="acc":["crossentropy","ce"].indexOf(h)!==-1&&(x="ce"),f=d,p=c+x}else f=SZ(h),p=c+V2(h);let m;Vi(p,()=>{m=f}),o(a,p,m)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,n,r={}){let s=r.batchSize==null?32:r.batchSize;DI(s);let o=!0,a=this.standardizeUserDataXY(t,n,o,s);try{let i=a[0].concat(a[1]);this.makeTestFunction();let l=this.testFunction,u=this.testLoop(l,i,s,r.verbose,r.steps);return Jr(u)}finally{yd(a[0],t),yd(a[1],n)}}async evaluateDataset(t,n){return this.makeTestFunction(),zZ(this,t,n)}checkNumSamples(t,n,r,s="steps"){let o;if(r!=null){if(o=null,n!=null)throw new ne(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(t!=null)Array.isArray(t)?o=t[0].shape[0]:o=t.shape[0];else throw new ne(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return o}execute(t,n){if(Array.isArray(n)&&n.length===0)throw new ne("`outputs` is an empty Array, which is not allowed.");let r=Array.isArray(n),s=r?n:[n],o=this.retrieveSymbolicTensors(s),a=new Gi;if(t instanceof Ot&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new ne(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],t[l])}else for(let l of this.inputs){let u=t[l.name];if(u==null)throw new ne(`No value is provided for the model's input ${l.name}`);a.add(l,u)}let i=Nm(o,a);return r?i:i[0]}retrieveSymbolicTensors(t){let n=Ya(null,t.length),r=t.length;for(let s of this.layers){let o=Array.isArray(s.output)?s.output:[s.output],a=o.map(i=>i.name);for(let i=0;i<t.length;++i){let l=a.indexOf(t[i]);if(l!==-1&&(n[i]=o[l],r--),r===0)break}if(r===0)break}if(r>0){let s=[];throw n.forEach((o,a)=>{o==null&&s.push(t[a])}),new ne(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(t,n=32,r=!1){return le(()=>{let s=this.checkNumSamples(t);if(r)throw new st("Verbose predictLoop() is not implemented yet.");let o=FI(s,n),a=this.outputs.map(i=>[]);for(let i=0;i<o.length;++i)le(()=>{let u=o[i][0],c=o[i][1],p=Gy(t,u,c),d=[];if(Array.isArray(p))for(let h=0;h<p.length;++h)d.push({key:this.inputs[h],value:p[h]});else d.push({key:this.inputs[0],value:p});let f=new Gi(d);return Nm(this.outputs,f)}).forEach((u,c)=>a[c].push(u));return Jr(a.map(i=>on(i,0)))})}predict(t,n={}){let r=k$(t);WZ(r,this.inputNames,this.feedInputShapes,!1);try{let s=n.batchSize==null?32:n.batchSize;return DI(s),this.predictLoop(r,s)}finally{yd(r,t)}}predictOnBatch(t){WZ(t,this.inputNames,this.feedInputShapes,!0);let n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,r=!0,s){if(this.optimizer_==null)throw new Os("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let o=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===By?o.push(i.slice(0,i.length-1).concat([1])):o.push(i)}if(t=VZ(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=VZ(n,this.feedOutputNames,o,!1,"target"),FGe(t,n,null),OGe(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&t[0].shape[0]%s!=0)throw new ne(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,n]}async standardizeUserData(t,n,r,s,o=!0,a){let[i,l]=this.standardizeUserDataXY(t,n,o,a);if(r!=null)throw new Error("sample weight is not supported yet.");let u=null;if(s!=null){let c=EI(s,this.outputNames);u=[];for(let p=0;p<c.length;++p)u.push(await RI(l[p],null,c[p]))}return[i,l,u]}testLoop(t,n,r,s=0,o){return le(()=>{let a=this.checkNumSamples(n,r,o,"steps"),i=[];if(s>0)throw new st("Verbose mode is not implemented yet.");if(o!=null)throw new st("steps mode in testLoop() is not implemented yet");{let l=FI(a,r),u=Kn(Ps(0,a));for(let c=0;c<l.length;++c){let p=l[c][0],d=l[c][1],f=fc(u,p,d-p),h=$I(n,f),m=t(h);if(c===0)for(let g=0;g<m.length;++g)i.push(Ke(0));for(let g=0;g<m.length;++g){let x=m[g];i[g]=Ie(i[g],Y(d-p,x))}}for(let c=0;c<i.length;++c)i[c]=Pe(i[c],a)}return i})}getDedupedMetricsNames(){let t=this.metricsNames,n=[];for(let r=0;r<t.length;++r){let s=t[r],o=s;o$(t,s)>1&&(o+=`_${o$(t.slice(0,r),s)}`),n.push(o)}return n}makeTrainFunction(){return t=>{let n=[],r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let p=[];for(let m=0;m<this.inputs.length;++m)p.push({key:this.inputs[m],value:r[m]});let d=new Gi(p),f=Nm(this.outputs,d,{training:!0}),h;for(let m=0;m<this.lossFunctions.length;++m){let x=this.lossFunctions[m](s[m],f[m]);o[m]!=null&&(x=$Z(x,o[m]));let y=Nn(x);n.push(y),m===0?h=x:h=Ie(h,x)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=n[m];else{let x=this.metricsTensors[m][0],y=this.metricsTensors[m][1];g=Nn(x(s[y],f[y]))}$n(g),a.push(g)}return h=Nn(h),this.calculateLosses().forEach(m=>{h=Ie(h,m)}),h},l=this.collectedTrainableWeights.map(p=>p.read()),u=!0;return[this.optimizer_.minimize(i,u,l)].concat(a)}}makeTestFunction(){this.testFunction=t=>le(()=>{let n=[],r,s=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:s[u]});let i=new Gi(a),l=Nm(this.outputs,i);for(let u=0;u<this.lossFunctions.length;++u){let c=this.lossFunctions[u],p=Nn(c(o[u],l[u]));u===0?r=p:r=Ie(r,p),n.push(r)}for(let u=0;u<this.metricsTensors.length;++u){let c=this.metricsTensors[u][0],p=this.metricsTensors[u][1],d=Nn(c(o[p],l[p]));n.push(d)}return n})}async fit(t,n,r={}){return LZ(this,t,n,r)}async fitDataset(t,n){return PZ(this,t,n)}async trainOnBatch(t,n){let r=await this.standardizeUserData(t,n),s=r[0],o=r[1],i=this.makeTrainFunction()(s.concat(o)),l=[];for(let u of i){let c=await u.data();l.push(c[0])}return ut(i),Jr(l)}getNamedWeights(t){let n=[],r=t!=null&&t.trainableOnly,s=r?this.trainableWeights:this.weights,o=this.getWeights(r);for(let a=0;a<s.length;++a)r&&!s[a].trainable||n.push({name:s[a].originalName,tensor:o[a]});return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let n=OA().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-OA().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Ja(this.loss);else if(Array.isArray(this.loss)){for(let n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(n=>Ja(n))}else{let n=Object.keys(this.loss);t={};let r=this.loss;for(let s of n)if(typeof r[s]=="string")t[s]=Ja(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Ja(V2(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Ja(V2(t)));{let t={};for(let n in this.metrics)t[n]=Ja(V2(this.metrics[n]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let n=W2(t.optimizer_config),r=aa(n),s;if(typeof t.loss=="string")s=pc(t.loss);else if(Array.isArray(t.loss))s=t.loss.map(a=>pc(a));else if(t.loss!=null){s={};for(let a in t.loss)s[a]=pc(t.loss[a])}let o;if(Array.isArray(t.metrics))o=t.metrics.map(a=>pc(a));else if(t.metrics!=null){o={};for(let a in t.metrics)o[a]=pc(t.metrics[a])}this.compile({loss:s,metrics:o,optimizer:r})}async save(t,n){if(typeof t=="string"){let u=na.getSaveHandlers(t);if(u.length===0)throw new ne(`Cannot find any save handlers for URL '${t}'`);if(u.length>1)throw new ne(`Found more than one (${u.length}) save handlers for URL '${t}'`);t=u[0]}if(t.save==null)throw new ne("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let r=await na.encodeWeights(this.getNamedWeights(n)),s=!1,o=null,i={modelTopology:this.toJSON(o,s),format:MGe,generatedBy:`TensorFlow.js tfjs-layers v${Wy}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();let u="optimizer",{data:c,specs:p}=await na.encodeWeights(await this.optimizer.getWeights(),u);r.specs.push(...p),r.data=na.concatenateArrayBuffers([r.data,c])}if(this.userDefinedMetadata!=null){let u=!0;A$(this.userDefinedMetadata,this.name,u),i.userDefinedMetadata=this.userDefinedMetadata}return i.weightData=r.data,i.weightSpecs=r.specs,t.save(i)}setUserDefinedMetadata(t){A$(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};Ui.className="Model";ke.registerClass(Ui);var C$=class extends Ui{};C$.className="Functional";ke.registerClass(C$);var bd=class extends Ui{constructor(t){super({inputs:[],outputs:[]});if(t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:gd("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new ne(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof bd||t instanceof Ui,r;if(n){if(r=t,r.outputs.length!==1)throw new ne("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new ne("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new ne("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=f$({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new ne(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new ne("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=d$(this.outputs[0])}this.inboundNodes=[],new xd({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ya(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(Ft(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ui({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new Os("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new Os("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new Os("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new Os("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},s=!1){let o,a={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new ne("Legacy serialization format not supported yet.");o=n}else C.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=n.layers,delete n.layers,a=n;let i=new t(a);if(!(i instanceof bd))throw new st(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let l of o){let c=aa(l,void 0,s);s&&c.setFastWeightInitDuringBuild(!0),i.add(c)}return i}set stopTraining(t){if(this.model==null)throw new ne("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new ne("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}};bd.className="Sequential";ke.registerClass(bd);var co=class extends ke.Serializable{getConfig(){return{}}},S$=class extends co{apply(t,n=1){return mZ(t,n)}};S$.className="elu";ke.registerClass(S$);var N$=class extends co{apply(t){return cm(t)}};N$.className="selu";ke.registerClass(N$);var T$=class extends co{apply(t){return to(t)}};T$.className="relu";ke.registerClass(T$);var _$=class extends co{apply(t){return le(()=>oc(6,to(t)))}};_$.className="relu6";ke.registerClass(_$);var E$=class extends co{apply(t){return t}};E$.className="linear";ke.registerClass(E$);var R$=class extends co{apply(t){return ra(t)}};R$.className="sigmoid";ke.registerClass(R$);var D$=class extends co{apply(t){return xZ(t)}};D$.className="hardSigmoid";ke.registerClass(D$);var $$=class extends co{apply(t){return Ka(t)}};$$.className="softplus";ke.registerClass($$);var F$=class extends co{apply(t){return gZ(t)}};F$.className="softsign";ke.registerClass(F$);var O$=class extends co{apply(t){return pd(t)}};O$.className="tanh";ke.registerClass(O$);var G2=class extends co{apply(t,n=-1){return uc(t,n)}};G2.className="softmax";ke.registerClass(G2);var P$=class extends co{apply(t,n=-1){return rm(t,n)}};P$.className="logSoftmax";ke.registerClass(P$);var M$=class extends co{apply(t,n=1){return le(()=>Y(ra(Y(t,n)),t))}};M$.className="swish";ke.registerClass(M$);var z$=class extends co{apply(t){return le(()=>Y(t,pd(Ka(t))))}};z$.className="mish";ke.registerClass(z$);function ji(e){return e.getClassName()}function L$(e,t={}){return Nl(e,ke.SerializationMap.getMap().classNameMap,t,"activation")}function Hi(e){if(e==null){let t={};return t.className="linear",t.config={},L$(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},L$(t)}else return e instanceof co?e:L$(e)}function zGe(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var B$=class extends ke.Serializable{},OI=class extends B${constructor(t){super();zGe(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return le(()=>{let n=fn([1]);return this.hasL1&&(n=Ie(n,ze(Y(this.l1,sr(t))))),this.hasL2&&(n=Ie(n,ze(Y(this.l2,km(t))))),X(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n.l1,l2:n.l2})}};OI.className="L1L2";ke.registerClass(OI);var GZ={l1l2:"L1L2"};function nn(e){return Ry(e)}function UZ(e,t={}){return Nl(e,ke.SerializationMap.getMap().classNameMap,t,"regularizer")}function gn(e){if(e==null)return null;if(typeof e=="string"){let n={className:e in GZ?GZ[e]:e,config:{}};return UZ(n)}else return e instanceof B$?e:UZ(e)}var PI=class extends It{constructor(t){super(t==null?{}:t);this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,n){t=bt(t);let r=to(t);return this.maxValue!=null&&(r=Pr(r,0,this.maxValue)),r}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}};PI.className="ReLU";ke.registerClass(PI);var MI=class extends It{constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){let r=bt(t);return nc(r,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};MI.className="LeakyReLU";ke.registerClass(MI);var zI=class extends It{constructor(t){super(t==null?{}:t);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=un(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=gn(t.alphaRegularizer),this.alphaConstraint=Bn(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new ne(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Ft(t);let n=t.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let r={};if(this.sharedAxes!=null)for(let s=1;s<t.length;++s)r[s]=t[s];this.inputSpec=[new wn({ndim:t.length,axes:r})],this.built=!0}call(t,n){return t=bt(t),ic(t,this.alpha.read())}getConfig(){let t={alphaInitializer:vn(this.alphaInitializer),alphaRegularizer:nn(this.alphaRegularizer),alphaConstraint:Ln(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}};zI.className="PReLU";ke.registerClass(zI);var LI=class extends It{constructor(t){super(t==null?{}:t);if(this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new st(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){let r=bt(t);return Pi(r)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};LI.className="ELU";ke.registerClass(LI);var BI=class extends It{constructor(t){super(t==null?{}:t);this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){let r=bt(t);return Y(r,we(qn(r,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}};BI.className="ThresholdedReLU";ke.registerClass(BI);var VI=class extends It{constructor(t){super(t==null?{}:t);this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new G2().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){let r=bt(t);return this.softmax(r,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}};VI.className="Softmax";ke.registerClass(VI);function Ad(e,t,n){if(typeof e=="number")return Ya(e,t);if(e.length!==t)throw new ne(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let s=e[r];if(!pZ(s))throw new ne(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Do(e,t,n,r,s=1){if(e==null)return e;let o=t+(t-1)*(s-1),a;return n==="same"?a=e:a=e-o+1,Math.floor((a+r-1)/r)}function qi(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Wi([n-t,0]);else if(r==="same")e=e*t;else throw new ne(`Unsupport padding mode: ${r}.`);return e}function U2(e,t){return le(()=>(Fn(t),t==="channelsFirst"?St(e,[0,2,3,1]):e))}function V$(e,t){return le(()=>(Fn(t),t==="channelsFirst"?St(e,[0,2,3,4,1]):e))}function LGe(e,t,n,r=1,s="valid",o,a=1){return le(()=>{if(o==null&&(o=oo()),Fn(o),e.shape.length!==3)throw new ne(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new ne(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new ne(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(o==="channelsFirst"&&(e=St(e,[0,2,1])),s==="causal")throw new st("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Zh(e,t,r,s==="same"?"same":"valid","NWC",a);return n!=null&&(i=io(i,n)),i})}function jZ(e,t,n,r=[1,1],s="valid",o,a,i=null){return le(()=>{if(o==null&&(o=oo()),Fn(o),e.rank!==3&&e.rank!==4)throw new ne(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new ne(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=U2(e,o);if(s==="causal")throw new st("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Xa.conv2d({x:l,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:i}),o==="channelsFirst"&&(l=St(l,[0,3,1,2])),l})}function BGe(e,t,n,r=[1,1,1],s="valid",o,a){return le(()=>{if(o==null&&(o=oo()),Fn(o),e.rank!==4&&e.rank!==5)throw new ne(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new ne(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let i=V$(e,o);if(s==="causal")throw new st("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=qA(i,t,r,s==="same"?"same":"valid","NDHWC",a),n!=null&&(i=io(i,n)),o==="channelsFirst"&&(i=St(i,[0,4,1,2,3])),i})}var Uy=class extends It{constructor(t,n){super(n);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Uy.verifyArgs(n),this.rank=t,ar(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new st(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ad(n.kernelSize,t,"kernelSize"),this.strides=Ad(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,ao(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Fn(this.dataFormat),this.activation=Hi(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=un(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Bn(n.biasConstraint),this.biasRegularizer=gn(n.biasRegularizer),this.activityRegularizer=gn(n.activityRegularizer),this.dilationRate=Ad(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ne(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ne(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ne(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(ka("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!Y3(t.kernelSize,"number",1,3))throw new ne(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ji(this.activation),useBias:this.useBias,biasInitializer:vn(this.biasInitializer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),biasConstraint:Ln(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},Tm=class extends Uy{constructor(t,n){super(t,n);this.kernel=null,Tm.verifyArgs(n),this.filters=n.filters,ar(this.filters,"filters"),this.kernelInitializer=un(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Bn(n.kernelConstraint),this.kernelRegularizer=gn(n.kernelRegularizer)}build(t){t=Ft(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ne(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return le(()=>{t=bt(t);let r,s=this.bias==null?null:this.bias.read(),o=J3(this.activation.getClassName());if(o!=null&&this.rank===2)r=jZ(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)r=LGe(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=jZ(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=BGe(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new st("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Ft(t);let n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<r.length;++o){let a=Do(r[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);n.push(a)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){let t={filters:this.filters,kernelInitializer:vn(this.kernelInitializer),kernelRegularizer:nn(this.kernelRegularizer),kernelConstraint:Ln(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new ne(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},_m=class extends Tm{constructor(t){super(2,t);_m.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Y3(t.kernelSize,"number",1,2))throw new ne(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};_m.className="Conv2D";ke.registerClass(_m);var Em=class extends Tm{constructor(t){super(3,t);Em.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new ne(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};Em.className="Conv3D";ke.registerClass(Em);var WI=class extends _m{constructor(t){super(t);if(this.inputSpec=[new wn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ne(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Ft(t),t.length!==4)throw new ne("Input should have rank 4; Received input shape: "+JSON.stringify(t));let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ne("The channel dimension of the inputs should be defined. Found `None`.");let r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wn({ndim:4,axes:{[n]:r}})],this.built=!0}call(t,n){return le(()=>{let r=bt(t);if(r.shape.length!==4)throw new ne(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);let s=r.shape,o=s[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let l=s[a],u=s[i],c=this.kernelSize[0],p=this.kernelSize[1],d=this.strides[0],f=this.strides[1],h=qi(l,d,c,this.padding),m=qi(u,f,p,this.padding),g=[o,h,m,this.filters];this.dataFormat!=="channelsLast"&&(r=St(r,[0,2,3,1]));let x=Yh(r,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=St(x,[0,3,1,2])),this.bias!=null&&(x=io(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(t){t=Ft(t);let n=t.slice(),r,s,o;this.dataFormat==="channelsFirst"?(r=1,s=2,o=3):(r=3,s=1,o=2);let a=this.kernelSize[0],i=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[r]=this.filters,n[s]=qi(n[s],l,a,this.padding),n[o]=qi(n[o],u,i,this.padding),n}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};WI.className="Conv2DTranspose";ke.registerClass(WI);var GI=class extends Em{constructor(t){super(t);if(this.inputSpec=[new wn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ne(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Ft(t),t.length!==5)throw new ne("Input should have rank 5; Received input shape: "+JSON.stringify(t));let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ne("The channel dimension of the inputs should be defined. Found `None`.");let r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wn({ndim:5,axes:{[n]:r}})],this.built=!0}call(t,n){return le(()=>{let r=bt(t);if(r.shape.length!==5)throw new ne(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);let s=r.shape,o=s[0],a,i,l;this.dataFormat==="channelsFirst"?(l=2,a=3,i=4):(l=1,a=2,i=3);let u=s[l],c=s[a],p=s[i],d=this.kernelSize[0],f=this.kernelSize[1],h=this.kernelSize[2],m=this.strides[0],g=this.strides[1],x=this.strides[2],y=qi(u,m,d,this.padding),b=qi(c,g,f,this.padding),A=qi(p,x,h,this.padding),v=[o,y,b,A,this.filters];this.dataFormat!=="channelsLast"&&(r=St(r,[0,2,3,4,1]));let w=kD(r,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=St(w,[0,4,1,2,3])),this.bias!==null&&(w=io(w,this.bias.read(),this.dataFormat)),this.activation!==null&&(w=this.activation.apply(w)),w})}computeOutputShape(t){t=Ft(t);let n=t.slice(),r,s,o,a;this.dataFormat==="channelsFirst"?(r=1,s=2,o=3,a=4):(r=4,s=1,o=2,a=3);let i=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],p=this.strides[1],d=this.strides[2];return n[r]=this.filters,n[s]=qi(n[s],c,i,this.padding),n[o]=qi(n[o],p,l,this.padding),n[a]=qi(n[a],d,u,this.padding),n}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};GI.className="Conv3DTranspose";ke.registerClass(GI);var W$=class extends Tm{constructor(t,n){super(t,n);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new ne("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new ne("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new ne(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=un(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=gn(n.depthwiseRegularizer),this.depthwiseConstraint=Bn(n.depthwiseConstraint),this.pointwiseInitializer=un(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=gn(n.pointwiseRegularizer),this.pointwiseConstraint=Bn(n.pointwiseConstraint)}build(t){if(t=Ft(t),t.length<this.rank+2)throw new ne(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0)throw new ne(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);let r=t[n],s=this.kernelSize.concat([r,this.depthMultiplier]),o=[];for(let i=0;i<this.rank;++i)o.push(1);o.push(r*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new wn({ndim:this.rank+2,axes:{[n]:r}})],this.built=!0}call(t,n){return le(()=>{t=bt(t);let r;if(this.rank===1)throw new st("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=St(t,[0,2,3,1])),r=i2(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=io(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=St(r,[0,3,1,2])),r})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=vn(this.depthwiseInitializer),t.pointwiseInitializer=vn(this.pointwiseInitializer),t.depthwiseRegularizer=nn(this.depthwiseRegularizer),t.pointwiseRegularizer=nn(this.pointwiseRegularizer),t.depthwiseConstraint=Ln(this.depthwiseConstraint),t.pointwiseConstraint=Ln(this.pointwiseConstraint),t}};W$.className="SeparableConv";var UI=class extends W${constructor(t){super(2,t)}};UI.className="SeparableConv2D";ke.registerClass(UI);var jy=class extends Tm{constructor(t){super(1,t);jy.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Y3(t.kernelSize,"number",1,1))throw new ne(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};jy.className="Conv1D";ke.registerClass(jy);var jI=class extends It{constructor(t){super(t);typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return le(()=>{if(t=bt(t),this.dataFormat==="channelsLast"){let r=_2(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return _2(r,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let r=_2(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return _2(r,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}};jI.className="Cropping2D";ke.registerClass(jI);var HI=class extends It{constructor(t){super(t);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Fn(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,lZ(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let n=t[2]==null?null:this.size[0]*t[2],r=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,r]}else{let n=t[1]==null?null:this.size[0]*t[1],r=t[2]==null?null:this.size[1]*t[2];return[t[0],n,r,t[3]]}}call(t,n){return le(()=>{let r=bt(t),s=r.shape;if(this.dataFormat==="channelsFirst"){r=St(r,[0,2,3,1]);let o=this.size[0]*s[2],a=this.size[1]*s[3],i=this.interpolation==="nearest"?so.resizeNearestNeighbor(r,[o,a]):so.resizeBilinear(r,[o,a]);return St(i,[0,3,1,2])}else{let o=this.size[0]*s[1],a=this.size[1]*s[2];return this.interpolation==="nearest"?so.resizeNearestNeighbor(r,[o,a]):so.resizeBilinear(r,[o,a])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}};HI.className="UpSampling2D";ke.registerClass(HI);function VGe(e,t,n=[1,1],r="valid",s,o){return le(()=>{s==null&&(s=oo()),Fn(s);let a=U2(e,s);if(e.rank!==4)throw new ne(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new ne(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=Oi(a,t,n,r==="same"?"same":"valid","NHWC",o),s==="channelsFirst"&&(a=St(a,[0,3,1,2])),a})}var qI=class extends Uy{constructor(t){super(2,t);this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=un(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Bn(t.depthwiseConstraint),this.depthwiseRegularizer=gn(t.depthwiseRegularizer)}build(t){if(t=Ft(t),t.length<4)throw new ne(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0)throw new ne(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);let r=t[n],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return le(()=>{t=bt(t);let r=VGe(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=io(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(t){t=Ft(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,o=Do(n,this.kernelSize[0],this.padding,this.strides[0]),a=Do(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],s,o,a]:[t[0],o,a,s]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=vn(this.depthwiseInitializer),t.depthwiseRegularizer=nn(this.depthwiseRegularizer),t.depthwiseConstraint=Ln(this.depthwiseRegularizer),t}};qI.className="DepthwiseConv2D";ke.registerClass(qI);function G$(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new ne("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(o){return o==null||Array.isArray(o)?o:[o]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function U$(e,t,n,r=!1,s,o,a=!1,i=!1){return le(()=>{let l=t.shape.length;if(l<3)throw new ne(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(Ps(2,l));if(t=St(t,u),o!=null)throw new st("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=we(we(s,"bool"),"float32"),s.rank===l-1&&(s=Mr(s,-1)),s=St(s,u)),r&&(t=no(t,0),s!=null&&(s=no(s,0)));let c=[],p,d=n,f=t.shape[0],h=zr(t),m;s!=null&&(m=zr(s));for(let x=0;x<f;++x){let y=h[x],b=le(()=>e(y,d));if(s==null)p=b[0],d=b[1];else{let A=le(()=>{let v=m[x],w=je(Nr(v),v),k=Ie(Y(b[0],v),Y(d[0],w)),I=d.map((N,T)=>Ie(Y(b[1][T],v),Y(N,w)));return{output:k,newStates:I}});p=A.output,d=A.newStates}i&&c.push(p)}let g;return i&&(g=or(c,1)),[p,g,d]})}var ri=class extends It{constructor(t){super(t);let n;if(t.cell==null)throw new ne("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new q2({cells:t.cell}):n=t.cell,n.stateSize==null)throw new ne("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new wn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ps(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){xI(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){let o=[];for(let a of n)o.push([t[0],a]);return[s].concat(o)}else return s}computeMask(t,n){return le(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let s=this.states.map(o=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){let n=null;if(this.numConstants!=null)throw new st("Constants support is not implemented in RNN yet.");xI(t)&&(t=t[0]),t=t;let r=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new wn({shape:[r,null,...s]});let o=[t[0]].concat(t.slice(2));if(n!=null)throw new st("Constants support is not implemented in RNN yet.");this.cell.build(o);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!C.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new ne(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new wn({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){le(()=>{if(!this.stateful)throw new sa("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new ne("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>fn([r,s])):this.states_=[fn([r,this.cell.stateSize])];else if(t==null)ut(this.states_),this.keptStates!=null&&(ut(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>fn([r,s])):this.states_[0]=fn([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ne(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):ut(this.states_);for(let s=0;s<this.states_.length;++s){let o=t[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,i=[r,a];if(!C.arraysEqual(o.shape,i))throw new ne(`State ${s} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${o.shape}`);this.states_[s]=o}}this.states_=this.states_.map(s=>$n(s.clone()))})}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let o=G$(t,r,s,this.numConstants);t=o.inputs,r=o.initialState,s=o.constants;let a=[],i=[];if(r!=null){n.initialState=r,a=a.concat(r),this.stateSpec=[];for(let u of r)this.stateSpec.push(new wn({shape:u.shape}));i=i.concat(this.stateSpec)}if(s!=null&&(n.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof uo){let u=[t].concat(a),c=this.inputSpec.concat(i),p=this.inputSpec;this.inputSpec=c;let d=super.apply(u,n);return this.inputSpec=p,d}else return super.apply(t,n)}call(t,n){return le(()=>{let r=n==null?null:n.mask,s=n==null?null:n.training,o=n==null?null:n.initialState;t=bt(t),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(t));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new ne(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:s},u=U$((h,m)=>{let g=this.cell.call([h].concat(m),i);return[g[0],g.slice(1)]},t,o,this.goBackwards,r,null,this.unroll,this.returnSequences),c=u[0],p=u[1],d=u[2];this.stateful&&this.resetStates(d,s);let f=this.returnSequences?p:c;return this.returnState?[f].concat(d):f})}getInitialState(t){return le(()=>{let n=fn(t.shape);return n=ze(n,[1,2]),n=dc(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?oI(n,[1,r]):n):this.cell.stateSize>1?[oI(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===ri.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign({},r,t,n)}static fromConfig(t,n,r={}){let s=n.cell,o=aa(s,r);return new t(Object.assign(n,{cell:o}))}};ri.className="RNN";ke.registerClass(ri);var Rm=class extends It{},j2=class extends Rm{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,ar(this.units,"units"),this.activation=Hi(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=un(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=un(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=un(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=gn(t.kernelRegularizer),this.recurrentRegularizer=gn(t.recurrentRegularizer),this.biasRegularizer=gn(t.biasRegularizer),this.kernelConstraint=Bn(t.kernelConstraint),this.recurrentConstraint=Bn(t.recurrentConstraint),this.biasConstraint=Bn(t.biasConstraint),this.dropout=vm([1,Wi([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=vm([1,Wi([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Ft(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return le(()=>{if(t=t,t.length!==2)throw new ne(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let r=t[1];t=t[0];let s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gc({ones:()=>Nr(t),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gc({ones:()=>Nr(r),rate:this.recurrentDropout,training:s}));let o,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?o=ni(Y(t,a),this.kernel.read()):o=ni(t,this.kernel.read()),this.bias!=null&&(o=io(o,this.bias.read())),i!=null&&(r=Y(r,i));let l=Ie(o,ni(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){let t=super.getConfig(),n={units:this.units,activation:ji(this.activation),useBias:this.useBias,kernelInitializer:vn(this.kernelInitializer),recurrentInitializer:vn(this.recurrentInitializer),biasInitializer:vn(this.biasInitializer),kernelRegularizer:nn(this.kernelRegularizer),recurrentRegularizer:nn(this.recurrentRegularizer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),kernelConstraint:Ln(this.kernelConstraint),recurrentConstraint:Ln(this.recurrentConstraint),biasConstraint:Ln(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,n)}};j2.className="SimpleRNNCell";ke.registerClass(j2);var KI=class extends ri{constructor(t){t.cell=new j2(t);super(t)}call(t,n){return le(()=>{this.cell.dropoutMask!=null&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=n==null?null:n.mask,s=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:o})})}static fromConfig(t,n){return new t(n)}};KI.className="SimpleRNN";ke.registerClass(KI);var H2=class extends Rm{constructor(t){super(t);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new ne("GRUCell does not support reset_after parameter set to true.");this.units=t.units,ar(this.units,"units"),this.activation=Hi(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Hi(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=un(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=un(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=un(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=gn(t.kernelRegularizer),this.recurrentRegularizer=gn(t.recurrentRegularizer),this.biasRegularizer=gn(t.biasRegularizer),this.kernelConstraint=Bn(t.kernelConstraint),this.recurrentConstraint=Bn(t.recurrentConstraint),this.biasConstraint=Bn(t.biasConstraint),this.dropout=vm([1,Wi([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=vm([1,Wi([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Ft(t);let n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return le(()=>{if(t=t,t.length!==2)throw new ne(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let r=n.training==null?!1:n.training,s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gc({ones:()=>Nr(t),rate:this.dropout,training:r,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gc({ones:()=>Nr(s),rate:this.recurrentDropout,training:r,count:3}));let o=this.dropoutMask,a=this.recurrentDropoutMask,i,l,u;0<this.dropout&&this.dropout<1&&(t=Y(t,o[0]));let c=ni(t,this.kernel.read());this.useBias&&(c=io(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Y(s,a[0]));let p=this.recurrentKernel.read(),[d,f]=yr(p,[2*this.units,this.units],p.rank-1),h=ni(s,d),[m,g,x]=yr(c,3,c.rank-1),[y,b]=yr(h,2,h.rank-1);i=this.recurrentActivation.apply(Ie(m,y)),l=this.recurrentActivation.apply(Ie(g,b));let A=ni(Y(l,s),f);u=this.activation.apply(Ie(x,A));let v=Ie(Y(i,s),Y(Ie(1,jt(i)),u));return[v,v]})}getConfig(){let t=super.getConfig(),n={units:this.units,activation:ji(this.activation),recurrentActivation:ji(this.recurrentActivation),useBias:this.useBias,kernelInitializer:vn(this.kernelInitializer),recurrentInitializer:vn(this.recurrentInitializer),biasInitializer:vn(this.biasInitializer),kernelRegularizer:nn(this.kernelRegularizer),recurrentRegularizer:nn(this.recurrentRegularizer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),kernelConstraint:Ln(this.kernelConstraint),recurrentConstraint:Ln(this.recurrentConstraint),biasConstraint:Ln(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,n)}};H2.className="GRUCell";ke.registerClass(H2);var XI=class extends ri{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new H2(t);super(t)}call(t,n){return le(()=>{this.cell.dropoutMask!=null&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=n==null?null:n.mask,s=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:o})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}};XI.className="GRU";ke.registerClass(XI);var Dm=class extends Rm{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,ar(this.units,"units"),this.activation=Hi(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Hi(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=un(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=un(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=un(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=gn(t.kernelRegularizer),this.recurrentRegularizer=gn(t.recurrentRegularizer),this.biasRegularizer=gn(t.biasRegularizer),this.kernelConstraint=Bn(t.kernelConstraint),this.recurrentConstraint=Bn(t.recurrentConstraint),this.biasConstraint=Bn(t.biasConstraint),this.dropout=vm([1,Wi([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=vm([1,Wi([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;t=Ft(t);let r=t[t.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){let o=this.biasInitializer,a=this.units;s=new(n=class extends Ro{apply(l,u){let c=o.apply([a]),p=new Py().apply([a]),d=o.apply([a*2]);return c$(c$(c,p),d)}},n.className="CustomInit",n)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return le(()=>{let r=n.training==null?!1:n.training;if(t=t,t.length!==3)throw new ne(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1],o=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gc({ones:()=>Nr(t),rate:this.dropout,training:r,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gc({ones:()=>Nr(s),rate:this.recurrentDropout,training:r,count:4}));let a=this.dropoutMask,i=this.recurrentDropoutMask,l,u,c,p;0<this.dropout&&this.dropout<1&&(t=Y(t,a[0]));let d=ni(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Y(s,i[0])),d=Ie(d,ni(s,this.recurrentKernel.read())),this.useBias&&(d=io(d,this.bias.read()));let[f,h,m,g]=yr(d,4,d.rank-1);l=this.recurrentActivation.apply(f),u=this.recurrentActivation.apply(h),c=Ie(Y(u,o),Y(l,this.activation.apply(m))),p=this.recurrentActivation.apply(g);let x=Y(p,this.activation.apply(c));return[x,x,c]})}getConfig(){let t=super.getConfig(),n={units:this.units,activation:ji(this.activation),recurrentActivation:ji(this.recurrentActivation),useBias:this.useBias,kernelInitializer:vn(this.kernelInitializer),recurrentInitializer:vn(this.recurrentInitializer),biasInitializer:vn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:nn(this.kernelRegularizer),recurrentRegularizer:nn(this.recurrentRegularizer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),kernelConstraint:Ln(this.kernelConstraint),recurrentConstraint:Ln(this.recurrentConstraint),biasConstraint:Ln(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,n)}};Dm.className="LSTMCell";ke.registerClass(Dm);var ZI=class extends ri{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Dm(t);super(t)}call(t,n){return le(()=>{this.cell.dropoutMask!=null&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=n==null?null:n.mask,s=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:o})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}};ZI.className="LSTM";ke.registerClass(ZI);var q2=class extends Rm{constructor(t){super(t);this.cells=t.cells}get stateSize(){let t=[];for(let n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return le(()=>{t=t;let r=t.slice(1),s=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?s.push(r.splice(0,i.stateSize.length)):s.push(r.splice(0,1));s.reverse();let o=[],a;for(let i=0;i<this.cells.length;++i){let l=this.cells[i];r=s[i],i===0?a=[t[0]].concat(r):a=[a[0]].concat(r),a=l.call(a,n),o.push(a.slice(1))}r=[];for(let i of o.slice().reverse())r.push(...i);return[a[0]].concat(r)})}build(t){xI(t)&&(t=t[0]),t=t;let n;this.cells.forEach((r,s)=>{Vi(`RNNCell_${s}`,()=>{r.build(t),Array.isArray(r.stateSize)?n=r.stateSize[0]:n=r.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){let t=super.getConfig(),n=o=>({className:o.getClassName(),config:o.getConfig()}),s={cells:this.cells.map(n)};return Object.assign({},t,s)}static fromConfig(t,n,r={}){let s=[];for(let o of n.cells)s.push(aa(o,r));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.cells)n.push(...r.trainableWeights);return n.concat(t)}return t}getWeights(){let t=[];for(let n of this.cells)t.push(...n.weights);return P2(t)}setWeights(t){let n=[];for(let r of this.cells){let s=r.weights.length,o=t.splice(s);for(let a=0;a<r.weights.length;++a)n.push([r.weights[a],o[a]])}Ly(n)}};q2.className="StackedRNNCells";ke.registerClass(q2);function gc(e){let{ones:t,rate:n,training:r=!1,count:s=1}=e,o=()=>iI(t(),n),a=()=>md(o,t,r);return!s||s<=1?$n(a().clone()):Array(s).fill(void 0).map(a).map(l=>$n(l.clone()))}var WGe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n};var j$=class extends ri{constructor(t){if(t.unroll)throw new st("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new st("It is not possible at the moment to stack convolutional cells.");super(t);this.inputSpec=[new wn({ndim:5})]}call(t,n){return le(()=>{if(this.cell.dropoutMask!=null&&(ut(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ut(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new ne("ConvRNN2D cell does not support constants");let r=n==null?null:n.mask,s=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:o})})}computeOutputShape(t){let n=this.computeSingleOutputShape(t);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([t[0],...n.slice(-3)])]),n}getInitialState(t){return le(()=>{let{stateSize:n}=this.cell,r=t.shape,s=this.computeSingleOutputShape(r),o=[s[0],...s.slice(2)],a=fn(o);return Array.isArray(n)?Array(n.length).fill(a):[a]})}resetStates(t,n=!1){le(()=>{if(!this.stateful)throw new sa("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),o=[s[0],...s.slice(2)];if(r[0]==null)throw new ne("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>fn(o)):this.states_=[fn(o)];else if(t==null)ut(this.states_),this.keptStates!=null&&(ut(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>fn(o)):this.states_[0]=fn(o);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ne(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n?this.keptStates.push(this.states_.slice()):ut(this.states_);for(let i=0;i<this.states_.length;++i){let l=t[i],u=o;if(!C.arraysEqual(l.shape,u))throw new ne(`State ${i} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[i]=l}}this.states_=this.states_.map(i=>$n(i.clone()))})}computeSingleOutputShape(t){let{dataFormat:n,filters:r,kernelSize:s,padding:o,strides:a,dilationRate:i}=this.cell,l=n==="channelsFirst",u=t[l?3:2],c=t[l?4:3],p=Do(u,s[0],o,a[0],i[0]),d=Do(c,s[1],o,a[1],i[1]);return[...t.slice(0,2),...l?[r,p,d]:[p,d,r]]}};j$.className="ConvRNN2D";var K2=class extends Dm{constructor(t){let{filters:n,kernelSize:r,strides:s,padding:o,dataFormat:a,dilationRate:i}=t;super(Object.assign({},t,{units:n}));this.filters=n,ar(this.filters,"filters"),this.kernelSize=Ad(r,2,"kernelSize"),this.kernelSize.forEach(l=>ar(l,"kernelSize")),this.strides=Ad(s||1,2,"strides"),this.strides.forEach(l=>ar(l,"strides")),this.padding=o||"valid",ao(this.padding),this.dataFormat=a||"channelsLast",Fn(this.dataFormat),this.dilationRate=Ad(i||1,2,"dilationRate"),this.dilationRate.forEach(l=>ar(l,"dilationRate"))}build(t){var n;t=Ft(t);let r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new ne(`The channel dimension of the input should be defined. Found ${t[r]}`);let s=t[r],o=4,a=this.kernelSize.concat([s,this.filters*o]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){let u=this.biasInitializer,c=this.filters;l=new(n=class extends Ro{apply(d,f){let h=u.apply([c]),m=eo([c]),g=u.apply([c*2]);return Fy([h,m,g])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return le(()=>{if(t.length!==3)throw new ne(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=n.training||!1,s=t[0],o=t[1],a=t[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gc({ones:()=>Nr(s),rate:this.dropout,training:r,count:i}));let l=this.dropoutMask,u=(Q,ee,ue)=>!ee||!ee[ue]?Q:Y(ee[ue],Q),c=u(s,l,0),p=u(s,l,1),d=u(s,l,2),f=u(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gc({ones:()=>Nr(o),rate:this.recurrentDropout,training:r,count:i}));let h=this.recurrentDropoutMask,m=u(o,h,0),g=u(o,h,1),x=u(o,h,2),y=u(o,h,3),b=3,[A,v,w,k]=yr(this.kernel.read(),i,b),[I,N,T,_]=this.useBias?yr(this.bias.read(),i):[null,null,null,null];c=this.inputConv(c,A,I,this.padding),p=this.inputConv(p,v,N,this.padding),d=this.inputConv(d,w,T,this.padding),f=this.inputConv(f,k,_,this.padding);let[R,S,F,B]=yr(this.recurrentKernel.read(),i,b);m=this.recurrentConv(m,R),g=this.recurrentConv(g,S),x=this.recurrentConv(x,F),y=this.recurrentConv(y,B);let W=this.recurrentActivation.apply(Ie(c,m)),q=this.recurrentActivation.apply(Ie(p,g)),K=Ie(Y(q,a),Y(W,this.activation.apply(Ie(d,x)))),J=Y(this.recurrentActivation.apply(Ie(f,y)),this.activation.apply(K));return[J,J,K]})}getConfig(){let t=super.getConfig(),{units:n}=t,r=WGe(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},r,s)}inputConv(t,n,r,s){let o=Js(t,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?io(o,r,this.dataFormat):o}recurrentConv(t,n){return Js(t,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};K2.className="ConvLSTM2DCell";ke.registerClass(K2);var YI=class extends j${constructor(t){let n=new K2(t);super(Object.assign({},t,{cell:n}))}static fromConfig(t,n){return new t(n)}};YI.className="ConvLSTM2D";ke.registerClass(YI);var X2=class extends It{constructor(t){super(t);this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let n=t.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return r}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t);if(0<this.rate&&this.rate<1){let s=n.training==null?!1:n.training,o=this.getNoiseShape(r);return md(()=>iI(r,this.rate,o,this.seed),()=>r,s)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}};X2.className="Dropout";ke.registerClass(X2);var JI=class extends X2{constructor(t){super(t);this.inputSpec=[{ndim:3}]}getNoiseShape(t){let n=t.shape;return[n[0],1,n[2]]}};JI.className="SpatialDropout1D";ke.registerClass(JI);var QI=class extends It{constructor(t){super(t);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;t.batchSize!=null&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,ar(this.units,"units"),this.activation=Hi(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=un(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=un(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Bn(t.kernelConstraint),this.biasConstraint=Bn(t.biasConstraint),this.kernelRegularizer=gn(t.kernelRegularizer),this.biasRegularizer=gn(t.biasRegularizer),this.activityRegularizer=gn(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Ft(t);let n=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){t=Ft(t);let n=t.slice();return n[n.length-1]=this.units,n}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t),s=J3(this.activation.getClassName()),o;return s!=null?o=ni(r,this.kernel.read(),s,this.bias?this.bias.read():null):(o=ni(r,this.kernel.read()),this.bias!=null&&(o=io(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){let t={units:this.units,activation:ji(this.activation),useBias:this.useBias,kernelInitializer:vn(this.kernelInitializer),biasInitializer:vn(this.biasInitializer),kernelRegularizer:nn(this.kernelRegularizer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),kernelConstraint:Ln(this.kernelConstraint),biasConstraint:Ln(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}};QI.className="Dense";ke.registerClass(QI);var eC=class extends It{constructor(t){t=t||{};super(t);this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Ft(t);for(let n of t.slice(1))if(n==null)throw new ne(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],ti(t,1)]}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t);if(this.dataFormat==="channelsFirst"&&r.rank>1){let s=[0];for(let o=2;o<r.rank;++o)s.push(o);s.push(1),r=St(r,s)}return hZ(r)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let n=super.getConfig();return Object.assign(t,n),t}};eC.className="Flatten";ke.registerClass(eC);var tC=class extends It{constructor(t){super(t);this.supportsMasking=!0,this.activation=Hi(t.activation)}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t);return this.activation.apply(r)})}getConfig(){let t={activation:ji(this.activation)},n=super.getConfig();return Object.assign(t,n),t}};tC.className="Activation";ke.registerClass(tC);var nC=class extends It{constructor(t){super(t);this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return le(()=>(t=bt(t),dZ(t,this.n)))}getConfig(){let t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}};nC.className="RepeatVector";ke.registerClass(nC);var rC=class extends It{constructor(t){super(t);this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){let r="Total size of new array must be unchanged.",s=n.slice(),o=1,a=null;for(let l=0;l<s.length;++l){let u=s[l];if(this.isUnknown(u))if(a===null)a=l;else throw new ne("Can only specifiy one unknown dimension.");else o*=u}let i=ti(t);if(a!==null){if(o===0||i%o!=0)throw new ne(r);s[a]=i/o}else if(i!==o)throw new ne(r);return s}computeOutputShape(t){let n=!1;for(let r=0;r<t.length;++r)if(this.isUnknown(t[r])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t),s=r.shape,o=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return X(r,o)})}getConfig(){let t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}};rC.className="Reshape";ke.registerClass(rC);var sC=class extends It{constructor(t){super(t);if(t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let n=Ps(1,t.dims.length+1);if(!C.arraysEqual(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new wn({ndim:this.dims.length+1})]}computeOutputShape(t){t=Ft(t);let n=t.slice();return this.dims.forEach((r,s)=>{n[s+1]=t[r]}),n}call(t,n){return St(bt(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}};sC.className="Permute";ke.registerClass(sC);var oC=class extends It{constructor(t){super(t==null?{}:t);this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){let r=bt(t),s=-1;return cd(Sl(r,this.maskValue),s)}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t),s=-1,o=!0,a=cd(Sl(r,this.maskValue),s,o);return Y(r,we(a,r.dtype))})}};oC.className="Masking";ke.registerClass(oC);var aC=class extends It{constructor(t){super(t);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let n=null;t.batchSize!=null&&(n=t.batchSize),t.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(mn(t.inputLength))}this.inputDim=t.inputDim,ar(this.inputDim,"inputDim"),this.outputDim=t.outputDim,ar(this.outputDim,"outputDim"),this.embeddingsInitializer=un(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=gn(t.embeddingsRegularizer),this.activityRegularizer=gn(t.activityRegularizer),this.embeddingsConstraint=Bn(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return le(()=>this.maskZero?(t=bt(t),Sl(t,Ye(t))):null)}computeOutputShape(t){if(t=Ft(t),this.inputLength==null)return[...t,this.outputDim];let n=mn(this.inputLength);if(n.length!==t.length-1)throw new ne(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let r=0;for(let s=0;s<n.length;++s){let o=n[s],a=t[s+1];if(o!=null&&a!=null&&o!==a)throw new ne(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);o==null&&(n[r]=a),r++}}return[t[0],...n,this.outputDim]}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t);r.dtype!=="int32"&&(r=wm(r,"int32"));let s=aI(this.embeddings.read(),X(r,[r.size]));return X(s,Ft(this.computeOutputShape(r.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:vn(this.embeddingsInitializer),embeddingsRegularizer:nn(this.embeddingsRegularizer),activityRegularizer:nn(this.activityRegularizer),embeddingsConstraint:Ln(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}};aC.className="Embedding";ke.registerClass(aC);var vd=class extends It{constructor(t){super(t||{});this.supportsMasking=!0}mergeFunction(t){throw new st}computeElementwiseOpOutputShape(t,n){if(t==null||n==null)return null;if(t.length<n.length)return this.computeElementwiseOpOutputShape(n,t);if(n.length===0)return t;let r=t.slice(0,t.length-n.length);for(let s=0;s<n.length;++s){let o=t[t.length-n.length+s],a=n[s];if(o==null||a==null||o<0||a<0)r.push(null);else if(o===1)r.push(a);else if(a===1)r.push(o);else{if(o!==a)throw new ne("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n));r.push(o)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Ft(t)]),t=t,t.length<2)throw new ne(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let n=[];for(let o of t)o!=null&&o[0]!==null&&n.push(o[0]);if(n=ei(n),n.length>1)throw new ne(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=t[0]==null?null:t[0].slice(1);for(let o=1;o<t.length;++o){let a=t[o]==null?null:t[o].slice(1);r=this.computeElementwiseOpOutputShape(r,a)}let s=t.map(o=>o.length);t.indexOf(null)===-1&&ei(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,n){return le(()=>{if(t=t,this.reshapeRequired){let r=[],s=t.map(o=>o.rank);if(s.indexOf(null)===-1){let o=Wi(s);for(let a of t){let i=a.rank;for(let l=0;l<o-i;++l)a=dc(a,1);r.push(a)}return this.mergeFunction(r)}else{let o=!1;for(let l of t){let u=l.rank;if(u==null){let c=l.shape,p=c[0],d=c.slice(1).concat([p]),f=X(l,[p].concat(ti(c.slice(1))));f=St(f,[1,0]),f=X(f,d),r.push(f),o=!0}else if(u>1){let c=Ps(1,u).concat([0]);r.push(St(l,c)),o=!0}else r.push(l)}let a=this.mergeFunction(r),i=a.rank;if(o){if(i==null){let l=a.shape,u=l.length,c=l[u-1],p=[c].concat(l.slice(0,l.length-1));a=X(St(X(a,[-1,c]),[1,0]),p)}else if(i>1){let l=[i-1].concat(Ps(0,i-1));a=St(a,l)}}return a}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let n;t[0]==null?n=null:n=t[0].slice(1);for(let s=1;s<t.length;++s){let o=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,o)}let r=[];for(let s of t)s!=null&&s[0]!==null&&r.push(s[0]);return r=ei(r),r.length===1?n=r.concat(n):n=[null].concat(n),n}computeMask(t,n){return le(()=>{if(n==null)return null;if(!Array.isArray(n))throw new ne("`mask` should be an Array");if(!Array.isArray(t))throw new ne("`inputs` should be an Array");if(n.length!==t.length)throw new ne(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${n.length})`);if(n.every(s=>s==null))return null;n=n.map(s=>s==null?s:Mr(s,0));let r=n[0];for(let s=1;s<n.length-1;++s)r=gs(r,n[s]);return r})}},iC=class extends vd{constructor(t){super(t)}mergeFunction(t){return le(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=Ie(n,t[r]);return n})}};iC.className="Add";ke.registerClass(iC);var lC=class extends vd{constructor(t){super(t)}mergeFunction(t){return le(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=Y(n,t[r]);return n})}};lC.className="Multiply";ke.registerClass(lC);var uC=class extends vd{constructor(t){super(t)}mergeFunction(t){return le(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=Ie(n,t[r]);return Y(1/t.length,n)})}};uC.className="Average";ke.registerClass(uC);var cC=class extends vd{constructor(t){super(t)}mergeFunction(t){return le(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=Qs(n,t[r]);return n})}};cC.className="Maximum";ke.registerClass(cC);var pC=class extends vd{constructor(t){super(t)}mergeFunction(t){return le(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=oc(n,t[r]);return n})}};pC.className="Minimum";ke.registerClass(pC);var dC=class extends vd{constructor(t){super(t);this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new ne("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let n=!0;for(let s of t)if(s!=null){n=!1;break}if(n)return;let r=[];for(let s=0;s<t.length;++s){let o=t[s].slice();o.splice(this.axis,1);let a=!1;for(let i of r)if(C.arraysEqual(i,o)){a=!0;break}a||r.push(o)}if(r.length>1)throw new ne("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return le(()=>Fy(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new ne("A `Concatenate` layer should be called on a list of inputs.");let n=t,r=n[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(let o of n.slice(1)){if(r[s]==null||o[s]==null){r[s]=null;break}r[s]+=o[s]}return r}computeMask(t,n){if(n==null)return null;if(!Array.isArray(n))throw new ne("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new ne("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new ne(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return le(()=>{let r=!0;if(n.forEach(a=>{if(a!=null){r=!1;return}}),r)return null;let s=[];for(let a=0;a<t.length;++a)n[a]==null?s.push(we(Nr(t[a]),"bool")):n[a].rank<t[a].rank?s.push(Mr(n[a],-1)):s.push(n[a]);let o=on(s,this.axis);return qh(o,-1,!1)})}getConfig(){let t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}};dC.className="Concatenate";ke.registerClass(dC);function Z2(e,t){for(;e<0;)e+=t;return e}function GGe(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new st("batchDot is not implemented for tensors of 4D or higher rank yet");if(C.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),C.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new st("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);let o=n;return le(()=>{let a;if(r>s){a=r-s;let l=[];for(let u=0;u<a;++u)l.push(1);t=X(t,t.shape.concat(l))}else if(s>r){a=s-r;let l=[];for(let u=0;u<a;++u)l.push(1);e=X(e,e.shape.concat(l))}else a=0;let i;if(e.shape.length===2&&t.shape.length===2)o[0]===o[1]?i=ze(Y(e,t),o[0]):i=ze(Y(St(e,[1,0]),t),o[1]);else{let l=o[0]!==e.shape.length-1,u=o[1]===t.shape.length-1;i=Bt(e,t,l,u)}if(a>0){let l;r>s?l=r+s-3:l=r-1;let u=[];for(let c=l;c<l+a;++c)u.push(c);i=ro(i,u)}return i.shape.length===1&&(i=Mr(i,1)),i})}var fC=class extends vd{constructor(t){super(t);this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){C.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let n=t[0],r=t[1];if(n.length>3||r.length>3)throw new st("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(n,r);if(n[s[0]]!==r[s[1]])throw new ne(`Dimension incompatibility: ${n[s[0]]} !== ${r[s[1]]}`)}mergeFunction(t){if(t.length!==2)throw new ne(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let n=t[0],r=t[1],s;return Array.isArray(this.axes)?s=this.axes.map((o,a)=>Z2(o,t[a].shape.length)):s=[Z2(this.axes,n.shape.length),Z2(this.axes,r.shape.length)],this.normalize&&(n=M2(n,s[0]),r=M2(r,s[1])),GGe(n,r,s)}interpretAxes(t,n){let r;return Array.isArray(this.axes)?r=this.axes:r=[Z2(this.axes,t.length),Z2(this.axes,n.length)],r}computeOutputShape(t){C.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let n=t[0].slice(),r=t[1].slice();if(n.length>3||r.length>3)throw new st("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(n,r);n.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);let o=n.concat(r);return o.length===1&&o.push(1),o}computeMask(t,n){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}};fC.className="Dot";ke.registerClass(fC);var hC=class extends It{constructor(t){super(t);this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t);return md(()=>Ie(Oy(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}};hC.className="GaussianNoise";ke.registerClass(hC);var mC=class extends It{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return le(()=>{this.invokeCallHook(t,n);let r=bt(t);return this.rate>0&&this.rate<1?md(()=>{let o=Math.sqrt(this.rate/(1-this.rate));return Y(r,Oy(r.shape,1,o))},()=>r,n.training||!1):r})}};mC.className="GaussianDropout";ke.registerClass(mC);var gC=class extends It{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||bt(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return le(()=>{if(this.rate<1&&this.rate>0){let r=this._getNoiseShape(t);return md(()=>{let o=bt(t),a=1.6732632423543772,i=1.0507009873554805,l=-a*i,u=To(Li(r),this.rate);u=wm(u,"float32");let c=((1-this.rate)*(1+this.rate*l**2))**-.5,p=-c*l*this.rate,d=Ie(Y(o,u),Y(Ie(u,-1),l));return Ie(Y(d,c),p)},()=>bt(t),n.training||!1)}return t})}};gC.className="AlphaDropout";ke.registerClass(gC);function Y2(e,t,n,r,s,o=.001){let a;if(e.rank===2)a=mD(e,t,n,r,s,o);else if(e.rank===3)a=gD(e,t,n,r,s,o);else if(e.rank===4)a=xD(e,t,n,r,s,o);else throw new st(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return a}function UGe(e,t,n,r,s=.001){return le(()=>{let o=Sy(e,r),a=o.mean,i=o.variance;return[Y2(e,a,i,n,t,s),a,i]})}function jGe(e,t,n,r,s=.001){return le(()=>{let o=Sy(e,r),a=o.mean,i=o.variance,l=[];for(let h of Ps(0,e.rank))r.indexOf(h)!==-1?l.push(1):l.push(e.shape[h]);let u=X(a,l),c=X(i,l),p=t==null?null:X(t,l),d=n==null?null:X(n,l);return[Y2(e,u,c,d,p,s),a,i]})}function HGe(e,t,n,r,s=.001){return C.arraysEqual(r.slice().sort(),Ps(0,e.rank-1))?UGe(e,t,n,r,s):jGe(e,t,n,r,s)}var xC=class extends It{constructor(t){t==null&&(t={});super(t);this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=un(t.betaInitializer||"zeros"),this.gammaInitializer=un(t.gammaInitializer||"ones"),this.movingMeanInitializer=un(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=un(t.movingVarianceInitializer||"ones"),this.betaConstraint=Bn(t.betaConstraint),this.gammaConstraint=Bn(t.gammaConstraint),this.betaRegularizer=gn(t.betaRegularizer),this.gammaRegularizer=gn(t.gammaRegularizer)}build(t){t=Ft(t);let n=this.axis>=0?this.axis:this.axis+t.length,r=t[n];if(r==null)throw new ne(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new wn({ndim:t.length,axes:{[n]:r}})];let s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return le(()=>{let r=n.training==null?!1:n.training,s=bt(t),o=s.shape,a=o.length,i=Ps(0,a),l=this.axis>=0?this.axis:this.axis+a;i.splice(l,1);let u=Ya(1,a);u[l]=o[l];let c=i.slice();c.sort();let p=!C.arraysEqual(c,Ps(0,a).slice(0,a-1)),d=()=>{if(p){let y=X(this.movingMean.read(),u),b=X(this.movingVariance.read(),u),A=this.center?X(this.beta.read(),u):null,v=this.scale?X(this.gamma.read(),u):null;return Y2(s,y,b,A,v,this.epsilon)}else return Y2(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return d();let[f,h,m]=HGe(s,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(y,b,A)=>{le(()=>{let v=1-A,w=y.read(),k=Y(je(w,b),v);y.write(je(w,k))})};return(()=>{g(this.movingMean,h,this.momentum),g(this.movingVariance,m,this.momentum)})(),f})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:vn(this.betaInitializer),gammaInitializer:vn(this.gammaInitializer),movingMeanInitializer:vn(this.movingMeanInitializer),movingVarianceInitializer:vn(this.movingVarianceInitializer),betaRegularizer:nn(this.betaRegularizer),gammaRegularizer:nn(this.gammaRegularizer),betaConstraint:Ln(this.betaConstraint),gammaConstraint:Ln(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}};xC.className="BatchNormalization";ke.registerClass(xC);var yC=class extends It{constructor(t){t==null&&(t={});super(t);if(this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=un(t.betaInitializer||"zeros"),this.gammaInitializer=un(t.gammaInitializer||"ones"),this.betaRegularizer=gn(t.betaRegularizer),this.gammaRegularizer=gn(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Ft(t);let n=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=n);for(let o of this.axis)if(o<0||o>=n)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==ei(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let r=this.axis.map(o=>t[o]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(t,n){let r=bt(t),s=r.shape,o=s.length;return le(()=>{let a=!0,{mean:i,variance:l}=Sy(r,this.axis,a),u=Ya(1,o);for(let m of this.axis)u[m]=s[m];let c=m=>m!=null&&m.shape.length!==o&&this.axis!==[o-1]?X(m,u):m,p=c(this.gamma.read()),d=c(this.beta.read()),f=[],h=[];for(let m=0;m<o;++m)this.axis.indexOf(m)!==-1?(f.push(s[m]),h.push(1)):(f.push(1),h.push(s[m]));return i=Yr(i,f),l=Yr(l,f),p=Yr(p,h),d=Yr(d,h),Y2(r,i,l,d,p,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:vn(this.betaInitializer),gammaInitializer:vn(this.gammaInitializer),betaRegularizer:nn(this.betaRegularizer),gammaRegularizer:nn(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}};yC.className="LayerNormalization";ke.registerClass(yC);function qGe(e,t,n){return le(()=>{if(e.rank!==4)throw new ne(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new ne("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=oo()),n!=="channelsLast"&&n!=="channelsFirst")throw new ne(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],zi(e,r)})}var bC=class extends It{constructor(t){t==null&&(t={});super(t);if(this.dataFormat=t.dataFormat==null?oo():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new ne(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,r;if(typeof t.padding[0]=="number")n=[t.padding[0],t.padding[0]],r=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new ne(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],t.padding[1].length!==2)throw new ne(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);r=t.padding[1]}this.padding=[n,r]}this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){t=Ft(t);let n,r;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?n=t[2]+this.padding[0][0]+this.padding[0][1]:n=null,t[3]!=null&&t[3]>=0?r=t[3]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],t[1],n,r]):(t[1]!=null&&t[1]>=0?n=t[1]+this.padding[0][0]+this.padding[0][1]:n=null,t[2]!=null&&t[2]>=0?r=t[2]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],n,r,t[3]])}call(t,n){return le(()=>qGe(bt(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}};bC.className="ZeroPadding2D";ke.registerClass(bC);function AC(e,t,n,r,s,o){return le(()=>{Fn(s),l$(o),ao(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=oo()),o==null&&(o="max"),e=U2(e,s);let a,i=r==="same"?"same":"valid";return o==="max"?a=sc(e,t,n,i):a=Yu(e,t,n,i),s==="channelsFirst"&&(a=St(a,[0,3,1,2])),a})}function HZ(e,t,n,r,s,o){return le(()=>{Fn(s),l$(o),ao(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=oo()),o==null&&(o="max"),e=V$(e,s);let a,i=r==="same"?"same":"valid";return o==="max"?a=n2(e,t,n,i):a=UA(e,t,n,i),s==="channelsFirst"&&(a=St(a,[0,4,1,2,3])),a})}var H$=class extends It{constructor(t){t.poolSize==null&&(t.poolSize=2);super(t);if(typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new ne(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(ar(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new ne(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);ar(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,ao(this.padding),this.inputSpec=[new wn({ndim:3})]}computeOutputShape(t){t=Ft(t);let n=Do(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return le(()=>{this.invokeCallHook(t,n),t=dc(bt(t),2);let r=this.poolingFunction(bt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ro(r,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(t,n),t}},vC=class extends H${constructor(t){super(t)}poolingFunction(t,n,r,s,o){return Fn(o),ao(s),AC(t,n,r,s,o,"max")}};vC.className="MaxPooling1D";ke.registerClass(vC);var wC=class extends H${constructor(t){super(t)}poolingFunction(t,n,r,s,o){return Fn(o),ao(s),AC(t,n,r,s,o,"avg")}};wC.className="AveragePooling1D";ke.registerClass(wC);var q$=class extends It{constructor(t){t.poolSize==null&&(t.poolSize=[2,2]);super(t);if(this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new ne(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];ar(this.poolSize,"poolSize"),ar(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Fn(this.dataFormat),ao(this.padding),this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){t=Ft(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2];return n=Do(n,this.poolSize[0],this.padding,this.strides[0]),r=Do(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r]:[t[0],n,r,t[3]]}call(t,n){return le(()=>(this.invokeCallHook(t,n),this.poolingFunction(bt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}},kC=class extends q${constructor(t){super(t)}poolingFunction(t,n,r,s,o){return Fn(o),ao(s),AC(t,n,r,s,o,"max")}};kC.className="MaxPooling2D";ke.registerClass(kC);var IC=class extends q${constructor(t){super(t)}poolingFunction(t,n,r,s,o){return Fn(o),ao(s),AC(t,n,r,s,o,"avg")}};IC.className="AveragePooling2D";ke.registerClass(IC);var K$=class extends It{constructor(t){t.poolSize==null&&(t.poolSize=[2,2,2]);super(t);if(this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new ne(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];ar(this.poolSize,"poolSize"),ar(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Fn(this.dataFormat),ao(this.padding),this.inputSpec=[new wn({ndim:5})]}computeOutputShape(t){t=Ft(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[4]:t[3];return n=Do(n,this.poolSize[0],this.padding,this.strides[0]),r=Do(r,this.poolSize[1],this.padding,this.strides[1]),s=Do(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r,s]:[t[0],n,r,s,t[4]]}call(t,n){return le(()=>(this.invokeCallHook(t,n),this.poolingFunction(bt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}},CC=class extends K${constructor(t){super(t)}poolingFunction(t,n,r,s,o){return Fn(o),ao(s),HZ(t,n,r,s,o,"max")}};CC.className="MaxPooling3D";ke.registerClass(CC);var SC=class extends K${constructor(t){super(t)}poolingFunction(t,n,r,s,o){return Fn(o),ao(s),HZ(t,n,r,s,o,"avg")}};SC.className="AveragePooling3D";ke.registerClass(SC);var X$=class extends It{constructor(t){super(t);this.inputSpec=[new wn({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new st}},NC=class extends X${constructor(t){super(t||{})}call(t,n){return le(()=>{let r=bt(t);return Nn(r,1)})}};NC.className="GlobalAveragePooling1D";ke.registerClass(NC);var TC=class extends X${constructor(t){super(t||{})}call(t,n){return le(()=>{let r=bt(t);return ms(r,1)})}};TC.className="GlobalMaxPooling1D";ke.registerClass(TC);var Z$=class extends It{constructor(t){super(t);this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Fn(this.dataFormat),this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,n){throw new st}getConfig(){let t={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}},_C=class extends Z${call(t,n){return le(()=>{let r=bt(t);return this.dataFormat==="channelsLast"?Nn(r,[1,2]):Nn(r,[2,3])})}};_C.className="GlobalAveragePooling2D";ke.registerClass(_C);var EC=class extends Z${call(t,n){return le(()=>{let r=bt(t);return this.dataFormat==="channelsLast"?ms(r,[1,2]):ms(r,[2,3])})}};EC.className="GlobalMaxPooling2D";ke.registerClass(EC);var Y$=class extends It{constructor(t){super(t);this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(t,n),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,n,r={}){let s=n.layer,o=aa(s,r);delete n.layer;let a={layer:o};return Object.assign(a,n),new t(a)}},RC=class extends Y${constructor(t){super(t);this.supportsMasking=!0}build(t){if(t=Ft(t),t.length<3)throw new ne(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Ft(t);let n=[t[0]].concat(t.slice(2)),r=this.layer.computeOutputShape(n),s=t[1];return[r[0],s].concat(r.slice(1))}call(t,n){return le(()=>(t=bt(t),U$((a,i)=>[bt(this.layer.call(a,n)),[]],t,[],!1,null,null,!1,!0)[1]))}};RC.className="TimeDistributed";ke.registerClass(RC);function KGe(e){Tl(iZ,"BidirectionalMergeMode",e)}var XGe="concat",DC=class extends Y${constructor(t){super(t);let n=t.layer.getConfig(),r={};r.className=t.layer.getClassName(),r.config=n,this.forwardLayer=aa(r),n.goBackwards=n.goBackwards!==!0;let s={};if(s.className=t.layer.getClassName(),s.config=n,this.backwardLayer=aa(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?XGe:t.mergeMode,KGe(this.mergeMode),t.weights)throw new st("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let n=t.length,r=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,r)),this.backwardLayer.setWeights(t.slice(r))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let r,s,o;return this.returnState&&(o=n.slice(1)),r=n[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(o).concat(o.slice()):[r].concat(o).concat(o.slice()):Jr(s)}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let o=G$(t,r,s,this.numConstants);if(t=o.inputs,r=o.initialState,s=o.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(r==null||r.length===0)&&s==null)return super.apply(t,n);let a=[],i=[];if(r!=null){let u=r.length;if(u%2>0)throw new ne("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,a.push(...r);let c=r.map(p=>new wn({shape:p.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),i.push(...c)}if(s!=null)throw new st("Support for constants in Bidirectional layers is not implemented yet.");let l=a[0]instanceof uo;for(let u of a)if(u instanceof uo!==l)throw new ne("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){let u=[t].concat(a),c=this.inputSpec.concat(i),p=this.inputSpec;this.inputSpec=c;let d=super.apply(u,n);return this.inputSpec=p,d}else return super.apply(t,n)}call(t,n){return le(()=>{let r=n.initialState,s,o;if(r==null)s=this.forwardLayer.call(t,n),o=this.backwardLayer.call(t,n);else{let l=r.slice(0,r.length/2),u=r.slice(r.length/2);s=this.forwardLayer.call(t,Object.assign(n,{initialState:l})),o=this.backwardLayer.call(t,Object.assign(n,{initialState:u}))}let a;this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(o.slice(1))),s=s[0],o=o[0]),this.returnSequences&&(o=no(o,1));let i;return this.mergeMode==="concat"?i=Fy([s,o]):this.mergeMode==="sum"?i=Ie(s,o):this.mergeMode==="ave"?i=Y(.5,Ie(s,o)):this.mergeMode==="mul"?i=Y(s,o):this.mergeMode==null&&(i=[s,o]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Vi(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Vi(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,n){Array.isArray(n)&&(n=n[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[n,n]:r=n:this.mergeMode==null?r=[null,null]:r=null,this.returnState){let o=this.forwardLayer.states.map(a=>null);return Array.isArray(r)?r.concat(o).concat(o):[r].concat(o).concat(o)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,n){let r=aa(n.layer);if(delete n.layer,n.numConstants!=null)throw new st("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=n;return s.layer=r,new t(s)}};DC.className="Bidirectional";ke.registerClass(DC);var si;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(si||(si={}));var qZ;(function(e){let t;(function(n){n[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(qZ||(qZ={}));var tUe={};function $C(e){return tUe[e]}function D(e,t,n,r,s){let o=t.inputParams[e];if(o&&o.inputIndexStart!==void 0){let i=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?i+1:o.inputIndexEnd;if(o.type==="tensor")return Lr(t.inputNames[o.inputIndexStart],n,r,s);if(o.type==="tensors")return t.inputNames.slice(i,l).map(d=>Lr(d,n,r,s));let u=Lr(t.inputNames.slice(i)[0],n,r,s),c=u.dataSync();return o.type==="number"?c[0]:C.toNestedArray(u.shape,c)}let a=t.attrParams[e];return a&&a.value}function Lr(e,t,n,r){let[s,o]=po(e);if(r!=null){let i=r.getHashTableHandleByName(s);if(i!=null)return i}let a=n.currentContextIds.find(i=>!!t[FC(s,i)]);return a!==void 0?t[FC(s,a)][o]:void 0}function KZ(e,t,n){return t[FC(e,n.currentContextId)]}function Ki(e,t){let[n,r,s]=po(e);return[FC(n,t&&t.currentContextId),r,s]}function FC(e,t){return t?`${e}-${t}`:e}function po(e){let t=e.split(":");if(t.length===1)return[e,0,void 0];let n=t[0],r=t.length===3?t[1]:void 0,s=Number(t[t.length-1]);return[n,s,r]}function J2(e,t,n){let r=D("pad",e,t,n);if(r==="explicit"){r=D("explicitPaddings",e,t,n);let s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function Xi(e){return e.kept?e:So(e)}var J$={};dn(J$,{json:()=>nUe});var nUe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Q$={};dn(Q$,{json:()=>rUe});var rUe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var e6={};dn(e6,{json:()=>sUe});var sUe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var t6={};dn(t6,{json:()=>oUe});var oUe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var n6={};dn(n6,{json:()=>aUe});var aUe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var r6={};dn(r6,{json:()=>iUe});var iUe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var s6={};dn(s6,{json:()=>lUe});var lUe=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var o6={};dn(o6,{json:()=>uUe});var uUe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var a6={};dn(a6,{json:()=>cUe});var cUe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var i6={};dn(i6,{json:()=>pUe});var pUe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var l6={};dn(l6,{json:()=>dUe});var dUe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var u6={};dn(u6,{json:()=>fUe});var fUe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var c6={};dn(c6,{json:()=>hUe});var hUe=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var p6={};dn(p6,{json:()=>mUe});var mUe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var d6={};dn(d6,{json:()=>gUe});var gUe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var f6={};dn(f6,{json:()=>xUe});var xUe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var h6={};dn(h6,{json:()=>yUe});var yUe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var m6={};dn(m6,{json:()=>bUe});var bUe=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var g6={};dn(g6,{json:()=>AUe});var AUe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var OC=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[J$,Q$,e6,t6,n6,r6,s6,o6,a6,i6,l6,u6,c6,p6,d6,f6,h6,m6,g6],n=[].concat(...t.map(r=>r.json));this.opMappers=n.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(t,n={}){let r=t.node,s=[],o=[],a=[],i=r.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):g.op==="Const"?o.push(m[g.name]):(g.input==null||g.input.length===0)&&a.push(m[g.name]),m),{}),l=[],u=[],c={},p={};n!=null&&(c=this.mapSignatureEntries(n.inputs),p=this.mapSignatureEntries(n.outputs));let d=Object.keys(i);d.forEach(m=>{let g=i[m];g.inputNames.forEach((x,y)=>{let[b,,A]=Ki(x),v=i[b];if(v.outputs!=null){let w=v.outputs.indexOf(A);if(w!==-1){let k=`${b}:${w}`;g.inputNames[y]=k}}g.inputs.push(v),v.children.push(g)})}),Object.keys(p).length===0?d.forEach(m=>{let g=i[m];g.children.length===0&&u.push(g)}):Object.keys(p).forEach(m=>{let[g]=Ki(m),x=i[g];x!=null&&(x.signatureKey=p[m],u.push(x))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{let[g]=Ki(m),x=i[g];x&&(x.signatureKey=c[m],l.push(x))}):l=s;let f={};t.library!=null&&t.library.function!=null&&(f=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));let h={nodes:i,inputs:l,outputs:u,weights:o,placeholders:s,signature:n,functions:f};return a.length>0&&(h.initNodes=a),h}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,r)=>(n[t[r].name]=r,n),{})}mapNode(t){let n=$C(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let r={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.substr(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((s,o)=>{let a=o.type,i;switch(o.type){case"string":i=PC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=PC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":i=GC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=GC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":i=zC(t.attr,o.tfName,o.defaultValue||0),i===void 0&&!!o.tfDeprecatedName&&(i=zC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":i=WC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=WC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":i=MC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=MC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":i=jC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=jC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":i=VC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=VC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":i=UC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=UC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":i=LC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=LC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":i=BC(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=BC(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":i=ZZ(t.attr,o.tfName,o.defaultValue),i===void 0&&!!o.tfDeprecatedName&&(i=ZZ(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}return s[o.name]={value:i,type:a},s},{})),r}mapFunction(t){let n=t.nodeDef,r=[],s=[],o={};n!=null&&(o=n.reduce((p,d)=>(p[d.name]=this.mapNode(d),d.op==="Const"&&s.push(p[d.name]),p),{}));let a=[],i=[];t.signature.inputArg.forEach(p=>{let[d]=Ki(p.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:x6(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,a.push(f),o[d]=f}),Object.keys(o).forEach(p=>{let d=o[p];d.inputNames.forEach((f,h)=>{let[m,,g]=Ki(f),x=o[m];if(x.outputs!=null){let y=x.outputs.indexOf(g);if(y!==-1){let b=`${m}:${y}`;d.inputNames[h]=b}}d.inputs.push(x),x.children.push(d)})});let u=t.ret;t.signature.outputArg.forEach(p=>{let[d,f]=Ki(u[p.name]),h=o[d];h!=null&&(h.defaultOutput=f,i.push(h))});let c=this.mapArgsToSignature(t);return{nodes:o,inputs:a,outputs:i,weights:s,placeholders:r,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:t.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,t.ret),n),{})}}mapArgToTensorInfo(t,n){let r=t.name;return n!=null&&(r=n[r]),{name:r,dtype:t.type}}};function vUe(e){let t=he().global;if(typeof t.atob!="undefined")return t.atob(e);if(typeof Buffer!="undefined")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function XZ(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):vUe(e);return t?n:n.toLowerCase()}function PC(e,t,n,r=!1){let s=e[t];return s!=null?XZ(s.s,r):n}function MC(e,t,n){let r=e[t];return r?r.b:n}function zC(e,t,n){let r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function x6(e){switch(typeof e=="string"&&(e=si[e]),e){case si.DT_FLOAT:return"float32";case si.DT_INT32:case si.DT_INT64:case si.DT_INT8:case si.DT_UINT8:return"int32";case si.DT_BOOL:return"bool";case si.DT_DOUBLE:return"float32";case si.DT_STRING:return"string";default:return null}}function ZZ(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function LC(e,t,n){let r=e[t];return r&&r.type?x6(r.type):n}function BC(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>x6(s)):n}function YZ(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function VC(e,t,n){let r=e[t];return r&&r.shape?YZ(r.shape):n}function WC(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function GC(e,t,n,r=!1){let s=e[t];return s&&s.list&&s.list.s?s.list.s.map(o=>XZ(o,r)):n}function UC(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>YZ(s)):n}function jC(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var y6=class{constructor(t,n,r){this.node=t,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(t){return Lr(t,this.tensorMap,this.context)}getAttr(t,n){let r=this.node.rawAttrs[t];if(r.tensor!=null)return Lr(t,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return zC(this.node.rawAttrs,t,n);if(r.s!=null)return PC(this.node.rawAttrs,t,n);if(r.b!=null)return MC(this.node.rawAttrs,t,n);if(r.shape!=null)return VC(this.node.rawAttrs,t,n);if(r.type!=null)return LC(this.node.rawAttrs,t,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return WC(this.node.rawAttrs,t,n);if(r.list.s!=null)return GC(this.node.rawAttrs,t,n);if(r.list.shape!=null)return UC(this.node.rawAttrs,t,n);if(r.list.b!=null)return jC(this.node.rawAttrs,t,n);if(r.list.type!=null)return BC(this.node.rawAttrs,t,n)}return n}};var JZ=(e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[Ie(D("a",e,t,n),D("b",e,t,n))];case"AddN":return[pD(D("tensors",e,t,n))];case"FloorMod":case"Mod":return[s2(D("a",e,t,n),D("b",e,t,n))];case"Mul":return[Y(D("a",e,t,n),D("b",e,t,n))];case"RealDiv":case"Div":return[Pe(D("a",e,t,n),D("b",e,t,n))];case"DivNoNan":return[ZA(D("a",e,t,n),D("b",e,t,n))];case"FloorDiv":return[Hh(D("a",e,t,n),D("b",e,t,n))];case"Sub":return[je(D("a",e,t,n),D("b",e,t,n))];case"Minimum":return[oc(D("a",e,t,n),D("b",e,t,n))];case"Maximum":return[Qs(D("a",e,t,n),D("b",e,t,n))];case"Pow":return[Eo(D("a",e,t,n),D("b",e,t,n))];case"SquaredDifference":return[f2(D("a",e,t,n),D("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var QZ=(e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[sr(D("x",e,t,n))];case"Acos":return[PA(D("x",e,t,n))];case"Acosh":return[MA(D("x",e,t,n))];case"Asin":return[LA(D("x",e,t,n))];case"Asinh":return[BA(D("x",e,t,n))];case"Atan":return[VA(D("x",e,t,n))];case"Atan2":return[WA(D("x",e,t,n),D("y",e,t,n))];case"Atanh":return[GA(D("x",e,t,n))];case"Ceil":return[HA(D("x",e,t,n))];case"Complex":return[ta(D("real",e,t,n),D("imag",e,t,n))];case"Cos":return[ec(D("x",e,t,n))];case"Cosh":return[Jh(D("x",e,t,n))];case"Elu":return[Pi(D("x",e,t,n))];case"Erf":return[YA(D("x",e,t,n))];case"Exp":return[Zr(D("x",e,t,n))];case"Expm1":return[JA(D("x",e,t,n))];case"Floor":return[Mi(D("x",e,t,n))];case"Log":return[Ns(D("x",e,t,n))];case"Log1p":return[nm(D("x",e,t,n))];case"Imag":return[em(D("x",e,t,n))];case"Neg":return[jt(D("x",e,t,n))];case"Reciprocal":return[a2(D("x",e,t,n))];case"Real":return[fd(D("x",e,t,n))];case"Relu":return[to(D("x",e,t,n))];case"Round":return[lm(D("x",e,t,n))];case"Selu":return[cm(D("x",e,t,n))];case"Sigmoid":return[ra(D("x",e,t,n))];case"Sin":return[pm(D("x",e,t,n))];case"Sign":return[l2(D("x",e,t,n))];case"Sinh":return[dm(D("x",e,t,n))];case"Softplus":return[Ka(D("x",e,t,n))];case"Sqrt":return[hn(D("x",e,t,n))];case"Square":return[Nt(D("x",e,t,n))];case"Tanh":return[pd(D("x",e,t,n))];case"Tan":return[m2(D("x",e,t,n))];case"ClipByValue":return[Pr(D("x",e,t,n),D("clipValueMin",e,t,n),D("clipValueMax",e,t,n))];case"Relu6":return[im(D("x",e,t,n))];case"Rsqrt":return[um(Lr(e.inputNames[0],t,n))];case"Prod":return[om(D("x",e,t,n),D("axes",e,t,n))];case"LeakyRelu":return[nc(D("x",e,t,n),D("alpha",e,t,n))];case"Prelu":return[ic(D("x",e,t,n),D("alpha",e,t,n))];case"IsNan":return[QA(Lr(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ia(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){C.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let s=e[r],o=t[r];C.assert(s<0||o<0||s===o,()=>n+` Shapes ${e} and ${t} must match`)}}}function eY(e){return!(typeof e=="number"||e.some(t=>t<0))}function Hy(e,t,n){let r=HC(e,n),s=!eY(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(o=>{r=HC(o.shape,r)}),!eY(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function HC(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let s=e[r],o=t[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:o}return n}var b6=class{constructor(t,n,r,s,o,a,i){this.name=t,this.dtype=n,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Ke(0),$n(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let n=this.tensors[t];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[t]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),ia(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=n,$n(n),r.written=!0,this.tensors[t]=r}writeMany(t,n){if(t.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`);t.forEach((r,s)=>this.write(r,n[s]))}gather(t,n){if(!!n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(t.length===0)return Zs([],[0].concat(this.elementShape));let r=this.readMany(t);return ia(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),or(r,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return Zs([],[0].concat(this.elementShape));let n=[];for(let s=0;s<this.size();s++)n.push(s);let r=this.readMany(n);return ia(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),on(r,0)}scatter(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);let r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,zr(n,0))}split(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0,s=t.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let o=r===0?0:n.size/r,a=[];le(()=>{n=X(n,[1,r,o]);for(let l=0;l<t.length;++l){let u=l===0?0:s[l-1],c=[0,u,0],p=[1,t[l],o];a[l]=X(Tt(n,c,p),this.elementShape)}return a});let i=[];for(let l=0;l<t.length;l++)i[l]=l;this.writeMany(i,a)}};var $m=class{constructor(t,n,r,s=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t!=null&&t.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);ia(n,o.shape,"TensorList shape mismatch: "),$n(o)}),this.idTensor=Ke(0),this.maxNumElements=s,$n(this.idTensor)}get id(){return this.idTensor.id}copy(){return new $m([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ia(t,this.elementShape,"TensorList shape mismatch: ");let s=Hy(this.elementShape,this.tensors,t);return le(()=>{let o=this.tensors.map(a=>X(a,s));return or(o,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Hy(this.elementShape,this.tensors,t),s=this.tensors.pop();return ia(s.shape,t,"TensorList shape mismatch: "),X(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(ia(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");$n(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);ia(this.tensors[t].shape,n,"TensorList shape mismatch: ");let s=Hy(this.elementShape,this.tensors,n);return X(this.tensors[t],s)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);ia(this.elementShape,n.shape,"TensorList shape mismatch: "),$n(n),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ia(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let s=Hy(this.elementShape,this.tensors,r);return t.length===0?Zs([],[0].concat(s)):le(()=>{let o=t.map(a=>X(this.tensors[a],s));return or(o,0)})}concat(t,n){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);ia(this.elementShape,n,"TensorList shape mismatch: ");let r=Hy(this.elementShape,this.tensors,n);return this.size()===0?Zs([],[0].concat(r)):le(()=>{let s=this.tensors.map(o=>X(o,r));return on(s,0)})}};function tY(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let s=e.shape.slice(1);ia(s,t,"TensorList shape mismatch: ");let o=zr(e);return new $m(o,t,r)}function nY(e,t,n){return new $m([],e,t,n)}function rY(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let o=new $m([],n,e.dtype,r),a=zr(e,0);return t.forEach((i,l)=>{o.setItem(i,a[l])}),o}function sY(e,t,n){let r=0,s=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let o=e.shape.slice(1),a=HC(o,n),i=r===0?0:e.size/r,l=le(()=>{let c=[];e=X(e,[1,r,i]);for(let p=0;p<t.length;++p){let d=p===0?0:s[p-1],f=[0,d,0],h=[1,t[p],i];c[p]=X(Tt(e,f,h),a)}return e.dispose(),c}),u=new $m([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var oY=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=D("thenBranch",e,t,n),s=D("elseBranch",e,t,n),o=D("cond",e,t,n),a=D("args",e,t,n);return(await o.data())[0]?n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=D("body",e,t,n),s=D("cond",e,t,n),o=D("args",e,t,n),a=await n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),i=o.map(c=>c.id),l=await a[0].data();a.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let u=o;for(;l[0];){let c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let p=u.map(f=>f.id);c.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let d=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await d[0].data(),d.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return u}case"LoopCond":{let r=D("pred",e,t,n);return[Xi(r)]}case"Switch":{let r=D("pred",e,t,n),s=D("data",e,t,n);return s.kept||(s=Xi(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=e.inputNames.find(s=>Lr(s,t,n)!==void 0);if(r){let s=Lr(r,t,n);return[Xi(s)]}return}case"Enter":{let r=D("frameName",e,t,n),s=D("tensor",e,t,n);return n.enterFrame(r),[Xi(s)]}case"Exit":{let r=D("tensor",e,t,n);return n.exitFrame(),[Xi(r)]}case"NextIteration":{let r=D("tensor",e,t,n);return n.nextIteration(),[Xi(r)]}case"TensorArrayV3":{let r=D("size",e,t,n),s=D("dtype",e,t,n),o=D("elementShape",e,t,n),a=D("dynamicSize",e,t,n),i=D("clearAfterRead",e,t,n),l=D("identicalElementShapes",e,t,n),u=D("name",e,t,n),c=new b6(u,s,r,o,l,a,i);return n.addTensorArray(c),[c.idTensor,Ke(1)]}case"TensorArrayWriteV3":{let r=D("tensorArrayId",e,t,n),s=D("index",e,t,n),o=D("tensor",e,t,n),a=n.getTensorArray(r.id);return a.write(s,o),[a.idTensor]}case"TensorArrayReadV3":{let r=D("tensorArrayId",e,t,n),s=D("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{let r=D("tensorArrayId",e,t,n),s=D("indices",e,t,n),o=D("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{let r=D("tensorArrayId",e,t,n),s=D("indices",e,t,n),o=D("tensor",e,t,n),a=n.getTensorArray(r.id);return a.scatter(s,o),[a.idTensor]}case"TensorArrayConcatV3":{let r=D("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),o=D("dtype",e,t,n);return[s.concat(o)]}case"TensorArraySplitV3":{let r=D("tensorArrayId",e,t,n),s=D("tensor",e,t,n),o=D("lengths",e,t,n),a=n.getTensorArray(r.id);return a.split(o,s),[a.idTensor]}case"TensorArraySizeV3":{let r=D("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[Ke(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=D("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=D("tensorListId",e,t,n),s=D("index",e,t,n),o=D("tensor",e,t,n),a=n.getTensorList(r.id);return a.setItem(s,o),[a.idTensor]}case"TensorListGetItem":{let r=D("tensorListId",e,t,n),s=D("index",e,t,n),o=D("elementShape",e,t,n),a=D("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{let r=D("indices",e,t,n),s=D("tensor",e,t,n),o=D("elementShape",e,t,n),a=D("numElements",e,t,n),i=rY(s,r,o,a);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=D("elementShape",e,t,n),s=D("elementDType",e,t,n),o;e.op==="TensorListReserve"?o="numElements":o="maxNumElements";let a=D(o,e,t,n),i=nY(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{let r=D("tensorListId",e,t,n),s=D("indices",e,t,n),o=D("elementShape",e,t,n),a=D("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,a,o)]}case"TensorListStack":{let r=D("tensorListId",e,t,n),s=D("elementShape",e,t,n),o=D("elementDType",e,t,n),a=D("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,o,a)]}case"TensorListFromTensor":{let r=D("tensor",e,t,n),s=D("elementShape",e,t,n),o=D("elementDType",e,t,n),a=tY(r,s,o);return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":{let r=D("tensorListId",e,t,n),s=n.getTensorList(r.id),o=D("dtype",e,t,n),a=D("elementShape",e,t,n);return[s.concat(o,a)]}case"TensorListPushBack":{let r=D("tensorListId",e,t,n),s=D("tensor",e,t,n),o=n.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{let r=D("tensorListId",e,t,n),s=D("elementShape",e,t,n),o=D("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{let r=D("tensor",e,t,n),s=D("elementShape",e,t,n),o=D("lengths",e,t,n),a=sY(r,o,s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function aY(e,t,n){let[r,s]=D("fusedOps",e,t,n),o=r==="biasadd",a=!o,i=s==="prelu",l=r==="fusedbatchnorm",u=D("numArgs",e,t,n);if(o){if(i&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=D("strides",e,t,n),p=J2(e,t,n),d=D("dataFormat",e,t,n).toUpperCase(),f=D("dilations",e,t,n),[h,m]=D("args",e,t,n);a&&(m=h,h=void 0);let g=D("leakyreluAlpha",e,t,n);return{stride:c,pad:p,dataFormat:d,dilations:f,biasArg:h,preluArg:m,activationFunc:s,leakyreluAlpha:g}}var iY=(e,t,n)=>{switch(e.op){case"Conv1D":{let r=D("stride",e,t,n),s=D("pad",e,t,n),o=D("dataFormat",e,t,n).toUpperCase(),a=D("dilation",e,t,n);return[Zh(D("x",e,t,n),D("filter",e,t,n),r,s,o,a)]}case"Conv2D":{let r=D("strides",e,t,n),s=J2(e,t,n),o=D("dataFormat",e,t,n).toUpperCase(),a=D("dilations",e,t,n);return[Js(D("x",e,t,n),D("filter",e,t,n),[r[1],r[2]],s,o,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:i,preluArg:l,activationFunc:u,leakyreluAlpha:c}=aY(e,t,n);return[Xa.conv2d({x:D("x",e,t,n),filter:D("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:i,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:o,dilations:a,biasArg:i,preluArg:l,activationFunc:u,leakyreluAlpha:c}=aY(e,t,n);return[Xa.depthwiseConv2d({x:D("x",e,t,n),filter:D("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:i,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=D("outputShape",e,t,n),s=D("strides",e,t,n),o=J2(e,t,n);return[Yh(D("x",e,t,n),D("filter",e,t,n),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=D("strides",e,t,n),s=J2(e,t,n),o=D("dilations",e,t,n),a=D("dataFormat",e,t,n).toUpperCase();return[Oi(D("input",e,t,n),D("filter",e,t,n),[r[1],r[2]],s,a,[o[1],o[2]])]}case"Conv3D":{let r=D("strides",e,t,n),s=D("pad",e,t,n),o=D("dataFormat",e,t,n).toUpperCase(),a=D("dilations",e,t,n);return[qA(D("x",e,t,n),D("filter",e,t,n),[r[1],r[2],r[3]],s,o,[a[1],a[2],a[3]])]}case"AvgPool":{let r=D("strides",e,t,n),s=D("pad",e,t,n),o=D("kernelSize",e,t,n);return[Yu(D("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=D("strides",e,t,n),s=D("pad",e,t,n),o=D("kernelSize",e,t,n);return[sc(D("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=D("strides",e,t,n),s=D("pad",e,t,n),o=D("kernelSize",e,t,n),a=D("includeBatchInIndex",e,t,n),{result:i,indexes:l}=FD(D("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s,a);return[i,l]}case"AvgPool3D":{let r=D("strides",e,t,n),s=D("pad",e,t,n),o=D("kernelSize",e,t,n);return[UA(D("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=D("strides",e,t,n),s=D("pad",e,t,n),o=D("kernelSize",e,t,n);return[n2(D("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=D("strides",e,t,n),s=D("pad",e,t,n),o=D("dilations",e,t,n),a=r[1],i=r[2],l=o[1],u=o[2];return[XA(D("x",e,t,n),D("filter",e,t,n),[a,i],s,[l,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var lY=(e,t,n)=>{switch(e.op){case"Fill":{let r=D("shape",e,t,n),s=D("dtype",e,t,n),o=D("value",e,t,n);return[tc(r,o,s)]}case"LinSpace":{let r=D("start",e,t,n),s=D("stop",e,t,n),o=D("num",e,t,n);return[TD(r,s,o)]}case"Multinomial":{let r=D("logits",e,t,n),s=D("numSamples",e,t,n),o=D("seed",e,t,n);return[OD(r,s,o)]}case"OneHot":{let r=D("indices",e,t,n),s=D("depth",e,t,n),o=D("onValue",e,t,n),a=D("offValue",e,t,n);return[ud(r,s,o,a)]}case"Ones":return[eo(D("shape",e,t,n),D("dtype",e,t,n))];case"OnesLike":return[Nr(D("x",e,t,n))];case"RandomUniform":return[Li(D("shape",e,t,n),D("minval",e,t,n),D("maxval",e,t,n),D("dtype",e,t,n))];case"Range":{let r=D("start",e,t,n),s=D("stop",e,t,n),o=D("step",e,t,n);return[lc(r,s,o,D("dtype",e,t,n))]}case"TruncatedNormal":{let r=D("shape",e,t,n),s=D("mean",e,t,n),o=D("stdDev",e,t,n),a=D("seed",e,t,n);return[hm(r,s,o,D("dtype",e,t,n),a)]}case"Zeros":return[fn(D("shape",e,t,n),D("dtype",e,t,n))];case"ZerosLike":return[Ye(D("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function A6(e,t,n){let r=D("boxes",e,t,n),s=D("scores",e,t,n),o=D("maxOutputSize",e,t,n),a=D("iouThreshold",e,t,n),i=D("scoreThreshold",e,t,n),l=D("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}}var uY=async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}=A6(e,t,n),u=await so.nonMaxSuppressionWithScoreAsync(r,s,o,a,i,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i}=A6(e,t,n),l=D("padToMaxOutputSize",e,t,n),u=await so.nonMaxSuppressionPaddedAsync(r,s,o,a,i,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:o,iouThreshold:a,scoreThreshold:i}=A6(e,t,n);return[await so.nonMaxSuppressionAsync(r,s,o,a,i)]}case"Where":{let r=we(D("condition",e,t,n),"bool"),s=[await KD(r)];return r.dispose(),s}case"ListDiff":return HD(D("x",e,t,n),D("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}};var cY=(e,t,n)=>{switch(e.op){case"TopKV2":{let r=D("x",e,t,n),s=D("k",e,t,n),o=D("sorted",e,t,n),a=x2(r,s,o);return[a.values,a.indices]}case"Unique":{let r=D("x",e,t,n),s=Ty(r);return[s.values,s.indices]}case"UniqueV2":{let r=D("x",e,t,n),s=D("axis",e,t,n),o=Ty(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var pY=(e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=D("default",e,t,n);return[Lr(e.name,t,n)||r];case"Placeholder":return[Lr(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=D("x",e,t,n);return[Xi(u)]}case"IdentityN":return D("x",e,t,n).map(u=>Xi(u));case"Snapshot":let s=D("x",e,t,n);return[Xi(s)];case"Shape":return[Kn(D("x",e,t,n).shape,"int32")];case"ShapeN":return D("x",e,t,n).map(u=>Kn(u.shape));case"Size":return[Ke(D("x",e,t,n).size,"int32")];case"Rank":return[Ke(D("x",e,t,n).rank,"int32")];case"NoOp":return[Ke(1)];case"Print":let o=D("x",e,t,n),a=D("data",e,t,n),i=D("message",e,t,n),l=D("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var v6=class{constructor(t,n){this.keyDType=t,this.valueDType=n,this.handle=Ke(0),this.tensorMap=new Map,$n(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ke(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);let r=await t.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),le(()=>{let s=zr(n),o=r.length,a=s.length;C.assert(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let i=0;i<o;i++){let l=r[i],u=s[i];$n(u),this.tensorMap.set(l,u)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);let r=await t.data();return le(()=>{let s=[];for(let o=0;o<r.length;o++){let a=r[o],i=this.findWithDefault(a,n);s.push(i)}return or(s)})}findWithDefault(t,n){let r=this.tensorMap.get(t);return r!=null?r:n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}};var dY=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let s=D("keyDType",e,t,n),o=D("valueDType",e,t,n),a=new v6(s,o);return r.addHashTable(e.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{let s=D("tableHandle",e,t,n,r),o=D("keys",e,t,n),a=D("values",e,t,n);return[await r.getHashTableById(s.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{let s=D("tableHandle",e,t,n,r),o=D("keys",e,t,n),a=D("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let s=D("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var fY=(e,t,n)=>{switch(e.op){case"ResizeBilinear":{let r=D("images",e,t,n),s=D("size",e,t,n),o=D("alignCorners",e,t,n),a=D("halfPixelCenters",e,t,n);return[so.resizeBilinear(r,[s[0],s[1]],o,a)]}case"ResizeNearestNeighbor":{let r=D("images",e,t,n),s=D("size",e,t,n),o=D("alignCorners",e,t,n),a=D("halfPixelCenters",e,t,n);return[so.resizeNearestNeighbor(r,[s[0],s[1]],o,a)]}case"CropAndResize":{let r=D("image",e,t,n),s=D("boxes",e,t,n),o=D("boxInd",e,t,n),a=D("cropSize",e,t,n),i=D("method",e,t,n),l=D("extrapolationValue",e,t,n);return[so.cropAndResize(r,s,o,a,i,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var hY=(e,t,n)=>{switch(e.op){case"Equal":return[Ss(D("a",e,t,n),D("b",e,t,n))];case"NotEqual":return[Sl(D("a",e,t,n),D("b",e,t,n))];case"Greater":return[qn(D("a",e,t,n),D("b",e,t,n))];case"GreaterEqual":return[To(D("a",e,t,n),D("b",e,t,n))];case"Less":return[tm(D("a",e,t,n),D("b",e,t,n))];case"LessEqual":return[_o(D("a",e,t,n),D("b",e,t,n))];case"LogicalAnd":return[gs(D("a",e,t,n),D("b",e,t,n))];case"LogicalNot":return[rc(D("a",e,t,n))];case"LogicalOr":return[sm(D("a",e,t,n),D("b",e,t,n))];case"Select":case"SelectV2":return[Sn(D("condition",e,t,n),D("a",e,t,n),D("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var mY=(e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Bt(D("a",e,t,n),D("b",e,t,n),D("transposeA",e,t,n),D("transposeB",e,t,n))];case"Einsum":return[CD(D("equation",e,t,n),...D("tensors",e,t,n))];case"Transpose":return[St(D("x",e,t,n),D("perm",e,t,n))];case"_FusedMatMul":let[r,s]=D("fusedOps",e,t,n),o=r==="biasadd",a=s==="prelu",i=D("numArgs",e,t,n),l=D("leakyreluAlpha",e,t,n);if(o){if(a&&i!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,c]=D("args",e,t,n);return[Xa.matMul({a:D("a",e,t,n),b:D("b",e,t,n),transposeA:D("transposeA",e,t,n),transposeB:D("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var gY=(e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[qa(D("x",e,t,n),D("mean",e,t,n),D("variance",e,t,n),D("offset",e,t,n),D("scale",e,t,n),D("epsilon",e,t,n))];case"FusedBatchNormV3":return[qa(D("x",e,t,n),D("mean",e,t,n),D("variance",e,t,n),D("offset",e,t,n),D("scale",e,t,n),D("epsilon",e,t,n))];case"LRN":return[e2(D("x",e,t,n),D("radius",e,t,n),D("bias",e,t,n),D("alpha",e,t,n),D("beta",e,t,n))];case"Softmax":return[uc(D("x",e,t,n))];case"LogSoftmax":return[rm(D("x",e,t,n))];case"SparseToDense":return[L3(D("sparseIndices",e,t,n),D("outputShape",e,t,n),D("sparseValues",e,t,n),D("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var xY=(e,t,n)=>{switch(e.op){case"Max":{let a=D("axis",e,t,n),i=D("keepDims",e,t,n);return[ms(D("x",e,t,n),a,i)]}case"Mean":{let a=D("axis",e,t,n),i=D("keepDims",e,t,n);return[Nn(D("x",e,t,n),a,i)]}case"Min":{let a=D("axis",e,t,n),i=D("keepDims",e,t,n);return[dd(D("x",e,t,n),a,i)]}case"Sum":{let a=D("axis",e,t,n),i=D("keepDims",e,t,n);return[ze(D("x",e,t,n),a,i)]}case"All":{let a=D("axis",e,t,n),i=D("keepDims",e,t,n);return[qh(D("x",e,t,n),a,i)]}case"Any":{let a=D("axis",e,t,n),i=D("keepDims",e,t,n);return[cd(D("x",e,t,n),a,i)]}case"ArgMax":{let a=D("axis",e,t,n);return[Fi(D("x",e,t,n),a)]}case"ArgMin":{let a=D("axis",e,t,n);return[zA(D("x",e,t,n),a)]}case"Prod":{let a=D("axis",e,t,n),i=D("keepDims",e,t,n);return[om(D("x",e,t,n),a,i)]}case"Cumsum":{let a=D("axis",e,t,n),i=D("exclusive",e,t,n),l=D("reverse",e,t,n);return[Qh(D("x",e,t,n),a,i,l)]}case"Bincount":let r=D("x",e,t,n),s=D("weights",e,t,n),o=D("size",e,t,n);return[jA(r,s,o)];case"DenseBincount":{let a=D("x",e,t,n),i=D("weights",e,t,n),l=D("size",e,t,n),u=D("binaryOutput",e,t,n);return[ID(a,i,l,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var yY=(e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=D("n",e,t,n),s=D("axis",e,t,n),o=D("tensors",e,t,n);return o=o.slice(0,r),[on(o,s)]}case"Gather":{let r=D("x",e,t,n),s=D("indices",e,t,n);return[Il(r,we(s,"int32"),0)]}case"GatherV2":{let r=D("axis",e,t,n),s=D("batchDims",e,t,n),o=D("x",e,t,n),a=D("indices",e,t,n);return[Il(o,we(a,"int32"),r,s)]}case"Reverse":{let r=D("dims",e,t,n),s=[];for(let a=0;a<r.length;a++)r[a]&&s.push(a);let o=D("x",e,t,n);return[no(o,s)]}case"ReverseV2":{let r=D("axis",e,t,n),s=D("x",e,t,n);return[no(s,r)]}case"Slice":{let r=D("begin",e,t,n),s=D("size",e,t,n);return[Tt(D("x",e,t,n),r,s)]}case"StridedSlice":{let r=D("begin",e,t,n),s=D("end",e,t,n),o=D("strides",e,t,n),a=D("beginMask",e,t,n),i=D("endMask",e,t,n),l=D("ellipsisMask",e,t,n),u=D("newAxisMask",e,t,n),c=D("shrinkAxisMask",e,t,n),p=D("x",e,t,n);return[h2(p,r,s,o,a,i,l,u,c)]}case"Pack":return le(()=>{let r=D("axis",e,t,n),s=D("tensors",e,t,n),o=s[0].shape,a=ro(s[0]).shape,i=s.map(l=>{let u=C.arraysEqual(l.shape,o);if(!u&&!C.arraysEqual(ro(l).shape,a))throw new Error("the input tensors shape does not match");return u?l:X(l,o)});return[or(i,r)]});case"Unpack":{let r=D("axis",e,t,n),s=D("tensor",e,t,n);return zr(s,r)}case"Tile":{let r=D("reps",e,t,n);return[Yr(D("x",e,t,n),r)]}case"Split":case"SplitV":{let r=D("axis",e,t,n),s=D("numOrSizeSplits",e,t,n),o=D("x",e,t,n);return yr(o,s,r)}case"ScatterNd":{let r=D("indices",e,t,n),s=D("values",e,t,n),o=D("shape",e,t,n);return[vq(r,s,o)]}case"GatherNd":{let r=D("x",e,t,n),s=D("indices",e,t,n);return[kq(r,s)]}case"SparseToDense":{let r=D("sparseIndices",e,t,n),s=D("outputShape",e,t,n),o=D("sparseValues",e,t,n),a=D("defaultValue",e,t,n);return[L3(r,o,s,o.dtype===a.dtype?a:we(a,o.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var bY=(e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:a}=y2.sparseFillEmptyRows(D("indices",e,t,n),D("values",e,t,n),D("denseShape",e,t,n),D("defaultValue",e,t,n));return[r,s,o,a]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=y2.sparseReshape(D("inputIndices",e,t,n),D("inputShape",e,t,n),D("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[y2.sparseSegmentMean(D("data",e,t,n),D("indices",e,t,n),D("segmentIds",e,t,n))];case"SparseSegmentSum":return[y2.sparseSegmentSum(D("data",e,t,n),D("indices",e,t,n),D("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var AY=(e,t,n)=>{switch(e.op){case"FFT":return[fm(D("x",e,t,n))];case"IFFT":return[hd(D("x",e,t,n))];case"RFFT":return[d2(D("x",e,t,n))];case"IRFFT":return[p2(D("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var vY=(e,t,n)=>{switch(e.op){case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=q3.stringNGrams(D("data",e,t,n),D("dataSplits",e,t,n),D("separator",e,t,n),D("nGramWidths",e,t,n),D("leftPad",e,t,n),D("rightPad",e,t,n),D("padWidth",e,t,n),D("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:o}=q3.stringSplit(D("input",e,t,n),D("delimiter",e,t,n),D("skipEmpty",e,t,n));return[r,s,o]}case"StringToHashBucketFast":return[q3.stringToHashBucketFast(D("input",e,t,n),D("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var wY=(e,t,n)=>{switch(e.op){case"Cast":return[we(D("x",e,t,n),D("dtype",e,t,n))];case"ExpandDims":{let r=D("axis",e,t,n);return[Mr(D("x",e,t,n),r)]}case"Squeeze":{let r=D("axis",e,t,n);return[ro(D("x",e,t,n),r)]}case"Reshape":return[X(D("x",e,t,n),D("shape",e,t,n))];case"MirrorPad":return[r2(D("x",e,t,n),D("padding",e,t,n),D("mode",e,t,n))];case"PadV2":case"Pad":return[zi(D("x",e,t,n),D("padding",e,t,n),D("constantValue",e,t,n))];case"SpaceToBatchND":{let r=D("blockShape",e,t,n),s=D("paddings",e,t,n);return[ac(D("x",e,t,n),r,s)]}case"BatchToSpaceND":{let r=D("blockShape",e,t,n),s=D("crops",e,t,n);return[Ju(D("x",e,t,n),r,s)]}case"DepthToSpace":{let r=D("blockSize",e,t,n),s=D("dataFormat",e,t,n).toUpperCase();return[KA(D("x",e,t,n),r,s)]}case"BroadcastTo":return[Qu(D("x",e,t,n),D("shape",e,t,n))];case"BroadcastArgs":return[yD(D("s0",e,t,n),D("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function w6(e,t,n,r){let s=((o,a,i)=>{switch(o.category){case"arithmetic":return le(()=>JZ(o,a,i));case"basic_math":return le(()=>QZ(o,a,i));case"control":return oY(o,a,i);case"convolution":return le(()=>iY(o,a,i));case"creation":return le(()=>lY(o,a,i));case"dynamic":return uY(o,a,i);case"evaluation":return le(()=>cY(o,a,i));case"image":return le(()=>fY(o,a,i));case"graph":return le(()=>pY(o,a,i));case"logical":return le(()=>hY(o,a,i));case"matrices":return le(()=>mY(o,a,i));case"normalization":return le(()=>gY(o,a,i));case"reduction":return le(()=>xY(o,a,i));case"slice_join":return le(()=>yY(o,a,i));case"sparse":return le(()=>bY(o,a,i));case"spectral":return le(()=>AY(o,a,i));case"string":return le(()=>vY(o,a,i));case"transformation":return le(()=>wY(o,a,i));case"hash_table":return dY(o,a,i,r);case"custom":let l=$C(o.op);if(l&&l.customExecutor)return l.customExecutor(new y6(o,a,i));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return C.isPromise(s)?s.then(o=>[].concat(o)):[].concat(s)}var qC=class{constructor(t={},n={},r={},s={}){this.weightMap=t,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let n=0;n<this.contexts.length-1;n++){let r=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(t);for(let n in this.tensorListMap)this.tensorListMap[n].clearAndClose(t)}};function k6(e,t,n,r){let s=new Set,o=[],a=null,i=null,l=new Set,u=Object.keys(e).map(d=>po(d)[0]),c=[];r!=null&&(c=r.map(d=>po(d.name)[0]));let p=[...t];for(;p.length>0;){let d=p.pop();if((I6(d)||CUe(d)||SUe(d))&&a==null&&(a=d,i=a.children.map(f=>f.name).filter(f=>s.has(f))),s.add(d.name),n[d.name]==null&&u.indexOf(d.name)===-1&&c.indexOf(d.name)===-1){if(d.inputs.length===0){o.push(d.name);continue}d.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),p.push(f))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:o,dynamicNode:a,syncInputs:i}}function kY(e,t,n){let{usedNodes:r,inputs:s}=n,o=[],a=Object.keys(s).map(c=>po(c)[0]).map(c=>e.nodes[c]),i=e.initNodes;a.forEach(c=>{r.has(c.name)&&o.push(c)}),e.weights.forEach(c=>{r.has(c.name)&&o.push(c)}),i!=null&&i.forEach(c=>{r.has(c.name)&&o.push(c)});let l=new Set,u=[];for(;o.length>0;){let c=o.pop();l.add(c.name),t[c.name]||u.push(c),c.children.forEach(p=>{!l.has(p.name)&&r.has(p.name)&&p.inputs.every(d=>l.has(d.name))&&o.push(p)})}return u}var wUe=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],kUe=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],IUe=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function I6(e){return wUe.indexOf(e.op)>=0}function CUe(e){return kUe.indexOf(e.op)>=0}function SUe(e){return IUe.indexOf(e.op)>=0}var qy=class{constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new qy(t.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}getCompilationKey(t,n){let r=t.map(o=>o.name).sort(),s=n.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(t,n){let r=k6(t,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:a}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(s.length>0){let i=n.map(u=>u.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}return kY(this.graph,this.weightMap,r)}execute(t,n){t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let s=r.map(p=>this.graph.nodes[po(p)[0]]),o=n.map(p=>po(p)[0]),a=o.map(p=>this.graph.nodes[p]);a.length===0&&(a=this._outputs);let i=this.getCompilationKey(s,a),l=this.compiledMap.get(i);l==null&&(l=this.compile(t,a),this.compiledMap.set(i,l));let u={},c={};return le(()=>{let p=new qC(this.weightMap,u,c,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(t).forEach(m=>{let[g,x]=po(m),y=[];y[x]=t[m],d[g]=y});let f=this.getFrozenTensorIds(d),h={};for(let m=0;m<l.length;m++){let g=l[m];if(!d[g.name]){let x=w6(g,d,p,this._resourceManager);if(C.isPromise(x))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);d[g.name]=x,this.checkTensorForDisposal(g.name,g,d,p,f,o,h)}}return this.parent==null&&p.dispose(f),n.map(m=>Lr(m,d,p))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(t,n,r,s,o,a,i){n.category==="control"||a.indexOf(t)!==-1||(r[t].forEach(l=>{l!=null&&(i[l.id]=(i[l.id]||0)+n.children.length)}),n.inputs.forEach(l=>{if(l.category!=="control"){let u=KZ(l.name,r,s);u!=null&&u.forEach(c=>{if(c&&!c.kept&&!o.has(c.id)){let p=i[c.id];p===1?(c.dispose(),delete i[c.id]):p!=null&&i[c.id]--}})}}))}async executeAsync(t,n){return this._executeAsync(t,n)}async _executeAsync(t,n,r=!1,s={},o={}){r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));let a=new qC(this.weightMap,s,o,this.functionExecutorMap),i=await this.executeWithControlFlow(t,a,n,r),l=n.map(d=>Lr(d,i,a)),u=l.map(d=>d.id),c=Object.keys(t).map(d=>t[d].id),p=new Set([...u,...c,...this.weightIds]);return Object.keys(i).forEach(d=>{i[d].forEach(h=>{h&&!h.kept&&!h.isDisposed&&!p.has(h.id)&&h.dispose()})}),this.parent==null&&a.dispose(p),l}async executeFunctionAsync(t,n,r){let s=t.reduce((o,a,i)=>(o[this.inputs[i].name]=a,o),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,s){let o=Object.keys(t),a=o.map(b=>this.graph.nodes[po(b)[0]]),i=r.map(b=>po(b)[0]),l=i.map(b=>this.graph.nodes[b]);l.length===0&&(l=this._outputs);let{usedNodes:u,missingInputs:c,dynamicNode:p,syncInputs:d}=k6(t,l,this.weightMap,this._initNodes),f=[...a,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:n.currentContext})),h=Object.assign({},this.weightMap);Object.keys(t).forEach(b=>{let[A,v]=po(b),w=[];w[v]=t[b],h[A]=w});let m={},g=this.getFrozenTensorIds(h),x={};for(;f.length>0;){let b=this.processStack(a,f,n,h,x,g,i,m,u);await Promise.all(b)}p==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let y=l.filter(b=>!I6(b)&&!Lr(b.name,h,n)).map(b=>b.name);if(y.length>0){let b="";throw p!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${b}`)}return h}processStack(t,n,r,s,o,a,i,l,u){let c=[];for(;n.length>0;){let p=n.pop();r.currentContext=p.contexts;let d="";if(p.node.op==="Enter"&&D("isConstant",p.node,s,r)&&([d]=Ki(p.node.name,r)),s[p.node.name]==null){let f=w6(p.node,s,r,this._resourceManager);d||([d]=Ki(p.node.name,r));let h=r.currentContext;C.isPromise(f)?c.push(f.then(m=>(s[d]=m,r.currentContext=h,this.checkTensorForDisposal(d,p.node,s,r,a,i,l),this.processChildNodes(p.node,n,r,s,o,u),m))):(s[d]=f,this.checkTensorForDisposal(d,p.node,s,r,a,i,l),this.processChildNodes(p.node,n,r,s,o,u))}else this.processChildNodes(p.node,n,r,s,o,u)}return c}processChildNodes(t,n,r,s,o,a){t.children.forEach(i=>{let[l]=Ki(i.name,r);o[l]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(u=>!!Lr(u,s,r))&&(o[l]=!0,n.push({contexts:r.currentContext,node:i})):i.inputNames.every(u=>!!Lr(u,s,r))&&(o[l]=!0,n.push({contexts:r.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[s]=po(n),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){let a=o.attrParams.shape.value,i=a.length===r.shape.length&&r.shape.every((l,u)=>a[u]===-1||a[u]===l);C.assert(i,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${a}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&C.assert(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){let n={};for(let r in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){let s=this._signature.inputs[r];n[s.name]=t[r]}else n[r]=t[r];return n}checkInputs(t){let n=Object.keys(t).filter(r=>{let[s]=po(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[n]!=null?this._signature.outputs[n].name:n,{})}checkOutputs(t){t.forEach(n=>{let[r]=po(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}};var C6=class{constructor(t={},n={}){this.hashTableNameToHandle=t,this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}};var NUe="?tfjs-format=file",TUe="model.json",S6=class{constructor(t,n={}){this.modelUrl=t,this.loadOptions=n,this.version="n/a",n==null&&(this.loadOptions={}),this.resourceManager=new C6}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=na.browserHTTPRequest(t,this.loadOptions);else{let n=na.getLoadHandlers(t,this.loadOptions);if(n.length===0)n.push(na.browserHTTPRequest(t,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`);this.handler=n[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;let n=this.artifacts.modelTopology,r;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?r=this.artifacts.userDefinedMetadata.signature:r=this.artifacts.signature,this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;let s=na.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new qy(OC.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let o=OC.Instance.transformGraph(t.modelInitializer);this.initializer=new qy(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,n){if(typeof t=="string"){let r=na.getSaveHandlers(t);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${t}'`);t=r[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,n){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof Ot)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((n,r,s)=>(n[r]=t[s],n),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,n){t=this.normalizeInputs(t),n=this.normalizeOutputs(n);let r=this.executor.execute(t,n);return r.length>1?r:r[0]}async executeAsync(t,n){t=this.normalizeInputs(t),n=this.normalizeOutputs(n);let r=await this.executor.executeAsync(t,n);return r.length>1?r:r[0]}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,r)=>(n[r]=[t[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function KC(e,t={}){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&e.load==null&&(e.endsWith("/")||(e=e+"/"),e=`${e}${TUe}${NUe}`);let n=new S6(e,t);return await n.load(),n}var aJ=T1($6());var HY=T1($6());function BY(e,t){return VY(e,t)}function VY(e,t,n=new Map,r=new Set){if(e==null)return null;if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(Ky(e)){let o=Array.isArray(e)?[]:{};r.add(e);for(let a in e){let i=e[a],l=VY(i,t,n,r);o[a]=l}return r.delete(e),o}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,s.value),s.value}function WY(e,t=F6){return GY(e,t)}function GY(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(Ky(r)){let o=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let i=e.map(u=>u[a]),l=GY(i,t,n);o[a]=l}return n.delete(r),o}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function F6(e){return e===null?null:Ky(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function Ky(e){let t=!1;if(he().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=LY();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Ot)&&!(e instanceof Promise)&&!t)}function UY(e){return e==null||PUe(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Ot||C.isTypedArray(e)}function PUe(e){return e===null||typeof e!="object"&&typeof e!="function"}function jY(e){return BY(e,MUe)}function MUe(e){return e instanceof Ot?{value:e.clone(),recurse:!1}:Ky(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var Q2=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,n){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=n}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let n of t)this.push(n)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let n=this.wrap(this.begin+t),r=this.get(n);return this.set(n,this.pop()),r}};var Xy=class extends Q2{constructor(){super(Xy.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),r=this.length();for(let s=0;s<r;s++)n[s]=this.get(this.wrap(this.begin+s));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};Xy.INITIAL_CAPACITY=32;function qY(e){return new XY(e)}function O6(e){return new ZY(e)}function KY(e,t){return new M6(e,t)}var _s=class{async toArray(){let t=[],n=await this.next();for(;!n.done;)t.push(n.value),n=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),n=[],r=await t.next();for(;!r.done;)n.push(r.value),r=await t.next();return n}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let n=await this.next(),r=t(n.value);for(;!n.done&&r;)n=await this.next(),r=t(n.value)}handleErrors(t){return new rJ(this,t)}filter(t){return new tJ(this,t)}map(t){return new nJ(this,t)}mapAsync(t){return new P6(this,t)}serialMapAsync(t){return new P6(this,t).serial()}flatmap(t){return new sJ(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(n=>n===!0)}rowMajorBatch(t,n=!0){return new eJ(this,t,n)}columnMajorBatch(t,n=!0,r=F6){return this.rowMajorBatch(t,n).map(o=>WY(o,r))}concatenate(t,n){return new M6(qY([this,t]),n)}take(t){return t<0||t==null?this:new QY(this,t)}skip(t){return t<0||t==null?this:new JY(this,t)}prefetch(t){return new L6(this,t)}shuffle(t,n){return new oJ(this,t,n)}serial(){return new YY(this)}},XY=class extends _s{constructor(t){super();this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:jY(t),done:!1}}},ZY=class extends _s{constructor(t){super();this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},YY=class extends _s{constructor(t){super();this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},JY=class extends _s{constructor(t,n){super();this.upstream=t,this.maxCount=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;ut(t.value)}return this.upstream.next()}},QY=class extends _s{constructor(t,n){super();this.upstream=t,this.maxCount=n,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},eJ=class extends _s{constructor(t,n,r=!0){super();this.upstream=t,this.batchSize=n,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}}},tJ=class extends _s{constructor(t,n){super();this.upstream=t,this.predicate=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;ut(t.value)}}},nJ=class extends _s{constructor(t,n){super();this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let n=Ha.getTensorsInContainer(t.value),r=this.transform(t.value),s=Ha.getTensorsInContainer(r);for(let o of n)Ha.isTensorInList(o,s)||o.dispose();return{value:r,done:!1}}},rJ=class extends _s{constructor(t,n){super();this.upstream=t,this.handler=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},P6=class extends _s{constructor(t,n){super();this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let n=Ha.getTensorsInContainer(t.value),r=await this.transform(t.value),s=Ha.getTensorsInContainer(r);for(let o of n)Ha.isTensorInList(o,s)||o.dispose();return{value:r,done:!1}}},ZC=class extends _s{constructor(){super();this.outputQueue=new Xy,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},sJ=class extends ZC{constructor(t,n){super();this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let n=Ha.getTensorsInContainer(t.value),r=this.transform(t.value),s=Ha.getTensorsInContainer(r);this.outputQueue.pushAll(r);for(let o of n)Ha.isTensorInList(o,s)||o.dispose();return!0}},M6=class extends _s{constructor(t,n){super();this.baseErrorHandler=n,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(t)):n}},z6;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(z6||(z6={}));var L6=class extends _s{constructor(t,n){super();this.upstream=t,this.bufferSize=n,this.buffer=new Q2(n)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},oJ=class extends L6{constructor(t,n,r){super(t,n);this.upstream=t,this.windowSize=n,this.upstreamExhausted=!1,this.random=HY.alea(r||C.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),n=await this.buffer.shuffleExcise(t);if(n.done)this.upstreamExhausted=!0;else return this.refill(),n}return{value:null,done:!0}}};var Zy=class{constructor(){this.size=null}batch(t,n=!0){let r=this;C.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let s;return this.size===1/0||this.size==null?s=this.size:n?s=Math.ceil(this.size/t):s=Math.floor(this.size/t),Zi(async()=>(await r.iterator()).columnMajorBatch(t,n,LUe),s)}concatenate(t){let n=this,r;return this.size===1/0||t.size===1/0?r=1/0:this.size!=null&&t.size!=null?r=this.size+t.size:r=null,Zi(async()=>(await n.iterator()).concatenate(await t.iterator()),r)}filter(t){let n=this,r;return this.size===1/0?r=1/0:r=null,Zi(async()=>(await n.iterator()).filter(s=>le(()=>t(s))),r)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let n=this;return Zi(async()=>(await n.iterator()).map(r=>le(()=>t(r))),this.size)}mapAsync(t){let n=this;return Zi(async()=>(await n.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let n=this;return Zi(async()=>(await n.iterator()).prefetch(t),this.size)}repeat(t){let n=this,r;return this.size!=null&&t>0?r=this.size*t:t===0?r=0:this.size!=null&&(t===void 0||t<0)?r=1/0:r=null,Zi(async()=>{let s=O6(async()=>({value:await n.iterator(),done:!1}));return KY(s.take(t))},r)}skip(t){let n=this,r;return this.size!=null&&t>=0&&this.size>=t?r=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?r=0:r=null,Zi(async()=>(await n.iterator()).skip(t),r)}shuffle(t,n,r=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let s=this,o=aJ.alea(n||C.now().toString());return Zi(async()=>{let a=o.int32();return r&&(a+=o.int32()),(await s.iterator()).shuffle(t,a.toString())},this.size)}take(t){let n=this,r;return this.size!=null&&this.size>t?r=t:this.size!=null&&this.size<=t?r=this.size:r=null,Zi(async()=>(await n.iterator()).take(t),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Zy.MAX_BUFFER_SIZE=1e4;function Zi(e,t=null){return new class extends Zy{constructor(){super(...arguments);this.size=t}async iterator(){return e()}}}function LUe(e){if(e===null)return null;let t=e[0];return UY(t)?{value:BUe(e),recurse:!1}:{value:null,recurse:!0}}function BUe(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Ot?or(e):Zs(e)}var Qen=Symbol("out"),etn=Symbol("field"),ttn=Symbol("quote"),ntn=Symbol("quoteafterquote"),rtn=Symbol("quoteinquote");function Se(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&C.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var ZUe=Ts.whereImpl,Yy=class extends up{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new ux(this,Zu())}nextDataId(){return Yy.nextDataId++}write(t,n,r){this.firstUse&&(this.firstUse=!1,he().get("IS_NODE")&&M.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&C.isString(r[0])){let o=r.map(a=>C.encodeString(a));s=this.write(o,t,n)}else s=this.write(r,t,n);return{dataId:s,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,r,s,o){this.data.set(t,{values:n,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){let s=this.readSync(r.real.dataId),o=this.readSync(r.imag.dataId);return M.mergeRealAndImagArrays(s,o)}return this.data.get(t).values}bufferSync(t){let n=this.readSync(t.dataId),r=n;if(t.dtype==="string")try{r=n.map(s=>C.decodeString(s))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return et(t.shape,t.dtype,r)}makeOutput(t,n,r){let s=this.write(t,n,r);return Zu().makeTensorFromDataId(s,n,r,this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=C.now();return t(),{kernelMs:C.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Se([t],"where");let n=this.readSync(t.dataId);return ZUe(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};Yy.nextDataId=0;var cF={};dn(cF,{addImpl:()=>V6,bincountImpl:()=>e1,bincountReduceImpl:()=>YC,ceilImpl:()=>W6,concatImpl:()=>JC,equalImpl:()=>G6,expImpl:()=>j6,expm1Impl:()=>q6,floorImpl:()=>K6,gatherNdImpl:()=>QC,gatherV2Impl:()=>eS,greaterEqualImpl:()=>Z6,greaterImpl:()=>X6,lessEqualImpl:()=>J6,lessImpl:()=>Y6,linSpaceImpl:()=>tS,logImpl:()=>Q6,maxImpl:()=>nS,maximumImpl:()=>eF,minimumImpl:()=>tF,multiplyImpl:()=>ev,negImpl:()=>nF,notEqualImpl:()=>rF,prodImpl:()=>sF,rangeImpl:()=>rS,rsqrtImpl:()=>oF,sigmoidImpl:()=>RJ,simpleAbsImpl:()=>B6,sliceImpl:()=>iF,sparseFillEmptyRowsImpl:()=>sS,sparseReshapeImpl:()=>oS,sparseSegmentReductionImpl:()=>n1,sqrtImpl:()=>FJ,squaredDifferenceImpl:()=>lF,stridedSliceImpl:()=>aS,stringNGramsImpl:()=>iS,stringSplitImpl:()=>lS,stringToHashBucketFastImpl:()=>uS,subImpl:()=>uF,tileImpl:()=>cS,topKImpl:()=>pS,transposeImpl:()=>t1,uniqueImpl:()=>dS});function B6(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var YUe=e=>{let{x:t}=e.inputs,n=e.backend;Se(t,"abs");let r=new Float32Array(C.sizeFromShape(t.shape)),s=n.data.get(t.dataId).values;return r=B6(s),n.makeOutput(r,t.shape,"float32")},iJ={kernelName:pp,backendName:"cpu",kernelFunc:YUe};function Pt(e){return(t,n,r,s,o)=>{let a=M.assertAndGetBroadcastShape(t,n),i=a.length,l=C.computeStrides(a),u=C.sizeFromShape(a),c=C.getTypedArrayFromDType(o,u),p=t.length,d=n.length,f=C.computeStrides(t),h=C.computeStrides(n),m=M.getBroadcastDims(t,a),g=M.getBroadcastDims(n,a);if(m.length+g.length===0)for(let x=0;x<c.length;++x)c[x]=e(r[x%r.length],s[x%s.length]);else for(let x=0;x<c.length;++x){let y=C.indexToLoc(x,i,l),b=y.slice(-p);m.forEach(k=>b[k]=0);let A=C.locToIndex(b,p,f),v=y.slice(-d);g.forEach(k=>v[k]=0);let w=C.locToIndex(v,d,h);c[x]=e(r[A],s[w])}return[c,a]}}function Br(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,i=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(i.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",o),imag:n.makeTensorInfo(s.shape,"float32",a)},i}var lJ={kernelName:vx,backendName:"cpu",kernelFunc:Br};function Jy(e,t,n="float32"){if(n==="complex64"){let s=Jy(e,t,"float32"),o=Jy(e,t,"float32");return Br({inputs:{real:s,imag:o},backend:e})}let r=C.makeZerosTypedArray(C.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function Es(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var uJ={kernelName:Al,backendName:"cpu",kernelFunc:Es};function oi(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}var cJ={kernelName:Xx,backendName:"cpu",kernelFunc:oi};function ai(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return Es({inputs:{x:s},backend:n});let a=Jy(n,s.shape,s.dtype),i=ai({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Br({inputs:{real:i,imag:a},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}if(s.dtype==="complex64"){let a=oi({inputs:{input:s},backend:n}),i=ai({inputs:{x:a},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(a),i}if(!C.hasEncodingLoss(s.dtype,o)){let a=Es({inputs:{x:s},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32"){let a=n.data.get(s.dataId).values,i=Int32Array.from(a);return n.makeTensorInfo(s.shape,"int32",i)}if(o==="bool"){let a=n.data.get(s.dataId).values,i=C.toTypedArray([0],s.dtype),[l,u]=Pt((c,p)=>c!==p?1:0)(s.shape,[],a,i,"bool");return n.makeTensorInfo(u,"bool",l)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}var pJ={kernelName:bl,backendName:"cpu",kernelFunc:ai};function Ht(e,t,n,r){return n==null?({inputs:s,backend:o})=>{let{a,b:i}=s,l=o;Se([a,i],e);let u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,p=a.dtype==="string"?M.fromUint8ToStringArray(u):u,d=a.dtype==="string"?M.fromUint8ToStringArray(c):c,f=r||a.dtype,[h,m]=t(a.shape,i.shape,p,d,f);return l.makeTensorInfo(m,f,h)}:({inputs:s,backend:o})=>{let{a,b:i}=s,l=o;if(a.dtype==="complex64"||i.dtype==="complex64"){let u=ai({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),p=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,f=l.data.get(p.dataId).values,h=l.data.get(d.dataId).values,m=ai({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),x=g.complexTensorInfos.real,y=g.complexTensorInfos.imag,b=l.data.get(x.dataId).values,A=l.data.get(y.dataId).values,[v,w,k]=n(a.shape,i.shape,f,h,b,A),I=l.makeTensorInfo(k,"float32",v),N=l.makeTensorInfo(k,"float32",w),T=Br({inputs:{real:I,imag:N},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(N),T}else{let u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,p=r||a.dtype,[d,f]=t(a.shape,i.shape,u,c,p);return l.makeTensorInfo(f,p,d)}}}function Qy(e){return(t,n,r,s,o,a)=>{let i=M.assertAndGetBroadcastShape(t,n),l=C.sizeFromShape(i),u=i.length,c=C.computeStrides(i),p=C.getTypedArrayFromDType("float32",l),d=C.getTypedArrayFromDType("float32",l),f=M.getBroadcastDims(t,i),h=M.getBroadcastDims(n,i),m=M.mergeRealAndImagArrays(r,s),g=M.mergeRealAndImagArrays(o,a),x=t.length,y=C.computeStrides(t),b=n.length,A=C.computeStrides(n);if(f.length+h.length===0)for(let v=0;v<p.length;v++){let w=v%m.length,k=v%g.length,I=e(m[w*2],m[w*2+1],g[k*2],g[k*2+1]);p[v]=I.real,d[v]=I.imag}else for(let v=0;v<p.length;v++){let w=C.indexToLoc(v,u,c),k=w.slice(-x);f.forEach(R=>k[R]=0);let I=C.locToIndex(k,x,y),N=w.slice(-b);h.forEach(R=>N[R]=0);let T=C.locToIndex(N,b,A),_=e(m[I*2],m[I*2+1],g[T*2],g[T*2+1]);p[v]=_.real,d[v]=_.imag}return[p,d,i]}}var V6=Pt((e,t)=>e+t),JUe=Qy((e,t,n,r)=>({real:e+n,imag:t+r})),xc=Ht(Ri,V6,JUe),dJ={kernelName:Ri,backendName:"cpu",kernelFunc:xc};function e1(e,t,n,r,s){let o=C.sizeFromShape(r),a=C.makeZerosTypedArray(s,n);for(let i=0;i<e.length;i++){let l=e[i];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o>0?a[l]+=t[i]:a[l]+=1)}return a}function YC(e,t,n,r=!1){let s=e.shape[0],o=e.shape[1],a=et([s,n],t.dtype);for(let i=0;i<s;i++)for(let l=0;l<o;l++){let u=e.get(i,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?a.set(1,i,u):t.size>0?a.set(a.get(i,u)+t.get(i,l),i,u):a.set(a.get(i,u)+1,i,u))}return a}function fo(e){return(t,n,r)=>{let s=C.getTypedArrayFromDType(n,t.length);for(let o=0;o<t.length;++o)s[o]=e(t[o],r);return s}}function pt(e,t,n){return({inputs:r,attrs:s,backend:o})=>{let{x:a}=r;if(Se(a,e),a.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=o,l=i.data.get(a.dataId).values,u=C.sizeFromShape(a.shape),c=n||a.dtype,p=C.getArrayFromDType(c,u);for(let d=0;d<u;++d)p[d]=t(l[d],s);return i.makeTensorInfo(a.shape,c,p)}}function ii(e,t,n){return({inputs:r,attrs:s,backend:o})=>{let{x:a}=r;if(Se(a,e),a.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=o,l=i.data.get(a.dataId).values,u=n||a.dtype,c=t(l,u,s);return i.makeTensorInfo(a.shape,u,c)}}var W6=fo(e=>Math.ceil(e)),QUe=ii(iu,W6),fJ={kernelName:iu,backendName:"cpu",kernelFunc:QUe};function JC(e,t,n,r){let s=C.getArrayFromDType(n,C.sizeFromShape(t));if(r&&n!=="string"){let o=0;e.forEach(a=>{let i=C.sizeFromShape(a.shape);s.set(a.vals,o),o+=i})}else{let o=0;e.forEach(a=>{let i=n==="string"?M.fromUint8ToStringArray(a.vals):a.vals,l=0;for(let u=0;u<a.shape[0];++u){let c=u*t[1]+o;for(let p=0;p<a.shape[1];++p)s[c+p]=i[l++]}o+=a.shape[1]})}return s}var G6=Pt((e,t)=>e===t?1:0),U6=Ht(Ch,G6,null,"bool"),hJ={kernelName:Ch,backendName:"cpu",kernelFunc:U6};var j6=fo(e=>Math.exp(e)),H6=ii(hu,j6),mJ={kernelName:hu,backendName:"cpu",kernelFunc:H6};var q6=fo(e=>Math.expm1(e)),eje=ii(mu,q6),gJ={kernelName:mu,backendName:"cpu",kernelFunc:eje};var K6=fo(e=>Math.floor(e)),tje=ii(gu,K6),xJ={kernelName:gu,backendName:"cpu",kernelFunc:tje};function QC(e,t,n,r,s,o,a,i,l){let u=et([r,o],n);for(let c=0;c<r;c++){let p=[],d=0;for(let f=0;f<s;f++){let h=e[c*s+f];d+=h*a[f],p.push(h)}if(d<0||d>=l/o)throw new Error(`Invalid indices: ${p} does not index into ${i}`);for(let f=0;f<o;f++)u.values[c*o+f]=t.get(...t.indexToLoc(d*o+f))}return u}function eS(e,t,n){let r=et(n,e.dtype);for(let s=0;s<r.size;++s){let a=r.indexToLoc(s).slice(),i=a[0],l=a[2],u=t.locToIndex([i,l]);a[2]=t.values[u];let c=e.locToIndex(a);r.values[s]=e.values[c]}return r}var X6=Pt((e,t)=>e>t?1:0),nje=Ht(Sh,X6,null,"bool"),yJ={kernelName:Sh,backendName:"cpu",kernelFunc:nje};var Z6=Pt((e,t)=>e>=t?1:0),rje=Ht(yu,Z6,null,"bool"),bJ={kernelName:yu,backendName:"cpu",kernelFunc:rje};var Y6=Pt((e,t)=>e<t?1:0),sje=Ht(Nh,Y6,null,"bool"),AJ={kernelName:Nh,backendName:"cpu",kernelFunc:sje};var J6=Pt((e,t)=>e<=t?1:0),oje=Ht(Th,J6,null,"bool"),vJ={kernelName:Th,backendName:"cpu",kernelFunc:oje};function tS(e,t,n){let r=(t-e)/(n-1),s=C.makeZerosTypedArray(n,"float32");s[0]=e;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}var Q6=fo(e=>Math.log(e)),aje=ii(wu,Q6),wJ={kernelName:wu,backendName:"cpu",kernelFunc:aje};function nS(e,t,n,r){let s=C.getTypedArrayFromDType(r,C.sizeFromShape(n));for(let o=0;o<s.length;++o){let a=o*t,i=e[a];for(let l=0;l<t;++l){let u=e[a+l];(Number.isNaN(u)||u>i)&&(i=u)}s[o]=i}return s}var eF=Pt((e,t)=>Math.max(e,t)),ije=Ht(Iu,eF),kJ={kernelName:Iu,backendName:"cpu",kernelFunc:ije};var tF=Pt((e,t)=>Math.min(e,t)),lje=Ht(Cu,tF),IJ={kernelName:Cu,backendName:"cpu",kernelFunc:lje};var ev=Pt((e,t)=>e*t),uje=Qy((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),Om=Ht(Nu,ev,uje),CJ={kernelName:Nu,backendName:"cpu",kernelFunc:Om};function nF(e,t,n){let r=C.createScalarValue(-1,n);return ev([],t,r,e,n)}function cje(e){let{inputs:t,backend:n}=e,{x:r}=t;Se(r,"neg");let s=n.data.get(r.dataId).values,[o,a]=nF(s,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,o)}var SJ={kernelName:zp,backendName:"cpu",kernelFunc:cje};var rF=Pt((e,t)=>e!==t?1:0),pje=Ht(Dh,rF,null,"bool"),NJ={kernelName:Dh,backendName:"cpu",kernelFunc:pje};function t1(e,t,n,r,s){let o=t.length,a=C.sizeFromShape(t),i=C.computeStrides(t),l=C.computeStrides(s),u=C.getTypedArrayFromDType(n,C.sizeFromShape(s));for(let c=0;c<a;++c){let p=C.indexToLoc(c,o,i),d=new Array(p.length);for(let h=0;h<d.length;h++)d[h]=p[r[h]];let f=C.locToIndex(d,o,l);u[f]=e[c]}return u}function dr(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:o}=n;Se(s,"transpose");let a=s.shape.length,i=new Array(a);for(let p=0;p<i.length;p++)i[p]=s.shape[o[p]];let l=r.data.get(s.dataId).values,u=t1(l,s.shape,s.dtype,o,i);return{dataId:r.write(u,i,s.dtype),shape:i,dtype:s.dtype}}var TJ={kernelName:ed,backendName:"cpu",kernelFunc:dr};function sF(e,t,n,r){let[s,o]=M.computeOutAndReduceShapes(e,r),a=Or(t,"int32"),i=C.makeZerosTypedArray(C.sizeFromShape(s),a),l=C.sizeFromShape(o);for(let u=0;u<i.length;++u){let c=u*l,p=1;for(let d=0;d<l;++d)p*=n[c+d];i[u]=p}return{outVals:i,outShape:s,outDtype:a}}function dje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;Se(s,"prod");let i=s.shape.length,l=C.parseAxisParam(o,s.shape),u=M.getAxesPermutation(l,i),c=l,p=s,d=[];u!=null&&(p=dr({inputs:{x:s},backend:n,attrs:{perm:u}}),d.push(p),c=M.getInnerMostAxes(c.length,i));let f=n.data.get(p.dataId).values,{outVals:h,outShape:m,outDtype:g}=sF(p.shape,p.dtype,f,c),x=m;return a&&(x=M.expandShapeToKeepDim(m,l)),d.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(x,g,h)}var _J={kernelName:qx,backendName:"cpu",kernelFunc:dje};function rS(e,t,n,r){let s=e===t,o=e<t&&n<0,a=t<e&&n>1;if(s||o||a)return C.makeZerosTypedArray(0,r);let i=Math.abs(Math.ceil((t-e)/n)),l=C.makeZerosTypedArray(i,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var oF=fo(e=>1/Math.sqrt(e)),fje=ii($u,oF),EJ={kernelName:$u,backendName:"cpu",kernelFunc:fje};var RJ=fo(e=>1/(1+Math.exp(-e))),aF=pt(zu,e=>1/(1+Math.exp(-e))),DJ={kernelName:zu,backendName:"cpu",kernelFunc:aF};function iF(e,t,n,r,s){let o=Cs.isSliceContinous(r,t,n),a=C.sizeFromShape(n),i=C.computeStrides(r);if(o){let p=Cs.computeFlatOffset(t,i);return s==="string"?e.slice(p,p+a):e.subarray(p,p+a)}let l=s==="string"?M.fromUint8ToStringArray(e):e,u=et(r,s,l),c=et(n,s);for(let p=0;p<c.size;++p){let d=c.indexToLoc(p),f=d.map((h,m)=>h+t[m]);c.set(u.get(...f),...d)}return s==="string"?M.fromStringArrayToUint8(c.values):c.values}function li(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,size:a}=r;Se(s,"slice");let[i,l]=Cs.parseSliceParams(s,o,a);Cs.assertParamsValid(s,i,l);let u=n.data.get(s.dataId).values,c=iF(u,i,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}var $J={kernelName:Xp,backendName:"cpu",kernelFunc:li};function sS(e,t,n,r,s,o,a){let i=t[0],l=o[0],u=new Array(l),c=new Array(i),p=t[1];if(l===0){if(i!==0)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${i}`);let g=C.getArrayFromDType(n,0),x=C.getArrayFromDType(s,0);return[g,[0,p],x,u,c]}let d=!0,f=0,h=new Array(l).fill(0);for(let g=0;g<i;++g){let x=e[g*p];if(x<0)throw new Error(`indices(${g}, 0) is invalid: ${x} < 0`);if(x>=l)throw new Error(`indices(${g}, 0) is invalid: ${x} >= ${l}`);++h[x],d=d&&x>=f,f=x}let m=!0;for(let g=0;g<l;++g){let x=h[g]===0;u[g]=x,m=m&&!x,h[g]=Math.max(h[g],1),g>0&&(h[g]+=h[g-1])}if(m&&d){let g=e,x=r;for(let y=0;y<i;++y)c[y]=y;return[g,[i,p],x,u,c]}else{let g=h[l-1],x=C.getArrayFromDType(n,g*p),y=C.getArrayFromDType(s,g),b=new Array(l).fill(0);for(let A=0;A<i;++A){let v=e[A*p],w=b[v],k=(v===0?0:h[v-1])+w;b[v]++;for(let I=0;I<p;++I)x[k*p+I]=e[A*p+I];y[k]=r[A],c[A]=k}for(let A=0;A<l;++A)if(b[A]===0){let w=A===0?0:h[A-1];x[w*p+0]=A;for(let k=1;k<p;++k)x[w*p+k]=0;y[w]=a}return[x,[g,p],y,u,c]}}function oS(e,t,n,r,s){let o=C.sizeFromShape(r),a=t[0],i=s.length,l=[],u=1,c=-1;for(let g=0;g<i;++g){let x=s[g];if(x===-1){if(c!==-1)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,l.push(1)}else{if(x<0)throw new Error(`size ${g} must be non-negative, not ${x}`);u*=x,l.push(x)}}if(c!==-1){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");let g=Math.trunc(o/u);if(u*g!==o)throw new Error(`Input to reshape is a SparseTensor with ${o}
          dense values, but the requested shape requires a multiple of ${u}. inputShape=${r} outputShape= ${l}`);l[c]=g}let p=C.sizeFromShape(l);if(p!==o)throw new Error(`Input to reshape is a tensor with ${o} dense values, but the requested shape has ${p}. inputShape=${r} outputShape=${l}`);let d=r.length,f=[];if(d>0){f[d-1]=1;for(let g=d-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}let h=[];if(i>0){h[i-1]=1;for(let g=i-2;g>=0;--g)h[g]=h[g+1]*l[g+1]}let m=C.getArrayFromDType(n,a*i);for(let g=0;g<a;++g){let x=0;for(let y=0;y<d;++y)x+=e[g*d+y]*f[y];for(let y=0;y<i;++y)m[g*i+y]=Math.trunc(x/h[y]),x%=h[y]}return[m,[a,i],l]}function n1(e,t,n,r,s,o=!1,a=0){let i=r.length;if(i!==s.length)throw new Error("segmentIds and indices should have same size.");let l=[t[0],e.length/t[0]],u=l[1],p=i>0?s[i-1]+1:0;if(p<0)throw new Error("segment ids must be >= 0");let d=t.slice();d[0]=p;let f=d.reduce((b,A)=>b*A,1),h=C.getArrayFromDType(n,f);if(i===0)return p>0&&h.fill(a),[h,d];if(p<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,x=0,y=s[m];for(;;){let b=0;if(g<i){if(b=s[g],y===b){++g;continue}if(y>=b)throw new Error("segment ids are not increasing")}if(y<0||y>=p)throw new Error(`Segment id ${y} out of range [0, ${p}), possibly because segmentIds input is not sorted.`);y>x&&h.fill(a,x*u,y*u);for(let A=m;A<g;++A){let v=r[A];if(v<0||v>=l[0])throw new Error(`Bad: indices[${A}] == ${r[A]} out of range [0, ${l[0]})`);for(let w=0;w<u;w++)h[y*u+w]+=e[v*u+w]}if(o)for(let A=0;A<u;A++)h[y*u+A]/=g-m;if(m=g,++g,x=y+1,y=b,g>i)break}return x<p&&h.fill(a,x*u,p*u),[h,d]}var FJ=fo(e=>Math.sqrt(e)),hje=pt(Bu,e=>Math.sqrt(e)),OJ={kernelName:Bu,backendName:"cpu",kernelFunc:hje};var lF=Pt((e,t)=>{let n=e-t;return n*n}),mje=Ht(Vu,lF),PJ={kernelName:Vu,backendName:"cpu",kernelFunc:mje};function aS(e,t,n,r){let s=et(e,t.dtype);for(let o=0;o<s.size;o++){let a=s.indexToLoc(o),i=new Array(a.length);for(let l=0;l<i.length;l++)i[l]=a[l]*n[l]+r[l];s.set(t.get(...i),...a)}return s}var MJ=class{constructor(t,n,r,s,o,a){this.separator=C.encodeString(t),this.nGramWidths=n,this.leftPad=C.encodeString(r),this.rightPad=C.encodeString(s),this.padWidth=o,this.preserveShort=a}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){let r=this.getPadWidth(n);return Math.max(0,t+2*r-n+1)}createNGrams(t,n,r,s,o,a){for(let i=0;i<o;++i){let l=this.getPadWidth(a),u=Math.max(0,l-i),c=Math.max(0,l-(o-(i+1))),p=a-(u+c),d=n+(u>0?0:i-l),f=0;f+=u*this.leftPad.length;for(let y=0;y<p;++y)f+=t[d+y].length;f+=c*this.rightPad.length,f+=(u+c+p-1)*this.separator.length,r[s+i]=new Uint8Array(f);let m=r[s+i],g=0,x=y=>y.forEach(b=>m[g++]=b);for(let y=0;y<u;++y)x(this.leftPad),x(this.separator);for(let y=0;y<p-1;++y)x(t[d+y]),x(this.separator);if(p>0){x(t[d+p-1]);for(let y=0;y<c;++y)x(this.separator),x(this.rightPad)}else{for(let y=0;y<c-1;++y)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(t,n){let r=t.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=n[u]>=l;if(c=c&&n[u]<=r,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${r}]`);l=n[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}let o=s-1,a=C.getArrayFromDType("int32",s);if(r===0||s===0){let l=new Array(r);for(let u=0;u<=o;++u)a[u]=0;return[l,a]}a[0]=0;for(let l=1;l<=o;++l){let u=n[l]-n[l-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(u,p)}),this.preserveShort&&u>0&&c===0&&(c=1),a[l]=a[l-1]+c}let i=new Array(a[o]);for(let l=0;l<o;++l){let u=n[l],c=a[l];if(this.nGramWidths.forEach(p=>{let d=n[l+1]-n[l],f=this.getNumNGrams(d,p);this.createNGrams(t,u,i,c,f,p),c+=f}),this.preserveShort&&c===a[l]){let p=n[l+1]-n[l];if(p===0)continue;let d=p+2*this.padWidth,f=1;this.createNGrams(t,u,i,c,f,d)}}return[i,a]}};function iS(e,t,n,r,s,o,a,i){return new MJ(n,r,s,o,a,i).compute(e,t)}function gje(e,t,n,r){if(!e.length)return;if(t.length===0){for(let o=0;o<e.length;++o)r.push(e.subarray(o,o+1));return}if(t.length===1){let o=t[0],a=e.indexOf(o);for(;a!==-1;){let i=e.subarray(0,a);(!n||i.length!==0)&&r.push(i),e=e.subarray(a+1),a=e.indexOf(o)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let o=0;o<e.length+1;o++)if(o===e.length||t.indexOf(e[o])!==-1){let a=e.subarray(s,o);(!n||a.length!==0)&&r.push(a),s=o+1}}function lS(e,t,n){let r=e.length,s=[],o=0,a=0,i=new Array(r);for(let d=0;d<r;++d){let f=s.length;gje(e[d],t,n,s);let h=s.length-f;i[d]=h,o+=h,a=Math.max(a,h)}let l=C.getArrayFromDType("int32",o*2),u=new Array(o),c=[r,a],p=0;for(let d=0;d<r;++d)for(let f=0;f<i[d];++f)l[p*2]=d,l[p*2+1]=f,u[p]=s[p],++p;return[l,u,c]}function uS(e,t){let n=C.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=C.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var uF=Pt((e,t)=>e-t),xje=Qy((e,t,n,r)=>({real:e-n,imag:t-r})),tv=Ht(Wu,uF,xje),zJ={kernelName:Wu,backendName:"cpu",kernelFunc:tv};function cS(e,t){let n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];let r=et(n,e.dtype);for(let s=0;s<r.values.length;++s){let o=r.indexToLoc(s),a=new Array(e.rank);for(let l=0;l<a.length;l++)a[l]=o[l]%e.shape[l];let i=e.locToIndex(a);r.values[s]=e.values[i]}return r}var nv=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function LJ(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let i=r-n+1,l=t-n+1,u=Math.log(i),c=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*c*(i-c)/i)*Math.sign(l-i/2),d=Math.max(n,Math.floor(t-l*c/i+p)),f=Math.min(r,Math.floor(t+(i-l)*c/i+p));LJ(e,t,d,f)}let s=e[t],o=n,a=r;for(C.swap(e,n,t),nv(e[r],s)>0&&C.swap(e,n,r);o<a;){for(C.swap(e,o,a),o++,a--;nv(e[o],s)<0;)o=o+1;for(;nv(e[a],s)>0;)a=a-1}nv(e[n],s)===0?C.swap(e,n,a):(a=a+1,C.swap(e,a,r)),a<=t&&(n=a+1),t<=a&&(r=a-1)}}function pS(e,t,n,r,s){let o=t[t.length-1],[a,i]=[e.length/o,o],l=C.getTypedArrayFromDType(n,a*r),u=C.getTypedArrayFromDType("int32",a*r);for(let p=0;p<a;p++){let d=p*i,f=e.subarray(d,d+i),h=new Array(f.length);f.forEach((y,b)=>h[b]={value:y,index:b}),r<h.length&&(LJ(h,r),h=h.slice(0,r)),s&&h.sort(nv);let m=p*r,g=l.subarray(m,m+r),x=u.subarray(m,m+r);for(let y=0;y<r;y++)g[y]=h[y].value,x[y]=h[y].index}let c=t.slice();return c[c.length-1]=r,[et(c,n,l),et(c,"int32",u)]}function dS(e,t,n,r){let s=C.parseAxisParam(t,n)[0],o=[1,n[0],1];for(let h=0;h<s;h++)o[0]*=n[h];o[1]=n[s];for(let h=s+1;h<n.length;h++)o[2]*=n[h];let a={},i=new Int32Array(n[s]),l=new sn(o,r,e),u=[],c=o[0]===1&&o[2]===1;for(let h=0;h<n[s];h++){let m;if(c)m=e[h].toString();else{let g=[];for(let x=0;x<o[0];x++)for(let y=0;y<o[2];y++)g.push(l.get(x,h,y));m=g.join(",")}if(a[m]!==void 0)i[h]=a[m];else{let g=Object.keys(a).length;a[m]=g,i[h]=g,u.push(h)}}let p=o.slice();p[1]=Object.keys(a).length;let d=new sn(p,r);u.forEach((h,m)=>{for(let g=0;g<o[0];g++)for(let x=0;x<o[2];x++)d.set(l.get(g,h,x),g,m,x)});let f=n.slice();return f[s]=p[1],{outputValues:d.values,outputShape:f,indices:i}}R3("cpu",()=>new Yy,1);var pF=pt(du,e=>e>=0?e:Math.exp(e)-1),BJ={kernelName:du,backendName:"cpu",kernelFunc:pF};function dF(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:o}=r;Se([s],"leakyRelu");let a=C.sizeFromShape(s.shape),i=n.data.get(s.dataId).values,l=C.getTypedArrayFromDType("float32",a);for(let u=0;u<i.length;u++)l[u]=i[u]<0?o*i[u]:i[u];return n.makeTensorInfo(s.shape,"float32",l)}var VJ={kernelName:Ep,backendName:"cpu",kernelFunc:dF};var yje=Pt((e,t)=>e<0?t*e:e);function fF(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t;Se([r,s],"prelu");let o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,[i,l]=yje(r.shape,s.shape,o,a,r.dtype);return n.makeTensorInfo(l,r.dtype,i)}var WJ={kernelName:Gp,backendName:"cpu",kernelFunc:fF};var hF=pt(Eu,e=>Math.max(0,e)),GJ={kernelName:Eu,backendName:"cpu",kernelFunc:hF};var mF=pt(Ru,e=>Math.min(Math.max(0,e),6)),UJ={kernelName:Ru,backendName:"cpu",kernelFunc:mF};function r1(e,t,n,r,s){if(n==="linear")return Es({inputs:{x:t},backend:e});if(n==="relu")return hF({inputs:{x:t},backend:e});if(n==="elu")return pF({inputs:{x:t},backend:e});if(n==="relu6")return mF({inputs:{x:t},backend:e});if(n==="prelu")return fF({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return dF({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return aF({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Mt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:o}=r,a=C.sizeFromShape(s.shape),i=C.inferFromImplicitShape(o,a),l=C.sizeFromShape(i);C.assert(a===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);let u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,p=u.complexTensorInfos.imag;c.shape=i,p.shape=i}return{dataId:s.dataId,shape:i,dtype:s.dtype}}var jJ={kernelName:Up,backendName:"cpu",kernelFunc:Mt};function gF(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o}=t,{transposeA:a,transposeB:i}=r;Se([s,o],"matMul");let l=s.shape.length,u=o.shape.length,c=a?s.shape[l-2]:s.shape[l-1],p=i?o.shape[u-1]:o.shape[u-2],d=a?s.shape[l-1]:s.shape[l-2],f=i?o.shape[u-2]:o.shape[u-1],h=s.shape.slice(0,-2),m=o.shape.slice(0,-2),g=C.sizeFromShape(h),x=C.sizeFromShape(m),y=g===x||g===1||x===1;C.assert(l>=2&&u>=2&&y,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${m}).`);let A=(g>x?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([d,f]);C.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${a} and transposeB=${i} must match.`);let v=a?[g,c,d]:[g,d,c],w=i?[x,f,p]:[x,p,f],k=Mt({inputs:{x:s},backend:n,attrs:{shape:v}}),I=Mt({inputs:{x:o},backend:n,attrs:{shape:w}}),N=a?k.shape[1]:k.shape[2],T=a?k.shape[2]:k.shape[1],_=i?I.shape[1]:I.shape[2],R=Math.max(g,x),S=n.data.get(k.dataId).values,F=n.data.get(I.dataId).values,B=C.computeStrides(k.shape),W=C.computeStrides(I.shape),[q,K,J]=a?[B[0],1,B[1]]:[B[0],B[1],1],[Q,ee,ue]=i?[1,W[1],W[0]]:[W[1],1,W[0]],re=T*_,de=et([R,T,_],k.dtype),fe=de.values,me=n.blockSize;for(let xe=0;xe<R;xe++)for(let Ne=0;Ne<T;Ne+=me)for(let _e=0;_e<_;_e+=me)for(let Oe=0;Oe<N;Oe+=me){let Ve=Math.min(Ne+me,T),He=Math.min(_e+me,_),At=Math.min(Oe+me,N);for(let ft=Ne;ft<Ve;ft++)for(let dt=_e;dt<He;dt++){let ct=0;for(let mt=Oe;mt<At;mt++){let it=Math.min(xe,g-1)*q,Zn=Math.min(xe,x-1)*ue,Dt=S[it+ft*K+mt*J],Yn=F[mt*Q+dt*ee+Zn];ct+=Dt*Yn}fe[xe*re+(ft*_+dt)]+=ct}}return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(A,de.dtype,de.values)}var HJ={kernelName:xp,backendName:"cpu",kernelFunc:gF};function bje(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o,bias:a,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r,d,f,h,m=[];d=gF({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(f=xc({inputs:{a:d,b:a},backend:n}),m.push(d),d=f),c&&(h=r1(n,d,c,i,p),m.push(d),d=h);for(let x of m)n.disposeIntermediateTensorInfo(x);return d}var qJ={kernelName:$h,backendName:"cpu",kernelFunc:bje};var Aje=pt(eu,e=>Math.acos(e)),KJ={kernelName:eu,backendName:"cpu",kernelFunc:Aje};var vje=pt(tu,e=>Math.acosh(e)),XJ={kernelName:tu,backendName:"cpu",kernelFunc:vje};function wje(e){let{inputs:t,backend:n}=e,r=t;Se(t,"addN");let s=r.map(i=>n.data.get(i.dataId).values),o=et(r[0].shape,r[0].dtype),a=o.values;for(let i=0;i<r.length;i++){let l=s[i];for(let u=0;u<a.length;u++)a[u]+=l[u]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}var ZJ={kernelName:dp,backendName:"cpu",kernelFunc:wje};function kje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;Se(s,"all");let i=C.parseAxisParam(o,s.shape),l=i,u=M.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=dr({inputs:{x:s},backend:n,attrs:{perm:u}}),l=M.getInnerMostAxes(l.length,s.shape.length)),M.assertAxesAreInnerMostDims("all",l,c.shape.length);let[p,d]=M.computeOutAndReduceShapes(c.shape,l),f=C.sizeFromShape(d),h=C.makeZerosTypedArray(C.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let y=x*f,b=m[y];for(let A=0;A<f;++A){let v=m[y+A];b=b&&v}h[x]=b}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,h);if(a){let x=M.expandShapeToKeepDim(p,i),y=Mt({inputs:{x:g},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(g),y}return g}var YJ={kernelName:gx,backendName:"cpu",kernelFunc:kje};function Ije(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;Se(s,"any");let i=C.parseAxisParam(o,s.shape),l=i,u=M.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=dr({inputs:{x:s},backend:n,attrs:{perm:u}}),l=M.getInnerMostAxes(l.length,s.shape.length)),M.assertAxesAreInnerMostDims("any",l,c.shape.length);let[p,d]=M.computeOutAndReduceShapes(c.shape,l),f=C.sizeFromShape(d),h=C.makeZerosTypedArray(C.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let y=x*f,b=m[y];for(let A=0;A<f;++A){let v=m[y+A];b=b||v}h[x]=b}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,h);if(a){let x=M.expandShapeToKeepDim(p,i),y=Mt({inputs:{x:g},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(g),y}return g}var JJ={kernelName:xx,backendName:"cpu",kernelFunc:Ije};function Cje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r;Se(s,"argMax");let a=C.parseAxisParam(o,s.shape),i=M.getAxesPermutation(a,s.shape.length),l=s,u=[];i!=null&&(l=dr({inputs:{x:s},backend:n,attrs:{perm:i}}),u.push(l),a=M.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],M.assertAxesAreInnerMostDims("argMax",a,l.shape.length);let[c,p]=M.computeOutAndReduceShapes(l.shape,a),d=C.sizeFromShape(c),f=C.makeZerosTypedArray(d,"int32"),h=C.sizeFromShape(p),m=n.data.get(l.dataId).values;for(let g=0;g<f.length;++g){let x=g*h,y=m[x],b=0;for(let A=0;A<h;++A){let v=m[x+A];v>y&&(y=v,b=A)}f[g]=b}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",f)}var QJ={kernelName:fp,backendName:"cpu",kernelFunc:Cje};function Sje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r;Se(s,"argMin");let a=C.parseAxisParam(o,s.shape),i=M.getAxesPermutation(a,s.shape.length),l=s,u=[];i!=null&&(l=dr({inputs:{x:s},backend:n,attrs:{perm:i}}),u.push(l),a=M.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],M.assertAxesAreInnerMostDims("argMin",a,l.shape.length);let[c,p]=M.computeOutAndReduceShapes(l.shape,a),d=C.sizeFromShape(c),f=C.makeZerosTypedArray(d,"int32"),h=C.sizeFromShape(p),m=n.data.get(l.dataId).values;for(let g=0;g<f.length;++g){let x=g*h,y=m[x],b=0;for(let A=0;A<h;++A){let v=m[x+A];v<y&&(y=v,b=A)}f[g]=b}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",f)}var eQ={kernelName:hp,backendName:"cpu",kernelFunc:Sje};var Nje=pt(nu,e=>Math.asin(e)),tQ={kernelName:nu,backendName:"cpu",kernelFunc:Nje};var Tje=pt(ru,e=>Math.asinh(e)),nQ={kernelName:ru,backendName:"cpu",kernelFunc:Tje};var _je=pt(su,e=>Math.atan(e)),rQ={kernelName:su,backendName:"cpu",kernelFunc:_je};var Eje=Pt((e,t)=>Math.atan2(e,t)),Rje=Ht(au,Eje),sQ={kernelName:au,backendName:"cpu",kernelFunc:Rje};var Dje=pt(ou,e=>Math.atanh(e)),oQ={kernelName:ou,backendName:"cpu",kernelFunc:Dje};function s1(e,t,n,r,s,o){let a=s.strideHeight,i=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,p=s.effectiveFilterWidth,d=s.padInfo.top,f=s.padInfo.left,h=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=et(s.outShape,n),g=m.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],b=s.outShape[3];for(let A=0;A<s.batchSize;++A){let v=A*x,w=A*r[0];for(let k=0;k<s.inChannels;++k)for(let I=0;I<s.outHeight;++I){let N=I*a-d,T=Math.max(0,N),_=Math.min(s.inHeight,c+N),R=v+I*y;for(let S=0;S<s.outWidth;++S){let F=S*i-f,B=Math.max(0,F),W=Math.min(s.inWidth,p+F),q=h,K=0,J=0;for(let ee=T;ee<_;ee+=l){let ue=w+ee*r[1];for(let re=B;re<W;re+=u){let de=ue+re*r[2],fe=e[de+k];o==="max"&&fe>q?q=fe:o==="avg"&&(K+=fe,J++)}if(isNaN(q))break}let Q=R+S*b+k;g[Q]=o==="avg"?K/J:q}}}return m}function fS(e,t,n,r,s=!1,o=!1){let a=et(r.outShape,"int32"),i=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,f=r.padInfo.top,h=r.padInfo.left,m=et(t,n,e);for(let g=0;g<r.batchSize;++g)for(let x=0;x<r.inChannels;++x)for(let y=0;y<r.outHeight;++y){let b=y*i-f,A=b;for(;A<0;)A+=u;let v=Math.min(r.inHeight,p+b);for(let w=0;w<r.outWidth;++w){let k=w*l-h,I=k;for(;I<0;)I+=c;let N=Math.min(r.inWidth,d+k),T=Number.NEGATIVE_INFINITY,_=-1;for(let R=A;R<v;R+=u){let S=R-b;for(let F=I;F<N;F+=c){let B=F-k,W=m.get(g,R,F,x);W>T&&(T=W,s?_=o?((g*r.inHeight+R)*r.inWidth+F)*r.inChannels+x:(R*r.inWidth+F)*r.inChannels+x:_=S*d+B)}}a.set(_,g,y,w,x)}}return a}function hS(e,t,n,r,s,o){let a=s.strideDepth,i=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,p=s.dilationWidth,d=s.effectiveFilterDepth,f=s.effectiveFilterHeight,h=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,x=s.padInfo.left,y=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=et(s.outShape,n),A=b.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],w=s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let N=0;N<s.batchSize;++N){let T=N*v,_=N*r[0];for(let R=0;R<s.inChannels;++R)for(let S=0;S<s.outDepth;++S){let F=S*a-m,B=F;for(;B<0;)B+=u;let W=Math.min(s.inDepth,d+F),q=T+S*w;for(let K=0;K<s.outHeight;++K){let J=K*i-g,Q=J;for(;Q<0;)Q+=c;let ee=Math.min(s.inHeight,f+J),ue=q+K*k;for(let re=0;re<s.outWidth;++re){let de=re*l-x,fe=de;for(;fe<0;)fe+=p;let me=Math.min(s.inWidth,h+de),xe=ue+re*I,Ne=y,_e=0,Oe=0;for(let He=B;He<W;He+=u){let At=_+He*r[1];for(let ft=Q;ft<ee;ft+=c){let dt=At+ft*r[2];for(let ct=fe;ct<me;ct+=p){let mt=dt+ct*r[3],it=e[mt+R];if(o==="max"&&it>Ne?Ne=it:o==="avg"&&(_e+=it,Oe++),isNaN(Ne))break}if(isNaN(Ne))break}if(isNaN(Ne))break}let Ve=xe+R;A[Ve]=o==="avg"?_e/Oe:Ne}}}}return b}function aQ(e,t){let n=et(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,i=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,d=t.padInfo.front,f=t.padInfo.top,h=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let x=0;x<t.outDepth;++x){let y=x*r-d,b=y;for(;b<0;)b+=a;let A=Math.min(t.inDepth,u+y);for(let v=0;v<t.outHeight;++v){let w=v*s-f,k=w;for(;k<0;)k+=i;let I=Math.min(t.inHeight,c+w);for(let N=0;N<t.outWidth;++N){let T=N*o-h,_=T;for(;_<0;)_+=l;let R=Math.min(t.inWidth,p+T),S=Number.NEGATIVE_INFINITY,F=-1;for(let B=b;B<A;B+=a){let W=B-y;for(let q=k;q<I;q+=i){let K=q-w;for(let J=_;J<R;J+=l){let Q=J-T,ee=e.get(m,B,q,J,g);ee>=S&&(S=ee,F=W*c*p+K*c+Q)}}}n.set(F,m,x,v,N,g)}}}return n}function $je(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Se(s,"avgPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,u=1;C.assert(M.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=M.computePool2DInfo(s.shape,o,a,u,i,l),p;if(c.filterWidth===1&&c.filterHeight===1&&C.arraysEqual(c.inShape,c.outShape))p=Es({inputs:{x:s},backend:n});else{let d=n.data.get(s.dataId).values,f=C.computeStrides(s.shape),h=s1(d,s.shape,s.dtype,f,c,"avg");p=n.makeTensorInfo(c.outShape,s.dtype,h.values)}return p}var iQ={kernelName:mp,backendName:"cpu",kernelFunc:$je};function Fje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=r;Se(s,"avgPool3d");let c=M.computePool3DInfo(s.shape,o,a,1,i,l,u),p=n.data.get(s.dataId).values,d=hS(p,s.shape,s.dtype,C.computeStrides(s.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var lQ={kernelName:gp,backendName:"cpu",kernelFunc:Fje};function Oje(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=r;Se([s,o],"avgPool3DGrad");let c=M.computePool3DInfo(o.shape,a,i,1,l,u),p=c.strideDepth,d=c.strideHeight,f=c.strideWidth,h=c.filterDepth,m=c.filterHeight,g=c.filterWidth,x=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,A=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,k=A-1-c.padInfo.front,I=w-1-c.padInfo.left,N=v-1-c.padInfo.top,T=et(o.shape,"float32"),_=1/(h*m*g),R=n.bufferSync(s);for(let S=0;S<c.batchSize;++S)for(let F=0;F<c.inChannels;++F)for(let B=0;B<c.inDepth;++B)for(let W=0;W<c.inHeight;++W)for(let q=0;q<c.inWidth;++q){let K=B-k,J=W-N,Q=q-I,ee=0;for(let ue=0;ue<A;ue+=x){let re=(K+ue)/p;if(!(re<0||re>=c.outDepth||Math.floor(re)!==re))for(let de=0;de<v;de+=y){let fe=(J+de)/d;if(!(fe<0||fe>=c.outHeight||Math.floor(fe)!==fe))for(let me=0;me<w;me+=b){let xe=(Q+me)/f;if(xe<0||xe>=c.outWidth||Math.floor(xe)!==xe)continue;ee+=R.get(S,re,fe,xe,F)}}}T.set(ee*_,S,B,W,q,F)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var uQ={kernelName:bx,backendName:"cpu",kernelFunc:Oje};function Pje(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,a=o;Se([s,o],"avgPoolGrad");let{filterSize:i,strides:l,pad:u}=r,c=M.computePool2DInfo(a.shape,i,l,1,u),p=c.strideHeight,d=c.strideWidth,f=c.filterHeight,h=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,x=c.effectiveFilterHeight,y=c.effectiveFilterWidth,b=y-1-c.padInfo.left,A=x-1-c.padInfo.top,v=et(a.shape,"float32"),w=1/(f*h),k=n.data.get(s.dataId).values,I=et(s.shape,"float32",k);for(let N=0;N<c.batchSize;++N)for(let T=0;T<c.inChannels;++T)for(let _=0;_<c.inHeight;++_)for(let R=0;R<c.inWidth;++R){let S=_-A,F=R-b,B=0;for(let W=0;W<x;W+=m){let q=(S+W)/p;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(let K=0;K<y;K+=g){let J=(F+K)/d;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;B+=I.get(N,q,J,T)}}v.set(B*w,N,_,R,T)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var cQ={kernelName:yx,backendName:"cpu",kernelFunc:Pje};function Mje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,scale:o,offset:a,mean:i,variance:l}=t;C.assert(i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C.assert(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Se([s,i,l,o,a],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let c=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values,d=n.data.get(l.dataId).values,f=o?n.data.get(o.dataId).values:new Float32Array([1]),h=a?n.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=h.length,x=f.length,y=d.length,b=p.length,A=0,v=0,w=0,k=0;for(let I=0;I<c.length;++I)m[I]=h[A++]+(c[I]-p[v++])*f[w++]/Math.sqrt(d[k++]+u),A>=g&&(A=0),v>=b&&(v=0),w>=x&&(w=0),k>=y&&(k=0);return n.makeTensorInfo(s.shape,s.dtype,m)}var pQ={kernelName:Tp,backendName:"cpu",kernelFunc:Mje};function zje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,crops:a}=r;Se([s],"batchToSpaceND");let i=o.reduce((x,y)=>x*y),l=M.getReshaped(s.shape,o,i),u=M.getPermuted(l.length,o.length),c=M.getReshapedPermuted(s.shape,o,i),p=M.getSliceBeginCoords(a,o.length),d=M.getSliceSize(c,a,o.length),f=Mt({inputs:{x:s},backend:n,attrs:{shape:l}}),h=dr({inputs:{x:f},backend:n,attrs:{perm:u}}),m=Mt({inputs:{x:h},backend:n,attrs:{shape:c}}),g=li({inputs:{x:m},backend:n,attrs:{begin:p,size:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var dQ={kernelName:yp,backendName:"cpu",kernelFunc:zje};function Lje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:a}=r,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,u=e1(i,l,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,u)}var fQ={kernelName:Ax,backendName:"cpu",kernelFunc:Lje};function Bje(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,o=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,i=M.assertAndGetBroadcastShape(Array.from(o),Array.from(a));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var hQ={kernelName:f3,backendName:"cpu",kernelFunc:Bje};var Vje=pt(lu,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),mQ={kernelName:lu,backendName:"cpu",kernelFunc:Vje};var Wje=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(C.sizeFromShape(t.shape)),s=n.data.get(t.dataId),o=s.complexTensorInfos.real,a=s.complexTensorInfos.imag,i=n.data.get(o.dataId).values,l=n.data.get(a.dataId).values;for(let u=0;u<i.length;u++){let c=i[u],p=l[u];r[u]=Math.hypot(c,p)}return n.makeOutput(r,t.shape,"float32")},gQ={kernelName:bp,backendName:"cpu",kernelFunc:Wje};function _l(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}var xQ={kernelName:Mx,backendName:"cpu",kernelFunc:_l};function wd(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,o=C.parseAxisParam(s,t[0].shape)[0],a=M.computeOutShape(t.map(m=>m.shape),o);if(C.sizeFromShape(a)===0)return n.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(m=>C.sizeFromShape(m.shape)>0);if(i.length===1)return Es({inputs:{x:i[0]},backend:n});let l=i.map(m=>m.shape);if(M.assertParamsConsistent(l,o),i[0].dtype==="complex64"){let m=i.map(A=>oi({inputs:{input:A},backend:n})),g=i.map(A=>_l({inputs:{input:A},backend:n})),x=wd({inputs:m,backend:n,attrs:{axis:o}}),y=wd({inputs:g,backend:n,attrs:{axis:o}}),b=Br({inputs:{real:x,imag:y},backend:n});return m.forEach(A=>n.disposeIntermediateTensorInfo(A)),g.forEach(A=>n.disposeIntermediateTensorInfo(A)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(y),b}let u=i.map(m=>{let g=C.sizeFromShape(m.shape.slice(o));return Mt({inputs:{x:m},backend:n,attrs:{shape:[-1,g]}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));a=M.computeOutShape(u.map(m=>m.shape),1);let p=u[0].shape[0]===1,d=JC(c,a,t[0].dtype,p),f=M.computeOutShape(i.map(m=>m.shape),o),h=n.makeTensorInfo(f,t[0].dtype,d);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var yQ={kernelName:Ap,backendName:"cpu",kernelFunc:wd};function xF(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Se([s,o],"conv2d");let p=M.convertConv2DDataFormat(l),d=M.computeConv2DInfo(s.shape,o.shape,a,u,i,c,!1,p),f=d.filterHeight,h=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,x=d.padInfo.left,y=d.padInfo.top,b=d.dataFormat==="channelsLast",A=new sn(d.outShape,s.dtype),v=C.computeStrides(s.shape),w=C.computeStrides(o.shape),k=v[0],I=b?v[1]:v[2],N=b?v[2]:1,T=b?1:v[1],_=A.strides[0],R=b?A.strides[1]:A.strides[2],S=b?A.strides[2]:1,F=b?1:A.strides[1],B=n.data.get(s.dataId).values,W=n.data.get(o.dataId).values,q=A.values;for(let K=0;K<d.batchSize;++K){let J=K*k,Q=K*_;for(let ee=0;ee<d.outHeight;++ee){let ue=Q+ee*R,re=ee*d.strideHeight-y;for(let de=0;de<f;++de){let fe=re+de*m;if(fe<0||fe>=d.inHeight)continue;let me=de*w[0],xe=J+fe*I;for(let Ne=0;Ne<d.outWidth;++Ne){let _e=ue+Ne*S,Oe=Ne*d.strideWidth-x;for(let Ve=0;Ve<h;++Ve){let He=Oe+Ve*g;if(He<0||He>=d.inWidth)continue;let At=me+Ve*w[1],ft=xe+He*N,dt=At;for(let ct=0;ct<d.inChannels;++ct){let mt=B[ft+ct*T];for(let it=0;it<d.outChannels;++it)q[_e+it*F]+=mt*W[dt+it];dt+=d.outChannels}}}}}}return n.makeTensorInfo(A.shape,A.dtype,q)}var bQ={kernelName:vp,backendName:"cpu",kernelFunc:xF};function Gje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Se([s,o],"conv2dBackpropFilter");let p=M.convertConv2DDataFormat(l),d=M.computeConv2DInfo(s.shape,c,a,1,i,u,!1,p),{strideHeight:f,strideWidth:h,filterHeight:m,filterWidth:g}=d,x=d.dataFormat==="channelsLast",y=new sn(d.filterShape,"float32"),b=d.padInfo.left,A=d.padInfo.top,v=n.data.get(s.dataId).values,w=n.data.get(o.dataId).values,k=new sn(s.shape,s.dtype,v),I=new sn(o.shape,o.dtype,w);for(let N=0;N<m;++N){let T=Math.max(0,Math.ceil((A-N)/f)),_=Math.min(d.outHeight,(d.inHeight+A-N)/f);for(let R=0;R<g;++R){let S=Math.max(0,Math.ceil((b-R)/h)),F=Math.min(d.outWidth,(d.inWidth+b-R)/h);for(let B=0;B<d.inChannels;++B)for(let W=0;W<d.outChannels;++W){let q=0;for(let K=0;K<d.batchSize;++K)for(let J=T;J<_;++J){let Q=N+J*f-A;for(let ee=S;ee<F;++ee){let ue=R+ee*h-b;x?q+=k.get(K,Q,ue,B)*I.get(K,J,ee,W):q+=k.get(K,B,Q,ue)*I.get(K,W,J,ee)}}y.set(q,N,R,B,W)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var AQ={kernelName:wx,backendName:"cpu",kernelFunc:Gje};function Uje(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=r;Se([s,o],"conv2dBackpropInput");let p=C.computeStrides(o.shape),d=C.computeStrides(s.shape),f=M.convertConv2DDataFormat(u),h=M.computeConv2DInfo(a,o.shape,i,1,l,c,!1,f),m=new sn(h.inShape,"float32"),g=m.values,x=n.data.get(s.dataId).values,y=n.data.get(o.dataId).values,[b,A,v]=p,{batchSize:w,filterHeight:k,filterWidth:I,inChannels:N,inHeight:T,inWidth:_,outChannels:R,outHeight:S,outWidth:F,strideHeight:B,strideWidth:W}=h;f=h.dataFormat;let q=k-1-h.padInfo.top,K=I-1-h.padInfo.left,J=f==="channelsLast",Q=m.strides[0],ee=J?m.strides[1]:m.strides[2],ue=J?m.strides[2]:1,re=J?1:m.strides[1],de=d[0],fe=J?d[1]:d[2],me=J?d[2]:1,xe=J?1:d[1];for(let Ne=0;Ne<w;++Ne)for(let _e=0;_e<N;++_e)for(let Oe=0;Oe<T;++Oe){let Ve=Oe-q,He=Math.max(0,Math.ceil(Ve/B)),At=Math.min(S,(k+Ve)/B);for(let ft=0;ft<_;++ft){let dt=ft-K,ct=Math.max(0,Math.ceil(dt/W)),mt=Math.min(F,(I+dt)/W),it=0;for(let Dt=He;Dt<At;++Dt){let Yn=Dt*B-Ve;for(let cn=ct;cn<mt;++cn){let Vr=cn*W-dt,_n=de*Ne+fe*Dt+me*cn,hr=b*(k-1-Yn)+A*(I-1-Vr)+v*_e;for(let Ar=0;Ar<R;++Ar){let Pn=x[_n+xe*Ar],vr=y[hr+Ar];it+=Pn*vr}}}let Zn=Q*Ne+ee*Oe+ue*ft+re*_e;g[Zn]=it}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var vQ={kernelName:wp,backendName:"cpu",kernelFunc:Uje};function jje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l}=r;Se([s,o],"conv3d");let u=M.computeConv3DInfo(s.shape,o.shape,a,l,i),{filterDepth:c,filterHeight:p,filterWidth:d,dilationDepth:f,dilationHeight:h,dilationWidth:m,padInfo:g}=u,x=g.front,y=g.left,b=g.top,A=new sn(u.outShape,s.dtype),v=n.data.get(s.dataId).values,w=n.data.get(o.dataId).values,k=A.values,I=C.computeStrides(s.shape),N=C.computeStrides(o.shape);for(let T=0;T<u.batchSize;++T){let _=T*I[0],R=T*A.strides[0];for(let S=0;S<u.outDepth;++S){let F=R+S*A.strides[1],B=S*u.strideDepth-x;for(let W=0;W<c;++W){let q=B+W*f;if(q<0||q>=u.inDepth)continue;let K=W*N[0],J=_+q*I[1];for(let Q=0;Q<u.outHeight;++Q){let ee=F+Q*A.strides[2],ue=Q*u.strideHeight-b;for(let re=0;re<p;++re){let de=ue+re*h;if(de<0||de>=u.inHeight)continue;let fe=K+re*N[1],me=J+de*I[2];for(let xe=0;xe<u.outWidth;++xe){let Ne=ee+xe*u.outChannels,_e=xe*u.strideWidth-y;for(let Oe=0;Oe<d;++Oe){let Ve=_e+Oe*m;if(Ve<0||Ve>=u.inWidth)continue;let He=fe+Oe*N[2],At=me+Ve*u.inChannels,ft=He;for(let dt=0;dt<u.inChannels;++dt){let ct=v[At+dt];for(let mt=0;mt<u.outChannels;++mt)k[Ne+mt]+=ct*w[ft+mt];ft+=u.outChannels}}}}}}}}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var wQ={kernelName:kp,backendName:"cpu",kernelFunc:jje};function Hje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,pad:i,filterShape:l}=r;Se([s,o],"conv3dBackpropFilterV2");let u=C.computeStrides(s.shape),c=C.computeStrides(o.shape),p=M.computeConv3DInfo(s.shape,l,a,1,i),d=p.strideDepth,f=p.strideHeight,h=p.strideWidth,m=p.filterDepth,g=p.filterHeight,x=p.filterWidth,y=new sn(p.filterShape,"float32"),b=y.values,[A,v,w,k]=y.strides,I=n.data.get(o.dataId).values,[N,T,_,R]=c,S=n.data.get(s.dataId).values,[F,B,W,q]=u,K=p.padInfo.front,J=p.padInfo.left,Q=p.padInfo.top;for(let ee=0;ee<m;++ee){let ue=Math.max(0,Math.ceil((K-ee)/d)),re=Math.min(p.outDepth,(p.inDepth+K-ee)/d),de=ee*A;for(let fe=0;fe<g;++fe){let me=Math.max(0,Math.ceil((Q-fe)/f)),xe=Math.min(p.outHeight,(p.inHeight+Q-fe)/f),Ne=fe*v+de;for(let _e=0;_e<x;++_e){let Oe=Math.max(0,Math.ceil((J-_e)/h)),Ve=Math.min(p.outWidth,(p.inWidth+J-_e)/h),He=_e*w+Ne;for(let At=0;At<p.inChannels;++At){let ft=At*k+He;for(let dt=0;dt<p.outChannels;++dt){let ct=0;for(let mt=0;mt<p.batchSize;++mt){let it=mt*F,Zn=mt*N;for(let Dt=ue;Dt<re;++Dt){let cn=(ee+Dt*d-K)*B+it,Vr=Dt*T+Zn;for(let _n=me;_n<xe;++_n){let Ar=(fe+_n*f-Q)*W+cn,Pn=_n*_+Vr;for(let vr=Oe;vr<Ve;++vr){let ys=(_e+vr*h-J)*q+Ar,Oo=vr*R+Pn;ct+=S[ys+At]*I[Oo+dt]}}}}b[ft+dt]=ct}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var kQ={kernelName:kx,backendName:"cpu",kernelFunc:Hje};function qje(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{pad:a,strides:i,inputShape:l}=r;Se([s],"conv3dBackpropInputV2");let u=C.computeStrides(s.shape),c=C.computeStrides(o.shape),p=M.computeConv3DInfo(l,o.shape,i,1,a),d=new sn(p.inShape,"float32"),f=d.values,[h,m,g,x]=d.strides,y=n.data.get(s.dataId).values,[b,A,v,w]=u,k=n.data.get(o.dataId).values,[I,N,T,_]=c,{batchSize:R,filterDepth:S,filterHeight:F,filterWidth:B,inChannels:W,inDepth:q,inHeight:K,inWidth:J,outChannels:Q,outDepth:ee,outHeight:ue,outWidth:re,strideDepth:de,strideHeight:fe,strideWidth:me}=p,xe=S-1-p.padInfo.front,Ne=F-1-p.padInfo.top,_e=B-1-p.padInfo.left;for(let Oe=0;Oe<R;++Oe)for(let Ve=0;Ve<W;++Ve)for(let He=0;He<q;++He){let At=He-xe,ft=Math.max(0,Math.ceil(At/de)),dt=Math.min(ee,(S+At)/de);for(let ct=0;ct<K;++ct){let mt=ct-Ne,it=Math.max(0,Math.ceil(mt/fe)),Zn=Math.min(ue,(F+mt)/fe);for(let Dt=0;Dt<J;++Dt){let Yn=Dt-_e,cn=Math.max(0,Math.ceil(Yn/me)),Vr=Math.min(re,(B+Yn)/me),_n=0;for(let hr=ft;hr<dt;++hr){let Ar=hr*de-At;for(let Pn=it;Pn<Zn;++Pn){let vr=Pn*fe-mt;for(let rs=cn;rs<Vr;++rs){let ys=rs*me-Yn,Oo=b*Oe+A*hr+v*Pn+w*rs,di=I*(S-1-Ar)+N*(F-1-vr)+T*(B-1-ys)+_*Ve;for(let ca=0;ca<Q;++ca){let kc=y[Oo+ca],_a=k[di+ca];_n+=kc*_a}}}}f[h*Oe+m*He+g*ct+x*Dt+Ve]=_n}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var IQ={kernelName:Ix,backendName:"cpu",kernelFunc:qje};var Kje=pt(uu,e=>Math.cos(e)),CQ={kernelName:uu,backendName:"cpu",kernelFunc:Kje};var Xje=pt(cu,e=>Math.cosh(e)),SQ={kernelName:cu,backendName:"cpu",kernelFunc:Xje};function Zje(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:o,boxInd:a}=t,{cropSize:i,method:l,extrapolationValue:u}=r,[c,p,d,f]=s.shape,h=o.shape[0],[m,g]=i,x=et([h,m,g,f],"float32"),y=n.data.get(o.dataId).values,b=n.data.get(a.dataId).values,A=n.data.get(s.dataId).values,v=C.computeStrides(s.shape),w=C.computeStrides(x.shape);for(let k=0;k<h;k++){let I=k*4,N=y[I],T=y[I+1],_=y[I+2],R=y[I+3],S=b[k];if(S>=c)continue;let F=m>1?(_-N)*(p-1)/(m-1):0,B=g>1?(R-T)*(d-1)/(g-1):0;for(let W=0;W<m;W++){let q=m>1?N*(p-1)+W*F:.5*(N+_)*(p-1);if(q<0||q>p-1){for(let K=0;K<g;K++)for(let J=0;J<f;J++){let Q=J+K*w[2]+W*w[1]+k*w[0];x.values[Q]=u}continue}if(l==="bilinear"){let K=Math.floor(q),J=Math.ceil(q),Q=q-K;for(let ee=0;ee<g;ee++){let ue=g>1?T*(d-1)+ee*B:.5*(T+R)*(d-1);if(ue<0||ue>d-1){for(let me=0;me<f;me++){let xe=me+ee*w[2]+W*w[1]+k*w[0];x.values[xe]=u}continue}let re=Math.floor(ue),de=Math.ceil(ue),fe=ue-re;for(let me=0;me<f;me++){let xe=me+re*v[2]+K*v[1]+S*v[0],Ne=A[xe];xe=me+de*v[2]+K*v[1]+S*v[0];let _e=A[xe];xe=me+re*v[2]+J*v[1]+S*v[0];let Oe=A[xe];xe=me+de*v[2]+J*v[1]+S*v[0];let Ve=A[xe],He=Ne+(_e-Ne)*fe,At=Oe+(Ve-Oe)*fe;xe=me+ee*w[2]+W*w[1]+k*w[0],x.values[xe]=He+(At-He)*Q}}}else for(let K=0;K<g;++K){let J=g>1?T*(d-1)+K*B:.5*(T+R)*(d-1);if(J<0||J>d-1){for(let ue=0;ue<f;ue++){let re=ue+K*w[2]+W*w[1]+k*w[0];x.values[re]=u}continue}let Q=Math.round(J),ee=Math.round(q);for(let ue=0;ue<f;ue++){let re=ue+Q*v[2]+ee*v[1]+S*v[0],de=ue+K*w[2]+W*w[1]+k*w[0];x.values[de]=A[re]}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var NQ={kernelName:Cx,backendName:"cpu",kernelFunc:Zje};function Yje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,exclusive:a,reverse:i}=r;Se(s,"cumsum");let l=M.getAxesPermutation([o],s.shape.length),u=s;l!=null&&(u=dr({inputs:{x:s},backend:n,attrs:{perm:l}}));let c=M.getInnerMostAxes(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=Or(u.dtype,"int32"),d=C.makeZerosTypedArray(C.sizeFromShape(u.shape),p),f=n.data.get(u.dataId).values,h=u.shape[u.shape.length-1],m=i?(x,y)=>x+h-y-1:(x,y)=>x+y;for(let x=0;x<f.length;x+=h)for(let y=0;y<h;y++){let b=m(x,y);if(y===0)d[b]=a?0:f[b];else{let A=m(x,y-1);d[b]=a?f[A]+d[A]:f[b]+d[A]}}let g=n.makeTensorInfo(u.shape,p,d);if(l!=null){let x=M.getUndoAxesPermutation(l),y=dr({inputs:{x:g},backend:n,attrs:{perm:x}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),y}return g}var TQ={kernelName:Ip,backendName:"cpu",kernelFunc:Yje};function Jje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:a,binaryOutput:i}=r;if(s.shape.length===1){let l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,c=e1(l,u,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(o),c=YC(l,u,a,i);return n.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var _Q={kernelName:Sx,backendName:"cpu",kernelFunc:Jje};function Qje(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:o,dataFormat:a}=r;C.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`),C.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let i=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],p=l*o,d=u*o,f=c/(o*o),h=n.data.get(s.dataId).values,m=new Float32Array(i*p*d*f),g=0;for(let x=0;x<i;++x)for(let y=0;y<p;++y){let b=Math.floor(y/o),A=y%o;for(let v=0;v<d;++v){let w=Math.floor(v/o),k=v%o,I=(A*o+k)*f;for(let N=0;N<f;++N){let _=N+I+c*(w+u*(b+l*x));m[g++]=h[_]}}}return n.makeTensorInfo([i,p,d,f],s.dtype,m)}var EQ={kernelName:Nx,backendName:"cpu",kernelFunc:Qje};function yF(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=r;Se([s,o],"depthwiseConv2DNative");let c=C.computeStrides(s.shape),p=C.computeStrides(o.shape),d=l;d==null&&(d=[1,1]),C.assert(M.eitherStridesOrDilationsAreOne(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);let f=M.computeConv2DInfo(s.shape,o.shape,a,d,i,u,!0),{filterHeight:h,filterWidth:m,dilationHeight:g,dilationWidth:x,padInfo:y}=f,b=y.left,A=y.top,v=f.outChannels/f.inChannels,w=new sn(f.outShape,s.dtype),k=n.data.get(s.dataId).values,I=n.data.get(o.dataId).values,N=w.values;for(let T=0;T<f.batchSize;++T){let _=T*c[0],R=T*w.strides[0];for(let S=0;S<f.outHeight;++S){let F=R+S*w.strides[1],B=S*f.strideHeight-A;for(let W=0;W<h;++W){let q=B+W*g;if(q<0||q>=f.inHeight)continue;let K=W*p[0],J=_+q*c[1];for(let Q=0;Q<f.outWidth;++Q){let ee=F+Q*w.strides[2],ue=Q*f.strideWidth-b;for(let re=0;re<m;++re){let de=ue+re*x;if(de<0||de>=f.inWidth)continue;let fe=K+re*p[1],me=J+de*f.inChannels,xe=ee,Ne=fe;for(let _e=0;_e<f.inChannels;++_e){let Oe=k[me+_e];for(let Ve=0;Ve<v;++Ve)N[xe+Ve]+=Oe*I[Ne+Ve];xe+=v,Ne+=v}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var RQ={kernelName:Cp,backendName:"cpu",kernelFunc:yF};function eHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=r;Se([s,o],"depthwiseConv2dNativeBackpropFilter");let p=M.computeConv2DInfo(s.shape,c,a,i,l,u,!0),{strideHeight:d,strideWidth:f,filterHeight:h,filterWidth:m}=p,g=new sn(p.filterShape,"float32"),x=p.padInfo.left,y=p.padInfo.top,b=p.outChannels/p.inChannels,A=n.data.get(s.dataId).values,v=new sn(s.shape,s.dtype,A),w=n.data.get(o.dataId).values,k=new sn(o.shape,o.dtype,w);for(let I=0;I<h;++I){let N=Math.max(0,Math.ceil((y-I)/d)),T=Math.min(p.outHeight,(p.inHeight+y-I)/d);for(let _=0;_<m;++_){let R=Math.max(0,Math.ceil((x-_)/f)),S=Math.min(p.outWidth,(p.inWidth+x-_)/f);for(let F=0;F<p.outChannels;++F){let B=Math.trunc(F/b),W=F%b,q=0;for(let K=0;K<p.batchSize;++K)for(let J=N;J<T;++J){let Q=I+J*d-y;for(let ee=R;ee<S;++ee){let ue=_+ee*f-x;q+=v.get(K,Q,ue,B)*k.get(K,J,ee,F)}}g.set(q,I,_,B,W)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var DQ={kernelName:Tx,backendName:"cpu",kernelFunc:eHe};function tHe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=r;Se([s,o],"depthwiseConv2DNativeBackpropInput");let p=C.computeStrides(s.shape),d=C.computeStrides(o.shape),f=M.computeConv2DInfo(c,o.shape,a,i,l,u,!0),h=new sn(f.inShape,"float32"),m=h.values,[g,x,y]=h.strides,b=n.data.get(s.dataId).values,[A,v,w]=p,k=n.data.get(o.dataId).values,[I,N,T]=d,{batchSize:_,filterHeight:R,filterWidth:S,inChannels:F,inHeight:B,inWidth:W,outChannels:q,outHeight:K,outWidth:J,strideHeight:Q,strideWidth:ee}=f,ue=R-1-f.padInfo.top,re=S-1-f.padInfo.left,de=q/F;for(let fe=0;fe<_;++fe)for(let me=0;me<F;++me)for(let xe=0;xe<B;++xe){let Ne=xe-ue,_e=Math.max(0,Math.ceil(Ne/Q)),Oe=Math.min(K,(R+Ne)/Q);for(let Ve=0;Ve<W;++Ve){let He=Ve-re,At=Math.max(0,Math.ceil(He/ee)),ft=Math.min(J,(S+He)/ee),dt=0;for(let ct=_e;ct<Oe;++ct){let mt=ct*Q-Ne;for(let it=At;it<ft;++it){let Zn=it*ee-He,Dt=A*fe+v*ct+w*it,Yn=I*(R-1-mt)+N*(S-1-Zn)+T*me;for(let cn=0;cn<de;++cn){let Vr=me*de+cn,_n=b[Dt+Vr],hr=k[Yn+cn];dt+=_n*hr}}}m[g*fe+x*xe+y*Ve+me]=dt}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}var $Q={kernelName:_x,backendName:"cpu",kernelFunc:tHe};function nHe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=C.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,a=et([s,s],r.dtype),i=a.values;for(let u=0;u<o.length;u++)i[u*s+u]=o[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,a.dtype,a.values)}var FQ={kernelName:h3,backendName:"cpu",kernelFunc:nHe};var OQ={kernelName:Sp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s}=e,{strides:o,pad:a,dilations:i}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,p=l.data.get(s.dataId).values,d=s.shape.length,{batchSize:f,inHeight:h,inWidth:m,inChannels:g,outHeight:x,outWidth:y,padInfo:b,strideHeight:A,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:T}=M.computeDilation2DInfo(r.shape,s.shape,o,a,"NHWC",i),_=C.sizeFromShape(T),R=T.length,S=C.getArrayFromDType(r.dtype,_);for(let B=0;B<f;++B)for(let W=0;W<x;++W){let q=W*A-b.top;for(let K=0;K<y;++K){let J=K*v-b.left;for(let Q=0;Q<g;++Q){let ee=Number.MIN_SAFE_INTEGER;for(let re=0;re<w;++re){let de=q+re*I;if(de>=0&&de<h)for(let fe=0;fe<k;++fe){let me=J+fe*N;if(me>=0&&me<m){let xe=C.locToIndex([B,de,me,Q],c,C.computeStrides(r.shape)),Ne=C.locToIndex([re,fe,Q],d,C.computeStrides(s.shape)),_e=u[xe]+p[Ne];_e>ee&&(ee=_e)}}}let ue=C.locToIndex([B,W,K,Q],R,C.computeStrides(T));S[ue]=ee}}}return{dataId:l.write(C.toTypedArray(S,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}};var PQ={kernelName:TA,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:o}=e,{strides:a,pad:i,dilations:l}=n,u=t,c=C.toNestedArray(r.shape,u.data.get(r.dataId).values),p=C.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:f,inWidth:h,inChannels:m,outHeight:g,outWidth:x,padInfo:y,strideHeight:b,strideWidth:A,filterHeight:v,filterWidth:w,dilationHeight:k,dilationWidth:I,outShape:N}=M.computeDilation2DInfo(r.shape,s.shape,a,i,"NHWC",l);C.assert(o.rank===N.length,()=>`Error in ${TA}, dy must have the same rank as output ${N.length}, but got ${o.rank}`);let T=C.toNestedArray(N,u.data.get(o.dataId).values),_=C.makeZerosNestedTypedArray(s.shape,s.dtype);for(let S=0;S<d;++S)for(let F=0;F<g;++F){let B=F*b-y.top;for(let W=0;W<x;++W){let q=W*A-y.left;for(let K=0;K<m;++K){let J=Number.MIN_SAFE_INTEGER,Q=0,ee=0;for(let ue=0;ue<v;++ue){let re=B+ue*k;if(re>=0&&re<f)for(let de=0;de<w;++de){let fe=q+de*I;if(fe>=0&&fe<h){let me=c[S][re][fe][K]+p[ue][de][K];me>J&&(J=me,Q=ue,ee=de)}}}_[Q][ee][K]+=T[S][F][W][K]}}}return{dataId:u.write(C.toTypedArray(_,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};var MQ={kernelName:NA,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:o}=e,{strides:a,pad:i,dilations:l}=n,u=t,c=C.toNestedArray(r.shape,u.data.get(r.dataId).values),p=C.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:f,inWidth:h,inChannels:m,outHeight:g,outWidth:x,padInfo:y,strideHeight:b,strideWidth:A,filterHeight:v,filterWidth:w,dilationHeight:k,dilationWidth:I,outShape:N}=M.computeDilation2DInfo(r.shape,s.shape,a,i,"NHWC",l);C.assert(o.rank===N.length,()=>`Error in ${NA}, dy must have the same rank as output ${N.length}, but got ${o.rank}`);let T=C.toNestedArray(N,u.data.get(o.dataId).values),_=C.makeZerosNestedTypedArray(r.shape,r.dtype);for(let S=0;S<d;++S)for(let F=0;F<g;++F){let B=F*b-y.top;for(let W=0;W<x;++W){let q=W*A-y.left;for(let K=0;K<m;++K){let J=Number.MIN_SAFE_INTEGER,Q=B<0?0:B,ee=q<0?0:q;for(let ue=0;ue<v;++ue){let re=B+ue*k;if(re>=0&&re<f)for(let de=0;de<w;++de){let fe=q+de*I;if(fe>=0&&fe<h){let me=c[S][re][fe][K]+p[ue][de][K];me>J&&(J=me,Q=re,ee=fe)}}}_[S][Q][ee][K]+=T[S][F][W][K]}}}return{dataId:u.write(C.toTypedArray(_,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function yc(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;Se(s,"sum");let i;s.dtype==="bool"?i=ai({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):i=Es({inputs:{x:s},backend:n});let l=i.shape.length,u=C.parseAxisParam(o,i.shape),c=M.getAxesPermutation(u,l),p=u,d=i;c!=null&&(d=dr({inputs:{x:i},backend:n,attrs:{perm:c}}),p=M.getInnerMostAxes(p.length,l)),M.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[f,h]=M.computeOutAndReduceShapes(d.shape,p),m=M.upcastType(d.dtype,"int32"),g=Jy(n,f,m),x=C.sizeFromShape(h),y=n.data.get(g.dataId).values,b=n.data.get(d.dataId).values;for(let A=0;A<y.length;++A){let v=A*x,w=0;for(let k=0;k<x;++k)w+=b[v+k];y[A]=w}if(a){let A=M.expandShapeToKeepDim(g.shape,u),v=g;g=Mt({inputs:{x:g},backend:n,attrs:{shape:A}}),n.disposeIntermediateTensorInfo(v)}return n.disposeIntermediateTensorInfo(i),c!=null&&n.disposeIntermediateTensorInfo(d),g}var zQ={kernelName:Zp,backendName:"cpu",kernelFunc:yc};function rHe(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,o=t,{allDims:a,summedDims:i,idDims:l}=M.decodeEinsumEquation(s,o.length);M.checkEinsumDimSizes(a.length,l,o);let{path:u,steps:c}=M.getEinsumComputePath(i,l),p=c.length,d=null,f=a.length,h=[];for(let m=0;m<p;++m){for(let g of c[m]){let{permutationIndices:x,expandDims:y}=M.getEinsumPermutation(f,l[g]),b;M.isIdentityPermutation(x)?b=o[g]:(b=dr({inputs:{x:o[g]},backend:n,attrs:{perm:x}}),h.push(b));let A=b.shape.slice();for(let v=0;v<y.length;++v)A.splice(y[v],0,1);C.arraysEqual(b.shape,A)||(b=Mt({inputs:{x:b},backend:n,attrs:{shape:A}}),h.push(b)),d===null?d=b:(d=Om({inputs:{a:b,b:d},backend:n}),h.push(d))}m<p-1&&(u[m]>=0&&(d=yc({inputs:{x:d},backend:n,attrs:{axis:u[m]-(a.length-f),keepDims:!1}}),h.push(d)),f--)}for(let m of h)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var LQ={kernelName:Ex,backendName:"cpu",kernelFunc:rHe};function sHe(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t;Se([r,s],"eluGrad");let o=new Float32Array(C.sizeFromShape(s.shape)),a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values;for(let l=0;l<a.length;++l){let u=a[l];u>=1?o[l]=i[l]:o[l]=i[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",o)}var BQ={kernelName:Rx,backendName:"cpu",kernelFunc:sHe};var oHe=M.ERF_P,aHe=M.ERF_A1,iHe=M.ERF_A2,lHe=M.ERF_A3,uHe=M.ERF_A4,cHe=M.ERF_A5,pHe=pt(fu,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+oHe*n);return t*(1-((((cHe*r+uHe)*r+lHe)*r+iHe)*r+aHe)*r*Math.exp(-n*n))}),VQ={kernelName:fu,backendName:"cpu",kernelFunc:pHe};function o1(e){let{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:o}=r,a=s.shape.length,i=s.shape.slice(),l=o;return o<0&&(C.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),i.splice(l,0,1),Mt({inputs:{x:s},backend:n,attrs:{shape:i}})}var WQ={kernelName:Np,backendName:"cpu",kernelFunc:o1};var dHe=Pt((e,t)=>e/t),rv=Ht(pu,dHe),sv={kernelName:pu,backendName:"cpu",kernelFunc:rv};function mS(e,t,n){let r=e.shape,s=r[0],o=r[1],a=n.data.get(e.dataId),i=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[s,o],c=C.sizeFromShape(u),p=C.getTypedArrayFromDType("float32",c),d=C.getTypedArrayFromDType("float32",c);for(let g=0;g<s;g++){let x=li({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,o]}}),y=li({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,o]}}),b=Br({inputs:{real:x,imag:y},backend:n}),{real:A,imag:v}=fHe(b,t,n),w=M.mergeRealAndImagArrays(A,v);for(let k=0;k<o;k++){let I=M.getComplexWithIndex(w,k);p[g*o+k]=I.real,d[g*o+k]=I.imag}n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b)}let f=n.makeTensorInfo(u,"float32",p),h=n.makeTensorInfo(u,"float32",d),m=Br({inputs:{real:f,imag:h},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),m}function fHe(e,t,n){let r=C.sizeFromShape(e.shape),s=n.data.get(e.dataId),o=n.data.get(s.complexTensorInfos.real.dataId).values,a=n.data.get(s.complexTensorInfos.imag.dataId).values;if(hHe(r)){let i=bF(o,a,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,"float32",i.real),c=n.makeTensorInfo(l,"float32",i.imag),p=n.makeTensorInfo([],"float32",C.createScalarValue(r,"float32")),d=Es({inputs:{x:p},backend:n}),f=sv.kernelFunc({inputs:{a:u,b:p},backend:n}),h=sv.kernelFunc({inputs:{a:c,b:d},backend:n}),m=n.data.get(f.dataId).values,g=n.data.get(h.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),{real:m,imag:g}}return i}else{let i=M.mergeRealAndImagArrays(o,a),l=mHe(i,r,t);return M.splitRealAndImagArrays(l)}}function hHe(e){return(e&e-1)==0}function bF(e,t,n,r,s){if(n===1)return{real:e,imag:t};let o=M.mergeRealAndImagArrays(e,t),a=n/2,i=M.complexWithEvenIndex(o),l=i.real,u=i.imag,c=[l.length],p=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),f=Br({inputs:{real:p,imag:d},backend:s}),h=M.complexWithOddIndex(o),m=h.real,g=h.imag,x=[m.length],y=s.makeTensorInfo(x,"float32",m),b=s.makeTensorInfo(x,"float32",g),A=Br({inputs:{real:y,imag:b},backend:s}),v=bF(l,u,a,r,s),w=v.real,k=v.imag,I=[w.length],N=s.makeTensorInfo(I,"float32",w),T=s.makeTensorInfo(I,"float32",k),_=Br({inputs:{real:N,imag:T},backend:s}),R=bF(m,g,a,r,s),S=R.real,F=R.imag,B=[S.length],W=s.makeTensorInfo(B,"float32",S),q=s.makeTensorInfo(B,"float32",F),K=Br({inputs:{real:W,imag:q},backend:s}),J=M.exponents(n,r),Q=[J.real.length],ee=s.makeTensorInfo(Q,"float32",J.real),ue=s.makeTensorInfo(Q,"float32",J.imag),re=Br({inputs:{real:ee,imag:ue},backend:s}),de=Om({inputs:{a:re,b:K},backend:s}),fe=xc({inputs:{a:_,b:de},backend:s}),me=tv({inputs:{a:_,b:de},backend:s}),xe=oi({inputs:{input:fe},backend:s}),Ne=oi({inputs:{input:me},backend:s}),_e=_l({inputs:{input:fe},backend:s}),Oe=_l({inputs:{input:me},backend:s}),Ve=wd({inputs:[xe,Ne],backend:s,attrs:{axis:0}}),He=wd({inputs:[_e,Oe],backend:s,attrs:{axis:0}}),At=s.data.get(Ve.dataId).values,ft=s.data.get(He.dataId).values;return s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(fe),s.disposeIntermediateTensorInfo(me),s.disposeIntermediateTensorInfo(xe),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(Ve),s.disposeIntermediateTensorInfo(He),{real:At,imag:ft}}function mHe(e,t,n){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let o=0,a=0;for(let i=0;i<t;i++){let l=M.exponent(s*i,t,n),u=M.getComplexWithIndex(e,i);o+=u.real*l.real-u.imag*l.imag,a+=u.real*l.imag+u.imag*l.real}n&&(o/=t,a/=t),M.assignToTypedArray(r,o,a,s)}return r}function gHe(e){let{inputs:t,backend:n}=e,{input:r}=t,s=C.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=s/o,i=Mt({inputs:{x:r},backend:n,attrs:{shape:[a,o]}}),l=mS(i,!1,n),u=Mt({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var GQ={kernelName:Dx,backendName:"cpu",kernelFunc:gHe};function ov(e){let{backend:t,attrs:n}=e,{shape:r,value:s,dtype:o}=n,a=o||C.inferDtype(s),i=C.getArrayFromDType(a,C.sizeFromShape(r));return xHe(i,s,a),t.makeTensorInfo(r,a,i)}var UQ={kernelName:$x,backendName:"cpu",kernelFunc:ov};function xHe(e,t,n){e.fill(t)}var jQ={kernelName:Fx,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,s=n,o=C.getTypedArrayFromDType(r.dtype,C.sizeFromShape(r.shape)),[a,i,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let d=0;d<a;d++){let f=d*l*i*u;for(let h=0;h<i;h++){let m=h*(l*u);for(let g=0;g<l;g++){let x=g*u;for(let y=0;y<u;y++){let b=Math.round(l-g-1),A=f+m+x+y,v=c[A];if(b>=0&&b<l){let w=b*u,k=f+m+w+y;v=c[k]}o[A]=v}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var yHe=Pt((e,t)=>Math.floor(e/t)),bHe=Ht(xu,yHe,null,"int32"),HQ={kernelName:xu,backendName:"cpu",kernelFunc:bHe};function AHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=r,m=xF({inputs:{x:s,filter:o},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d}});if(a){let g=m;m=xc({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(g)}if(f){let g=m;m=r1(n,m,f,i,h),n.disposeIntermediateTensorInfo(g)}return m}var qQ={kernelName:Fh,backendName:"cpu",kernelFunc:AHe};function vHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=r,m=yF({inputs:{x:s,filter:o},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d}});if(a){let g=m;m=xc({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(g)}if(f){let g=m;m=r1(n,m,f,i,h),n.disposeIntermediateTensorInfo(g)}return m}var KQ={kernelName:Oh,backendName:"cpu",kernelFunc:vHe};function wHe(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,o=C.sizeFromShape(r.shape),a=s.shape,i=a[a.length-1],[l,u,c,p]=M.prepareAndValidate(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);let d=n.data.get(s.dataId).values,f=n.bufferSync(r),h=QC(d,f,r.dtype,u,i,c,p,r.shape,o);return n.makeTensorInfo(l,r.dtype,h.values)}var XQ={kernelName:Ox,backendName:"cpu",kernelFunc:wHe};function kHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:o}=t,{axis:a,batchDims:i}=r;Se([s,o],"gatherV2");let l=i;i==null&&(l=0);let u=C.sizeFromShape(o.shape),c=C.parseAxisParam(a,s.shape)[0],p=M.segment_util.collectGatherOpShapeInfo(s,o,c,l),d=Mt({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),f=Mt({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,u/p.batchSize]}}),h=[p.batchSize,p.outerSize,u/p.batchSize,p.sliceSize],m=n.bufferSync(f),g=n.bufferSync(d),x=eS(g,m,h);return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}var ZQ={kernelName:_p,backendName:"cpu",kernelFunc:kHe};function IHe(e){let{inputs:t,backend:n}=e,{input:r}=t,s=C.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=s/o,i=Mt({inputs:{x:r},backend:n,attrs:{shape:[a,o]}}),l=mS(i,!0,n),u=Mt({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var YQ={kernelName:Px,backendName:"cpu",kernelFunc:IHe};var CHe=pt(bu,e=>Number.isFinite(e)?1:0,"bool"),JQ={kernelName:bu,backendName:"cpu",kernelFunc:CHe};var SHe=pt(Au,e=>Math.abs(e)===1/0?1:0,"bool"),QQ={kernelName:Au,backendName:"cpu",kernelFunc:SHe};var NHe=pt(vu,e=>Number.isNaN(e)?1:0,"bool"),eee={kernelName:vu,backendName:"cpu",kernelFunc:NHe};function THe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:o}=n,a=tS(r,s,o);return t.makeTensorInfo([a.length],"float32",a)}var tee={kernelName:zx,backendName:"cpu",kernelFunc:THe};var _He=pt(ku,e=>Math.log1p(e)),nee={kernelName:ku,backendName:"cpu",kernelFunc:_He};var EHe=Pt((e,t)=>e&&t),RHe=Ht(_h,EHe,null,"bool"),ree={kernelName:_h,backendName:"cpu",kernelFunc:RHe};var DHe=pt(Eh,e=>e?0:1,"bool"),see={kernelName:Eh,backendName:"cpu",kernelFunc:DHe};var $He=Pt((e,t)=>e||t),FHe=Ht(Rh,$He,null,"bool"),oee={kernelName:Rh,backendName:"cpu",kernelFunc:FHe};function OHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:o,bias:a,alpha:i,beta:l}=r;Se(s,"LRN");let u=s.shape[3],c=u-1,p=n.data.get(s.dataId).values,d=C.sizeFromShape(s.shape),f=new Float32Array(d);function h(m){let g=m%u,x=m-g+Math.max(0,g-o),y=m-g+Math.min(g+o,c),b=0;for(;x<=y;x++){let A=p[x];b+=A*A}return b}for(let m=0;m<d;m++){let g=h(m),x=p[m]*Math.pow(a+i*g,-l);f[m]=x}return n.makeTensorInfo(s.shape,s.dtype,f)}var aee={kernelName:Rp,backendName:"cpu",kernelFunc:OHe};function PHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:o,dy:a}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=r;Se(a,"LRNGrad");let p=C.sizeFromShape(a.shape),d=a.shape[3],f=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,m=n.data.get(o.dataId).values,g=new Float32Array(p),x=p;for(let y=0;y<x;y++){let b=y%d,A=y-b+Math.max(0,b-i),v=y-b+Math.min(d,b+i+1),w=0;for(let k=A;k<v;k++)w+=Math.pow(h[k],2);w=u*w+l;for(let k=A;k<v;k++){let I=-2*u*c*h[k]*m[y]/w;y===k&&(I+=Math.pow(w,-c)),I*=f[y],g[k]+=I}}return n.makeTensorInfo(a.shape,s.dtype,g)}var iee={kernelName:Lx,backendName:"cpu",kernelFunc:PHe};function AF(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:o,keepDims:a}=r,i=n,l=s.shape,u=l.length,c=C.parseAxisParam(o,l),p=c,d=M.getAxesPermutation(p,u),f=i.data.get(s.dataId).values;if(d!=null){let A=new Array(u);for(let v=0;v<A.length;v++)A[v]=l[d[v]];f=t1(f,l,s.dtype,d,A),p=M.getInnerMostAxes(p.length,u),l=A}Se(s,"max"),M.assertAxesAreInnerMostDims("max",p,u);let[h,m]=M.computeOutAndReduceShapes(l,p),g=C.sizeFromShape(m),x=nS(f,g,h,s.dtype),y=i.write(x,h,s.dtype),b=h;return a&&(b=M.expandShapeToKeepDim(h,c)),{dataId:y,shape:b,dtype:s.dtype}}var lee={kernelName:Dp,backendName:"cpu",kernelFunc:AF};function MHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Se(s,"maxPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,u=1;C.assert(M.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=M.computePool2DInfo(s.shape,o,a,u,i,l),p;if(c.filterWidth===1&&c.filterHeight===1&&C.arraysEqual(c.inShape,c.outShape))p=Es({inputs:{x:s},backend:n});else{let d=n.data.get(s.dataId).values,f=C.computeStrides(s.shape),h=s1(d,s.shape,s.dtype,f,c,"max");p=n.makeTensorInfo(c.outShape,s.dtype,h.values)}return p}var uee={kernelName:$p,backendName:"cpu",kernelFunc:MHe};function zHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=r;Se(s,"maxPool3d");let c=M.computePool3DInfo(s.shape,o,a,1,i,l,u),p=n.data.get(s.dataId).values,d=hS(p,s.shape,s.dtype,C.computeStrides(s.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var cee={kernelName:Fp,backendName:"cpu",kernelFunc:zHe};function LHe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=r;Se([s,o],"maxPool3DGrad");let c=M.computePool3DInfo(o.shape,a,i,1,l,u),p=n.bufferSync(o),d=aQ(p,c),f=c.strideDepth,h=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,x=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,A=c.effectiveFilterHeight,v=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=v-1-c.padInfo.left,I=A-1-c.padInfo.top,N=et(o.shape,"float32"),T=n.bufferSync(s);for(let _=0;_<c.batchSize;++_)for(let R=0;R<c.inChannels;++R)for(let S=0;S<c.inDepth;++S)for(let F=0;F<c.inHeight;++F)for(let B=0;B<c.inWidth;++B){let W=S-w,q=F-I,K=B-k,J=0;for(let Q=0;Q<b;Q+=g){let ee=(W+Q)/f;if(!(ee<0||ee>=c.outDepth||Math.floor(ee)!==ee))for(let ue=0;ue<A;ue+=x){let re=(q+ue)/h;if(!(re<0||re>=c.outHeight||Math.floor(re)!==re))for(let de=0;de<v;de+=y){let fe=(K+de)/m;if(fe<0||fe>=c.outWidth||Math.floor(fe)!==fe)continue;let me=b*A*v-1-d.get(_,ee,re,fe,R),xe=Q*A*v+ue*v+de,Ne=me===xe?1:0;if(Ne===0)continue;J+=T.get(_,ee,re,fe,R)*Ne}}}N.set(J,_,S,F,B,R)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var pee={kernelName:Vx,backendName:"cpu",kernelFunc:LHe};function BHe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o,output:a}=t,i=o;Se([o,a],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,d=M.computePool2DInfo(i.shape,l,u,1,c,p),f=n.data.get(i.dataId).values,h=et(d.outShape,i.dtype,fS(f,i.shape,i.dtype,d).values),m=d.strideHeight,g=d.strideWidth,x=d.dilationHeight,y=d.dilationWidth,b=d.effectiveFilterHeight,A=d.effectiveFilterWidth,v=A-1-d.padInfo.left,w=b-1-d.padInfo.top,k=et(i.shape,"float32"),I=n.data.get(s.dataId).values,N=et(s.shape,"float32",I);for(let T=0;T<d.batchSize;++T)for(let _=0;_<d.inChannels;++_)for(let R=0;R<d.inHeight;++R)for(let S=0;S<d.inWidth;++S){let F=R-w,B=S-v,W=0;for(let q=0;q<b;q+=x){let K=(F+q)/m;if(!(K<0||K>=d.outHeight||Math.floor(K)!==K))for(let J=0;J<A;J+=y){let Q=(B+J)/g;if(Q<0||Q>=d.outWidth||Math.floor(Q)!==Q)continue;let ee=b*A-1-h.get(T,K,Q,_),ue=q*A+J,re=ee===ue?1:0;if(re===0)continue;W+=N.get(T,K,Q,_)*re}}k.set(W,T,R,S,_)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var dee={kernelName:Bx,backendName:"cpu",kernelFunc:BHe};function fee(e,t,n,r,s){let o=C.computeStrides(t),a=s1(e,t,n,o,s,"max"),i=fS(e,t,n,s,!0,r);return[a.values,i.values]}var hee={kernelName:Wx,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:o,pad:a,includeBatchInIndex:i}=t,l=n;Se(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=M.computePool2DInfo(r.shape,s,o,[1,1],a),[p,d]=fee(u,r.shape,r.dtype,i,c),f=l.write(p,c.outShape,r.dtype),h=l.write(d,c.outShape,r.dtype);return[{dataId:f,shape:c.outShape,dtype:r.dtype},{dataId:h,shape:c.outShape,dtype:"int32"}]}};function VHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=C.parseAxisParam(o,s.shape),u=M.computeOutAndReduceShapes(s.shape,i)[1],c=C.sizeFromShape(u),p=[],d=n.makeTensorInfo([],"float32",new Float32Array([c]));p.push(d);let f=ai({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});p.push(f);let h=rv({inputs:{a:f,b:d},backend:n});p.push(h);let m=yc({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:a}});return p.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var mee={kernelName:Op,backendName:"cpu",kernelFunc:VHe};function WHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;Se(s,"min");let i=C.parseAxisParam(o,s.shape),l=i,u=M.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=dr({inputs:{x:s},backend:n,attrs:{perm:u}}),l=M.getInnerMostAxes(l.length,s.shape.length)),M.assertAxesAreInnerMostDims("min",l,c.shape.length);let[p,d]=M.computeOutAndReduceShapes(c.shape,l),f=C.sizeFromShape(d),h=C.makeZerosTypedArray(C.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let x=0;x<h.length;++x){let y=x*f,b=m[y];for(let A=0;A<f;++A){let v=m[y+A];(Number.isNaN(v)||v<b)&&(b=v)}h[x]=b}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,h);if(a){let x=M.expandShapeToKeepDim(p,i),y=Mt({inputs:{x:g},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(g),y}return g}var gee={kernelName:Pp,backendName:"cpu",kernelFunc:WHe};function GHe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,mode:a}=r;Se(s,"mirrorPad");let i=o.map((b,A)=>b[0]+s.shape[A]+b[1]),l=o.map(b=>b[0]),u=o.map((b,A)=>b[0]+s.shape[A]),c=a==="reflect"?0:1,p=n.data.get(s.dataId).values,d=s.shape.length,f=C.computeStrides(s.shape),h=C.sizeFromShape(i),m=i.length,g=C.computeStrides(i),x=C.getTypedArrayFromDType(s.dtype,h);for(let b=0;b<h;b++){let A=C.indexToLoc(b,m,g);for(let w=0;w<m;w++)A[w]<l[w]?A[w]=l[w]*2-A[w]-c:A[w]>=u[w]&&(A[w]=(u[w]-1)*2-A[w]+c);A=A.map((w,k)=>w-l[k]);let v=C.locToIndex(A,d,f);x[b]=p[v]}return{dataId:n.write(x,i,s.dtype),shape:i,dtype:s.dtype}}var xee={kernelName:Mp,backendName:"cpu",kernelFunc:GHe};var UHe=Pt((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),jHe=Ht(Su,UHe),yee={kernelName:Su,backendName:"cpu",kernelFunc:jHe};var Aee=T1(GD());function vF(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:o}=r,a=s.shape.length,i=o;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let l=C.parseAxisParam([i],s.shape),u=AF({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=M.expandShapeToKeepDim(u.shape,l),p=Mt({inputs:{x:u},backend:n,attrs:{shape:c}}),d=tv({inputs:{a:s,b:p},backend:n}),f=H6({inputs:{x:d},backend:n}),h=yc({inputs:{x:f},backend:n,attrs:{axis:l,keepDims:!1}}),m=Mt({inputs:{x:h},backend:n,attrs:{shape:c}}),g=rv({inputs:{a:f,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var bee={kernelName:Qp,backendName:"cpu",kernelFunc:vF};function HHe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:o,seed:a,normalized:i}=r;Se(s,"multinomial");let l=i?s:vF({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],p=n.data.get(l.dataId).values,d=[u,o],f=C.makeZerosTypedArray(C.sizeFromShape(d),"int32");for(let h=0;h<u;++h){let m=h*c,g=new Float32Array(c-1);g[0]=p[m];for(let b=1;b<g.length;++b)g[b]=g[b-1]+p[m+b];let x=Aee.alea(a.toString()),y=h*o;for(let b=0;b<o;++b){let A=x();f[y+b]=g.length;for(let v=0;v<g.length;v++)if(A<g[v]){f[y+b]=v;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",f)}var vee={kernelName:Gx,backendName:"cpu",kernelFunc:HHe};var qHe=Ts.nonMaxSuppressionV3Impl;function KHe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=r;Se(s,"NonMaxSuppression");let u=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values,{selectedIndices:p}=qHe(u,c,a,i,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var wee={kernelName:Ux,backendName:"cpu",kernelFunc:KHe};var XHe=Ts.nonMaxSuppressionV4Impl;function ZHe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=r;Se(s,"NonMaxSuppressionPadded");let c=n.data.get(s.dataId).values,p=n.data.get(o.dataId).values,{selectedIndices:d,validOutputs:f}=XHe(c,p,a,i,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}var kee={kernelName:jx,backendName:"cpu",kernelFunc:ZHe};var YHe=Ts.nonMaxSuppressionV5Impl;function JHe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=r;Se(s,"NonMaxSuppressionWithScore");let c=n.data.get(s.dataId).values,p=n.data.get(o.dataId).values,d=a,f=i,h=l,m=u,{selectedIndices:g,selectedScores:x}=YHe(c,p,d,f,h,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var Iee={kernelName:Hx,backendName:"cpu",kernelFunc:JHe};function QHe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:o,onValue:a,offValue:i}=r;Se(s,"oneHot");let l=C.sizeFromShape(s.shape),u=new Float32Array(l*o);u.fill(i);let c=n.data.get(s.dataId).values;for(let p=0;p<l;++p)c[p]>=0&&c[p]<o&&(u[p*o+c[p]]=a);return n.makeTensorInfo([...s.shape,o],"int32",u)}var Cee={kernelName:Bp,backendName:"cpu",kernelFunc:QHe};function av(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let s=oi({inputs:{input:r},backend:n}),o=av({inputs:{x:s},backend:n}),a=_l({inputs:{input:r},backend:n}),i=av({inputs:{x:a},backend:n}),l=Br({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return ov({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var See={kernelName:rd,backendName:"cpu",kernelFunc:av};function Nee(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let s=oi({inputs:{input:r},backend:n}),o=Nee({inputs:{x:s},backend:n}),a=_l({inputs:{input:r},backend:n}),i=av({inputs:{x:a},backend:n}),l=Br({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return ov({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var Tee={kernelName:Lp,backendName:"cpu",kernelFunc:Nee};function wF(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return o1({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let o=t[0].shape,a=t[0].dtype;t.forEach(c=>{C.assertShapesMatch(o,c.shape,"All tensors passed to stack must have matching shapes"),C.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=t.map(c=>{let p=o1({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(p),p}),u=wd({inputs:l,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var _ee={kernelName:Vp,backendName:"cpu",kernelFunc:wF};function eqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,constantValue:a}=r;Se(s,"pad");let i=o.map((y,b)=>y[0]+s.shape[b]+y[1]),l=o.map(y=>y[0]),u=n.data.get(s.dataId).values,c=C.sizeFromShape(s.shape),p=s.shape.length,d=C.computeStrides(s.shape),f=C.sizeFromShape(i),h=i.length,m=C.computeStrides(i),g=C.getTypedArrayFromDType(s.dtype,f);a!==0&&g.fill(a);for(let y=0;y<c;y++){let A=C.indexToLoc(y,p,d).map((w,k)=>w+l[k]),v=C.locToIndex(A,h,m);g[v]=u[y]}return{dataId:n.write(g,i,s.dtype),shape:i,dtype:s.dtype}}var gS={kernelName:Wp,backendName:"cpu",kernelFunc:eqe};var tqe=Pt((e,t)=>Math.pow(e,t)),nqe=Ht(Tu,tqe),Eee={kernelName:Tu,backendName:"cpu",kernelFunc:nqe};function rqe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,dtype:o,step:a}=n,i=rS(r,s,a,o);return t.makeTensorInfo([i.length],o,i)}var Ree={kernelName:Kx,backendName:"cpu",kernelFunc:rqe};var sqe=pt(_u,e=>1/e),Dee={kernelName:_u,backendName:"cpu",kernelFunc:sqe};function oqe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:i}=r;Se(s,"resizeBilinear");let l=C.computeStrides(s.shape),[u,c]=i,[p,d,f,h]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(C.sizeFromShape([p,u,c,h])),x=[o&&u>1?d-1:d,o&&c>1?f-1:f],y=[o&&u>1?u-1:u,o&&c>1?c-1:c],b=0,A=x[0]/y[0],v=x[1]/y[1];for(let w=0;w<p;w++)for(let k=0;k<u;k++){let I;a?I=A*(k+.5)-.5:I=A*k;let N=Math.max(0,Math.floor(I)),T=I-N,_=Math.min(d-1,Math.ceil(I)),R=w*l[0]+N*l[1],S=w*l[0]+_*l[1];for(let F=0;F<c;F++){let B;a?B=v*(F+.5)-.5:B=v*F;let W=Math.max(0,Math.floor(B)),q=B-W,K=Math.min(f-1,Math.ceil(B)),J=R+W*l[2],Q=S+W*l[2],ee=R+K*l[2],ue=S+K*l[2];for(let re=0;re<h;re++){let de=m[J+re],fe=m[Q+re],me=m[ee+re],xe=m[ue+re],Ne=de+(me-de)*q,_e=fe+(xe-fe)*q,Oe=Ne+(_e-Ne)*T;g[b++]=Oe}}}return n.makeTensorInfo([p,u,c,h],"float32",g)}var $ee={kernelName:Hp,backendName:"cpu",kernelFunc:oqe};function aqe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:a}=r;Se([o,s],"resizeBilinearGrad");let i=C.computeStrides(s.shape),[l,u,c,p]=s.shape,[,d,f]=o.shape,h=new Float32Array(l*u*c*p),m=[a&&d>1?u-1:u,a&&f>1?c-1:c],g=[a&&d>1?d-1:d,a&&f>1?f-1:f],x=m[0]/g[0],y=m[1]/g[1],b=n.data.get(o.dataId).values,A=0;for(let v=0;v<l;v++){let w=v*i[0];for(let k=0;k<d;k++){let I=k*x,N=Math.floor(I),T=Math.min(Math.ceil(I),u-1),_=w+N*i[1],R=w+T*i[1],S=I-N,F=1-S;for(let B=0;B<f;B++){let W=B*y,q=Math.floor(W),K=Math.min(Math.ceil(W),c-1),J=W-q,Q=1-J,ee=_+q*i[2],ue=_+K*i[2],re=R+q*i[2],de=R+K*i[2],fe=F*Q,me=F*J,xe=S*Q,Ne=S*J;for(let _e=0;_e<p;_e++){let Oe=b[A++];h[ee+_e]+=Oe*fe,h[ue+_e]+=Oe*me,h[re+_e]+=Oe*xe,h[de+_e]+=Oe*Ne}}}}return n.makeTensorInfo([l,c,u,p],"float32",h)}var Fee={kernelName:Yx,backendName:"cpu",kernelFunc:aqe};function iqe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:i}=r;Se(s,"resizeNearestNeighbor");let l=C.computeStrides(s.shape),[u,c]=i,[p,d,f,h]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(p*u*c*h),x=[o&&u>1?d-1:d,o&&c>1?f-1:f],y=[o&&u>1?u-1:u,o&&c>1?c-1:c],b=x[0]/y[0],A=x[1]/y[1],v=0;for(let w=0;w<p;w++){let k=w*l[0];for(let I=0;I<u;I++){let N=a?b*(I+.5):b*I,T=Math.min(d-1,o?Math.round(N):Math.floor(N));a&&(T=Math.max(0,T));let _=k+T*l[1];for(let R=0;R<c;R++){let S=a?A*(R+.5):A*R,F=Math.min(f-1,o?Math.round(S):Math.floor(S));a&&(F=Math.max(0,F));let B=_+F*l[2];for(let W=0;W<h;W++){let q=m[B+W];g[v++]=q}}}}return n.makeTensorInfo([p,u,c,h],s.dtype,g)}var Oee={kernelName:jp,backendName:"cpu",kernelFunc:iqe};function lqe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:a}=r;Se([o,s],"resizeNearestNeighborGrad");let i=C.computeStrides(s.shape),l=C.computeStrides(o.shape),[u,c,p,d]=s.shape,[,f,h]=o.shape,m=new Float32Array(u*c*p*d),g=n.data.get(o.dataId).values,x=[a&&f>1?c-1:c,a&&h>1?p-1:p],y=[a&&f>1?f-1:f,a&&h>1?h-1:h],b=x[0]/y[0],A=x[1]/y[1],v=1/b,w=1/A,k=Math.ceil(v)*2+2,I=Math.ceil(w)*2+2;for(let N=0;N<u;N++){let T=N*i[0];for(let _=0;_<c;_++){let R=T+_*i[1],S=Math.floor(_*v),F=Math.floor(S-k/2);for(let B=0;B<p;B++){let W=R+B*i[2],q=Math.floor(B*w),K=Math.floor(q-I/2);for(let J=0;J<d;J++){let Q=0;for(let ee=0;ee<k;ee++){let ue=ee+F;if(ue<0||ue>=f)continue;let re=T+ue*l[1],de=ue*b,fe=Math.min(c-1,a?Math.round(de):Math.floor(de));if(_===fe)for(let me=0;me<I;me++){let xe=me+K;if(xe<0||xe>=h)continue;let Ne=re+xe*l[2],_e=xe*A,Oe=Math.min(p-1,a?Math.round(_e):Math.floor(_e));B===Oe&&(Q+=g[Ne+J])}}m[W+J]=Q}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}var Pee={kernelName:Zx,backendName:"cpu",kernelFunc:lqe};function uqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:o}=r;Se(s,"reverse");let a=s.shape.length,i=C.parseAxisParam(o,s.shape);if(a===0)return Es({inputs:{x:s},backend:n});let l=new sn(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){let p=l.indexToLoc(c),d=p.slice();i.forEach(f=>d[f]=s.shape[f]-1-d[f]),l.set(u.get(...d),...p)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var Mee={kernelName:qp,backendName:"cpu",kernelFunc:uqe};var zee={kernelName:dy,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:o,center:a}=t,i=n,l=C.getTypedArrayFromDType(r.dtype,C.sizeFromShape(r.shape)),[u,c,p,d]=r.shape,[f,h]=M.getImageCenter(a,c,p),m=255,g=Math.sin(s),x=Math.cos(s),y=i.data.get(r.dataId).values;for(let A=0;A<u;A++){let v=A*p*c*d;for(let w=0;w<c;w++){let k=w*(p*d);for(let I=0;I<p;I++){let N=I*d;for(let T=0;T<d;T++){let _=[u,w,I,T],R=_[2],S=_[1],F=(R-f)*x-(S-h)*g,B=(R-f)*g+(S-h)*x;F=Math.round(F+f),B=Math.round(B+h);let W=o;if(typeof o!="number"&&(T===3?W=m:W=o[T]),F>=0&&F<p&&B>=0&&B<c){let K=B*(p*d),J=F*d,Q=v+K+J+T;W=y[Q]}let q=v+k+N+T;l[q]=W}}}}return{dataId:i.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var cqe=pt(Du,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),Lee={kernelName:Du,backendName:"cpu",kernelFunc:cqe};function xS(e,t,n,r,s,o,a,i,l,u){let c=[r/s,s],p=e.values,d=t.values;if(r===0)return et(n,t.dtype);let f=et(c,t.dtype);f.values.fill(l);for(let h=0;h<o;h++){let m=[],g=0;for(let x=0;x<a;x++){let y=p[h*a+x];m.push(y),g+=y*i[x]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let x=0;x<s;x++)u?f.values[g*s+x]+=d[h*s+x]:f.values[g*s+x]=t.rank===0?d[0]:d[h*s+x]}return f}function pqe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:o}=t,{shape:a}=r,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=M.calculateShapes(o,s,a),d=!0,f=n.bufferSync(s),h=n.bufferSync(o),m=xS(f,h,a,p,u,l,i,c,0,d);return n.makeTensorInfo(a,m.dtype,m.values)}var Bee={kernelName:Jx,backendName:"cpu",kernelFunc:pqe};function dqe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:o}=t;Se([r,s,o],"select");let a=r.shape.length,i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,c=Or(s.dtype,o.dtype),p=C.makeZerosTypedArray(C.sizeFromShape(s.shape),c),d=0,f=a===0||a>1||s.shape.length===1?1:C.sizeFromShape(s.shape.slice(1));for(let h=0;h<i.length;h++)for(let m=0;m<f;m++)i[h]===1?p[d++]=l[h]:p[d++]=u[h];return n.makeTensorInfo(s.shape,c,p)}var Vee={kernelName:Kp,backendName:"cpu",kernelFunc:dqe};var fqe=M.SELU_SCALEALPHA,hqe=M.SELU_SCALE,mqe=pt(Fu,e=>e>=0?hqe*e:fqe*(Math.exp(e)-1)),Wee={kernelName:Fu,backendName:"cpu",kernelFunc:mqe};var gqe=pt(Mu,e=>e<0?-1:e>0?1:0),Gee={kernelName:Mu,backendName:"cpu",kernelFunc:gqe};var xqe=pt(Ou,e=>Math.sin(e)),Uee={kernelName:Ou,backendName:"cpu",kernelFunc:xqe};var yqe=pt(Pu,e=>Math.sinh(e)),jee={kernelName:Pu,backendName:"cpu",kernelFunc:yqe};var bqe=11920928955078125e-23,Hee=Math.log(bqe)+2,Aqe=pt(Lu,e=>{let t=e>-Hee,n=e<Hee,r=Math.exp(e),s;return n?s=r:t?s=e:s=Math.log(1+r),s}),qee={kernelName:Lu,backendName:"cpu",kernelFunc:Aqe};function vqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,paddings:a}=r;Se([s],"spaceToBatchND");let i=C.sizeFromShape(o),l=[[0,0]];l.push(...a);for(let w=1+o.length;w<s.shape.length;++w)l.push([0,0]);let u=gS.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=M.getReshaped(u.shape,o,i,!1),p=M.getPermuted(c.length,o.length,!1),d=M.getReshapedPermuted(u.shape,o,i,!1),m=Mt({inputs:{x:u},backend:n,attrs:{shape:c}}),y=dr({inputs:{x:m},backend:n,attrs:{perm:p}}),v=Mt({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),v}var Kee={kernelName:Yp,backendName:"cpu",kernelFunc:vqe};function wqe(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:o,defaultValue:a}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,c=n.data.get(a.dataId).values[0],[p,d,f,h,m]=sS(i,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],s.dtype,f),n.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Xee={kernelName:Qx,backendName:"cpu",kernelFunc:wqe};function kqe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:o}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);let a=Array.from(n.data.get(s.dataId).values),i=n.data.get(r.dataId).values,l=Array.from(n.data.get(o.dataId).values),[u,c,p]=oS(i,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([p.length],o.dtype,new Int32Array(p))]}var Zee={kernelName:ey,backendName:"cpu",kernelFunc:kqe};function Iqe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);let a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,[u,c]=n1(a,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var Yee={kernelName:ty,backendName:"cpu",kernelFunc:Iqe};function Cqe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);let a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,[u,c]=n1(a,r.shape,r.dtype,i,l);return n.makeTensorInfo(c,r.dtype,u)}var Jee={kernelName:ny,backendName:"cpu",kernelFunc:Cqe};function Sqe(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:a}=t,{outputShape:i}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:d}=M.calculateShapes(o,s,i),f=!1,h=n.bufferSync(s),m=n.bufferSync(o),g=n.data.get(a.dataId).values[0],x=xS(h,m,i,d,c,u,l,p,g,f);return n.makeTensorInfo(i,x.dtype,x.values)}var Qee={kernelName:ry,backendName:"cpu",kernelFunc:Sqe};function Nqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:o,axis:a}=r,i=C.parseAxisParam(a,s.shape)[0],l=M.prepareSplitSize(s,o,i),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(p=>{let d=[...c];d[i]=p;let f=li({inputs:{x:s},backend:n,attrs:{begin:u,size:d}});return u[i]+=p,f})}var ete={kernelName:Jp,backendName:"cpu",kernelFunc:Nqe};var tte={kernelName:sy,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;Se(n,"square");let s=r.data.get(n.dataId).values,o=new Float32Array(s.length);for(let i=0;i<s.length;++i){let l=s[i];o[i]=l*l}return{dataId:r.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Tqe=pt(ju,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),nte={kernelName:ju,backendName:"cpu",kernelFunc:Tqe};function _qe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=r;Se(s,"stridedSlice");let{nonStrided:f,$begin:h,$strides:m,size:g,newShape:x,outShape:y}=Cs.sliceInfo(s.shape,o,a,i,l,u,c,p,d),b=Mt({inputs:{x:s},backend:n,attrs:{shape:x}}),A;if(f){let w=li({inputs:{x:b},backend:n,attrs:{begin:h,size:g}});A=Mt({inputs:{x:w},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(w)}else if(y.some(w=>w===0))A=n.makeTensorInfo(y,s.dtype,[]);else{let w=n.bufferSync(b),k=aS(y,w,m,h);A=n.makeTensorInfo(k.shape,k.dtype,k.values)}let v=Mt({inputs:{x:A},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(A),v}var rte={kernelName:oy,backendName:"cpu",kernelFunc:_qe};function Eqe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=t,d=n.data.get(c.dataId).values,f=n.data.get(p.dataId).values,[h,m]=iS(d,f,s,o,a,i,l,u);return[n.makeTensorInfo([h.length],"string",h),n.makeTensorInfo(p.shape,"int32",m)]}var ste={kernelName:ay,backendName:"cpu",kernelFunc:Eqe};function Rqe(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:o,delimiter:a}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=n.data.get(o.dataId).values,l=n.data.get(a.dataId).values[0],[u,c,p]=lS(i,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var ote={kernelName:iy,backendName:"cpu",kernelFunc:Rqe};function Dqe(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let a=n.data.get(o.dataId).values,i=uS(a,s);return n.makeTensorInfo(o.shape,"int32",i)}var ate={kernelName:ly,backendName:"cpu",kernelFunc:Dqe};var $qe=pt(Gu,e=>Math.tan(e)),ite={kernelName:Gu,backendName:"cpu",kernelFunc:$qe};var Fqe=pt(Uu,e=>Math.tanh(e)),lte={kernelName:Uu,backendName:"cpu",kernelFunc:Fqe};function Oqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:o}=r;Se(s,"tile");let a=cS(n.bufferSync(s),o);return n.makeTensorInfo(a.shape,a.dtype,a.values)}var ute={kernelName:vl,backendName:"cpu",kernelFunc:Oqe};function Pqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:o,sorted:a}=r;Se(s,"topk");let i=n.data.get(s.dataId).values,[l,u]=pS(i,s.shape,s.dtype,o,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var cte={kernelName:uy,backendName:"cpu",kernelFunc:Pqe};function Mqe(e){let{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:o}=t,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=n,[c,p,d,f]=s.shape,[h,m]=u!=null?u:[p,d],g=[c,h,m,f],x=C.computeStrides(s.shape),y=x[0],b=x[1],A=x[2],v=C.getTypedArrayFromDType(s.dtype,C.sizeFromShape(g));v.fill(l);let w=r.data.get(s.dataId).values,k=r.data.get(o.dataId).values;for(let N=0;N<c;++N){let T=o.shape[0]===1?k:k.subarray(N*8,N*8+8);for(let _=0;_<h;++_)for(let R=0;R<m;++R)for(let S=0;S<f;++S){let F,B=T[6]*R+T[7]*_+1;if(B===0)continue;let W=(T[0]*R+T[1]*_+T[2])/B,q=(T[3]*R+T[4]*_+T[5])/B,K=dte(W,d,i),J=dte(q,p,i);switch(a){case"nearest":F=Wqe(w,p,d,y,b,A,N,J,K,S,l);break;case"bilinear":F=Gqe(w,p,d,y,b,A,N,J,K,S,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let Q=N*y+_*b+R*A+S;v[Q]=F}return r.makeTensorInfo(g,s.dtype,v)}return{dataId:r.write(v,g,s.dtype),shape:s.shape,dtype:s.dtype}}var pte={kernelName:cy,backendName:"cpu",kernelFunc:Mqe};function dte(e,t,n){switch(n){case"reflect":return zqe(e,t);case"wrap":return Lqe(e,t);case"nearest":return Vqe(e,t);case"constant":default:return Bqe(e,t)}}function zqe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return C.clamp(0,n,t-1)}function Lqe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return C.clamp(0,n,t-1)}function Bqe(e,t){return e}function Vqe(e,t){return C.clamp(0,e,t-1)}function iv(e,t,n,r,s,o,a,i,l,u,c){let p=a*r+i*s+l*o+u;return 0<=i&&i<t&&0<=l&&l<n?e[p]:c}function Wqe(e,t,n,r,s,o,a,i,l,u,c){let p=Math.round(i),d=Math.round(l);return iv(e,t,n,r,s,o,a,p,d,u,c)}function Gqe(e,t,n,r,s,o,a,i,l,u,c){let p=Math.floor(i),d=Math.floor(l),f=p+1,h=d+1,m=(h-l)*iv(e,t,n,r,s,o,a,p,d,u,c)+(l-d)*iv(e,t,n,r,s,o,a,p,h,u,c),g=(h-l)*iv(e,t,n,r,s,o,a,f,d,u,c)+(l-d)*iv(e,t,n,r,s,o,a,f,h,u,c);return(f-i)*m+(i-p)*g}function Uqe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:o}=t;Se(o,"unique");let a=r.data.get(o.dataId).values,{outputValues:i,outputShape:l,indices:u}=dS(a,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,i),r.makeTensorInfo([u.length],"int32",u)]}var fte={kernelName:py,backendName:"cpu",kernelFunc:Uqe};function jqe(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:o}=r;o<0&&(o+=s.shape.length);let a=s.shape.length,i=s.shape[o],l=new Array(a-1),u=0;for(let f=0;f<a;f++)f!==o&&(l[u++]=s.shape[f]);let c=new Array(a).fill(0),p=s.shape.slice();p[o]=1;let d=new Array(i);for(let f=0;f<d.length;f++){c[o]=f;let h=li({inputs:{x:s},backend:n,attrs:{begin:c,size:p}});d[f]=Mt({inputs:{x:h},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(h)}return d}var hte={kernelName:td,backendName:"cpu",kernelFunc:jqe};function Hqe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:o}=t,{numSegments:a}=r;Se(s,"unsortedSegmentSum");let i=s.shape.length,l=o.shape.length,u=[],c=[],p=i-l,d=o;for(let h=0;h<p;++h){let m=o1({inputs:{input:d},backend:n,attrs:{dim:h+1}});d=m,c.push(m)}for(let h=0;h<a;++h){let m=C.createScalarValue(h,"int32"),g=n.makeTensorInfo([],"int32",m),x=U6({inputs:{a:g,b:d},backend:n}),y=ai({inputs:{x},backend:n,attrs:{dtype:"float32"}}),b=Om({inputs:{a:y,b:s},backend:n}),A=yc({inputs:{x:b},backend:n,attrs:{axis:0,keepDims:!1}});u.push(A),c.push(g),c.push(x),c.push(y),c.push(b),c.push(A)}let f=wF({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(h=>n.disposeIntermediateTensorInfo(h)),f}var mte={kernelName:nd,backendName:"cpu",kernelFunc:Hqe};var qqe=[qJ,iJ,KJ,XJ,dJ,ZJ,YJ,JJ,QJ,eQ,tQ,nQ,rQ,sQ,oQ,iQ,lQ,uQ,cQ,HJ,pQ,dQ,fQ,hQ,pJ,fJ,mQ,lJ,gQ,yQ,AQ,vQ,bQ,kQ,IQ,wQ,CQ,SQ,NQ,TQ,_Q,EQ,RQ,DQ,$Q,FQ,OQ,MQ,PQ,sv,LQ,BJ,BQ,hJ,VQ,mJ,WQ,gJ,GQ,UQ,jQ,xJ,HQ,qQ,KQ,XQ,ZQ,yJ,bJ,uJ,YQ,xQ,JQ,QQ,eee,VJ,AJ,vJ,tee,wJ,nee,ree,see,oee,aee,iee,kJ,uee,cee,pee,dee,hee,lee,mee,gee,IJ,xee,yee,vee,CJ,SJ,wee,kee,Iee,NJ,Cee,Tee,_ee,gS,Eee,WJ,_J,Ree,cJ,Dee,GJ,UJ,jJ,$ee,Fee,Oee,Pee,Mee,zee,Lee,EJ,Bee,Vee,Wee,DJ,Gee,Uee,jee,$J,bee,qee,Kee,Xee,Zee,Yee,Jee,Qee,ete,OJ,tte,PJ,nte,rte,ste,ote,ate,zJ,zQ,ite,lte,ute,cte,TJ,pte,fte,hte,mte,See];for(let e of qqe)g3(e);var Pm={},kF={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function gte(e,t){Pm[e]=t}function Ca(e){if(!(e in Pm)){let n=Xqe(e);if(n!==null)Pm[e]=n;else return console.log("Could not get context for WebGL version",e),null}let t=Pm[e];return t.isContextLost()?(delete Pm[e],Ca(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Pm[e])}function Kqe(e){if(typeof OffscreenCanvas!="undefined"&&e===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Xqe(e){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=Kqe(e);return t.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete Pm[e]},!1),e===1?t.getContext("webgl",kF)||t.getContext("experimental-webgl",kF):t.getContext("webgl2",kF)}var kd;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(kd||(kd={}));var Rs;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Rs||(Rs={}));var xs;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(xs||(xs={}));function Mm(e,t){return[t,e]}function xte(e,t){return e*t}function lv(e){let t=C.sizeFromShape(e),n=Math.ceil(t/4);return C.sizeToSquarishShape(n)}function El(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function yte(e,t){let[n,r]=El(e,t);return n*r*4}function uv(e,t){let n=e,r,s,o,a,i,l,u,c,p,d;return he().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,o=n.RGBA16F,a=n.RGBA32F,i=n.RED,u=4,c=1,p=n.HALF_FLOAT,d=n.FLOAT):(r=e.RGBA,s=e.RGBA,o=e.RGBA,a=n.RGBA,i=e.RGBA,u=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,d=e.FLOAT),l=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:d}}function ot(e,t){let n=t();return he().getBool("DEBUG")&&Zqe(e),n}function Zqe(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+Qqe(e,t))}var Yqe=596e-10,Jqe=65504;function bte(e){return!!(he().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Yqe<Math.abs(e)&&Math.abs(e)<Jqe)}function Qqe(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function cv(e,t){return bc(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function Ate(e,t){let n=bc(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ot(e,()=>e.shaderSource(n,t)),ot(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function vte(e,t){let n=bc(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ot(e,()=>e.shaderSource(n,t)),ot(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw tKe(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var eKe=/ERROR: [0-9]+:([0-9]+):/g;function tKe(e,t){let n=eKe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],s=e.split(`
`),o=s.length.toString().length+2,a=s.map((p,d)=>C.rightPad((d+1).toString(),o)+p),i=0;for(let p=0;p<a.length;p++)i=Math.max(a[p].length,i);let l=a.slice(0,r-1),u=a.slice(r-1,r),c=a.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${C.rightPad(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function wte(e){return bc(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function kte(e,t){if(ot(e,()=>e.linkProgram(t)),e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function yS(e,t){if(ot(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Ite(e,t){let n=bc(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ot(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),ot(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Cte(e,t){let n=bc(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ot(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),ot(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Ste(e){return bc(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function Nte(e,t){let n=he().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function Tte(e){return bc(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function IF(e,t,n,r,s,o,a){let i=e.getAttribLocation(t,n);return i===-1?!1:(ot(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),ot(e,()=>e.vertexAttribPointer(i,s,e.FLOAT,!1,o,a)),ot(e,()=>e.enableVertexAttribArray(i)),!0)}function nKe(e,t,n){sKe(e,n),ot(e,()=>e.activeTexture(e.TEXTURE0+n)),ot(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function _te(e,t,n){return bc(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function Ete(e,t,n){return e.getUniformLocation(t,n)}function Rte(e,t,n,r){ot(e,()=>nKe(e,t,r)),ot(e,()=>e.uniform1i(n,r))}function bS(e,t,n){ot(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),ot(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function CF(e,t){ot(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),ot(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function pv(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+rKe(e,t))}function rKe(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function bc(e,t,n){let r=ot(e,()=>t());if(r==null)throw new Error(n);return r}function sKe(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Id(e,t=2){return C.sizeFromShape(e.slice(0,e.length-t))}function Cd(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function AS(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Id(e),...Cd(e)]),t}function Dte(e,t=!1){let n=he().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(n=n*2,e=e.map((s,o)=>o>=e.length-2?C.nearestLargerEven(e[o]):e[o]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=C.squeezeShape(e).newShape);let r=C.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(e.length===2&&e[0]<=n&&e[1]<=n)return e;if(e.length===3&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(e.length===3&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){let s=Id(e),o=2,a=2;return e.length&&([o,a]=Cd(e)),r=s*(o/2)*(a/2),C.sizeToSquarishShape(r).map(i=>i*2)}return C.sizeToSquarishShape(r)}function vS(e){return e%2==0}function zm(e,t){if(e=e.slice(-2),t=t.slice(-2),C.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r||vS(n)&&vS(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&vS(e[0])&&vS(t[0])}var SF,NF;function $te(e){if(SF==null){let t=Ca(e);SF=t.getParameter(t.MAX_TEXTURE_SIZE)}return SF}function Fte(e){if(NF==null){let t=Ca(e);NF=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,NF)}function Ote(e){if(e===0)return 0;let t,n=Ca(e);return Sa(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Sa(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Sa(e,t){return e.getExtension(t)!=null}function TF(e){try{if(Ca(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Pte(e){if(e===0)return!1;let t=Ca(e);if(e===1){if(!Sa(t,"OES_texture_float"))return!1}else if(!Sa(t,"EXT_color_buffer_float"))return!1;return _F(t)}function Mte(e){if(e===0)return!1;let t=Ca(e);if(e===1){if(!Sa(t,"OES_texture_float")||!Sa(t,"WEBGL_color_buffer_float"))return!1}else{if(Sa(t,"EXT_color_buffer_float"))return _F(t);let r="EXT_color_buffer_half_float";if(Sa(t,r)){let s=t.getExtension(r);return oKe(t,s)}return!1}return _F(t)}function _F(e){let t=uv(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(o),a}function oKe(e,t){let n=uv(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let s=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),i}function zte(e){return e!==2?!1:Ca(e).fenceSync!=null}function Rl(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&C.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var yt=he();yt.registerFlag("HAS_WEBGL",()=>yt.getNumber("WEBGL_VERSION")>0);yt.registerFlag("WEBGL_VERSION",()=>TF(2)?2:TF(1)?1:0);yt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);yt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>yt.get("WEBGL_VERSION")===2);yt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);yt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);yt.registerFlag("WEBGL_PACK",()=>yt.getBool("HAS_WEBGL"));yt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_CLIP",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_PACK_REDUCE",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_LAZILY_UNPACK",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_CONV_IM2COL",()=>yt.getBool("WEBGL_PACK"));yt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>$te(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Fte(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=yt.getNumber("WEBGL_VERSION");return e===0?0:Ote(e)});yt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>yt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Gh.isMobile());yt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Pte(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>yt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:yt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));yt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Mte(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>zte(yt.getNumber("WEBGL_VERSION")));yt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>yt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);yt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});yt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Gh.isMobile()&&yt.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});yt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);yt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);yt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);yt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function Vn(){let e,t,n,r,s,o,a,i,l,u;return he().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",o="outputColor",a="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function Yi(e,t,n="index"){let r=C.computeStrides(t);return r.map((s,o)=>{let a=`int ${e[o]} = ${n} / ${s}`,i=o===r.length-1?`int ${e[o+1]} = ${n} - ${e[o]} * ${s}`:`index -= ${e[o]} * ${s}`;return`${a}; ${i};`}).join("")}function Lm(e,t,n="index"){let r=C.computeStrides(t);return r.map((s,o)=>{let a=`int ${e[o]} = ${n} / outShapeStrides[${o}]`,i=o===r.length-1?`int ${e[o+1]} = ${n} - ${e[o]} * outShapeStrides[${o}]`:`index -= ${e[o]} * outShapeStrides[${o}]`;return`${a}; ${i};`}).join("")}function aKe(e,t){let n=e.length,r=e.map(o=>`${t}[${o}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let o=n-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function Lte(e,t,n="index"){let r=e.map((o,a)=>a),s=aKe(r,t);return s.map((o,a)=>{let i=`int ${e[a]} = ${n} / ${s[a]}`,l=a===s.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s[a]}`:`index -= ${e[a]} * ${s[a]}`;return`${i}; ${l};`}).join("")}function a1(e){let t=C.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function i1(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var wS=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:Bte}=M;function Vte(e,t,n){let r=[];if(e.forEach(f=>{let h=C.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${h>1?`[${h}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),n.enableShapeUniforms){let{uniformShape:m}=kS(n.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let s=r.join(`
`),o=e.map(f=>iKe(f,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),a=t.texShape,i=Vn(),l=cKe(i),u,c,p=fKe(i);return t.isPacked?(u=lKe(t.logicalShape,a,n.enableShapeUniforms),c=dKe(i)):(u=uKe(t.logicalShape,a,n.enableShapeUniforms),c=pKe(i)),n.packedInputs&&(p+=xKe),[p,l,c,s,u,o,n.userCode].join(`
`)}function l1(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return _Ke(e,t);case 1:return RKe(e,t);case 2:return $Ke(e,t);case 3:return OKe(e,t);case 4:return MKe(e,t);case 5:return zKe(e);case 6:return LKe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Wte(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return TKe(e);case 1:return EKe(e,t);case 2:return DKe(e,t);case 3:return FKe(e,t);default:return PKe(e,t)}}function iKe(e,t,n=!1,r){let s="";n?s+=Wte(e,r):s+=l1(e,r);let o=e.shapeInfo.logicalShape,a=t.logicalShape;return o.length<=a.length&&(n?s+=BKe(e,t):s+=VKe(e,t)),s}function lKe(e,t,n){switch(e.length){case 0:return Gte();case 1:return yKe(e,t,n);case 2:return SKe(e,t,n);case 3:return AKe(e,t,n);default:return wKe(e,t,n)}}function uKe(e,t,n){switch(e.length){case 0:return Gte();case 1:return bKe(e,t,n);case 2:return NKe(e,t,n);case 3:return vKe(e,t,n);case 4:return kKe(e,t,n);case 5:return IKe(e,t);case 6:return CKe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function cKe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function pKe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function dKe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function fKe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${hKe}
    ${mKe}
    ${gKe}
  `}var hKe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,mKe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,gKe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,xKe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Gte(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function yKe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function bKe(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function AKe(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),o=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function vKe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Lm(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=Yi(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function wKe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),o=s*Math.ceil(e[e.length-2]/2),a=o,i="",l="b, r, c";for(let u=2;u<e.length-1;u++)a*=e[e.length-u-1],i=`
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    `+i,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${i}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${l});
    }
  `}function kKe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Lm(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=Yi(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function IKe(e,t){let n=Yi(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function CKe(e,t){let n=Yi(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function SKe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(C.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function NKe(e,t,n){return C.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Bm(e){return`offset${e}`}function TKe(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Vn();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function _Ke(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[s,o]=e.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let a=Bm(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});
      return sampleTexture(${n}, uv);
    }
  `;let[i,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${i}, ${l}, ${a});
      return sampleTexture(${n}, uv);
    }
  `}function EKe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,o=Vn();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;let a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function RKe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${u1(e)}
      }
    `;let s=e.shapeInfo.texShape,o=s[0],a=s[1];if(a===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Bm(n);return a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${a}, index + ${i});
      return sampleTexture(${n}, uv);
    }
  `}function DKe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=o[0],i=o[1],l=Vn();if(o!=null&&C.arraysEqual(n,o))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function $Ke(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape;if(o!=null&&C.arraysEqual(n,o)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=o[0],f=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:a,keptDims:i}=C.squeezeShape(n),l=a;if(l.length<n.length){let d=c1(e,l),f=["row","col"];return`
      ${l1(d,t)}
      float ${s}(int row, int col) {
        return ${s}(${p1(f,i)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${u1(e)}
      }
    `;let u=o[0],c=o[1],p=Bm(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function FKe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){let d=n.slice(1),f=[1,2],h=c1(e,d),m=["b","row","col"];return`
        ${Wte(h,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${p1(m,f)});
        }
      `}let i=Vn();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `;let l=a[0],u=a[1],c=Math.ceil(n[2]/2),p=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${p}, ${c}, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `}function OKe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],a=n[2],{newShape:i,keptDims:l}=C.squeezeShape(n),u=i;if(u.length<n.length){let m=c1(e,u),g=["row","col","depth"];return`
        ${l1(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${p1(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${a}, 1)));
        ${u1(e)}
      }
    `;let c=e.shapeInfo.texShape,p=c[0],d=c[1],f=e.shapeInfo.flatOffset;if(d===o&&f==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===a&&f==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let h=Bm(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * ${o} + col * ${a} + depth + ${h};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${a} + depth + ${h};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function PKe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Vn();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;let o=e.shapeInfo.logicalShape,a=o.length,i=e.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=l[0],c=l[1],p=Math.ceil(o[a-1]/2),d=p*Math.ceil(o[a-2]/2),f="int b, int row, int col",h=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let m=2;m<a-1;m++)f=`int b${m}, `+f,d*=o[a-m-1],h=`b${m} * ${d} + `+h;return`
    vec4 ${r}(${f}) {
      int index = ${h};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function MKe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],a=n[2]*o,i=n[1]*a,{newShape:l,keptDims:u}=C.squeezeShape(n);if(l.length<n.length){let y=c1(e,l),b=["row","col","depth","depth2"];return`
      ${l1(y,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${p1(b,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${o}, 1)));
        ${u1(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],f=p[1],h=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===i&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${h}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(f===o&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let x=Bm(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${x});
      return sampleTexture(${r}, uv);
    }
  `}function zKe(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],o=t[3]*s,a=t[2]*o,i=t[1]*a,{newShape:l,keptDims:u}=C.squeezeShape(t);if(l.length<t.length){let m=c1(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${l1(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${p1(g,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${o}, ${s})) +
          depth3;
        ${u1(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],f=p[1];if(f===i&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;let h=Bm(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${o} +
          depth2 * ${s} + depth3 + ${h};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function LKe(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=C.squeezeShape(t);if(s.length<t.length){let g=c1(e,s),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${l1(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${p1(x,o)});
      }
    `}let a=t[5],i=t[4]*a,l=t[3]*i,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${u1(e)}
      }
    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,f=d[0],h=d[1];if(h===c&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===a&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=Bm(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${m};
      vec2 uv = uvFromFlat(${f}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function u1(e){let t=e.name,n=C.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function BKe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,a=t.logicalShape.length,i=Bte(e.shapeInfo.logicalShape,t.logicalShape),l=Ct(a),u=a-o,c,p=["x","y","z","w","u","v"];o===0?c="":a<2&&i.length>=1?c="coords = 0;":c=i.map(y=>`coords.${p[y+u]} = 0;`).join(`
`);let d="";a<2&&o>0?d="coords":d=e.shapeInfo.logicalShape.map((y,b)=>`coords.${p[b+u]}`).join(", ");let f="return outputValue;",m=C.sizeFromShape(e.shapeInfo.logicalShape)===1,x=C.sizeFromShape(t.logicalShape)===1;if(o===1&&!m&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!x)a===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(i.length){let y=o-2,b=o-1;i.indexOf(y)>-1&&i.indexOf(b)>-1?f="return vec4(outputValue.x);":i.indexOf(y)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(b)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${d});
      ${f}
    }
  `}function VKe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=t.texShape,a=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===l&&e.shapeInfo.flatOffset==null&&C.arraysEqual(a,o))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let u=Ct(l),c=Bte(e.shapeInfo.logicalShape,t.logicalShape),p=l-i,d,f=["x","y","z","w","u","v"];i===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(m=>`coords.${f[m+p]} = 0;`).join(`
`);let h="";return l<2&&i>0?h="coords":h=e.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${r}(${h});
    }
  `}function Ct(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function kS(e,t,n){let{newShape:r,keptDims:s}=C.squeezeShape(t),o=t.length,a=e&&o===3&&t[0]===1,i=a?t.slice(1):r,l=!e&&o>1&&!C.arraysEqual(t,n)&&r.length<o||a;return{useSqueezeShape:l,uniformShape:l?i:t,keptDims:s}}function c1(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function p1(e,t){return t.map(n=>e[n]).join(", ")}function Ute(e,t,n,r){let s=n.map((b,A)=>{let v={logicalShape:b.shape,texShape:b.isUniform?null:b.texData.texShape,isUniform:b.isUniform,isPacked:b.isUniform?!1:b.texData.isPacked,flatOffset:null};return b.texData!=null&&b.texData.slice!=null&&b.texData.slice.flatOffset>0&&(v.flatOffset=b.texData.slice.flatOffset),{name:t.variableNames[A],shapeInfo:v}}),o=s.map(b=>b.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=Vte(s,a,t),l=e.createProgram(i),u=null,c=e.getUniformLocation(l,"NAN",!1);he().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(l,"INFINITY",!1));let p=!1,d={},f={},h={};for(let b=0;b<t.variableNames.length;b++){let A=t.variableNames[b];d[A]=e.getUniformLocation(l,A,p),d[`offset${A}`]=e.getUniformLocation(l,`offset${A}`,p),t.enableShapeUniforms&&(f[`${A}Shape`]=e.getUniformLocation(l,`${A}Shape`,p),h[`${A}TexShape`]=e.getUniformLocation(l,`${A}TexShape`,p))}let m,g,x;t.enableShapeUniforms&&(m=e.getUniformLocation(l,"outShape",p),x=e.getUniformLocation(l,"outShapeStrides",p),g=e.getUniformLocation(l,"outTexShape",p));let y=[];return t.customUniforms&&t.customUniforms.forEach((b,A)=>{y[A]=e.getUniformLocation(l,b.name,p)}),{program:t,source:i,webGLProgram:l,uniformLocations:d,customUniformLocations:y,inShapeInfos:o,outShapeInfo:a,infLoc:u,nanLoc:c,inShapesLocations:f,inTexShapesLocations:h,outShapeLocation:m,outShapeStridesLocation:x,outTexShapeLocation:g}}function jte(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let s=n.logicalShape,o=t[r],a=o.shape;if(!C.arraysEqual(s,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${a} must match`);if(n.isUniform&&o.isUniform)return;let i=n.texShape,l=o.isUniform?null:o.texData.texShape;if(!C.arraysEqual(i,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${l} must match`)})}function Hte(e,t,n,r,s){t.program.enableShapeUniforms||(jte(t.inShapeInfos,n),jte([t.outShapeInfo],[r]));let o=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(o,a[0],a[1]):e.setOutputMatrixTexture(o,a[0],a[1]),e.setProgram(t.webGLProgram),he().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((l,u)=>{let c=t.program.variableNames[u],p=t.uniformLocations[c],d=t.uniformLocations[`offset${c}`],f=t.inShapesLocations[`${c}Shape`],h=t.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:m}=kS(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(f,new Int32Array(m));break;case 2:e.gl.uniform2iv(f,new Int32Array(m));break;case 3:e.gl.uniform3iv(f,new Int32Array(m));break;case 4:e.gl.uniform4iv(f,new Int32Array(m));break;default:break}}if(h&&e.gl.uniform2i(h,l.texData.texShape[0],l.texData.texShape[1]),p!=null){if(l.isUniform){if(C.sizeFromShape(l.shape)<2)e.gl.uniform1f(p,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(p,m)}return}l.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,l.texData.slice.flatOffset),e.setInputMatrixTexture(l.texData.texture,p,u)}});let i=t.outShapeLocation;if(i)switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let l=C.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break;default:break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((l,u)=>{let c=t.customUniformLocations[u],p=s[u];if(l.type==="float")e.gl.uniform1fv(c,p);else if(l.type==="vec2")e.gl.uniform2fv(c,p);else if(l.type==="vec3")e.gl.uniform3fv(c,p);else if(l.type==="vec4")e.gl.uniform4fv(c,p);else if(l.type==="int")e.gl.uniform1iv(c,p);else if(l.type==="ivec2")e.gl.uniform2iv(c,p);else if(l.type==="ivec3")e.gl.uniform3iv(c,p);else if(l.type==="ivec4")e.gl.uniform4iv(c,p);else throw Error(`uniform type ${l.type} is not supported yet.`)}),e.executeProgram()}function qte(e,t,n){let r="";t.concat(n).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!a.isUniform){let l=a.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:p}=kS(e.packedInputs,a.shape,l),d="",f="",h="";if(c.length===1&&e.packedInputs){let v=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${v[0]>1}_${v[1]>1}`}else if(c.length===2&&!e.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let v=C.computeStrides(c);h=`${v[0]===l[1]}_${v[v.length-1]===l[1]}`}let m=a.shape.length,g=c.length===2&&C.arraysEqual(a.shape,l),x=C.sizeFromShape(a.shape)===1,y=M.getBroadcastDims(a.shape,n.shape),b=!e.packedInputs&&m===n.shape.length&&C.arraysEqual(l,n.texData.texShape),A=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${b}_${u?p:""}_${c.length}_${x}_${y}_${g}_${d}_${f}_${h}_${A}_${i}`}else{let l=a.isUniform?"uniform":a.texData.texShape;r+=`${a.shape}_${l}_${i}`}});let s=e.userCode,o=e.constructor.name;return o+="_"+r+"_"+s+`${he().getNumber("WEBGL_VERSION")}`,o}function Xn(e){return he().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var EF=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=kd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Vn();this.outputShape=t,this.enableShapeUniforms=Xn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Lm(["r","c","d"],t):Yi(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}};var RF=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=kd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Vn();this.outputShape=t,this.enableShapeUniforms=Xn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Lm(["r","c","d"],t):Yi(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}};var DF=class{constructor(t){this.variableNames=["A"],this.outTexUsage=Rs.DOWNLOAD;let n=Vn();this.outputShape=t,this.userCode=`
      ${wS}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}};var $F=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Rs.DOWNLOAD;let n=Vn();this.outputShape=t,this.userCode=`
      ${wS}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}};var FF=class{constructor(t,n=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Vn();this.outputShape=t,this.enableShapeUniforms=Xn(this.outputShape.length);let s="result";n&&(s="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?i1():a1(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var OF=class{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Vn();this.outputShape=t,this.enableShapeUniforms=Xn(this.outputShape.length);let s="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let l=a*2+i;s+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?i1():a1(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}};function Kte(e){let t=Vn(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Ate(e,n)}function Xte(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Ite(e,t)}function Zte(e){let t=new Uint16Array([0,1,2,2,1,3]);return Cte(e,t)}function dv(e,t,n,r,s,o){Nte(t,n);let a=Ste(e),i=e.TEXTURE_2D;return ot(e,()=>e.bindTexture(i,a)),ot(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),ot(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),ot(e,()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST)),ot(e,()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST)),ot(e,()=>e.texImage2D(i,0,r,t,n,0,s,o,null)),ot(e,()=>e.bindTexture(e.TEXTURE_2D,null)),a}function PF(e){return e.internalFormatFloat}function Yte(e,t,n,r){let[s,o]=Mm(t,n);return dv(e,s,o,PF(r),r.textureFormatFloat,e.FLOAT)}function MF(e){return e.internalFormatHalfFloat}function Jte(e,t,n,r){let[s,o]=Mm(t,n);return dv(e,s,o,MF(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function zF(e){return e.downloadTextureFormat}function Qte(e,t,n,r){let[s,o]=Mm(t,n);return dv(e,s,o,zF(r),e.RGBA,e.UNSIGNED_BYTE)}function LF(e){return e.internalFormatPackedFloat}function ene(e,t,n,r){let[s,o]=El(t,n);return dv(e,s,o,LF(r),e.RGBA,e.FLOAT)}function BF(e){return e.internalFormatPackedHalfFloat}function tne(e,t,n,r){let[s,o]=El(t,n);return dv(e,s,o,BF(r),e.RGBA,r.textureTypeHalfFloat)}function nne(e,t,n){let r=0,s=3*4,o=3*4+2*4;return ot(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),IF(e,t,"clipSpacePos",n,3,o,r)&&IF(e,t,"uv",n,2,o,s)}function rne(e,t,n,r,s,o){ot(e,()=>e.bindTexture(e.TEXTURE_2D,t));let a,i,l;s instanceof Uint8Array?(a=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,l=e.RGBA):(a=new Float32Array(n*r*4),i=e.FLOAT,l=o.internalFormatPackedFloat),a.set(s),ot(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,i,a)),ot(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function sne(e,t,n){ot(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?ot(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):ot(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),ot(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function one(e,t,n,r){let s=e.createBuffer();ot(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));let i=4*4*t*n;return ot(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),ot(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),ot(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function ane(e,t,n){let r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function ine(e,t,n,r){let[s,o]=Mm(t,n),a=4,i=new Uint8Array(xte(t*n,a));return ot(e,()=>e.readPixels(0,0,s,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function lne(e,t,n,r,s,o,a,i){let l=e,u=new Float32Array(yte(o,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function une(e,t,n){let r=new Float32Array(t*n*4);return ot(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var VF=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let n=he().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,gte(n,t)):this.gl=Ca(n);let r="WEBGL_color_buffer_float",s="EXT_color_buffer_half_float";if(he().getNumber("WEBGL_VERSION")===1){let o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=cv(this.gl,o),Sa(this.gl,a))this.textureHalfFloatExtension=cv(this.gl,a);else if(he().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Sa(this.gl,s))this.colorBufferHalfFloatExtension=cv(this.gl,s);else if(he().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Sa(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Sa(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Xte(this.gl),this.indexBuffer=Zte(this.gl),this.framebuffer=Tte(this.gl),this.textureConfig=uv(this.gl,this.textureHalfFloatExtension)}get debug(){return he().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;ot(t,()=>t.finish()),ot(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ot(t,()=>t.deleteFramebuffer(this.framebuffer)),ot(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ot(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ot(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),Yte(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),Jte(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),Qte(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed(),sne(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,r,s){this.throwIfDisposed(),rne(this.gl,t,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),tne(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),ene(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(CF(this.gl,this.framebuffer),this.outputTexture=null),ot(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,r){return this.downloadMatrixDriver(t,()=>ine(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,r,s,o,a){return lne(this.gl,t,n,r,s,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,n){return ane(this.gl,t,n)}createBufferFromTexture(t,n,r){this.bindTextureToFrameBuffer(t);let s=one(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,r;if(he().getBool("WEBGL_FENCE_API_ENABLED")){let s=t,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{let a=s.clientWaitSync(o,0,0);return a===s.ALREADY_SIGNALED||a===s.CONDITION_SATISFIED},n=o}else he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(t,n,r){return this.downloadMatrixDriver(t,()=>une(this.gl,n,r))}createProgram(t){this.throwIfDisposed();let n=this.gl,r=vte(n,t);this.vertexShader==null&&(this.vertexShader=Kte(n));let s=wte(n);return ot(n,()=>n.attachShader(s,this.vertexShader)),ot(n,()=>n.attachShader(s,r)),kte(n,s),this.debug&&yS(n,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=nne(n,this.program,this.vertexBuffer)),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&ot(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&yS(this.gl,this.program),ot(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,r=!0){return this.throwIfDisposed(),r?_te(this.gl,t,n):Ete(this.gl,t,n)}getAttributeLocation(t,n){return this.throwIfDisposed(),ot(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),Rte(this.gl,t,n,r)}setOutputMatrixTexture(t,n,r){this.setOutputMatrixTextureDriver(t,r,n)}setOutputPackedMatrixTexture(t,n,r){this.throwIfDisposed();let[s,o]=El(n,r);this.setOutputMatrixTextureDriver(t,s,o)}setOutputMatrixWriteRegion(t,n,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,n)}setOutputPackedMatrixWriteRegion(t,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&yS(this.gl,this.program),pv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),ot(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ot(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=cv(this.gl,he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}let t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if(he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await C.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0)return null;if(n===2){let r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}else{let r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(n===0)return!0;if(n===2){let r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){let t=WKe(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){let{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),!(this.itemsToPoll.length>1)&&C.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),bS(this.gl,t,this.framebuffer),this.debug&&pv(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(bS(this.gl,this.outputTexture,this.framebuffer),this.debug&&pv(this.gl)):CF(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);let r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,n,r){this.throwIfDisposed();let s=this.gl;bS(s,t,this.framebuffer),this.debug&&pv(s),this.outputTexture=t,ot(s,()=>s.viewport(0,0,n,r)),ot(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(t,n,r,s){this.throwIfDisposed(),ot(this.gl,()=>this.gl.scissor(t,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function WKe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:cne,bincountImpl:IS,bincountReduceImpl:pne,ceilImpl:dne,concatImpl:fne,equalImpl:hne,expImpl:mne,expm1Impl:gne,floorImpl:xne,gatherNdImpl:yne,gatherV2Impl:bne,greaterImpl:Ane,greaterEqualImpl:vne,lessImpl:wne,lessEqualImpl:kne,linSpaceImpl:Ine,logImpl:Cne,maxImpl:Sne,maximumImpl:Nne,minimumImpl:Tne,multiplyImpl:_ne,negImpl:Ene,notEqualImpl:Rne,prodImpl:Dne,rangeImpl:$ne,rsqrtImpl:Fne,sigmoidImpl:One,simpleAbsImpl:CS,sliceImpl:Pne,sparseFillEmptyRowsImpl:Mne,sparseReshapeImpl:zne,sparseSegmentReductionImpl:SS,sqrtImpl:Lne,stridedSliceImpl:Bne,stringNGramsImpl:Vne,stringSplitImpl:Wne,stringToHashBucketFastImpl:Gne,subImpl:Une,tileImpl:jne,topKImpl:Hne,transposeImpl:Vm,uniqueImpl:qne}=cF;function WF(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function ir(e,t){return t===1?[e]:WF(e,t)}function Kne(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var GF=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;let n=t.length;if(n===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let r=ir("rc",n),s=Ct(n),o=UKe(n,t,r),a=jKe(n,t[t.length-1],t[t.length-2],r),i=HKe(t,r);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}};function GKe(e,t){let n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let a=2;a<e;a++)o=`${t[t.length-1-a]},`+o;n.push(o)}return n}function UKe(e,t,n){if(e===1)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s]}`,s<e-1&&(r+="||");return r}function jKe(e,t,n,r){if(e===1)return"";let s=r.slice(-2);return`
    int r = ${s[0]};
    int c = ${s[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${t};
    bool rEdge = rp1 >= ${n};
  `}function HKe(e,t){let n=e.length,r=GKe(n,t);return n===1?`getA(rc),
            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${r[0]}),
          cEdge ? 0. : getA(${r[1]}),
          rEdge ? 0. : getA(${r[2]}),
          rEdge || cEdge ? 0. : getA(${r[3]})`}var fv=class{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Xn(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${qKe(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?i1():a1(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${r}

        setOutput(result);
      }
    `}};function qKe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Lte(["r","c","d"],"inputShape"):Yi(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var UF=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,n,r){let s=Zne(n,r),o=Yne(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);let a=Xne(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let l=this.freeTextures[o].shift();return this.usedTextures[o].push(l),l}let i;return s===xs.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===xs.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===xs.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===xs.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===xs.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(t,n,r,s){if(this.freeTextures==null)return;let o=Zne(r,s),a=Yne(n,o,s);a in this.freeTextures||(this.freeTextures[a]=[]);let i=Xne(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=he().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=i):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let u=this.usedTextures[a],c=u.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n)});for(let t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function KKe(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}function Xne(e,t,n,r,s){let o=XKe(t,r),a;if(s){let[l,u]=El(e[0],e[1]);a=l*u}else{let[l,u]=Mm(e[0],e[1]);a=l*u}let i=KKe(n,o);return a*i}function XKe(e,t){switch(e){case xs.PACKED_2X2_FLOAT32:return LF(t);case xs.PACKED_2X2_FLOAT16:return BF(t);case xs.UNPACKED_FLOAT32:return PF(t);case xs.UNPACKED_FLOAT16:return MF(t);case xs.PACKED_4X1_UNSIGNED_BYTE:return zF(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function ZKe(e){return he().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?xs.PACKED_2X2_FLOAT32:xs.UNPACKED_FLOAT32:e?xs.PACKED_2X2_FLOAT16:xs.UNPACKED_FLOAT16}function Zne(e,t){if(e===Rs.UPLOAD)return xs.PACKED_2X2_FLOAT32;if(e===Rs.RENDER||e==null)return ZKe(t);if(e===Rs.DOWNLOAD||e===Rs.PIXELS)return xs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Yne(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var $o=class{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Xn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Qr="if (isnan(x)) return x;",Jne="return x;",jF="return abs(x);";var Qne="return (x >= 0.0) ? x : (exp(x) - 1.0);",ere=Qr+`
  return (x < 0.0) ? 0.0 : x;
`,tre=Qr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,hv="return x;",nre="return 1.0 / (1.0 + exp(-1.0 * x));";var rre="return x;",sre=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ore=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,are=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ire="return 1.0 / (1.0 + exp(-1.0 * x));",Ji=class{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Xn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var HF=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;let n=t.length,r=ir("rc",n),s=Ct(n),o=Kne(n,r),a=r.slice(-2),i=n<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}};var YKe=Ts.whereImpl,JKe=1e-7,QKe=1e-4,NS={};function eXe(e){return e in NS||(NS[e]={}),NS[e]}var tXe=he().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),nXe=600;function rXe(){return he().global.screen==null?1024:he().global.screen.height*he().global.screen.width*window.devicePixelRatio*nXe/1024/1024}var d1=class extends up{constructor(t){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!he().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(t==null){let n=Ca(he().getNumber("WEBGL_VERSION"));this.binaryCache=eXe(he().getNumber("WEBGL_VERSION")),this.gpgpu=new VF(n),this.canvas=n.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;this.textureManager=new UF(this.gpgpu),this.numMBBeforeWarning=rXe(),this.texData=new ux(this,Zu())}nextDataId(){return d1.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,n,r){if((he().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||he().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:t,usage:Rs.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,r,s,o){if(he().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:n,usage:Rs.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:o,slice:a,shape:i,isPacked:l}=n;if(a!=null){let d;l?d=new Ji(i,hv):d=new $o(i,hv);let f=this.runWebGLProgram(d,[{dataId:t,shape:i,dtype:s}],s),h=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),h}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;let u=this.activeTimers!=null,c;u&&(c=C.now());let p;if(s==="complex64"){let d=this.readSync(o.real.dataId),f=this.readSync(o.imag.dataId);p=M.mergeRealAndImagArrays(d,f)}else p=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=C.now()-c),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){let h=this.pendingRead.get(t);return new Promise(m=>h.push(m))}let n=this.texData.get(t),{values:r,shape:s,slice:o,dtype:a,complexTensorInfos:i,isPacked:l}=n;if(o!=null){let h;l?h=new Ji(s,hv):h=new $o(s,hv);let m=this.runWebGLProgram(h,[{dataId:t,shape:s,dtype:a}],a),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(!he().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&he().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(a!=="complex64"&&he().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let h=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(h.texture,...lv(s))}this.pendingRead.set(t,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(a==="complex64"){let h=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),m=h[0],g=h[1];p=M.mergeRealAndImagArrays(m,g)}else if(u==null)p=this.getValuesFromTexture(t);else{let h=C.sizeFromShape(s);p=this.gpgpu.downloadFloat32MatrixFromBuffer(u,h)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let h=this.gpgpu.gl;ot(h,()=>h.deleteBuffer(u))}let d=this.convertAndCacheOnCPU(t,p),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(h=>h(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Zu().removeDataId(t,this),this.pendingDeletes--),d}bufferSync(t){let n=this.readSync(t.dataId),r=n;if(t.dtype==="string")try{r=n.map(s=>C.decodeString(s))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return et(t.shape,t.dtype,r)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let r=t[n];if(!bte(r))throw he().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:r,isPacked:s}=this.texData.get(t),o=C.sizeFromShape(n);if(he().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(t),f=this.texData.get(d.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(f.texture,...lv(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(d),h}let a=he().getBool("WEBGL_PACK")&&s===!0,i=a?AS(n):n,l=a?new $F(i):new DF(i),u=this.runWebGLProgram(l,[{shape:i,dtype:r,dataId:t}],"float32"),c=this.texData.get(u.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),p}timerAvailable(){return he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(t){let n=this.activeTimers,r=[],s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();let o=C.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=C.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(o);i.kernelMs=C.sum(l),i.getExtraProfileInfo=()=>l.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:C.now(),endMs:null}}endTimer(t){return he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=C.now(),t)}async getQueryTime(t){if(he().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:r,texShape:s,usage:o,isPacked:a,slice:i}=this.texData.get(t),l=i&&i.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,o,a)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=tXe){return he().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&C.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){M.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return YKe(t.shape,n)}packedUnaryOp(t,n,r){let s=new Ji(t.shape,n),o=this.compileAndRun(s,[t],r);return Zu().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let s=CS(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(he().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,jF,t.dtype);let n=new $o(t.shape,jF),r=this.compileAndRun(n,[t]);return Zu().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&C.isString(r[0])){let o=r.map(a=>C.encodeString(a));s=this.write(o,t,n)}else s=this.write(r,t,n);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:n}}makeOutput(t,n,r){let{dataId:s}=this.makeTensorInfo(t,n,r);return Zu().makeTensorFromDataId(s,t,n,this)}unpackTensor(t){let n=new HF(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new GF(t.shape),r=!0;return this.runWebGLProgram(n,[t],t.dtype,null,r)}packedReshape(t,n){let r=[Id(t.shape),...Cd(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[Id(n),...Cd(n)],a=new fv(o,r),i=!0,l=[r],u=this.runWebGLProgram(a,[s],t.dtype,l,i);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t){let n=this.texData.get(t),{isPacked:r,shape:s,dtype:o}=n,a=AS(s),i,l=lv(a);r?i=new RF(a):i=new EF(a);let u=!0,c=[l],p=this.runWebGLProgram(i,[{shape:a,dtype:o,dataId:t}],o,c,u);return{dtype:o,shape:s,dataId:p.dataId}}runWebGLProgram(t,n,r,s,o=!1){let a=this.makeTensorInfo(t.outputShape,r),i=this.texData.get(a.dataId);if(t.packedOutput&&(i.isPacked=!0),t.outPackingScheme===kd.DENSE){let g=lv(t.outputShape);i.texShape=g.map(x=>x*2)}if(t.outTexUsage!=null&&(i.usage=t.outTexUsage),C.sizeFromShape(a.shape)===0)return i.values=C.getTypedArrayFromDType(a.dtype,0),a;let l=[],u=n.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(g.dataId);if(x.texture==null){if(!t.packedInputs&&C.sizeFromShape(g.shape)<=he().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:x.values};t.packedInputs&&(x.isPacked=!0,x.shape=g.shape)}else if(!!x.isPacked!=!!t.packedInputs)g=x.isPacked?this.unpackTensor(g):this.packTensor(g),l.push(g),x=this.texData.get(g.dataId);else if(x.isPacked&&!zm(x.shape,g.shape)){let y=g,b=g.shape;g.shape=x.shape,g=this.packedReshape(g,b),l.push(g),x=this.texData.get(g.dataId),y.shape=b}return this.uploadToGPU(g.dataId),{shape:g.shape,texData:x,isUniform:!1}});this.uploadToGPU(a.dataId);let c={shape:a.shape,texData:i,isUniform:!1},p=qte(t,u,c),d=this.getAndSaveBinary(p,()=>Ute(this.gpgpu,t,u,c)),f=this.activeTimers!=null,h;f&&(h=this.startTimer()),Hte(this.gpgpu,d,u,c,s),l.forEach(g=>this.disposeIntermediateTensorInfo(g)),f&&(h=this.endTimer(h),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(h)}));let m=he().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let g=C.now();g-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!he().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&o===!1){let g=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),g}return a}compileAndRun(t,n,r,s,o=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,s,o)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(he().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=le(()=>{if(!he().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=he().getBool("DEBUG");he().set("DEBUG",!1);let n=this.abs(Ke(1e-8)).dataSync()[0];if(he().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?JKe:QKe}uploadToGPU(t){let n=this.texData.get(t),{shape:r,dtype:s,values:o,texture:a,usage:i,isPacked:l}=n;if(a!=null)return;let u=this.activeTimers!=null,c;u&&(c=C.now());let p=n.texShape;if(p==null&&(p=Dte(r,l),n.texShape=p),o!=null){let d=AS(r),f,h=p[1],m=p[0],g=o instanceof Uint8Array;l?([h,m]=El(p[0],p[1]),f=new OF(d,g)):f=new FF(d,g);let x=this.makeTensorInfo([m,h],s);g?this.texData.get(x.dataId).usage=Rs.PIXELS:this.texData.get(x.dataId).usage=Rs.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),h,m,o);let y=[[m,h]],b=!0,A=this.runWebGLProgram(f,[x],s,y,b),v=this.texData.get(A.dataId);n.texture=v.texture,n.texShape=v.texShape,n.isPacked=v.isPacked,n.usage=v.usage,this.disposeIntermediateTensorInfo(x),this.texData.delete(A.dataId),n.values=null,u&&(this.uploadWaitMs+=C.now()-c)}else{let d=this.acquireTexture(p,i,s,l);n.texture=d}}convertAndCacheOnCPU(t,n){let r=this.texData.get(t),{dtype:s}=r;return this.releaseGPUData(t),n!=null&&(r.values=sXe(n,s)),r.values}acquireTexture(t,n,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*C.bytesPerElement(n)}};d1.nextDataId=0;function sXe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}Gh.isBrowser()&&R3("webgl",()=>new d1,2);var TS=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var ui=class{constructor(t,n,r){this.variableNames=["A","B"],this.outputShape=M.assertAndGetBroadcastShape(n,r),this.enableShapeUniforms=Xn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Sd=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Qi=class{constructor(t,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=M.assertAndGetBroadcastShape(n,r);let o=this.outputShape.length;this.enableShapeUniforms=Xn(o);let a="";if(s)if(o===0||C.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ct(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let l=ir("coords",o);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function lr(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var lre={kernelName:Al,backendName:"webgl",kernelFunc:lr};function Fo(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(o.dataId),i=lr({inputs:{x:r},backend:n}),l=lr({inputs:{x:s},backend:n});return a.complexTensorInfos={real:i,imag:l},o}var ure={kernelName:vx,backendName:"webgl",kernelFunc:Fo};var qF="return (a < 0.) ? b * a : a;",KF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function oXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:o}=r,a=n.makeTensorInfo([],"float32",C.createScalarValue(o,"float32")),i=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qi(KF,s.shape,a.shape):new ui(qF,s.shape,a.shape),l=n.runWebGLProgram(i,[s,a],s.dtype);return n.disposeIntermediateTensorInfo(a),l}var cre={kernelName:Ep,backendName:"webgl",kernelFunc:oXe};var XF="return (a < 0.) ? b * a : a;",ZF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function aXe(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,o=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qi(ZF,r.shape,s.shape):new ui(XF,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)}var pre={kernelName:Gp,backendName:"webgl",kernelFunc:aXe};var _S="if (isnan(x)) return x;",dre=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,fre=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function Xe({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{let{x:a}=s,i=o,l=r||a.dtype;if(i.shouldExecuteOnCPU([a])&&n!=null){let p=i.texData.get(a.dataId),d=n(p.values,l);return i.makeTensorInfo(a.shape,l,d)}let u=he().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new Ji(a.shape,t):c=new $o(a.shape,e),i.runWebGLProgram(c,[a],l)}}function Qt({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:a,backend:i})=>{let{a:l,b:u}=a,c=i;if(r&&l.dtype==="complex64"){let h=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,x]=[[h.complexTensorInfos.real,m.complexTensorInfos.real],[h.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(b=>{let[A,v]=b,w={dataId:A.dataId,dtype:A.dtype,shape:l.shape},k={dataId:v.dataId,dtype:v.dtype,shape:u.shape},I=new ui(e,l.shape,u.shape);return c.runWebGLProgram(I,[w,k],Or(A.dtype,v.dtype))}),y=Fo({inputs:{real:g,imag:x},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(x),y}let p=o||Or(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){let h=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?M.fromUint8ToStringArray(h):h,x=l.dtype==="string"?M.fromUint8ToStringArray(m):m,[y,b]=s(l.shape,u.shape,g,x,p),A=c.makeTensorInfo(b,p),v=c.texData.get(A.dataId);return v.values=y,A}let d=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return d?f=new Qi(t,l.shape,u.shape,n):f=new ui(e,l.shape,u.shape),c.runWebGLProgram(f,[l,u],p)}}function Nd(e,t=!1){if(e==="linear")return t?rre:Jne;if(e==="relu")return t?ore:ere;if(e==="elu")return t?sre:Qne;if(e==="relu6")return t?are:tre;if(e==="prelu")return t?ZF:XF;if(e==="leakyrelu")return t?KF:qF;if(e==="sigmoid")return t?ire:nre;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var mv=class{constructor(t,n,r,s=!1,o=!1,a=!1,i=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Xn(this.outputShape.length);let c=s?t[1]:t[2],p=Math.ceil(c/2),d=s?"i * 2, rc.y":"rc.y, i * 2",f=o?"rc.z, i * 2":"i * 2, rc.z",h=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",x="";i&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,x="result = activation(result);");let y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",A="rc.x";t[0]<n[0]?b=`int(min(float(rc.x), ${t[0]-1}.))`:n[0]<t[0]&&(A=`int(min(float(rc.x), ${n[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${b};
          int batchB = ${A};
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${m[0]});
          result += (${h[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${x}

        setOutput(result);
      }
    `}};var YF={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},ES=class{constructor(t,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=M.assertAndGetBroadcastShape(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var hre="return a * b;";function gv(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,o=M.upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){let i=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new ES(YF.REAL,r.shape,s.shape),c=new ES(YF.IMAG,r.shape,s.shape),p=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:r.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],d=n.runWebGLProgram(u,p,"float32"),f=n.runWebGLProgram(c,p,"float32"),h=Fo({inputs:{real:d,imag:f},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),h}if(n.shouldExecuteOnCPU([r,s])){let i=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=_ne(r.shape,s.shape,i.values,l.values,o),p=n.makeTensorInfo(c,o),d=n.texData.get(p.dataId);return d.values=u,p}let a;return he().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Qi(hre,r.shape,s.shape):a=new ui(hre,r.shape,s.shape),n.runWebGLProgram(a,[r,s],o)}var mre={kernelName:Nu,backendName:"webgl",kernelFunc:gv};function gre(e,t,n){let r=[Id(e.shape),...Cd(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Id(t),...Cd(t)],a=new fv(o,r),i=!0,l=[r],u=n.runWebGLProgram(a,[s],e.dtype,l,i);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function $e(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:o}=r,a=n,i=C.sizeFromShape(s.shape),l=C.inferFromImplicitShape(o,i),u=C.sizeFromShape(l);C.assert(i===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let c=a.texData.get(s.dataId);return c.isPacked&&!zm(s.shape,l)&&!(c.texture!==null&&zm(c.shape,l))?gre(s,l,a):(a.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}var xre={kernelName:Up,backendName:"webgl",kernelFunc:$e};var RS=class{constructor(t,n){this.variableNames=["x"];let{windowSize:r,batchSize:s,inSize:o,outSize:a}=t;this.outputShape=[s,a];let i=Math.floor(r/4)*4,l=r%4,u="sumValue += dot(values, ones);";if(n!=null){let p=1/n;u=`sumValue += dot(values * ${C.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";o%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};var JF=class{constructor(t,n){this.variableNames=["x"];let{windowSize:r,batchSize:s,inSize:o,outSize:a}=t;this.outputShape=[s,a];let i="0.0",l="";n==="prod"?i="1.0":n==="min"?(i="1.0 / 1e-20",l="min"):n==="max"&&(i="-1.0 / 1e-20",l="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?u="sumValue":n==="prod"?u="prodValue":n==="all"?u="allValue":n==="any"&&(u="anyValue");let c=Math.floor(r/4)*4,p=r%4,d=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";n==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):n==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let h="";o%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};function iXe(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=M.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function la(e,t,n,r){let s=iXe(e.shape),o=e;for(let a=0;a<s.length;a++){let{inSize:i,windowSize:l,outSize:u}=s[a],c,p;n==="mean"?c=a===0?new RS({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u},i):new RS({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u}):c=new JF({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u},n),p=o,o=r.runWebGLProgram(c,[o],t),p.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(p)}return o}var QF=class{constructor(t,n){this.variableNames=["A"];let r=new Array(t.length);for(let a=0;a<r.length;a++)r[a]=t[n[a]];this.outputShape=r,this.rank=r.length;let s=Ct(this.rank),o=lXe(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}};function lXe(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}var e8=class{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=new Array(t.length);for(let c=0;c<r.length;c++)r[c]=t[n[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let s=Ct(this.rank),o=WF("rc",this.rank),a=new Array(this.rank);for(let c=0;c<n.length;c++)a[n[c]]=o[c];let i=`vec2(${a.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function Td(e,t,n){let r=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new e8(e.shape,t):new QF(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function yre(e,t,n,r){let s=t,o=e.shape.length,a=C.parseAxisParam(s,e.shape),i=a,l=M.getAxesPermutation(i,o),u=l!=null,c=e;u&&(c=Td(e,l,r),i=M.getInnerMostAxes(i.length,o)),M.assertAxesAreInnerMostDims("sum",i,o);let[p,d]=M.computeOutAndReduceShapes(c.shape,i),f=p;n&&(f=M.expandShapeToKeepDim(p,a));let h=C.sizeFromShape(d),g=C.sizeFromShape(e.shape)/h,x=$e({inputs:{x:c},attrs:{shape:[g,h]},backend:r}),y=Vh(e.dtype),b=la(x,y,"sum",r),A=$e({inputs:{x:b},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),A}function Wm(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r;return yre(s,o,a,n)}var bre={kernelName:Zp,backendName:"webgl",kernelFunc:Wm};function On(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:o}=r,a=n,i=s.shape.length,l=new Array(i);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(a.shouldExecuteOnCPU([s])){let p=a.texData.get(s.dataId).values,d=Vm(p,s.shape,s.dtype,o,l);u=a.makeTensorInfo(l,s.dtype);let f=a.texData.get(u.dataId);f.values=d}else u=Td(s,o,a);return u}var Are={kernelName:ed,backendName:"webgl",kernelFunc:On};var t8=1e3;function Gm({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,p=n?e.shape[u-2]:e.shape[u-1],d=r?t.shape[c-1]:t.shape[c-2],f=n?e.shape[u-1]:e.shape[u-2],h=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),x=C.sizeFromShape(m),y=C.sizeFromShape(g),b=x===y||x===1||y===1;C.assert(u>=2&&c>=2&&b,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);let v=(x>y?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([f,h]);C.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let w=n?[x,p,f]:[x,f,p],k=r?[y,h,d]:[y,d,h],I=$e({inputs:{x:e},backend:s,attrs:{shape:w}}),N=$e({inputs:{x:t},backend:s,attrs:{shape:k}}),T=[I,N],_=Math.max(x,y),R=n?I.shape[1]:I.shape[2],S=o!=null,F=a!=null,B=l==="leakyrelu",W=l!=null?Nd(l,!0):null,q=S||F||B||W!=null,K;if((f===1||h===1)&&R>t8&&q===!1){let Q=I,ee=N;n&&(Q=On({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),T.push(Q)),r&&(ee=On({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),T.push(ee));let ue=h!==1,re=h===1,de=Q;ue&&(de=$e({inputs:{x:Q},backend:s,attrs:{shape:[_,R,1]}}),T.push(de));let fe=h===1?2:1,me=ee;re&&(me=$e({inputs:{x:ee},backend:s,attrs:{shape:[_,1,R]}}),T.push(me));let xe=gv({inputs:{a:de,b:me},backend:s});K=Wm({inputs:{x:xe},backend:s,attrs:{axis:fe,keepDims:!0}}),T.push(xe)}else{let Q=Or(e.dtype,t.dtype),ee=new mv(w,k,[_,f,h],n,r,S,W,F,B),ue=[I,N];if(o!=null&&ue.push(o),F&&ue.push(a),B){let re=s.makeTensorInfo([],"float32",C.createScalarValue(i,"float32"));ue.push(re),T.push(re)}K=s.runWebGLProgram(ee,ue,Q)}let J=$e({inputs:{x:K},backend:s,attrs:{shape:v}});T.push(K);for(let Q of T)s.disposeIntermediateTensorInfo(Q);return J}function uXe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o,bias:a,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r;return Gm({a:s,b:o,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:i,leakyreluAlpha:p,activation:c})}var vre={kernelName:$h,backendName:"webgl",kernelFunc:uXe};var wre="return abs(x);";function cXe(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let o=n.texData.get(r.dataId),a=CS(o.values);return n.makeTensorInfo(r.shape,r.dtype,a)}let s;return he().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Ji(r.shape,wre):s=new $o(r.shape,wre),n.runWebGLProgram(s,[r],r.dtype)}var kre={kernelName:pp,backendName:"webgl",kernelFunc:cXe};var pXe=Qr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,dXe=Xe({opSnippet:pXe}),Ire={kernelName:eu,backendName:"webgl",kernelFunc:dXe};var fXe=Qr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,hXe=Xe({opSnippet:fXe}),Cre={kernelName:tu,backendName:"webgl",kernelFunc:hXe};var Sre="return a + b;",mXe=Qt({opSnippet:Sre,packedOpSnippet:Sre,supportsComplex:!0,cpuKernelImpl:cne}),Nre={kernelName:Ri,backendName:"webgl",kernelFunc:mXe};var n8=class{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((o,a)=>`T${a}`);let r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});let s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}};var r8=class{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((o,a)=>`T${a}`);let r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});let s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};function DS(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return lr({inputs:{x:r[0]},backend:n});if(r.length>he().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(r.length/2),u=DS({inputs:r.slice(0,l),backend:n}),c=DS({inputs:r.slice(l),backend:n});return DS({inputs:[u,c],backend:n})}let s=r.map(l=>l.dtype).reduce((l,u)=>Or(l,u)),o=r.map(l=>l.shape),i=he().getBool("WEBGL_PACK")?new r8(r[0].shape,o):new n8(r[0].shape,o);return n.runWebGLProgram(i,r,s)}var Tre={kernelName:dp,backendName:"webgl",kernelFunc:DS};function gXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=s.shape.length,l=C.parseAxisParam(o,s.shape),u=l,c=M.getAxesPermutation(u,i),p=s;c!=null&&(p=On({inputs:{x:s},backend:n,attrs:{perm:c}}),u=M.getInnerMostAxes(u.length,i)),M.assertAxesAreInnerMostDims("all",u,i);let[d,f]=M.computeOutAndReduceShapes(p.shape,u),h=C.sizeFromShape(f),m=$e({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}}),g=la(m,m.dtype,"all",n),x;if(a){let y=M.expandShapeToKeepDim(d,l);x=$e({inputs:{x:g},backend:n,attrs:{shape:y}})}else x=$e({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(p),x}var _re={kernelName:gx,backendName:"webgl",kernelFunc:gXe};function xXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=s.shape.length,l=C.parseAxisParam(o,s.shape),u=l,c=M.getAxesPermutation(u,i),p=s;c!=null&&(p=On({inputs:{x:s},backend:n,attrs:{perm:c}}),u=M.getInnerMostAxes(u.length,i)),M.assertAxesAreInnerMostDims("any",u,i);let[d,f]=M.computeOutAndReduceShapes(p.shape,u),h=C.sizeFromShape(f),m=$e({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}}),g=la(m,m.dtype,"any",n),x;if(a){let y=M.expandShapeToKeepDim(d,l);x=$e({inputs:{x:g},backend:n,attrs:{shape:y}})}else x=$e({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(p),x}var Ere={kernelName:xx,backendName:"webgl",kernelFunc:xXe};var s8=class{constructor(t,n,r){this.variableNames=["A"];let{windowSize:s,batchSize:o,outSize:a}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];let i=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var o8=class{constructor(t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C.assert(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let o=t[t.length-1],a=Math.ceil(o/n);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),s||this.variableNames.push("bestIndicesA");let i=this.outputShape,l=i.length,u=Ct(l),c=ir("coords",l),p,d;if(a===1){d=l+1;let I=Ct(d);p=`
        ${I} sourceLocR = ${I}(${c.join()}, 0);
        ++${c[l-1]};
        ${I} sourceLocG = ${I}(${c.join()}, 0);
        ++${c[l-2]};
        ${I} sourceLocA = ${I}(${c.join()}, 0);
        --${c[l-1]};
        ${I} sourceLocB = ${I}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,p=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;let f=["x","y","z","w","u","v"].slice(0,d),h="."+f[d-1],m=f.map(I=>"int "+I),g=ir("sourceLocR",d-1).concat("inIdx.r"),x=ir("sourceLocG",d-1).concat("inIdx.g"),y=ir("sourceLocB",d-1).concat("inIdx.b"),b=ir("sourceLocA",d-1).concat("inIdx.a"),A=r==="max"?"greaterThan":"lessThan",v=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${i[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${i[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${A}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function Rre(e,t,n,r=null){let s=t.shape[0],o=t.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);let a=M.computeOptimalWindowSize(o),i={windowSize:a,inSize:o,batchSize:s,outSize:Math.ceil(o/a)},l=new s8(i,n,r==null),u=[t];r!=null&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let p=Rre(e,t,n,c);return e.disposeIntermediateTensorInfo(c),p}function Dre(e,t,n,r=null){let s=r!=null?r.shape:t.shape,o=s[s.length-1],a=M.computeOptimalWindowSize(o),i=new o8(s,a,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(i,l,"int32");if(u.shape.length===t.shape.length){let c=Dre(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function $S(e,t,n,r){let s=[n];if(M.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!he().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let o=[],a=e.texData.get(t.dataId),i=a!==null&&a.isPacked,l=t;i&&(l=e.unpackTensor(t),o.push(l));let[u,c]=M.computeOutAndReduceShapes(l.shape,s),p=C.sizeFromShape(c),d=$e({inputs:{x:l},backend:e,attrs:{shape:[-1,p]}});o.push(d);let f=Rre(e,d,r);o.push(f);let h=$e({inputs:{x:f},backend:e,attrs:{shape:u}});return o.forEach(m=>e.disposeIntermediateTensorInfo(m)),h}return Dre(e,t,r)}function yXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r,a=C.parseAxisParam(o,s.shape),i=M.getAxesPermutation(a,s.shape.length),l=s,u=[];i!=null&&(l=On({inputs:{x:s},backend:n,attrs:{perm:i}}),u.push(l),a=M.getInnerMostAxes(a.length,l.shape.length)),M.assertAxesAreInnerMostDims("argMax",[a[0]],l.shape.length);let c=$S(n,l,a[0],"max");return u.forEach(p=>n.disposeIntermediateTensorInfo(p)),c}var $re={kernelName:fp,backendName:"webgl",kernelFunc:yXe};function bXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r,a=C.parseAxisParam(o,s.shape),i=M.getAxesPermutation(a,s.shape.length),l=s,u=[];i!=null&&(l=On({inputs:{x:s},backend:n,attrs:{perm:i}}),u.push(l),a=M.getInnerMostAxes(a.length,l.shape.length)),M.assertAxesAreInnerMostDims("argMin",[a[0]],l.shape.length);let c=$S(n,l,a[0],"min");return u.forEach(p=>n.disposeIntermediateTensorInfo(p)),c}var Fre={kernelName:hp,backendName:"webgl",kernelFunc:bXe};var AXe=Qr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,vXe=Xe({opSnippet:AXe}),Ore={kernelName:nu,backendName:"webgl",kernelFunc:vXe};var wXe=Qr+"return log(x + sqrt(x * x + 1.0));",kXe=Xe({opSnippet:wXe}),Pre={kernelName:ru,backendName:"webgl",kernelFunc:kXe};var IXe=Qr+`
  return atan(x);
`,CXe=Xe({opSnippet:IXe}),Mre={kernelName:su,backendName:"webgl",kernelFunc:CXe};var SXe=dre+`
  return atan(a, b);
`,NXe=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+fre+`
  return result;
`,TXe=Qt({opSnippet:SXe,packedOpSnippet:NXe}),zre={kernelName:au,backendName:"webgl",kernelFunc:TXe};var _Xe=Qr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,EXe=Xe({opSnippet:_Xe}),Lre={kernelName:ou,backendName:"webgl",kernelFunc:EXe};var Dl=class{constructor(t,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let a=t.filterWidth,i=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,d=t.effectiveFilterWidth,f=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;let m=n==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,x=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,y="0.0";if(m||(y="-1.0 / 1e-20"),r){let I=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${l});
        const ivec2 pads = ivec2(${f}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?g:x:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",A=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(A="avgValue / count");let v=Math.floor(a/4)*4,w=a%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${f}, ${h});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${v};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${A});
      }
    `}},Um=class{constructor(t,n,r,s=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let a=t.filterWidth,i=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,d=t.dilationWidth,f=t.effectiveFilterDepth,h=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,x=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;let b=n==="avg",A="0.0";if(b||(A="-1.0 / 1e-20"),r){let T=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${l}, ${u});
        const ivec3 pads = ivec3(${g}, ${x}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${T} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${h} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",w=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(w="avgValue / count");let k=Math.floor(a/4)*4,I=a%4,N=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${l}, ${u});
      const ivec3 pads = ivec3(${g}, ${x}, ${y});
      const float initializationValue = ${A};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${A});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${N}
            }

            int xC = xCCorner + ${k};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${N}
            }
          }
          setOutput(${w});
        }
      }
    `}};function RXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Rl(s,"avgPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,u=1;C.assert(M.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=M.computePool2DInfo(s.shape,o,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&C.arraysEqual(c.inShape,c.outShape))return lr({inputs:{x:s},backend:n});let p=new Dl(c,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}var Bre={kernelName:mp,backendName:"webgl",kernelFunc:RXe};function DXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],p=M.computePool3DInfo(s.shape,o,a,c,i,l,u),d=new Um(p,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}var Vre={kernelName:gp,backendName:"webgl",kernelFunc:DXe};var a8=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=l-1-t.padInfo.top,p=u-1-t.padInfo.left,d=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},i8=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,d=t.effectiveFilterHeight,f=t.effectiveFilterWidth,h=p-1-t.padInfo.front,m=d-1-t.padInfo.top,g=f-1-t.padInfo.left,x=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${m}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function $Xe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,a=o,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],d=M.computePool3DInfo(a.shape,i,l,p,u,c),f=new i8(d);return n.runWebGLProgram(f,[s],a.dtype)}var Wre={kernelName:bx,backendName:"webgl",kernelFunc:$Xe};function FXe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,a=o;Rl([s,o],"avgPoolGrad");let{filterSize:i,strides:l,pad:u}=r,c=M.computePool2DInfo(a.shape,i,l,1,u),p=new a8(c);return n.runWebGLProgram(p,[s],a.dtype)}var Gre={kernelName:yx,backendName:"webgl",kernelFunc:FXe};function OXe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:o}=t,{transposeA:a,transposeB:i}=r;return Gm({a:s,b:o,transposeA:a,transposeB:i,backend:n})}var Ure={kernelName:xp,backendName:"webgl",kernelFunc:OXe};var l8=class{constructor(t,n,r,s,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],M.assertAndGetBroadcastShape(t,n),M.assertAndGetBroadcastShape(t,r);let i="0.0";s!=null&&(M.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="1.0";o!=null&&(M.assertAndGetBroadcastShape(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var u8=class{constructor(t,n,r,s,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],M.assertAndGetBroadcastShape(t,n),M.assertAndGetBroadcastShape(t,r);let i="vec4(0.0)";s!=null&&(M.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(M.assertAndGetBroadcastShape(t,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var PXe=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:s,variance:o,offset:a,scale:i}=e;C.assert(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C.assert(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C.assert(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[r,s,o],c=null;a!=null&&(c=a.shape,u.push(a));let p=null;i!=null&&(p=i.shape,u.push(i));let d=he().getBool("WEBGL_PACK_NORMALIZATION")?new u8(r.shape,s.shape,o.shape,c,p,l):new l8(r.shape,s.shape,o.shape,c,p,l);return t.runWebGLProgram(d,u,u[0].dtype)},jre={kernelName:Tp,backendName:"webgl",kernelFunc:PXe};var c8=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let n=Ct(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r=MXe(this.rank),s,o=t.map((a,i)=>`sourceLoc.${p8[i]} = start[${i}] + coords.${p8[i]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}},p8=["x","y","z","w","u","v"];function MXe(e){if(e===1)return"sourceLoc";if(e<=6)return p8.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var d8=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=Ct(this.rank),r=ir("coords",this.rank),s=ir("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,a=`getChannel(getSource(${s.join()}), ${o})`,i=`
      result.x = ${a};
      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${a};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${a};
        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${s[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i}
        ${l}
        setOutput(result);
      }
    `}};function zXe(e,t,n,r){let s=r.texData.get(e.dataId),o=r.makeTensorInfo(n,e.dtype),a=r.texData.get(o.dataId);Object.assign(a,s),a.refCount=1,a.shape=n,a.dtype=e.dtype;let i=Cs.computeFlatOffset(t,C.computeStrides(e.shape));s.slice&&(i+=s.slice.flatOffset),a.slice={flatOffset:i,origDataId:s.slice&&s.slice.origDataId||e.dataId};let l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),o}function el(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,size:a}=r,[i,l]=Cs.parseSliceParams(s,o,a);if(Cs.assertParamsValid(s,i,l),C.sizeFromShape(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){let p=n.texData.get(s.dataId),d=Pne(p.values,i,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,d)}let{isPacked:u}=n.texData.get(s.dataId),c=Cs.isSliceContinous(s.shape,i,l);if(u||!c){let p=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new d8(l):new c8(l),d=[i];return n.runWebGLProgram(p,[s],s.dtype,d)}return n.uploadToGPU(s.dataId),zXe(s,i,l,n)}var Hre={kernelName:Xp,backendName:"webgl",kernelFunc:el};var LXe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,crops:a}=r;C.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=o.reduce((y,b)=>y*b),l=M.getReshaped(s.shape,o,i),u=M.getPermuted(l.length,o.length),c=M.getReshapedPermuted(s.shape,o,i),p=M.getSliceBeginCoords(a,o.length),d=M.getSliceSize(c,a,o.length),f=[],h=$e({inputs:{x:s},backend:n,attrs:{shape:l}}),m=On({inputs:{x:h},backend:n,attrs:{perm:u}}),g=$e({inputs:{x:m},backend:n,attrs:{shape:c}}),x=el({inputs:{x:g},backend:n,attrs:{begin:p,size:d}});return f.push(h),f.push(m),f.push(g),f.forEach(y=>n.disposeIntermediateTensorInfo(y)),x},qre={kernelName:yp,backendName:"webgl",kernelFunc:LXe};function BXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:a}=r,i=n.readSync(s.dataId),l=n.readSync(o.dataId),u=IS(i,l,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,u)}var Kre={kernelName:Ax,backendName:"webgl",kernelFunc:BXe};var VXe="return float(a != b);",f8=Qt({opSnippet:VXe,cpuKernelImpl:Rne,dtype:"bool"}),Xre={kernelName:Dh,backendName:"webgl",kernelFunc:f8};function Ac(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return lr({inputs:{x:s.complexTensorInfos.real},backend:n})}var Zre={kernelName:Xx,backendName:"webgl",kernelFunc:Ac};var WXe="return float(int(x));";function Yre(e,t){let n=new $o(e.shape,WXe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function h8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return lr({inputs:{x:s},backend:n});let a=fn(s.shape),i=h8({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Fo({inputs:{real:i,imag:a},backend:n});return a.dispose(),n.disposeIntermediateTensorInfo(i),l}if(s.dtype==="complex64"){let a=Ac({inputs:{input:s},backend:n}),i=h8({inputs:{x:a},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(a),i}if(!C.hasEncodingLoss(s.dtype,o)){let a=lr({inputs:{x:s},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32")return Yre(s,n);if(o==="bool"){let a=n.makeTensorInfo([],"bool",C.getTypedArrayFromDType("bool",1)),l=f8({inputs:{a:s,b:a},backend:n});return n.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}var Jre={kernelName:bl,backendName:"webgl",kernelFunc:h8};var Qre="return ceil(x);",GXe=Xe({opSnippet:Qre,packedOpSnippet:Qre,cpuKernelImpl:dne}),ese={kernelName:iu,backendName:"webgl",kernelFunc:GXe};var m8=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var g8=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function UXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:o,clipValueMax:a}=r,i;he().getBool("WEBGL_PACK_CLIP")?i=new g8(s.shape):i=new m8(s.shape);let l=[[o],[a]];return n.runWebGLProgram(i,[s],s.dtype,l)}var tse={kernelName:lu,backendName:"webgl",kernelFunc:UXe};var x8=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function nse(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function jXe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),o=new x8(r.shape),a=[nse(r,s.complexTensorInfos.real),nse(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,a,a[0].dtype)}var rse={kernelName:bp,backendName:"webgl",kernelFunc:jXe};var y8=class{constructor(t){this.outputShape=[],this.outputShape=M.computeOutShape(t,1),this.variableNames=t.map((a,i)=>`T${i}`);let n=new Array(t.length-1);n[0]=t[0][1];for(let a=1;a<n.length;a++)n[a]=n[a-1]+t[a][1];let r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<n.length;a++){let i=n[a-1];r.push(`else if (yC < ${n[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let s=n.length,o=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};var b8=class{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=M.computeOutShape(t,n);let r=this.outputShape,s=r.length,o=Ct(s),a=ir("coords",s),i=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);let l=new Array(t.length-1);l[0]=t[0][n];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][n];let u=i[n],c=i.slice(-2),p=i.join(),d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let m=1;m<l.length;m++){let g=l[m-1];d+=`
        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${FS(i,u,g)}),
            vec2(${FS(c,u,g)}));
        }`}let f=l.length,h=l[l.length-1];d+=`
        return getChannel(
          getT${f}(${FS(i,u,h)}),
          vec2(${FS(c,u,h)}));`,this.userCode=`
      float getValue(${i.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[s-1]} = ${a[s-1]} + 1;
        if (${a[s-1]} < ${r[s-1]}) {
          result.g = getValue(${a});
        }

        ${a[s-2]} = ${a[s-2]} + 1;
        if (${a[s-2]} < ${r[s-2]}) {
          result.a = getValue(${a});
        }

        ${a[s-1]} = ${a[s-1]} - 1;
        if (${a[s-2]} < ${r[s-2]} &&
            ${a[s-1]} < ${r[s-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function FS(e,t,n){let r=e.indexOf(t);return e.map((o,a)=>a===r?`${o} - ${n}`:o).join()}function jm(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return lr({inputs:{x:s.complexTensorInfos.imag},backend:n})}var sse={kernelName:Mx,backendName:"webgl",kernelFunc:jm};function Hm(e,t,n){let r=e[0].dtype;if(r==="complex64"){let c=e.map(m=>Ac({inputs:{input:m},backend:n})),p=e.map(m=>jm({inputs:{input:m},backend:n})),d=Hm(c,t,n),f=Hm(p,t,n),h=Fo({inputs:{real:d,imag:f},backend:n});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),p.forEach(m=>n.disposeIntermediateTensorInfo(m)),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),h}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let c=e.map(x=>{let y=C.sizeFromShape(x.shape.slice(t));return $e({inputs:{x},backend:n,attrs:{shape:[-1,y]}})}),p=c.map(x=>({vals:n.readSync(x.dataId),shape:x.shape})),d=M.computeOutShape(c.map(x=>x.shape),1),f=c[0].shape[0]===1,h=fne(p,d,r,f),m=M.computeOutShape(e.map(x=>x.shape),t),g=n.makeTensorInfo(m,r,h);return c.forEach(x=>n.disposeIntermediateTensorInfo(x)),g}if(e.length>he().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(e.length/2),p=Hm(e.slice(0,c),t,n),d=Hm(e.slice(c),t,n),f=Hm([p,d],t,n);return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),f}if(he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){let c=new b8(e.map(p=>p.shape),t);return n.runWebGLProgram(c,e,r)}let{tensors2D:o,outShape:a}=HXe(e,t,n),i=new y8(o.map(c=>c.shape)),l=n.runWebGLProgram(i,o,r);o.forEach(c=>n.disposeIntermediateTensorInfo(c));let u=$e({inputs:{x:l},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(l),u}function HXe(e,t,n){let r=M.computeOutShape(e.map(o=>o.shape),t);return{tensors2D:e.map(o=>$e({inputs:{x:o},attrs:{shape:[-1,C.sizeFromShape(o.shape.slice(t))]},backend:n})),outShape:r}}function A8(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,o=C.parseAxisParam(s,t[0].shape)[0],a=M.computeOutShape(t.map(u=>u.shape),o);if(C.sizeFromShape(a)===0)return n.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(u=>C.sizeFromShape(u.shape)>0);if(i.length===1)return lr({inputs:{x:i[0]},backend:n});let l=i.map(u=>u.shape);return M.assertParamsConsistent(l,o),Hm(i,o,n)}var ose={kernelName:Ap,backendName:"webgl",kernelFunc:A8};var xv=class{constructor(t,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let a=t.padInfo.top,i=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,d=t.filterHeight,f=t.filterWidth,h=Math.floor(t.inChannels/4)*4,m=t.inChannels%4,g=t.dataFormat==="channelsLast",x=g?1:2,y=g?2:3,b=g?3:1,A="",v="";r&&(s?A=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?A=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:A=`
          float activation(float x) {
            ${r}
          }
        `,v="result = activation(result);");let w=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${A}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${v}
        setOutput(result);
      }
    `}},v8=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let n=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,d=t.filterHeight,f=t.filterWidth,h=Math.floor(t.inChannels/4)*4,m=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${i});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var w8=class{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Xn(this.outputShape.length);let{dataFormat:r}=n,s=Vn(),o=r==="channelsLast",a=o?0:1,i=o?1:2,l=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${t[1]} && pos < ${t[0]}) {`,u="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)u+=`
          blockIndex = rc.y + ${p};
          pos = rc.x + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${s.output} = result;
      }
    `}};function OS({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){let l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,p=l[0]*l[1]*l[2],d=n.outChannels,f=n.dataFormat==="channelsLast",h=!1,m=!1,g,x=[];if(!((p===1||d===1)&&c>t8)&&u.isPacked&&f&&u.texture!=null&&l[2]%2!=0&&C.arraysEqual(u.shape.slice(-3),l.slice(-3))){let A=l[0]*l[1]*(l[2]+1),v={dataId:e.dataId,shape:[1,A,n.inChannels],dtype:e.dtype},w=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,C.assert(zm(u.shape,v.shape),()=>`packed reshape ${u.shape} to ${v.shape} isn't free`);let k=$e({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});x.push(k);let I=Gm({a:v,b:k,backend:r,transposeA:h,transposeB:m,bias:s,activation:i,preluActivationWeights:o,leakyreluAlpha:a}),N=r.texData.get(I.dataId);C.assert(N.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=w,N.shape=n.outShape,g=lr({inputs:{x:I},backend:r}),g.shape=n.outShape,x.push(I)}else{let A=f?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],v=$e({inputs:{x:e},backend:r,attrs:{shape:[1,A,n.inChannels]}}),w=$e({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),k=Gm({a:v,b:w,transposeA:h,transposeB:m,backend:r,bias:s,activation:i,preluActivationWeights:o,leakyreluAlpha:a});g=$e({inputs:{x:k},backend:r,attrs:{shape:n.outShape}}),x.push(v),x.push(w),x.push(k)}for(let A of x)r.disposeIntermediateTensorInfo(A);return g}function PS({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:p,outHeight:d,dataFormat:f}=n,h=f==="channelsLast",m=l*u*c,g=d*p,x=[m,g],y=!0,b=!1,A=[],v=$e({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),w=$e({inputs:{x:t},backend:r,attrs:{shape:[1,m,C.sizeFromShape(t.shape)/m]}});A.push(v),A.push(w);let k=new w8(x,n),I=[v.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],N=r.runWebGLProgram(k,[v],"float32",I),T=$e({inputs:{x:N},backend:r,attrs:{shape:[1,x[0],x[1]]}});A.push(N),A.push(T);let _=s!=null,R=o!=null,S=i==="leakyrelu",F=i?Nd(i,!0):null,B=new mv(T.shape,w.shape,[1,g,n.outChannels],y,b,_,F,R,S),W=[T,w];if(s&&W.push(s),R&&W.push(o),S){let Q=r.makeTensorInfo([],"float32",C.createScalarValue(a,"float32"));W.push(Q),A.push(Q)}let q=r.runWebGLProgram(B,W,"float32"),K=h?[1,d,p,n.outChannels]:[1,n.outChannels,d,p],J=$e({inputs:{x:q},backend:r,attrs:{shape:K}});A.push(q);for(let Q of A)r.disposeIntermediateTensorInfo(Q);return J}function qXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=r,p=M.convertConv2DDataFormat(l),d=M.computeConv2DInfo(s.shape,o.shape,a,u,i,c,!1,p),f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=OS({x:s,filter:o,convInfo:d,backend:n});else if(he().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)f=PS({x:s,filter:o,convInfo:d,backend:n});else{let m=new xv(d);f=n.runWebGLProgram(m,[s,o],"float32")}let h=$e({inputs:{x:f},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(f),h}var ase={kernelName:vp,backendName:"webgl",kernelFunc:qXe};var k8=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,o=t.padInfo.left,a=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},I8=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,o=t.strideWidth,a=t.dataFormat==="channelsLast",i=n-1-t.padInfo.top,l=r-1-t.padInfo.left,u=a?1:2,c=a?2:3,p=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},C8=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,o=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${o};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${a};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${i};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},S8=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,l=n-1-t.padInfo.front,u=r-1-t.padInfo.top,c=s-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function KXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,p=M.convertConv2DDataFormat(l),d=M.computeConv2DInfo(s.shape,c,a,1,i,u,!1,p),f=new k8(d);return n.runWebGLProgram(f,[s,o],"float32")}var ise={kernelName:wx,backendName:"webgl",kernelFunc:KXe};function XXe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=r,p=M.convertConv2DDataFormat(u),d=M.computeConv2DInfo(a,o.shape,i,1,l,c,!1,p),f=new I8(d);return n.runWebGLProgram(f,[s,o],"float32")}var lse={kernelName:wp,backendName:"webgl",kernelFunc:XXe};function ZXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l}=r,u=M.computeConv3DInfo(s.shape,o.shape,a,l,i),c=new v8(u);return n.runWebGLProgram(c,[s,o],"float32")}var use={kernelName:kp,backendName:"webgl",kernelFunc:ZXe};function YXe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,pad:i,filterShape:l}=r,u=M.computeConv3DInfo(s.shape,l,a,1,i),c=new C8(u);return n.runWebGLProgram(c,[s,o],"float32")}var cse={kernelName:kx,backendName:"webgl",kernelFunc:YXe};function JXe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{pad:a,strides:i,inputShape:l}=r,u=M.computeConv3DInfo(l,o.shape,i,1,a),c=new S8(u);return n.runWebGLProgram(c,[s,o],"float32")}var pse={kernelName:Ix,backendName:"webgl",kernelFunc:JXe};var QXe=_S+`
  return cos(x);
`,eZe=Xe({opSnippet:QXe}),dse={kernelName:uu,backendName:"webgl",kernelFunc:eZe};var tZe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,nZe=Xe({opSnippet:tZe}),fse={kernelName:cu,backendName:"webgl",kernelFunc:nZe};var N8=class{constructor(t,n,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,i,l,u]=t,[c]=n,[p,d]=r;this.outputShape=[c,p,d,u];let f=s==="bilinear"?1:0,[h,m]=[`${i-1}.0`,`${l-1}.0`],[g,x,y]=p>1?[`${(i-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,A,v]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${A};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var rZe=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:o,boxInd:a}=t,{cropSize:i,method:l,extrapolationValue:u}=r,c=new N8(s.shape,o.shape,i,l,u);return n.runWebGLProgram(c,[s,o,a],"float32")},hse={kernelName:Cx,backendName:"webgl",kernelFunc:rZe};var MS=class{constructor(t,n,r){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;let s=t.length,o=n?"0.0":`getX(${mse(s,"coords")})`,a=t[t.length-1],i="",l="";n?(i=r?`end != ${a-1}`:"end != 0",l=r?"end + 1":"end - 1"):(i=r?`end + pow2 < ${a}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ct(s)} coords = getOutputCoords();
        int end = ${gse(s,"coords")};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${i}) {
          int idx = ${l};
          ${gse(s,"coords")} = idx;
          val += getX(${mse(s,"coords")});
        }
        setOutput(val);
      }
    `}};function mse(e,t){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function gse(e,t){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function sZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,exclusive:a,reverse:i}=r,l=s.shape.length,u=M.getAxesPermutation([o],l),c=s;u!=null&&(c=On({inputs:{x:s},backend:n,attrs:{perm:u}}));let p=M.getInnerMostAxes(1,l)[0];if(p!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);let d=c.shape[p],f=lr({inputs:{x:c},backend:n});for(let h=0;h<=Math.ceil(Math.log2(d))-1;h++){let m=new MS(c.shape,!1,i),g=[[h]],x=f;f=n.runWebGLProgram(m,[f],f.dtype,g),n.disposeIntermediateTensorInfo(x)}if(a){let h=new MS(c.shape,a,i),m=f;f=n.runWebGLProgram(h,[f],f.dtype),n.disposeIntermediateTensorInfo(m)}if(u!=null){let h=M.getUndoAxesPermutation(u),m=On({inputs:{x:f},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(c),m}return f}var xse={kernelName:Ip,backendName:"webgl",kernelFunc:sZe};function oZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:a,binaryOutput:i}=r;if(s.shape.length===1){let l=n.readSync(s.dataId),u=n.readSync(o.dataId),c=IS(l,u,o.dtype,o.shape,a);return n.makeTensorInfo([a],o.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(o),c=pne(l,u,a,i);return n.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var yse={kernelName:Sx,backendName:"webgl",kernelFunc:oZe};var T8=class{constructor(t,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function aZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:o,dataFormat:a}=r;C.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let i=s.shape[0],l=a==="NHWC"?s.shape[1]:s.shape[2],u=a==="NHWC"?s.shape[2]:s.shape[3],c=a==="NHWC"?s.shape[3]:s.shape[1],p=l*o,d=u*o,f=c/(o*o),h=a==="NHWC"?[i,p,d,f]:[i,f,p,d],m=new T8(h,o,a);return n.runWebGLProgram(m,[s],s.dtype)}var bse={kernelName:Nx,backendName:"webgl",kernelFunc:aZe};var yv=class{constructor(t,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xn(this.outputShape.length);let a=t.filterHeight,i=t.filterWidth,l=t.outChannels/t.inChannels,u="",c="";r&&(s?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");let p=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var bv=class{constructor(t,n=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Xn(this.outputShape.length);let a=t.outChannels/t.inChannels,i=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,d=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<p;x++)f+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;for(let x=0;x<c;x++){for(let y=0;y<p;y++)f+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;f+=`
        xR = xRCorner + ${x} * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){let b=y*2;if(f+=`
          xC = xCCorner + ${b*u};
          `,l===1){if(b<p&&(i%2==1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?f+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<p)){let A=i%2==0?C.nearestLargerEven(u):u;u%2==0&&i%2==1||u%2!=0&&i%2!=1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${A};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1&&(f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                      xTexelC${b} = getX(batch, xR, xCOffset, d1);
                      xTexelC${b}Ready = 1;
                    }
                    `),f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                  `):A===1?f+=`
                    xC${b+1} = xTexelC${b};
                    `:f+=`
                    xCOffset = xC + ${A};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<p&&(i%2==1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<p&&(f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<p&&(f+=`
            wTexel = getW(${x}, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<p&&(f+=`
              wTexel = getW(${x}, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
        }
      `}let h="",m="";r&&(s?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:h=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");let g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}};function iZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=r,c=l;c==null&&(c=[1,1]),C.assert(M.eitherStridesOrDilationsAreOne(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let p=M.computeConv2DInfo(s.shape,o.shape,a,c,i,u,!0),d;he().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?d=new bv(p):d=new yv(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(d,[s,o],"float32",f)}var Ase={kernelName:Cp,backendName:"webgl",kernelFunc:iZe};var _8=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,o=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},E8=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,o=t.strideWidth,a=n-1-t.padInfo.top,i=r-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function lZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=r,p=M.computeConv2DInfo(s.shape,c,a,i,l,u,!0),d=new _8(p);return n.runWebGLProgram(d,[s,o],"float32")}var vse={kernelName:Tx,backendName:"webgl",kernelFunc:lZe};function uZe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=r,p=M.computeConv2DInfo(c,o.shape,a,i,l,u,!0),d=new E8(p);return n.runWebGLProgram(d,[s,o],"float32")}var wse={kernelName:_x,backendName:"webgl",kernelFunc:uZe};var R8=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function cZe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],o=C.sizeFromShape(r.shape),a=$e({inputs:{x:r},backend:n,attrs:{shape:[o]}}),i=new R8(o),l=n.runWebGLProgram(i,[a],a.dtype),u=$e({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}var kse={kernelName:h3,backendName:"webgl",kernelFunc:cZe};var D8=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:n,inWidth:r,padInfo:s,strideHeight:o,strideWidth:a,filterHeight:i,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:p,left:d}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${p}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function pZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:a,pad:i,dilations:l}=r,u=M.computeDilation2DInfo(s.shape,o.shape,a,i,"NHWC",l),c,p=new D8(u);c=n.runWebGLProgram(p,[s,o],"float32");let d=$e({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}var Ise={kernelName:Sp,backendName:"webgl",kernelFunc:pZe};function dZe(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,o=t,{allDims:a,summedDims:i,idDims:l}=M.decodeEinsumEquation(s,o.length);M.checkEinsumDimSizes(a.length,l,o);let{path:u,steps:c}=M.getEinsumComputePath(i,l),p=c.length,d=null,f=a.length,h=[];for(let m=0;m<p;++m){for(let g of c[m]){let{permutationIndices:x,expandDims:y}=M.getEinsumPermutation(f,l[g]),b;M.isIdentityPermutation(x)?b=o[g]:(b=On({inputs:{x:o[g]},backend:n,attrs:{perm:x}}),h.push(b));let A=b.shape.slice();for(let v=0;v<y.length;++v)A.splice(y[v],0,1);C.arraysEqual(b.shape,A)||(b=$e({inputs:{x:b},backend:n,attrs:{shape:A}}),h.push(b)),d===null?d=b:(d=gv({inputs:{a:b,b:d},backend:n}),h.push(d))}m<p-1&&(u[m]>=0&&(d=Wm({inputs:{x:d},backend:n,attrs:{axis:u[m]-(a.length-f),keepDims:!1}}),h.push(d)),f--)}for(let m of h)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var Cse={kernelName:Ex,backendName:"webgl",kernelFunc:dZe};var fZe="return (x >= 0.0) ? x : (exp(x) - 1.0);",hZe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,mZe=Xe({opSnippet:fZe,packedOpSnippet:hZe}),Sse={kernelName:du,backendName:"webgl",kernelFunc:mZe};var gZe="return (b >= 1.0) ? a : a * (b + 1.0);",xZe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,yZe=e=>{let{inputs:t,backend:n}=e,{dy:r,y:s}=t,o=he().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qi(xZe,r.shape,s.shape):new ui(gZe,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)},Nse={kernelName:Rx,backendName:"webgl",kernelFunc:yZe};var bZe=`
  return vec4(equal(a, b));
`,AZe="return float(a == b);",vZe=Qt({opSnippet:AZe,packedOpSnippet:bZe,dtype:"bool",cpuKernelImpl:hne}),Tse={kernelName:Ch,backendName:"webgl",kernelFunc:vZe};var wZe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${M.ERF_P};
  float a1 = ${M.ERF_A1};
  float a2 = ${M.ERF_A2};
  float a3 = ${M.ERF_A3};
  float a4 = ${M.ERF_A4};
  float a5 = ${M.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,kZe=Xe({opSnippet:wZe}),_se={kernelName:fu,backendName:"webgl",kernelFunc:kZe};var Ese="return exp(x);",$8=Xe({opSnippet:Ese,packedOpSnippet:Ese,cpuKernelImpl:mne}),Rse={kernelName:hu,backendName:"webgl",kernelFunc:$8};function zS(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:o}=t,a=o.shape.length,i=o.shape.slice(),l=s;return s<0&&(C.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),i.splice(l,0,1),$e({inputs:{x:o},backend:r,attrs:{shape:i}})}var Dse={kernelName:Np,backendName:"webgl",kernelFunc:zS};var $se="return exp(x) - 1.0;",IZe=Xe({opSnippet:$se,packedOpSnippet:$se,cpuKernelImpl:gne}),Fse={kernelName:mu,backendName:"webgl",kernelFunc:IZe};var LS=class{constructor(t,n,r){this.variableNames=["real","imag"];let s=n[1];this.outputShape=n;let o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=r?`${s}.0`:"1.0",i;if(t==="real")i="return real * expR - imag * expI;";else if(t==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function BS(e,t,n){let r=n.texData.get(e.dataId),s=C.sizeFromShape(e.shape),o=e.shape[e.shape.length-1],a=s/o,i=$e({inputs:{x:e},backend:n,attrs:{shape:[a,o]}}),l=i.shape,u=new LS("real",l,t),c=new LS("imag",l,t),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,p,"float32"),f=n.runWebGLProgram(c,p,"float32"),h=Fo({inputs:{real:d,imag:f},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f);let m=$e({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(h),m}function CZe(e){let{inputs:t,backend:n}=e,{input:r}=t;return BS(r,!1,n)}var Ose={kernelName:Dx,backendName:"webgl",kernelFunc:CZe};var F8=class{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function vc(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:o}=n;if(o=o||C.inferDtype(s),o==="string"){let a=C.getArrayFromDType(o,C.sizeFromShape(r));return a.fill(s),t.makeTensorInfo(r,o,a)}else{let a=new F8(r,s),i=[[s]];return t.runWebGLProgram(a,[],o,i)}}var Pse={kernelName:$x,backendName:"webgl",kernelFunc:vc};var O8=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let n=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Mse={kernelName:Fx,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new O8(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};var zse="return floor(x);",SZe=Xe({opSnippet:zse,packedOpSnippet:zse,cpuKernelImpl:xne}),Lse={kernelName:gu,backendName:"webgl",kernelFunc:SZe};var NZe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,TZe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,_Ze=Qt({opSnippet:NZe,packedOpSnippet:TZe,dtype:"int32"}),Bse={kernelName:xu,backendName:"webgl",kernelFunc:_Ze};var P8=class{constructor(t){this.variableNames=["A"];let n=Vn(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var M8=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let n=Vn(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}};var Vse={kernelName:Dj,backendName:"webgl",kernelFunc:EZe},f1;function EZe(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:o}=r,a=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,[l,u]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],p=[u,l,o];(i||a)&&(f1==null&&(f1=document.createElement("canvas").getContext("2d")),f1.canvas.width=l,f1.canvas.height=u,f1.drawImage(s,0,0,l,u),s=f1.canvas);let d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=Rs.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);let f=he().getBool("WEBGL_PACK")?new M8(p):new P8(p),h=n.runWebGLProgram(f,[d],"int32");return n.disposeData(d.dataId),h}function RZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=r,m=M.convertConv2DDataFormat(c),g=M.computeConv2DInfo(s.shape,o.shape,l,p,u,d,!1,m),x,y=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=OS({x:s,filter:o,convInfo:g,backend:n,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:h});else if(he().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)x=PS({x:s,filter:o,convInfo:g,backend:n,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:h});else{let A=a!=null,v=i!=null,w=f==="leakyrelu",k=f?Nd(f,!1):null,I=new xv(g,A,k,v,w),N=[s,o];if(a&&N.push(a),i&&N.push(i),w){let T=n.makeTensorInfo([],"float32",C.createScalarValue(h,"float32"));N.push(T),y.push(T)}x=n.runWebGLProgram(I,N,"float32")}let b=$e({inputs:{x},backend:n,attrs:{shape:g.outShape}});return y.push(x),y.forEach(A=>n.disposeIntermediateTensorInfo(A)),b}var Wse={kernelName:Fh,backendName:"webgl",kernelFunc:RZe};function DZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:a,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,h=[],m=c;m==null&&(m=[1,1]),C.assert(M.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=M.computeConv2DInfo(s.shape,o.shape,l,m,u,p,!0),x=he().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=d?Nd(d,x):null,b=[s,o],A=a!=null,v=i!=null,w=d==="leakyrelu";if(A&&b.push(a),v&&b.push(i),w){let T=n.makeTensorInfo([],"float32",C.createScalarValue(f,"float32"));b.push(T),h.push(T)}let k;x?k=new bv(g,A,y,v,w):k=new yv(g,A,y,v,w);let I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(k,b,"float32",I);return h.forEach(T=>n.disposeIntermediateTensorInfo(T)),N}var Gse={kernelName:Oh,backendName:"webgl",kernelFunc:DZe};var z8=class{constructor(t,n,r){this.sliceDim=t,this.strides=n,this.variableNames=["x","indices"],this.outputShape=r;let s=Ct(n.length),o=Ct(r.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${s} strides = ${s}(${this.strides});
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function $Ze(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,o=s.shape,a=o[o.length-1],i=C.sizeFromShape(r.shape),[l,u,c,p]=M.prepareAndValidate(r,s),d=$e({inputs:{x:s},backend:n,attrs:{shape:[u,a]}}),f=$e({inputs:{x:r},backend:n,attrs:{shape:[C.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let x=n.readSync(s.dataId),y=n.bufferSync(r),b=yne(x,y,r.dtype,u,a,c,p,r.shape,i);return n.makeTensorInfo(l,r.dtype,b.values)}let h=new z8(a,p,[u,c]),m=n.runWebGLProgram(h,[f,d],f.dtype),g=$e({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var Use={kernelName:Ox,backendName:"webgl",kernelFunc:$Ze};var L8=class{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;let r=Ct(this.rank),s=FZe(t,2);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function FZe(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("int(getIndices(resRC.x, resRC.z))"):r.push(`${n[s]}`);return r.join()}function B8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:o}=t,{axis:a,batchDims:i}=r,l=C.parseAxisParam(a,s.shape)[0],u=M.segment_util.collectGatherOpShapeInfo(s,o,l,i),c=C.sizeFromShape(o.shape),p=[],d=$e({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=$e({inputs:{x:o},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});p.push(d),p.push(f);let h=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,o])||s.dtype==="string"){let y=n.bufferSync(f),b=n.bufferSync(d),A=bne(b,y,h);return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(u.outputShape,A.dtype,A.values)}let m=new L8(d.shape,h),g=n.runWebGLProgram(m,[d,f],d.dtype);p.push(g);let x=$e({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return p.forEach(y=>n.disposeIntermediateTensorInfo(y)),x}var jse={kernelName:_p,backendName:"webgl",kernelFunc:B8};var OZe="return float(a > b);",PZe=`
  return vec4(greaterThan(a, b));
`,MZe=Qt({opSnippet:OZe,packedOpSnippet:PZe,cpuKernelImpl:Ane,dtype:"bool"}),Hse={kernelName:Sh,backendName:"webgl",kernelFunc:MZe};var zZe="return float(a >= b);",LZe=`
  return vec4(greaterThanEqual(a, b));
`,BZe=Qt({opSnippet:zZe,packedOpSnippet:LZe,dtype:"bool",cpuKernelImpl:vne}),qse={kernelName:yu,backendName:"webgl",kernelFunc:BZe};function VZe(e){let{inputs:t,backend:n}=e,{input:r}=t;return BS(r,!0,n)}var Kse={kernelName:Px,backendName:"webgl",kernelFunc:VZe};var WZe="return float(!isnan(x) && !isinf(x));",GZe=Xe({opSnippet:WZe,dtype:"bool"}),Xse={kernelName:bu,backendName:"webgl",kernelFunc:GZe};var UZe="return float(isinf(x));",jZe=Xe({opSnippet:UZe,dtype:"bool"}),Zse={kernelName:Au,backendName:"webgl",kernelFunc:jZe};var HZe="return float(isnan(x));",qZe=Xe({opSnippet:HZe,dtype:"bool"}),Yse={kernelName:vu,backendName:"webgl",kernelFunc:qZe};var KZe="return float(a < b);",XZe=`
  return vec4(lessThan(a, b));
`,ZZe=Qt({opSnippet:KZe,packedOpSnippet:XZe,cpuKernelImpl:wne,dtype:"bool"}),Jse={kernelName:Nh,backendName:"webgl",kernelFunc:ZZe};var YZe="return float(a <= b);",JZe=`
  return vec4(lessThanEqual(a, b));
`,QZe=Qt({opSnippet:YZe,packedOpSnippet:JZe,cpuKernelImpl:kne,dtype:"bool"}),Qse={kernelName:Th,backendName:"webgl",kernelFunc:QZe};function eYe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:o}=n,a=Ine(r,s,o);return t.makeTensorInfo([a.length],"float32",a)}var eoe={kernelName:zx,backendName:"webgl",kernelFunc:eYe};var tYe=`if (x < 0.0) return NAN;
  return log(x);`,nYe=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,rYe=Xe({opSnippet:tYe,packedOpSnippet:nYe,cpuKernelImpl:Cne}),toe={kernelName:wu,backendName:"webgl",kernelFunc:rYe};var sYe="return log(1.0 + x);",oYe=Xe({opSnippet:sYe}),noe={kernelName:ku,backendName:"webgl",kernelFunc:oYe};var aYe="return float(a >= 1.0 && b >= 1.0);",iYe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,lYe=Qt({opSnippet:aYe,packedOpSnippet:iYe,dtype:"bool"}),roe={kernelName:_h,backendName:"webgl",kernelFunc:lYe};var uYe="return float(!(x >= 1.0));",cYe=Xe({opSnippet:uYe}),soe={kernelName:Eh,backendName:"webgl",kernelFunc:cYe};var pYe="return float(a >= 1.0 || b >= 1.0);",dYe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,fYe=Qt({opSnippet:pYe,packedOpSnippet:dYe,dtype:"bool"}),ooe={kernelName:Rh,backendName:"webgl",kernelFunc:fYe};var V8=class{constructor(t,n,r,s,o){this.variableNames=["x"],this.outputShape=[];let a=n,i=t[3]-1;this.outputShape=t;let l,u=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};var W8=class{constructor(t,n,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=n,i=t[3]-1;this.outputShape=t;let l,u=`float(${r}) + float(${s}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}};var hYe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:o,bias:a,alpha:i,beta:l}=r,u=he().getBool("WEBGL_PACK_NORMALIZATION")?new W8(s.shape,o,a,i,l):new V8(s.shape,o,a,i,l);return n.runWebGLProgram(u,[s],s.dtype)},aoe={kernelName:Rp,backendName:"webgl",kernelFunc:hYe};var G8=class{constructor(t,n,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var mYe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s,y:o,dy:a}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=r,p=new G8(s.shape,i,l,u,c);return n.runWebGLProgram(p,[s,o,a],s.dtype)},ioe={kernelName:Lx,backendName:"webgl",kernelFunc:mYe};function loe(e,t,n,r){let s=C.sizeFromShape(t),a=C.sizeFromShape(e.shape)/s,i=$e({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),l=la(i,e.dtype,"max",r),u=$e({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(l),u}function U8(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:o,keepDims:a}=r,i=s.shape.length,l=C.parseAxisParam(o,s.shape),u=l,c=M.getAxesPermutation(u,i),p=c!=null,d=n.shouldExecuteOnCPU([s]),f=s;if(p){if(d){let b=n.texData.get(f.dataId).values,A=new Array(i);for(let k=0;k<A.length;k++)A[k]=s.shape[c[k]];let v=Vm(b,s.shape,s.dtype,c,A);f=n.makeTensorInfo(A,s.dtype);let w=n.texData.get(f.dataId);w.values=v}else f=Td(s,c,n);u=M.getInnerMostAxes(u.length,i)}M.assertAxesAreInnerMostDims("max",u,i);let[h,m]=M.computeOutAndReduceShapes(f.shape,u),g=h;a&&(g=M.expandShapeToKeepDim(h,l));let x;if(d){let b=n.texData.get(f.dataId).values,A=Sne(b,C.sizeFromShape(m),g,s.dtype);x=n.makeTensorInfo(g,s.dtype);let v=n.texData.get(x.dataId);v.values=A}else x=loe(f,m,g,n);return p&&n.disposeIntermediateTensorInfo(f),x}var uoe={kernelName:Dp,backendName:"webgl",kernelFunc:U8};var gYe=TS+`
  return max(a, b);
`,xYe=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Sd+`
  return result;
`,yYe=Qt({opSnippet:gYe,packedOpSnippet:xYe,cpuKernelImpl:Nne}),coe={kernelName:Iu,backendName:"webgl",kernelFunc:yYe};function bYe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Rl(s,"maxPool");let{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=r,u=1;C.assert(M.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=M.computePool2DInfo(s.shape,o,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&C.arraysEqual(c.inShape,c.outShape))return lr({inputs:{x:s},backend:n});let p=new Dl(c,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}var poe={kernelName:$p,backendName:"webgl",kernelFunc:bYe};function AYe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:a,pad:i,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],p=M.computePool3DInfo(s.shape,o,a,c,i,u,l),d=new Um(p,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}var doe={kernelName:Fp,backendName:"webgl",kernelFunc:AYe};var j8=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let n=t.strideHeight,r=t.strideWidth,s=t.dilationHeight,o=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=o-1-t.padInfo.top,l=a-1-t.padInfo.left,u=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},H8=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,i=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=l-1-t.padInfo.front,d=u-1-t.padInfo.top,f=c-1-t.padInfo.left,h=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function vYe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,a=o,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],d=M.computePool3DInfo(a.shape,i,l,p,u,c),f=new Um(d,"max",!0),h=n.runWebGLProgram(f,[a],a.dtype),m=new H8(d),g=n.runWebGLProgram(m,[s,h],a.dtype);return n.disposeIntermediateTensorInfo(h),g}var foe={kernelName:Vx,backendName:"webgl",kernelFunc:vYe};function wYe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o,output:a}=t,i=o;Rl([o,a],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,d=M.computePool2DInfo(i.shape,l,u,1,c,p),f=!0,h=new Dl(d,"max",f),m=n.runWebGLProgram(h,[i],i.dtype),g=new j8(d),x=n.runWebGLProgram(g,[s,m],i.dtype);return n.disposeIntermediateTensorInfo(m),x}var hoe={kernelName:Bx,backendName:"webgl",kernelFunc:wYe};function moe(e,t,n,r){let s=new Dl(n,"max",!1),o=r.runWebGLProgram(s,[e],"float32");s=new Dl(n,"max",!0,!0,t);let a=r.runWebGLProgram(s,[e],"float32");return[o,a]}var goe={kernelName:Wx,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:o,pad:a,includeBatchInIndex:i}=t,l=n;C.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];C.assert(M.eitherStridesOrDilationsAreOne(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);let c=M.computePool2DInfo(r.shape,s,o,u,a),[p,d]=moe(r,i,c,l);return[p,d]}};function xoe(e,t,n,r){let s=C.sizeFromShape(t),a=C.sizeFromShape(e.shape)/s,i=$e({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),l=la(i,"float32","mean",r),u=$e({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(l),u}var yoe={kernelName:Op,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:s,axis:o}=t,a=n,i=r.shape.length,l=C.parseAxisParam(o,r.shape),u=l,c=M.getAxesPermutation(u,i),p=c!=null,d=a.shouldExecuteOnCPU([r]),f=[],h=r;if(p){if(d){let A=a.texData.get(h.dataId).values,v=new Array(i);for(let I=0;I<v.length;I++)v[I]=r.shape[c[I]];let w=Vm(A,r.shape,r.dtype,c,v);h=a.makeTensorInfo(v,r.dtype);let k=a.texData.get(h.dataId);k.values=w}else h=Td(r,c,a);f.push(h),u=M.getInnerMostAxes(u.length,i)}M.assertAxesAreInnerMostDims("sum",u,i);let[m,g]=M.computeOutAndReduceShapes(h.shape,u),x=m;s&&(x=M.expandShapeToKeepDim(m,l));let y=xoe(h,g,x,a);for(let b of f)a.disposeIntermediateTensorInfo(b);return y}};function kYe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=s.shape.length,l=C.parseAxisParam(o,s.shape),u=l,c=M.getAxesPermutation(u,i),p=s;c!=null&&(p=On({inputs:{x:s},backend:n,attrs:{perm:c}}),u=M.getInnerMostAxes(u.length,s.shape.length)),M.assertAxesAreInnerMostDims("min",u,i);let[d,f]=M.computeOutAndReduceShapes(p.shape,u),h=C.sizeFromShape(f),m=$e({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}}),g=la(m,m.dtype,"min",n),x;if(a){let y=M.expandShapeToKeepDim(d,l);x=$e({inputs:{x:g},backend:n,attrs:{shape:y}})}else x=$e({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(p),x}var boe={kernelName:Pp,backendName:"webgl",kernelFunc:kYe};var IYe=TS+`
  return min(a, b);
`,CYe=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Sd+`
  return result;
`,SYe=Qt({opSnippet:IYe,packedOpSnippet:CYe,cpuKernelImpl:Tne}),Aoe={kernelName:Cu,backendName:"webgl",kernelFunc:SYe};var q8=class{constructor(t,n,r){this.variableNames=["x"],this.outputShape=n.map((c,p)=>c[0]+t[p]+c[1]);let s=t.length,o=Ct(s),a=n.map(c=>c[0]).join(","),i=n.map((c,p)=>c[0]+t[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};var K8=class{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((h,m)=>h[0]+t[m]+h[1]);let s=t.length,o=Ct(s),a=n.map(h=>h[0]).join(","),i=n.map((h,m)=>h[0]+t[m]).join(","),l=ir("rc",s),u=ir("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,p=s===1?"source":`vec2(${u.slice(-2).join()})`,d=r==="reflect"?0:1,f="";if(s===1){let h=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${o} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[s-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
      `}else{let h=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${o} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[s-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${h}
          result[2] = getChannel(getX(${u.join()}), ${p});
          ${l[s-1]} += 1;
          if(${c}) {
            ${h}
            result[3] = getChannel(getX(${u.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var NYe=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:s,mode:o}=n,a=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new K8(r.shape,s,o):new q8(r.shape,s,o);return t.runWebGLProgram(a,[r],r.dtype)},voe={kernelName:Mp,backendName:"webgl",kernelFunc:NYe};var TYe=`if (b == 0.0) return NAN;
  return mod(a, b);`,_Ye=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+Sd+`
  return result;
`,EYe=Qt({opSnippet:TYe,packedOpSnippet:_Ye}),woe={kernelName:Su,backendName:"webgl",kernelFunc:EYe};var X8=class{constructor(t,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}};var RYe=`
if (a == b) {
  return 1.0;
};
return a / b;`,DYe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Z8=Qt({opSnippet:RYe,packedOpSnippet:DYe,checkOutOfBounds:!0}),koe={kernelName:pu,backendName:"webgl",kernelFunc:Z8};var Ioe="return a - b;",Y8=Qt({opSnippet:Ioe,packedOpSnippet:Ioe,supportsComplex:!0,cpuKernelImpl:Une}),Coe={kernelName:Wu,backendName:"webgl",kernelFunc:Y8};function J8(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:o}=r,a=C.parseAxisParam([o],s.shape),i=U8({inputs:{x:s},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=M.expandShapeToKeepDim(i.shape,a),u=$e({inputs:{x:i},backend:n,attrs:{shape:l}}),c=Y8({inputs:{a:s,b:u},backend:n}),p=$8({inputs:{x:c},backend:n}),d=Wm({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:!1}}),f=$e({inputs:{x:d},backend:n,attrs:{shape:l}}),h=Z8({inputs:{a:p,b:f},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),h}var Soe={kernelName:Qp,backendName:"webgl",kernelFunc:J8};function $Ye(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:o,seed:a,normalized:i}=r,l=i?s:J8({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],p=new X8(u,c,o),d=[[a]],f=n.runWebGLProgram(p,[l],"int32",d);return i||n.disposeIntermediateTensorInfo(l),f}var Noe={kernelName:Gx,backendName:"webgl",kernelFunc:$Ye};var Toe="return -x;";function FYe(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let o=n.texData.get(r.dataId),[a,i]=Ene(o.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}let s;return he().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Ji(r.shape,Toe):s=new $o(r.shape,Toe),n.runWebGLProgram(s,[r],r.dtype)}var _oe={kernelName:zp,backendName:"webgl",kernelFunc:FYe};var OYe=Ts.nonMaxSuppressionV3Impl;function PYe(e){M.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(o.dataId),{selectedIndices:p}=OYe(u,c,a,i,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var Eoe={kernelName:Ux,backendName:"webgl",kernelFunc:PYe};var MYe=Ts.nonMaxSuppressionV4Impl;function zYe(e){M.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),p=n.readSync(o.dataId),{selectedIndices:d,validOutputs:f}=MYe(c,p,a,i,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}var Roe={kernelName:jx,backendName:"webgl",kernelFunc:zYe};var LYe=Ts.nonMaxSuppressionV5Impl;function BYe(e){M.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),p=n.readSync(o.dataId),d=a,f=i,h=l,m=u,{selectedIndices:g,selectedScores:x}=LYe(c,p,d,f,h,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var Doe={kernelName:Hx,backendName:"webgl",kernelFunc:BYe};var Q8=class{constructor(t,n,r,s){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}};var VYe=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:o,onValue:a,offValue:i}=r,l=C.sizeFromShape(s.shape),u=new Q8(l,o,a,i),c=$e({inputs:{x:s},backend:n,attrs:{shape:[l]}}),p=n.runWebGLProgram(u,[c],s.dtype);n.disposeIntermediateTensorInfo(c);let d=[...s.shape,o],f=$e({inputs:{x:p},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(p),f},$oe={kernelName:Bp,backendName:"webgl",kernelFunc:VYe};function Av(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=Ac({inputs:{input:r},backend:n}),o=Av({inputs:{x:s},backend:n}),a=jm({inputs:{input:r},backend:n}),i=Av({inputs:{x:a},backend:n}),l=Fo({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return vc({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var Foe={kernelName:rd,backendName:"webgl",kernelFunc:Av};function Ooe(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=Ac({inputs:{input:r},backend:n}),o=Ooe({inputs:{x:s},backend:n}),a=jm({inputs:{input:r},backend:n}),i=Av({inputs:{x:a},backend:n}),l=Fo({inputs:{real:o,imag:i},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),l}else return vc({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var Poe={kernelName:Lp,backendName:"webgl",kernelFunc:Ooe};function WYe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return zS({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let o=t[0].shape,a=t[0].dtype;t.forEach(c=>{C.assertShapesMatch(o,c.shape,"All tensors passed to stack must have matching shapes"),C.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=t.map(c=>{let p=zS({inputs:{input:c},backend:n,attrs:{dim:s}});return i.push(p),p}),u=A8({inputs:l,backend:n,attrs:{axis:s}});return i.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var Moe={kernelName:Vp,backendName:"webgl",kernelFunc:WYe};var eO=class{constructor(t,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((u,c)=>u[0]+t[c]+u[1]);let s=t.length,o=Ct(s),a=n.map(u=>u[0]).join(","),i=n.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};var tO=class{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((m,g)=>m[0]+t[g]+m[1]);let s=t.length,o=Ct(s),a=n.map(m=>m[0]).join(","),i=n.map((m,g)=>m[0]+t[g]).join(","),l=ir("rc",s),u=ir("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,p=s===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${c}) {`],f=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let m=0,g=s===1?2:4;m<g;m++)h+=`
        ${d[m]}
        if (${f}) {
          result[${m}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${m}] = getChannel(getX(${u.join()}), ${p});
        }
      `;h+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}};var nO=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,constantValue:a}=r;if(C.sizeFromShape(s.shape)===0){let u=o.map((c,p)=>c[0]+s.shape[p]+c[1]);return vc({backend:n,attrs:{shape:u,value:a,dtype:s.dtype}})}let i=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tO(s.shape,o,a):new eO(s.shape,o,a),l=[[a]];return n.runWebGLProgram(i,[s],s.dtype,l)},zoe={kernelName:Wp,backendName:"webgl",kernelFunc:nO};var GYe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,UYe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+Sd+`
  return result;
`,jYe=Qt({opSnippet:GYe,packedOpSnippet:UYe}),Loe={kernelName:Tu,backendName:"webgl",kernelFunc:jYe};function HYe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:a}=r,i=s.shape.length,l=[],u=C.parseAxisParam(o,s.shape),c=u,p=M.getAxesPermutation(c,i),d=s;p!=null&&(d=On({inputs:{x:s},backend:n,attrs:{perm:p}}),c=M.getInnerMostAxes(c.length,i),l.push(d)),M.assertAxesAreInnerMostDims("prod",c,i);let f;if(n.shouldExecuteOnCPU([d])){let h=n.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:x}=Dne(d.shape,d.dtype,h,c);f=n.makeTensorInfo(g,x,m)}else{let[h,m]=M.computeOutAndReduceShapes(d.shape,c),g=C.sizeFromShape(m),x=$e({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),y=Vh(s.dtype),b=la(x,y,"prod",n);f=$e({inputs:{x:b},backend:n,attrs:{shape:h}}),l.push(x),l.push(b)}if(a){l.push(f);let h=M.expandShapeToKeepDim(f.shape,u);f=$e({inputs:{x:f},backend:n,attrs:{shape:h}})}return l.forEach(h=>n.disposeIntermediateTensorInfo(h)),f}var Boe={kernelName:qx,backendName:"webgl",kernelFunc:HYe};var rO=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:o,dtype:a}=n,i=$ne(r,s,o,a);return t.makeTensorInfo([i.length],a,i)},Voe={kernelName:Kx,backendName:"webgl",kernelFunc:rO};var qYe="return 1.0 / x;",KYe=Xe({opSnippet:qYe}),Woe={kernelName:_u,backendName:"webgl",kernelFunc:KYe};var XYe=Qr+`
  return (x < 0.0) ? 0.0 : x;
`,ZYe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,YYe=Xe({opSnippet:XYe,packedOpSnippet:ZYe}),Goe={kernelName:Eu,backendName:"webgl",kernelFunc:YYe};var JYe=Qr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,QYe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,eJe=Xe({opSnippet:JYe,packedOpSnippet:QYe}),Uoe={kernelName:Ru,backendName:"webgl",kernelFunc:eJe};var sO=class{constructor(t,n,r,s,o){this.variableNames=["A"],this.outputShape=[];let[a,i,l,u]=t;this.outputShape=[a,n,r,u];let c=[s&&n>1?i-1:i,s&&r>1?l-1:l],p=[s&&n>1?n-1:n,s&&r>1?r-1:r],d;o?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var oO=class{constructor(t,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,l,u]=t;this.outputShape=[a,n,r,u];let c=[s&&n>1?i-1:i,s&&r>1?l-1:l],p=[s&&n>1?n-1:n,s&&r>1?r-1:r],d;o?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function tJe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:i}=r,[l,u]=i,c=he().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new oO(s.shape,l,u,o,a):new sO(s.shape,l,u,o,a);return n.runWebGLProgram(c,[s],"float32")}var joe={kernelName:Hp,backendName:"webgl",kernelFunc:tJe};var aO=class{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;let[,s,o]=n,[,a,i]=t,l=[r&&a>1?s-1:s,r&&i>1?o-1:o],u=[r&&a>1?a-1:a,r&&i>1?i-1:i],c=l[0]/u[0],p=l[1]/u[1],d=1/c,f=1/p,h=Math.ceil(d)*2+2,m=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${h});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function nJe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:a}=r,i=new aO(o.shape,s.shape,a);return n.runWebGLProgram(i,[o],o.dtype)}var Hoe={kernelName:Yx,backendName:"webgl",kernelFunc:nJe};var iO=class{constructor(t,n,r,s,o){this.variableNames=["A"],this.outputShape=[];let[a,i,l,u]=t;this.outputShape=[a,n,r,u];let c=[s&&n>1?i-1:i,s&&r>1?l-1:l],p=[s&&n>1?n-1:n,s&&r>1?r-1:r],d=s?"0.5":"0.0",f;o?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var lO=class{constructor(t,n,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,l,u]=t;this.outputShape=[a,n,r,u];let c=[s&&n>1?i-1:i,s&&r>1?l-1:l],p=[s&&n>1?n-1:n,s&&r>1?r-1:r],d=s?"0.5":"0.0",f;o?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function rJe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:i}=r,[l,u]=i,c=he().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lO(s.shape,l,u,o,a):new iO(s.shape,l,u,o,a);return n.runWebGLProgram(c,[s],s.dtype)}var qoe={kernelName:jp,backendName:"webgl",kernelFunc:rJe};var uO=class{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;let[,s,o]=n,[,a,i]=t,l=[r&&a>1?s-1:s,r&&i>1?o-1:o],u=[r&&a>1?a-1:a,r&&i>1?i-1:i],c=l[0]/u[0],p=l[1]/u[1],d=1/c,f=1/p,h=Math.ceil(d)*2+2,m=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${h});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function sJe(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:a}=r,i=new uO(o.shape,s.shape,a);return n.runWebGLProgram(i,[o],o.dtype)}var Koe={kernelName:Zx,backendName:"webgl",kernelFunc:sJe};var cO=class{constructor(t,n){this.variableNames=["x"];let r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let s=i=>n.indexOf(i)!==-1&&t[i]!==1?`${t[i]} - coords[${i}] - 1`:`coords[${i}]`,o=t.map((i,l)=>s(l)).join(","),a=Ct(r);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};var pO=class{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;let s=ir("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,a=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,i=Ct(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${o}){
            result.g = ${u(s.slice())};
          }
          if(${a}) {
            result.b = ${c(s.slice())};
            if(${o}) {
              result.a = ${p(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(h){return d(h)}function u(h){return h[r-1]="("+h[r-1]+" + 1)",d(h)}function c(h){return h[r-2]="("+h[r-2]+" + 1)",d(h)}function p(h){return h[r-1]="("+h[r-1]+" + 1)",h[r-2]="("+h[r-2]+" + 1)",d(h)}function d(h){let m=t.map((y,b)=>f(b,h)),g=m.join(","),x=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${x}))`}function f(h,m){return n.indexOf(h)!==-1&&t[h]!==1?`${t[h]} - ${m[h]} - 1`:`${m[h]}`}}};function oJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:o}=r,a=s.shape.length,i=C.parseAxisParam(o,s.shape);if(a===0)return lr({inputs:{x:s},backend:n});let l=he().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pO(s.shape,i):new cO(s.shape,i);return n.runWebGLProgram(l,[s],s.dtype)}var Xoe={kernelName:qp,backendName:"webgl",kernelFunc:oJe};var dO=class{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let r=t[1],s=t[2];this.outputShape=t;let o="";typeof n=="number"?o=`float outputValue = ${n.toFixed(2)};`:o=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Zoe={kernelName:dy,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:o,center:a}=t,i=n,l=new dO(r.shape,o),[u,c]=M.getImageCenter(a,r.shape[1],r.shape[2]),p=[[u,c,Math.sin(s),Math.cos(s)]];return i.runWebGLProgram(l,[r],r.dtype,p)}};var aJe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,iJe=Xe({opSnippet:aJe}),Yoe={kernelName:Du,backendName:"webgl",kernelFunc:iJe};var lJe="return inversesqrt(x);",uJe=Xe({opSnippet:lJe,cpuKernelImpl:Fne}),Joe={kernelName:$u,backendName:"webgl",kernelFunc:uJe};var vv=class{constructor(t,n,r,s,o,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let l=Ct(o.length),u=Ct(a.length),c="";r===1?c="i":r===2&&(c="i, j");let p=`getIndices(${c})`,d="";s===1?d="i":s===2&&(d="i, coords[1]");let f=`getUpdates(${d})`,h=n>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${o});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${h};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function cJe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:o}=t,{shape:a}=r,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=M.calculateShapes(o,s,a),d=[p/u,u];if(p===0)return n.makeTensorInfo(a,s.dtype);let f=$e({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),h=$e({inputs:{x:o},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new vv(l,i,f.shape.length,h.shape.length,c,d),x=n.runWebGLProgram(g,[h,f,m],h.dtype),y=$e({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(m),y}var Qoe={kernelName:Jx,backendName:"webgl",kernelFunc:cJe};var fO=class{constructor(t,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<n.length;c++)u.push(`${i[c]}`),c<t&&l.push(`${i[c]}`);s=l.join(),o=u.join()}let a=Ct(r);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}};function pJe(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:o}=t,a=new fO(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(a,[r,s,o],Or(s.dtype,o.dtype))}var eae={kernelName:Kp,backendName:"webgl",kernelFunc:pJe};var dJe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${M.SELU_SCALEALPHA};
  float scale = ${M.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,fJe=Xe({opSnippet:dJe}),tae={kernelName:Fu,backendName:"webgl",kernelFunc:fJe};var nae="return 1.0 / (1.0 + exp(-1.0 * x));",hJe=Xe({opSnippet:nae,packedOpSnippet:nae,cpuKernelImpl:One}),rae={kernelName:zu,backendName:"webgl",kernelFunc:hJe};var mJe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,gJe=Xe({opSnippet:mJe}),sae={kernelName:Mu,backendName:"webgl",kernelFunc:gJe};var xJe=_S+`
  return sin(x);
`,yJe=Xe({opSnippet:xJe}),oae={kernelName:Ou,backendName:"webgl",kernelFunc:yJe};var bJe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,AJe=Xe({opSnippet:bJe}),aae={kernelName:Pu,backendName:"webgl",kernelFunc:AJe};var vJe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,wJe=Xe({opSnippet:vJe}),iae={kernelName:Lu,backendName:"webgl",kernelFunc:wJe};var kJe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,paddings:a}=r;C.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=o.reduce((x,y)=>x*y),l=[[0,0]];l.push(...a);for(let x=1+o.length;x<s.shape.length;++x)l.push([0,0]);let u=[],c=nO({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),p=M.getReshaped(c.shape,o,i,!1),d=M.getPermuted(p.length,o.length,!1),f=M.getReshapedPermuted(c.shape,o,i,!1),h=$e({inputs:{x:c},backend:n,attrs:{shape:p}}),m=On({inputs:{x:h},backend:n,attrs:{perm:d}}),g=$e({inputs:{x:m},backend:n,attrs:{shape:f}});return u.push(c),u.push(h),u.push(m),u.forEach(x=>n.disposeIntermediateTensorInfo(x)),g},lae={kernelName:Yp,backendName:"webgl",kernelFunc:kJe};function IJe(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:o,defaultValue:a}=t;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(o.dataId),c=n.readSync(a.dataId)[0],[p,d,f,h,m]=Mne(i,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],s.dtype,f),n.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var uae={kernelName:Qx,backendName:"webgl",kernelFunc:IJe};function CJe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:o}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);let a=Array.from(n.readSync(s.dataId)),i=n.readSync(r.dataId),l=Array.from(n.readSync(o.dataId)),[u,c,p]=zne(i,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([p.length],o.dtype,new Int32Array(p))]}var cae={kernelName:ey,backendName:"webgl",kernelFunc:CJe};function SJe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);let a=n.readSync(r.dataId),i=n.readSync(s.dataId),l=n.readSync(o.dataId),[u,c]=SS(a,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var pae={kernelName:ty,backendName:"webgl",kernelFunc:SJe};function NJe(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);let a=n.readSync(r.dataId),i=n.readSync(s.dataId),l=n.readSync(o.dataId),[u,c]=SS(a,r.shape,r.dtype,i,l);return n.makeTensorInfo(c,r.dtype,u)}var dae={kernelName:ny,backendName:"webgl",kernelFunc:NJe};function TJe(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:a}=t,{outputShape:i}=r,{sliceRank:l,numUpdates:u,strides:c,outputSize:p}=M.calculateShapes(o,s,i),d=!1,f=new vv(u,l,s.shape.length,o.shape.length,c,[p,1],d),h=n.runWebGLProgram(f,[o,s,a],o.dtype),m=$e({inputs:{x:h},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),m}var fae={kernelName:ry,backendName:"webgl",kernelFunc:TJe};function _Je(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:o,axis:a}=r,i=C.parseAxisParam(a,s.shape)[0],l=M.prepareSplitSize(s,o,i),u=s.shape.length,c=new Array(u).fill(0),p=s.shape.slice();return l.map(d=>{let f=[...p];f[i]=d;let h=el({inputs:{x:s},backend:n,attrs:{begin:c,size:f}});return c[i]+=d,h})}var hae={kernelName:Jp,backendName:"webgl",kernelFunc:_Je};var mae="return sqrt(x);",EJe=Xe({opSnippet:mae,packedOpSnippet:mae,cpuKernelImpl:Lne}),gae={kernelName:Bu,backendName:"webgl",kernelFunc:EJe};var RJe="return x * x;",DJe=Xe({opSnippet:RJe}),xae={kernelName:sy,backendName:"webgl",kernelFunc:DJe};var yae="return (a - b) * (a - b);",$Je=Qt({opSnippet:yae,packedOpSnippet:yae}),bae={kernelName:Vu,backendName:"webgl",kernelFunc:$Je};function FJe({inputs:e,attrs:t,backend:n}){let{x:r}=e,s=Qr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,o=new $o(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}var Aae={kernelName:ju,backendName:"webgl",kernelFunc:FJe};var hO=class{constructor(t,n,r){this.variableNames=["x"],this.outputShape=r;let s=r.length,o=Ct(r.length),a=Ct(r.length),i="";if(s===1)i="coords * strides + begin";else{let l=0;i=r.map((u,c)=>(l++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${t});
      ${o} strides = ${o}(${n});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function OJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=r,{nonStrided:f,$begin:h,$strides:m,size:g,newShape:x,outShape:y}=Cs.sliceInfo(s.shape,o,a,i,l,u,c,p,d),b=$e({inputs:{x:s},backend:n,attrs:{shape:x}}),A;if(f){let w=el({inputs:{x:b},backend:n,attrs:{begin:h,size:g}});A=$e({inputs:{x:w},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(w)}else if(y.some(w=>w===0))A=n.makeTensorInfo(y,s.dtype,[]);else if(n.shouldExecuteOnCPU([b])){let I=n.texData.get(b.dataId).values,N=et(b.shape,b.dtype,I),T=Bne(y,N,m,h);A=n.makeTensorInfo(y,b.dtype,T.values)}else{let k=new hO(h,m,y);A=n.runWebGLProgram(k,[b],b.dtype)}let v=$e({inputs:{x:A},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(A),v}var vae={kernelName:oy,backendName:"webgl",kernelFunc:OJe};function PJe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=t,d=n.readSync(c.dataId),f=n.readSync(p.dataId),[h,m]=Vne(d,f,s,o,a,i,l,u);return[n.makeTensorInfo([h.length],"string",h),n.makeTensorInfo(p.shape,"int32",m)]}var wae={kernelName:ay,backendName:"webgl",kernelFunc:PJe};function MJe(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:o,delimiter:a}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=n.readSync(o.dataId),l=n.readSync(a.dataId)[0],[u,c,p]=Wne(i,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var kae={kernelName:iy,backendName:"webgl",kernelFunc:MJe};function zJe(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let a=n.readSync(o.dataId),i=Gne(a,s);return n.makeTensorInfo(o.shape,"int32",i)}var Iae={kernelName:ly,backendName:"webgl",kernelFunc:zJe};var LJe="return tan(x);",BJe=Xe({opSnippet:LJe}),Cae={kernelName:Gu,backendName:"webgl",kernelFunc:BJe};var VJe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,WJe=Xe({opSnippet:VJe}),Sae={kernelName:Uu,backendName:"webgl",kernelFunc:WJe};var mO=class{constructor(t,n){this.variableNames=["A"];let r=new Array(t.length);for(let a=0;a<r.length;a++)r[a]=t[a]*n[a];this.outputShape=r,this.rank=r.length;let s=Ct(this.rank),o=GJe(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function GJe(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}function gO(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){let l=n.readSync(s.dataId),u=s.dtype==="string"?l.map(d=>C.decodeString(d)):l,c=et(s.shape,s.dtype,u),p=jne(c,o);return n.makeTensorInfo(p.shape,p.dtype,p.values)}let a=new mO(s.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}var Nae={kernelName:vl,backendName:"webgl",kernelFunc:gO};var xO=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},yO=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function qm(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function Tae(e){let t=1;for(;t<e;)t*=2;return t}function UJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:o,sorted:a}=r,i=he().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=he().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<i||o>l){let T=n.readSync(s.dataId),[_,R]=Hne(T,u,s.dtype,o,a);return[n.makeTensorInfo(_.shape,_.dtype,_.values),n.makeTensorInfo(R.shape,R.dtype,R.values)]}if(o===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,vc({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let p=n.texData.get(s.dataId),d=p!==null&&p.isPacked,f=d?n.unpackTensor(s):s,m=C.sizeFromShape(u)/c,g=$e({inputs:{x:f},attrs:{shape:[m,c]},backend:n});d&&qm(n,f);let x=Tae(o),y=Tae(c),b=null,A=()=>b===null?[g,g]:[g,b],v=(T,_,R)=>{let S=A(),F=new xO(R),W=[[c],[b===null?1:0],[Number.NEGATIVE_INFINITY],[T],[_]],q=b;b=n.runWebGLProgram(F,S,"int32",W),qm(n,q)};for(let T=1;T<x;T*=2){let _=T*2;for(let R=T;R>=1;R/=2)v(_,R,[m,y])}for(let T=y;T>x;T/=2){let _=A(),R=new yO([m,T/2]),F=[[c],[b===null?1:0],[x]],B=b;b=n.runWebGLProgram(R,_,"int32",F),qm(n,B);let W=x/2,q=W*2;for(let K=W;K>=1;K/=2)v(q,K,b.shape)}let w=b;b=el({inputs:{x:b},backend:n,attrs:{begin:0,size:[m,o]}}),qm(n,w);let k=B8({inputs:{x:g,indices:b},backend:n,attrs:{axis:1,batchDims:1}});qm(n,g);let I=u.slice(0,-1);I.push(o),w=b,b=$e({inputs:{x:b},attrs:{shape:I},backend:n}),qm(n,w);let N=k;return k=$e({inputs:{x:k},attrs:{shape:I},backend:n}),qm(n,N),[k,b]}var _ae={kernelName:uy,backendName:"webgl",kernelFunc:UJe};var bO=class{constructor(t,n,r,s,o,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let i=r==="nearest"?1:2,l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function jJe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:o}=t,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=r,[c,p,d,f]=s.shape,[h,m]=u!=null?u:[p,d],g=[c,h,m,f],x=new bO(p,d,a,i,l,g);return n.runWebGLProgram(x,[s,o],"float32")}var Eae={kernelName:cy,backendName:"webgl",kernelFunc:jJe};function HJe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:o}=t;Rl(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=r.readSync(o.dataId),{outputValues:i,outputShape:l,indices:u}=qne(a,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,i),r.makeTensorInfo([u.length],"int32",u)]}var Rae={kernelName:py,backendName:"webgl",kernelFunc:HJe};function qJe(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:o}=r;o<0&&(o+=s.shape.length);let a=s,i=a.shape.length,l=s.shape[o],u=new Array(i-1),c=0;for(let m=0;m<i;m++)m!==o&&(u[c++]=a.shape[m]);let p=[],d=new Array(i).fill(0),f=a.shape.slice();f[o]=1;let h=new Array(l);for(let m=0;m<h.length;m++){d[o]=m;let g=el({inputs:{x:a},backend:n,attrs:{begin:d,size:f}}),x=$e({inputs:{x:g},backend:n,attrs:{shape:u}});h[m]=x,p.push(g)}return p.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var Dae={kernelName:td,backendName:"webgl",kernelFunc:qJe};var AO=class{constructor(t,n){this.variableNames=["x","segmentIds"];let r=t.windowSize,s=t.batchSize,o=t.inSize,a=t.numSegments,i=a*Math.ceil(o/r);this.outputShape=[s,i];let l="0.0",u="sumValue",c=Math.floor(r/4)*4,p=r%4,d=`
        sumValue += dot(values, segFilter);
    `,f="";o%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let h="";o%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};function KJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:o}=t,{numSegments:a}=r,i=s.shape.length,l=[],u=0,c=M.getAxesPermutation([u],i),p=s;c!=null&&(p=On({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(p),u=M.getInnerMostAxes(1,i)[0]);let d=M.segment_util.computeOutShape(p.shape,u,a),f=C.sizeFromShape([p.shape[u]]),h=$e({inputs:{x:p},backend:n,attrs:{shape:[-1,f]}});l.push(h);let m=Vh(s.dtype),g=(A,v,w,k,I)=>{let N=A.shape[0],T=A.shape[1],_=M.segment_util.segOpComputeOptimalWindowSize(T,I),R={windowSize:_,inSize:T,batchSize:N,numSegments:I},S=new AO(R,v),F=n.compileAndRun(S,[A,w],k);if(l.push(F),F.shape[1]===I)return F;let B=rO({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),W=gO({inputs:{x:B},backend:n,attrs:{reps:[T/_]}});return l.push(B),l.push(W),g(F,v,W,k,I)},x=g(h,"unsortedSegmentSum",o,m,a),y=$e({inputs:{x},backend:n,attrs:{shape:d}}),b=y;if(c!=null){l.push(y);let A=M.getUndoAxesPermutation(c);b=On({inputs:{x:b},backend:n,attrs:{perm:A}})}return l.forEach(A=>n.disposeIntermediateTensorInfo(A)),b}var $ae={kernelName:nd,backendName:"webgl",kernelFunc:KJe};var XJe=[aoe,ioe,vre,kre,Ire,Cre,Nre,Tre,_re,Ere,$re,Fre,Ore,Pre,zre,Mre,Lre,Vre,Bre,Wre,Gre,Ure,jre,qre,Kre,Jre,ese,tse,rse,ure,ose,ise,lse,ase,cse,pse,use,dse,fse,hse,xse,yse,bse,vse,wse,Ase,kse,Ise,Cse,Sse,Nse,Tse,_se,Rse,Dse,Fse,Ose,Pse,Mse,Lse,Bse,Vse,Wse,Gse,Use,jse,Hse,qse,lre,Kse,sse,Xse,Zse,Yse,cre,Jse,Qse,eoe,noe,toe,roe,soe,ooe,uoe,doe,poe,foe,hoe,goe,coe,yoe,boe,Aoe,voe,woe,Noe,mre,_oe,Eoe,Roe,Doe,Xre,$oe,Poe,Moe,zoe,Loe,pre,Boe,Voe,Zre,koe,Woe,Uoe,Goe,xre,joe,Hoe,qoe,Koe,Xoe,Zoe,Yoe,Joe,Qoe,eae,tae,rae,sae,oae,aae,Hre,Soe,iae,lae,uae,cae,pae,dae,fae,hae,gae,xae,bae,Aae,vae,wae,kae,Iae,Coe,bre,Cae,Sae,Nae,_ae,Eae,Are,Rae,Dae,$ae,Foe];for(let e of XJe)g3(e);var Fae=["nose","leftEyeInside","leftEye","leftEyeOutside","rightEyeInside","rightEye","rightEyeOutside","leftEar","rightEar","leftMouth","rightMouth","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftPalm","rightPalm","leftIndex","rightIndex","leftPinky","rightPinky","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle","leftHeel","rightHeel","leftFoot","rightFoot","bodyCenter","bodyTop","leftThumb","leftHand","rightThumb","rightHand"],Oae={leftLeg:["leftHip","leftKnee","leftAnkle","leftHeel","leftFoot"],rightLeg:["rightHip","rightKnee","rightAnkle","rightHeel","rightFoot"],torso:["leftShoulder","rightShoulder","rightHip","leftHip","leftShoulder"],leftArm:["leftShoulder","leftElbow","leftWrist","leftPalm"],rightArm:["rightShoulder","rightElbow","rightWrist","rightPalm"],leftHand:[],rightHand:[],head:[]};var Pae={initial:!0},es=[null,null],_d=[[0,0],[0,0]],vO=Number.MAX_SAFE_INTEGER,wO,kO=null,Ed=[[0,0],[0,0],[0,0],[0,0]];async function Mae(e){var t,n;if(Pae.initial&&(es[0]=null),!es[0]&&((t=e.body.detector)==null?void 0:t.modelPath)){es[0]=await KC(an(e.modelBasePath,((n=e.body.detector)==null?void 0:n.modelPath)||""));let r=Object.values(es[0].modelSignature.inputs);_d[0][0]=Array.isArray(r)?parseInt(r[0].tensorShape.dim[1].size):0,_d[0][1]=Array.isArray(r)?parseInt(r[0].tensorShape.dim[2].size):0,!es[0]||!es[0].modelUrl?Ce("load model failed:",e.object.modelPath):e.debug&&Ce("load model:",es[0].modelUrl)}else e.debug&&es[0]&&Ce("cached model:",es[0].modelUrl);return es[0]}async function zae(e){var t;if(Pae.initial&&(es[1]=null),es[1])e.debug&&Ce("cached model:",es[1].modelUrl);else{es[1]=await KC(an(e.modelBasePath,e.body.modelPath||""));let n=Object.values(es[1].modelSignature.inputs);_d[1][0]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[1].size):0,_d[1][1]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[2].size):0,((t=e.body.modelPath)==null?void 0:t.includes("lite"))?wO=["ld_3d","output_segmentation","output_heatmap","world_3d","output_poseflag"]:wO=["Identity","Identity_2","Identity_3","Identity_4","Identity_1"],!es[1]||!es[1].modelUrl?Ce("load model failed:",e.object.modelPath):e.debug&&Ce("load model:",es[1].modelUrl)}return es[1]}function ZJe(e,t){let n=e.map(a=>a.position[0]),r=e.map(a=>a.position[1]),s=[Math.min(...n),Math.min(...r),Math.max(...n)-Math.min(...n),Math.max(...r)-Math.min(...r)],o=[s[0]/t[0],s[1]/t[1],s[2]/t[0],s[3]/t[1]];return{keypointsBox:s,keypointsBoxRaw:o}}async function YJe(e){let t={};if(!e.shape||!e.shape[1]||!e.shape[2])return e;Ed=[[0,0],[e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0,e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0],[e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0,e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0],[0,0]],t.pad=zi(e,Ed),t.resize=so.resizeBilinear(t.pad,[_d[1][0],_d[1][1]]);let n=Pe(t.resize,255);return Object.keys(t).forEach(r=>ut(t[r])),n}function JJe(e,t){for(let n of e)n.position=[n.position[0]*(t[0]+Ed[2][0]+Ed[2][1])/t[0]-Ed[2][0],n.position[1]*(t[1]+Ed[1][0]+Ed[1][1])/t[1]-Ed[1][0],n.position[2]],n.positionRaw=[n.position[0]/t[0],n.position[1]/t[1],n.position[2]];return e}async function QJe(e,t,n){var p;let r={};r.input=await YJe(e),[r.ld,r.segmentation,r.heatmap,r.world,r.poseflag]=await((p=es[1])==null?void 0:p.execute(r.input,wO));let s=await r.ld.data(),o=[],a=5;for(let d=0;d<s.length/a;d++){let f=(100-Math.trunc(100/(1+Math.exp(s[a*d+3]))))/100,h=[s[a*d+0]/_d[1][0],s[a*d+1]/_d[1][1],s[a*d+2]+0],m=[Math.trunc(n[0]*h[0]),Math.trunc(n[1]*h[1]),h[2]];o.push({part:Fae[d],positionRaw:h,position:m,score:f})}let i=Math.round(100*o.reduce((d,f)=>d+=f.score,0)/o.length)/100;if(i<(t.body.minConfidence||0))return null;let l=JJe(o,n),u=ZJe(l,[n[0],n[1]]);Object.keys(r).forEach(d=>ut(r[d]));let c={};for(let[d,f]of Object.entries(Oae)){let h=[];for(let m=0;m<f.length-1;m++){let g=l.find(y=>y.part===f[m]),x=l.find(y=>y.part===f[m+1]);g&&x&&g.score>(t.body.minConfidence||0)&&x.score>(t.body.minConfidence||0)&&h.push([g.position,x.position])}c[d]=h}return{id:0,score:i,box:u.keypointsBox,boxRaw:u.keypointsBoxRaw,keypoints:l,annotations:c}}async function IO(e,t){let n=[e.shape[2]||0,e.shape[1]||0];return vO<(t.body.skipFrames||0)&&t.skipFrame?vO++:(kO=await QJe(e,t,n),vO=0),kO?[kO]:[]}var Lae=["head","neck","rightShoulder","rightElbow","rightWrist","chest","leftShoulder","leftElbow","leftWrist","bodyCenter","rightHip","rightKnee","rightAnkle","leftHip","leftKnee","leftAnkle"],Bae={leftLeg:["leftHip","leftKnee","leftAnkle"],rightLeg:["rightHip","rightKnee","rightAnkle"],torso:["leftShoulder","rightShoulder","rightHip","leftHip","leftShoulder"],leftArm:["leftShoulder","leftElbow","leftWrist"],rightArm:["rightShoulder","rightElbow","rightWrist"],head:[]};var ts,ci=[],CO=[0,0,0,0],SO=[0,0,0,0],VS=0,NO=Number.MAX_SAFE_INTEGER;async function TO(e){return Ee.initial&&(ts=null),ts?e.debug&&Ce("cached model:",ts.modelUrl):(ts=await yn(an(e.modelBasePath,e.body.modelPath||"")),!ts||!ts.modelUrl?Ce("load model failed:",e.body.modelPath):e.debug&&Ce("load model:",ts.modelUrl)),ts}function eQe(e,t){let[n,r]=e.shape;return ce(()=>{let s=(i,l)=>Ge(i,te(Me(i,at(l,"int32")),at(l,"int32"))),o=ie(e,[r*n]),a=Wo(o,0).dataSync()[0];if(a>t){let i=xi(o,0),l=s(i,n).dataSync()[0],u=Me(i,at(n,"int32")).dataSync()[0];return[l,u,a]}return[0,0,a]})}async function _O(e,t){var n;return NO<(((n=t.body)==null?void 0:n.skipFrames)||0)&&t.skipFrame&&Object.keys(ci).length>0?(NO++,[{id:0,score:VS,box:CO,boxRaw:SO,keypoints:ci,annotations:{}}]):(NO=0,new Promise(async r=>{var p;let s=ce(()=>{if(!(ts==null?void 0:ts.inputs[0].shape))return null;let d=ht.resizeBilinear(e,[ts.inputs[0].shape[2],ts.inputs[0].shape[1]],!1);return te(d,2).sub(1)}),o;if(t.body.enabled&&(o=await(ts==null?void 0:ts.predict(s))),ye(s),o){ci.length=0;let d=o.squeeze();ye(o);let f=d.unstack(2);ye(d);for(let h=0;h<f.length;h++){let[m,g,x]=eQe(f[h],t.body.minConfidence);VS>(((p=t.body)==null?void 0:p.minConfidence)||0)&&ci.push({score:Math.round(100*x)/100,part:Lae[h],positionRaw:[m/ts.inputs[0].shape[2],g/ts.inputs[0].shape[1]],position:[Math.round(e.shape[2]*m/ts.inputs[0].shape[2]),Math.round(e.shape[1]*g/ts.inputs[0].shape[1])]})}f.forEach(h=>ye(h))}VS=ci.reduce((d,f)=>f.score>d?f.score:d,0);let a=ci.map(d=>d.position[0]),i=ci.map(d=>d.position[1]);CO=[Math.min(...a),Math.min(...i),Math.max(...a)-Math.min(...a),Math.max(...i)-Math.min(...i)];let l=ci.map(d=>d.positionRaw[0]),u=ci.map(d=>d.positionRaw[1]);SO=[Math.min(...l),Math.min(...u),Math.max(...l)-Math.min(...l),Math.max(...u)-Math.min(...u)];let c={};for(let[d,f]of Object.entries(Bae)){let h=[];for(let m=0;m<f.length-1;m++){let g=ci.find(y=>y.part===f[m]),x=ci.find(y=>y.part===f[m+1]);g&&x&&g.score>(t.body.minConfidence||0)&&x.score>(t.body.minConfidence||0)&&h.push([g.position,x.position])}c[d]=h}r([{id:0,score:VS,box:CO,boxRaw:SO,keypoints:ci,annotations:c}])}))}var EO=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],RO={leftLeg:["leftHip","leftKnee","leftAnkle"],rightLeg:["rightHip","rightKnee","rightAnkle"],torso:["leftShoulder","rightShoulder","rightHip","leftHip","leftShoulder"],leftArm:["leftShoulder","leftElbow","leftWrist"],rightArm:["rightShoulder","rightElbow","rightWrist"],head:[]};var ns,Km=0,Rd=[],DO=Number.MAX_SAFE_INTEGER,Na=[];async function Vae(e){return Ee.initial&&(ns=null),ns?e.debug&&Ce("cached model:",ns.modelUrl):(lx(["size"],e),ns=await yn(an(e.modelBasePath,e.body.modelPath||"")),!ns||!ns.modelUrl?Ce("load model failed:",e.body.modelPath):e.debug&&Ce("load model:",ns.modelUrl)),Km=ns.inputs[0].shape?ns.inputs[0].shape[2]:0,Km===-1&&(Km=256),ns}function Wae(e){let t=e.map(i=>i.position[0]),n=e.map(i=>i.position[1]),r=[Math.min(...t),Math.min(...n),Math.max(...t)-Math.min(...t),Math.max(...n)-Math.min(...n)],s=e.map(i=>i.positionRaw[0]),o=e.map(i=>i.positionRaw[1]),a=[Math.min(...s),Math.min(...o),Math.max(...s)-Math.min(...s),Math.max(...o)-Math.min(...o)];return[r,a]}async function Gae(e,t,n,r){let s=e[0][0];Na.length=0;let o=0;for(let c=0;c<s.length;c++)if(o=s[c][2],o>t.body.minConfidence){let p=[(r[3]-r[1])*s[c][1]+r[1],(r[2]-r[0])*s[c][0]+r[0]];Na.push({score:Math.round(100*o)/100,part:EO[c],positionRaw:p,position:[Math.round((n.shape[2]||0)*p[0]),Math.round((n.shape[1]||0)*p[1])]})}o=Na.reduce((c,p)=>p.score>c?p.score:c,0);let a=[],[i,l]=Wae(Na),u={};for(let[c,p]of Object.entries(RO)){let d=[];for(let f=0;f<p.length-1;f++){let h=Na.find(g=>g.part===p[f]),m=Na.find(g=>g.part===p[f+1]);h&&m&&h.score>(t.body.minConfidence||0)&&m.score>(t.body.minConfidence||0)&&d.push([h.position,m.position])}u[c]=d}return a.push({id:0,score:o,box:i,boxRaw:l,keypoints:Na,annotations:u}),a}async function Uae(e,t,n,r){let s=[];for(let o=0;o<e[0].length;o++){let a=e[0][o],i=Math.round(100*a[51+4])/100;if(i>t.body.minConfidence){Na.length=0;for(let p=0;p<17;p++){let d=a[3*p+2];if(d>t.body.minConfidence){let f=[(r[3]-r[1])*a[3*p+1]+r[1],(r[2]-r[0])*a[3*p+0]+r[0]];Na.push({part:EO[p],score:Math.round(100*d)/100,positionRaw:f,position:[Math.round((n.shape[2]||0)*f[0]),Math.round((n.shape[1]||0)*f[1])]})}}let[l,u]=Wae(Na),c={};for(let[p,d]of Object.entries(RO)){let f=[];for(let h=0;h<d.length-1;h++){let m=Na.find(x=>x.part===d[h]),g=Na.find(x=>x.part===d[h+1]);m&&g&&m.score>(t.body.minConfidence||0)&&g.score>(t.body.minConfidence||0)&&f.push([m.position,g.position])}c[p]=f}s.push({id:o,score:i,boxRaw:u,box:l,keypoints:[...Na],annotations:c})}}return s.sort((o,a)=>a.score-o.score),s.length>t.body.maxDetected&&(s.length=t.body.maxDetected),s}async function $O(e,t){return!ns||!(ns==null?void 0:ns.inputs[0].shape)?[]:new Promise(async n=>{let r={},s=[];t.skipFrame||(Rd.length=0),DO++;for(let o=0;o<Rd.length;o++){r.crop=ht.cropAndResize(e,[Rd[o]],[0],[Km,Km],"bilinear"),r.cast=Fe(r.crop,"int32"),r.res=await(ns==null?void 0:ns.predict(r.cast));let a=await r.res.array(),i=r.res.shape[2]===17?await Gae(a,t,e,Rd[o]):await Uae(a,t,e,Rd[o]);s=s.concat(i),Object.keys(r).forEach(l=>ye(r[l]))}if(s.length!==t.body.maxDetected&&DO>(t.body.skipFrames||0)){r.resized=ht.resizeBilinear(e,[Km,Km],!1),r.cast=Fe(r.resized,"int32"),r.res=await(ns==null?void 0:ns.predict(r.cast));let o=await r.res.array();s=r.res.shape[2]===17?await Gae(o,t,e,[0,0,1,1]):await Uae(o,t,e,[0,0,1,1]),Object.keys(r).forEach(a=>ye(r[a])),Rd.length=0,DO=0}if(t.skipFrame){Rd.length=0;for(let o=0;o<s.length;o++)if(s[o].keypoints.length>10){let a=s[o].keypoints.map(l=>l.position),i=l3(a,1.5,[e.shape[2],e.shape[1]]);Rd.push([...i.yxBox])}}n(s)})}var h1=[{class:1,label:"person"},{class:2,label:"bicycle"},{class:3,label:"car"},{class:4,label:"motorcycle"},{class:5,label:"airplane"},{class:6,label:"bus"},{class:7,label:"train"},{class:8,label:"truck"},{class:9,label:"boat"},{class:10,label:"traffic light"},{class:11,label:"fire hydrant"},{class:12,label:"stop sign"},{class:13,label:"parking meter"},{class:14,label:"bench"},{class:15,label:"bird"},{class:16,label:"cat"},{class:17,label:"dog"},{class:18,label:"horse"},{class:19,label:"sheep"},{class:20,label:"cow"},{class:21,label:"elephant"},{class:22,label:"bear"},{class:23,label:"zebra"},{class:24,label:"giraffe"},{class:25,label:"backpack"},{class:26,label:"umbrella"},{class:27,label:"handbag"},{class:28,label:"tie"},{class:29,label:"suitcase"},{class:30,label:"frisbee"},{class:31,label:"skis"},{class:32,label:"snowboard"},{class:33,label:"sports ball"},{class:34,label:"kite"},{class:35,label:"baseball bat"},{class:36,label:"baseball glove"},{class:37,label:"skateboard"},{class:38,label:"surfboard"},{class:39,label:"tennis racket"},{class:40,label:"bottle"},{class:41,label:"wine glass"},{class:42,label:"cup"},{class:43,label:"fork"},{class:44,label:"knife"},{class:45,label:"spoon"},{class:46,label:"bowl"},{class:47,label:"banana"},{class:48,label:"apple"},{class:49,label:"sandwich"},{class:50,label:"orange"},{class:51,label:"broccoli"},{class:52,label:"carrot"},{class:53,label:"hot dog"},{class:54,label:"pizza"},{class:55,label:"donut"},{class:56,label:"cake"},{class:57,label:"chair"},{class:58,label:"couch"},{class:59,label:"potted plant"},{class:60,label:"bed"},{class:61,label:"dining table"},{class:62,label:"toilet"},{class:63,label:"tv"},{class:64,label:"laptop"},{class:65,label:"mouse"},{class:66,label:"remote"},{class:67,label:"keyboard"},{class:68,label:"cell phone"},{class:69,label:"microwave"},{class:70,label:"oven"},{class:71,label:"toaster"},{class:72,label:"sink"},{class:73,label:"refrigerator"},{class:74,label:"book"},{class:75,label:"clock"},{class:76,label:"vase"},{class:77,label:"scissors"},{class:78,label:"teddy bear"},{class:79,label:"hair drier"},{class:80,label:"toothbrush"}];var ua,WS=[],FO=Number.MAX_SAFE_INTEGER,GS=2.5;async function jae(e){if(!ua||Ee.initial){ua=await yn(an(e.modelBasePath,e.object.modelPath||""));let t=Object.values(ua.modelSignature.inputs);if(ua.inputSize=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):null,!ua.inputSize)throw new Error(`cannot determine model inputSize: ${e.object.modelPath}`);!ua||!ua.modelUrl?Ce("load model failed:",e.object.modelPath):e.debug&&Ce("load model:",ua.modelUrl)}else e.debug&&Ce("cached model:",ua.modelUrl);return ua}async function tQe(e,t,n,r){let s=0,o=[];for(let u of[1,2,4])ce(async()=>{var g,x;let c=u*13,p=(g=e.find(y=>y.shape[1]===c**2&&y.shape[2]===h1.length))==null?void 0:g.squeeze(),d=(x=e.find(y=>y.shape[1]===c**2&&y.shape[2]<h1.length))==null?void 0:x.squeeze(),h=await d.reshape([-1,4,d.shape[1]/4]).argMax(2).array(),m=await p.array();for(let y=0;y<p.shape[0];y++)for(let b=0;b<p.shape[1];b++){let A=m[y][b];if(A>r.object.minConfidence&&b!==61){let v=(.5+Math.trunc(y%c))/c,w=(.5+Math.trunc(y/c))/c,k=h[y].map(B=>B*(c/u/t)),[I,N]=[v-GS/u*k[0],w-GS/u*k[1]],[T,_]=[v+GS/u*k[2]-I,w+GS/u*k[3]-N],R=[I,N,T,_];R=R.map(B=>Math.max(0,Math.min(B,1)));let S=[R[0]*n[0],R[1]*n[1],R[2]*n[0],R[3]*n[1]],F={id:s++,score:Math.round(100*A)/100,class:b+1,label:h1[b].label,box:S.map(B=>Math.trunc(B)),boxRaw:R};o.push(F)}}});e.forEach(u=>ye(u));let a=o.map(u=>[u.boxRaw[1],u.boxRaw[0],u.boxRaw[3],u.boxRaw[2]]),i=o.map(u=>u.score),l=[];if(a&&a.length>0){let u=await ht.nonMaxSuppressionAsync(a,i,r.object.maxDetected,r.object.iouThreshold,r.object.minConfidence);l=await u.data(),ye(u)}return o=o.filter((u,c)=>l.includes(c)).sort((u,c)=>c.score-u.score),o}async function OO(e,t){return FO<(t.object.skipFrames||0)&&t.skipFrame&&WS.length>0?(FO++,WS):(FO=0,!Ee.kernels.includes("mod")||!Ee.kernels.includes("sparsetodense")?WS:new Promise(async n=>{let r=[e.shape[2],e.shape[1]],s=ht.resizeBilinear(e,[ua.inputSize,ua.inputSize],!1),o=Me(s,255),a=o.transpose([0,3,1,2]);ye(o),ye(s);let i;t.object.enabled&&(i=await ua.predict(a)),ye(a);let l=await tQe(i,ua.inputSize,r,t);WS=l,n(l)}))}var pi,Xm=0,US=[],PO=Number.MAX_SAFE_INTEGER;async function Hae(e){if(Ee.initial&&(pi=null),pi)e.debug&&Ce("cached model:",pi.modelUrl);else{lx(["floormod"],e),pi=await yn(an(e.modelBasePath,e.object.modelPath||""));let t=Object.values(pi.modelSignature.inputs);Xm=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):0,!pi||!pi.modelUrl?Ce("load model failed:",e.object.modelPath):e.debug&&Ce("load model:",pi.modelUrl)}return pi}async function nQe(e,t,n){if(!e)return[];let r=[],s=await e.array(),o=ln(e);ye(e);let a=_r(o,6,1);ye(o);let i=vs([a[1],a[0],a[3],a[2]],1),l=ln(i);ye(i);let u=ln(a[4]),c=ln(a[5]);a.forEach(h=>ye(h));let p=await ht.nonMaxSuppressionAsync(l,u,n.object.maxDetected,n.object.iouThreshold,n.object.minConfidence);ye(l),ye(u),ye(c);let d=await p.data();ye(p);let f=0;for(let h of d){let m=Math.trunc(100*s[0][h][4])/100,g=s[0][h][5],x=h1[g].label,[y,b]=[s[0][h][0]/Xm,s[0][h][1]/Xm],A=[y,b,s[0][h][2]/Xm-y,s[0][h][3]/Xm-b],v=[Math.trunc(A[0]*t[0]),Math.trunc(A[1]*t[1]),Math.trunc(A[2]*t[0]),Math.trunc(A[3]*t[1])];r.push({id:f++,score:m,class:g,label:x,box:v,boxRaw:A})}return r}async function MO(e,t){return PO<(t.object.skipFrames||0)&&t.skipFrame&&US.length>0?(PO++,US):(PO=0,!Ee.kernels.includes("mod")||!Ee.kernels.includes("sparsetodense")?US:new Promise(async n=>{let r=[e.shape[2],e.shape[1]],s=ht.resizeBilinear(e,[Xm,Xm]),o=t.object.enabled?pi==null?void 0:pi.execute(s,["tower_0/detections"]):null;ye(s);let a=await nQe(o,r,t);US=a,n(a)}))}var Ta,zO=!1;async function LO(e){return!Ta||Ee.initial?(Ta=await yn(an(e.modelBasePath,e.segmentation.modelPath||"")),!Ta||!Ta.modelUrl?Ce("load model failed:",e.segmentation.modelPath):e.debug&&Ce("load model:",Ta.modelUrl)):e.debug&&Ce("cached model:",Ta.modelUrl),Ta}async function qae(e,t,n){var m,g;if(zO)return{data:[],canvas:null,alpha:null};zO=!0,Ta||await LO(n);let r=rx(e,n),s=((m=r.canvas)==null?void 0:m.width)||0,o=((g=r.canvas)==null?void 0:g.height)||0;if(!r.tensor)return{data:[],canvas:null,alpha:null};let a={};a.resize=ht.resizeBilinear(r.tensor,[Ta.inputs[0].shape?Ta.inputs[0].shape[1]:0,Ta.inputs[0].shape?Ta.inputs[0].shape[2]:0],!1),ye(r.tensor),a.norm=Me(a.resize,255),a.res=Ta.predict(a.norm),a.squeeze=ln(a.res,0),a.squeeze.shape[2]===2?(a.softmax=Jf(a.squeeze),[a.bg,a.fg]=Vs(a.softmax,2),a.expand=kr(a.fg,2),a.pad=kr(a.expand,0),a.crop=ht.cropAndResize(a.pad,[[0,0,.5,.5]],[0],[s,o]),a.data=ln(a.crop,0)):a.data=ht.resizeBilinear(a.squeeze,[o,s]);let i=Array.from(await a.data.data());if(Ee.node&&!Ee.Canvas&&typeof ImageData=="undefined")return n.debug&&Ce("canvas support missing"),Object.keys(a).forEach(x=>ye(a[x])),{data:i,canvas:null,alpha:null};let l=Zo(s,o);await Mo.toPixels(a.data,l);let u=l.getContext("2d");n.segmentation.blur&&n.segmentation.blur>0&&(u.filter=`blur(${n.segmentation.blur}px)`);let c=u.getImageData(0,0,s,o),p=Zo(s,o),d=p.getContext("2d");r.canvas&&d.drawImage(r.canvas,0,0),d.globalCompositeOperation="darken",n.segmentation.blur&&n.segmentation.blur>0&&(d.filter=`blur(${n.segmentation.blur}px)`),d.drawImage(l,0,0),d.globalCompositeOperation="source-over",d.filter="none";let f=d.getImageData(0,0,s,o);for(let x=0;x<s*o;x++)f.data[4*x+3]=c.data[4*x+0];d.putImageData(f,0,0);let h=null;if(t&&p){h=Zo(s,o);let x=rx(t,n);ye(x.tensor);let y=h.getContext("2d");y.drawImage(x.canvas,0,0,h.width,h.height),y.drawImage(p,0,0)}return Object.keys(a).forEach(x=>ye(a[x])),zO=!1,{data:i,canvas:h||p,alpha:l}}var Dd;var jDn=Number.MAX_SAFE_INTEGER;async function Kae(e){return Ee.initial&&(Dd=null),Dd?e.debug&&Ce("cached model:",Dd.modelUrl):(Dd=await yn(an(e.modelBasePath,e.face.agegenderrace.modelPath)),!Dd||!Dd.modelUrl?Ce("load model failed:",e.face.agegenderrace.modelPath):e.debug&&Ce("load model:",Dd.modelUrl)),Dd}var wv=class{constructor(){nt(this,"age",null);nt(this,"agegenderrace",null);nt(this,"blazeposedetect",null);nt(this,"blazepose",null);nt(this,"centernet",null);nt(this,"efficientpose",null);nt(this,"embedding",null);nt(this,"emotion",null);nt(this,"facedetect",null);nt(this,"faceiris",null);nt(this,"facemesh",null);nt(this,"faceres",null);nt(this,"gender",null);nt(this,"handpose",null);nt(this,"handskeleton",null);nt(this,"handtrack",null);nt(this,"movenet",null);nt(this,"nanodet",null);nt(this,"posenet",null);nt(this,"segmentation",null)}};function BO(e){for(let t of Object.keys(e.models))e.models[t]=null}async function Xae(e){var t,n,r,s,o,a,i,l,u,c,p,d,f,h,m,g,x,y,b,A,v,w,k,I,N,T,_,R,S,F;Ee.initial&&BO(e),e.config.hand.enabled&&(!e.models.handpose&&((n=(t=e.config.hand.detector)==null?void 0:t.modelPath)==null?void 0:n.includes("handdetect"))&&([e.models.handpose,e.models.handskeleton]=await w7(e.config)),!e.models.handskeleton&&e.config.hand.landmarks&&((s=(r=e.config.hand.detector)==null?void 0:r.modelPath)==null?void 0:s.includes("handdetect"))&&([e.models.handpose,e.models.handskeleton]=await w7(e.config))),e.config.face.enabled&&!e.models.facedetect&&(e.models.facedetect=$U(e.config)),e.config.face.enabled&&((o=e.config.face.mesh)==null?void 0:o.enabled)&&!e.models.facemesh&&(e.models.facemesh=WU(e.config)),e.config.face.enabled&&((a=e.config.face.iris)==null?void 0:a.enabled)&&!e.models.faceiris&&(e.models.faceiris=OU(e.config)),e.config.hand.enabled&&!e.models.handtrack&&((l=(i=e.config.hand.detector)==null?void 0:i.modelPath)==null?void 0:l.includes("handtrack"))&&(e.models.handtrack=wj(e.config)),e.config.hand.enabled&&e.config.hand.landmarks&&!e.models.handskeleton&&((c=(u=e.config.hand.detector)==null?void 0:u.modelPath)==null?void 0:c.includes("handtrack"))&&(e.models.handskeleton=kj(e.config)),e.config.body.enabled&&!e.models.posenet&&((d=(p=e.config.body)==null?void 0:p.modelPath)==null?void 0:d.includes("posenet"))&&(e.models.posenet=tj(e.config)),e.config.body.enabled&&!e.models.efficientpose&&((h=(f=e.config.body)==null?void 0:f.modelPath)==null?void 0:h.includes("efficientpose"))&&(e.models.efficientpose=TO(e.config)),e.config.body.enabled&&!e.models.blazepose&&((g=(m=e.config.body)==null?void 0:m.modelPath)==null?void 0:g.includes("blazepose"))&&(e.models.blazepose=zae(e.config)),e.config.body.enabled&&!e.models.blazeposedetect&&((x=e.config.body.detector)==null?void 0:x.modelPath)&&((b=(y=e.config.body)==null?void 0:y.modelPath)==null?void 0:b.includes("blazepose"))&&(e.models.blazeposedetect=Mae(e.config)),e.config.body.enabled&&!e.models.efficientpose&&((v=(A=e.config.body)==null?void 0:A.modelPath)==null?void 0:v.includes("efficientpose"))&&(e.models.efficientpose=TO(e.config)),e.config.body.enabled&&!e.models.movenet&&((k=(w=e.config.body)==null?void 0:w.modelPath)==null?void 0:k.includes("movenet"))&&(e.models.movenet=Vae(e.config)),e.config.object.enabled&&!e.models.nanodet&&((N=(I=e.config.object)==null?void 0:I.modelPath)==null?void 0:N.includes("nanodet"))&&(e.models.nanodet=jae(e.config)),e.config.object.enabled&&!e.models.centernet&&((_=(T=e.config.object)==null?void 0:T.modelPath)==null?void 0:_.includes("centernet"))&&(e.models.centernet=Hae(e.config)),e.config.face.enabled&&((R=e.config.face.emotion)==null?void 0:R.enabled)&&!e.models.emotion&&(e.models.emotion=KU(e.config)),e.config.face.enabled&&((S=e.config.face.description)==null?void 0:S.enabled)&&!e.models.faceres&&(e.models.faceres=HU(e.config)),e.config.segmentation.enabled&&!e.models.segmentation&&(e.models.segmentation=LO(e.config)),e.config.face.enabled&&((F=e.config.face.agegenderrace)==null?void 0:F.enabled)&&!e.models.agegenderrace&&(e.models.agegenderrace=Kae(e.config));for await(let B of Object.keys(e.models))e.models[B]&&typeof e.models[B]!="undefined"&&(e.models[B]=await e.models[B])}async function Zae(e){let t=["const","placeholder","noop","pad","squeeze","add","sub","mul","div"];for(let n of Object.keys(e.models))if(e.models[n]){let r=[];Array.isArray(e.models[n])?r=e.models[n].filter(s=>s!==null).map(s=>s&&s.executor?s:s.model):r=[e.models[n]];for(let s of r){if(!s){e.config.debug&&Ce("model marked as loaded but not defined:",n);continue}let o=[],a=s==null?void 0:s.executor;if(a&&a.graph.nodes)for(let l of Object.values(a.graph.nodes)){let u=l.op.toLowerCase();o.includes(u)||o.push(u)}else!a&&e.config.debug&&Ce("model signature not determined:",n);let i=[];for(let l of o)!t.includes(l)&&!e.env.kernels.includes(l)&&!e.env.kernels.includes(l.replace("_",""))&&!e.env.kernels.includes(l.replace("native",""))&&!e.env.kernels.includes(l.replace("v2",""))&&i.push(l);i.length>0&&e.config.debug&&Ce("model validation:",n,i)}}}var fr={name:"humangl",priority:999,canvas:null,gl:null,extensions:[],webGLattr:{alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!1,desynchronized:!0}};function rQe(){let e=fr.gl;!e||(fr.extensions=e.getSupportedExtensions())}async function Yae(e){var t;if(e.config.backend==="humangl"&&(fr.name in zo().registry&&(!fr.gl||!fr.gl.getParameter(fr.gl.VERSION))&&(Ce("error: humangl backend invalid context"),BO(e)),!l_(fr.name))){try{fr.canvas=await Zo(100,100)}catch(r){Ce("error: cannot create canvas:",r);return}try{fr.gl=(t=fr.canvas)==null?void 0:t.getContext("webgl2",fr.webGLattr),fr.canvas&&(fr.canvas.addEventListener("webglcontextlost",async r=>{Ce("error: humangl:",r.type),Ce("possible browser memory leak using webgl"),e.emit("error")}),fr.canvas.addEventListener("webglcontextrestored",r=>{Ce("error: humangl context restored:",r)}),fr.canvas.addEventListener("webglcontextcreationerror",r=>{Ce("error: humangl context create:",r)}))}catch(r){Ce("error: cannot get WebGL context:",r);return}try{I5(2,fr.gl)}catch(r){Ce("error: cannot set WebGL context:",r);return}try{let r=new $5(fr.gl);y0(fr.name,()=>new Y0(r),fr.priority)}catch(r){Ce("error: cannot register WebGL backend:",r);return}try{zl("webgl").forEach(s=>{let o={...s,backendName:fr.name};Mc(o)})}catch(r){Ce("error: cannot update WebGL backend registration:",r);return}let n=sl().getGPGPUContext?sl().getGPGPUContext().gl:null;if(n)Ce(`humangl webgl version:${n.getParameter(n.VERSION)} renderer:${n.getParameter(n.RENDERER)}`);else{Ce("error: no current gl context:",n,fr.gl);return}try{Da.set("WEBGL_VERSION",2)}catch(r){Ce("error: cannot set WebGL backend flags:",r);return}rQe(),Ce("backend registered:",fr.name)}}async function jS(e,t=!1){if(e.state="backend",t||Ee.initial||e.config.backend&&e.config.backend.length>0&&gi()!==e.config.backend){let n=en();if(e.config.backend&&e.config.backend.length>0){if(typeof window=="undefined"&&typeof WorkerGlobalScope!="undefined"&&e.config.debug&&e.config.debug&&Ce("running inside web worker"),Ee.browser&&e.config.backend==="tensorflow"&&(e.config.debug&&Ce("override: backend set to tensorflow while running in browser"),e.config.backend="humangl"),Ee.node&&(e.config.backend==="webgl"||e.config.backend==="humangl")&&(e.config.debug&&Ce(`override: backend set to ${e.config.backend} while running in nodejs`),e.config.backend="tensorflow"),Ee.browser&&e.config.backend==="webgpu")if(typeof navigator=="undefined"||typeof navigator.gpu=="undefined")Ce("override: backend set to webgpu but browser does not support webgpu"),e.config.backend="humangl";else{let s=await navigator.gpu.requestAdapter();e.config.debug&&Ce("enumerated webgpu adapter:",s)}e.config.backend==="humangl"&&await Yae(e);let r=Object.keys(zo().registryFactory);if(e.config.debug&&Ce("available backends:",r),r.includes(e.config.backend)||(Ce(`error: backend ${e.config.backend} not found in registry`),e.config.backend=Ee.node?"tensorflow":"webgl",e.config.debug&&Ce(`override: setting backend ${e.config.backend}`)),e.config.debug&&Ce("setting backend:",e.config.backend),e.config.backend==="wasm"){if(e.config.debug&&Ce("wasm path:",e.config.wasmPath),typeof(bh==null?void 0:bh.setWasmPaths)!="undefined")await bU(e.config.wasmPath);else throw new Error("wasm backend is not loaded");let s=await be().getAsync("WASM_HAS_SIMD_SUPPORT"),o=await be().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");e.config.debug&&Ce(`wasm execution: ${s?"SIMD":"no SIMD"} ${o?"multithreaded":"singlethreaded"}`),e.config.debug&&!s&&Ce("warning: wasm simd support is not enabled")}try{await S9(e.config.backend),await Xw()}catch(s){return Ce("error: cannot set backend:",e.config.backend,s),!1}}if(gi()==="humangl"&&(Da.set("CHECK_COMPUTATION_FOR_ERRORS",!1),Da.set("WEBGL_CPU_FORWARD",!0),Da.set("WEBGL_PACK_DEPTHWISECONV",!1),Da.set("WEBGL_USE_SHAPES_UNIFORMS",!0),Da.set("CPU_HANDOFF_SIZE_THRESHOLD",128),typeof e.config.deallocate!="undefined"&&e.config.deallocate&&(Ce("changing webgl: WEBGL_DELETE_TEXTURE_THRESHOLD:",!0),Da.set("WEBGL_DELETE_TEXTURE_THRESHOLD",0)),sl().getGPGPUContext)){let r=await sl().getGPGPUContext().gl;e.config.debug&&Ce(`gl version:${r.getParameter(r.VERSION)} renderer:${r.getParameter(r.RENDERER)}`)}gi()==="webgpu"&&Da.set("WEBGPU_USE_GLSL",!0),C9(),await Xw(),e.performance.backend=Math.trunc(en()-n),e.config.backend=gi(),K5(),e.env=Ee}return!0}function lx(e,t){for(let n of e){let r={kernelName:n,backendName:t.backend,kernelFunc:()=>{t.debug&&Ce("kernelFunc",n,t.backend)}};Mc(r)}Ee.kernels=zl(gi()).map(n=>n.kernelName.toLowerCase())}var wc={color:"rgba(173, 216, 230, 0.6)",labelColor:"rgba(173, 216, 230, 1)",shadowColor:"black",font:'small-caps 14px "Segoe UI"',lineHeight:18,lineWidth:4,pointSize:2,roundRect:8,drawPoints:!1,drawLabels:!0,drawBoxes:!0,drawPolygons:!0,drawGaze:!0,fillPolygons:!1,useDepth:!0,useCurves:!1,bufferedOutput:!0},Zm=e=>{if(e&&e.getContext)return e.getContext("2d");throw new Error("invalid canvas")},HS=e=>Math.round(e*180/Math.PI);function VO(e,t,n,r=0,s){e.fillStyle=s.useDepth&&r?`rgba(${127.5+2*r}, ${127.5-2*r}, 255, 0.3)`:s.color,e.beginPath(),e.arc(t,n,s.pointSize,0,2*Math.PI),e.fill()}function kv(e,t,n,r,s,o){if(e.beginPath(),o.useCurves){let a=(t+t+r)/2,i=(n+n+s)/2;e.ellipse(a,i,r/2,s/2,0,0,2*Math.PI)}else e.lineWidth=o.lineWidth,e.moveTo(t+o.roundRect,n),e.lineTo(t+r-o.roundRect,n),e.quadraticCurveTo(t+r,n,t+r,n+o.roundRect),e.lineTo(t+r,n+s-o.roundRect),e.quadraticCurveTo(t+r,n+s,t+r-o.roundRect,n+s),e.lineTo(t+o.roundRect,n+s),e.quadraticCurveTo(t,n+s,t,n+s-o.roundRect),e.lineTo(t,n+o.roundRect),e.quadraticCurveTo(t,n,t+o.roundRect,n),e.closePath();e.stroke()}function Jae(e,t=[],n){if(!(t===void 0||t.length===0)){e.beginPath(),e.moveTo(t[0][0],t[0][1]);for(let r of t){let s=r[2]||0;e.strokeStyle=n.useDepth&&s?`rgba(${127.5+2*s}, ${127.5-2*s}, 255, 0.3)`:n.color,e.fillStyle=n.useDepth&&s?`rgba(${127.5+2*s}, ${127.5-2*s}, 255, 0.3)`:n.color,e.lineTo(r[0],Math.round(r[1]))}e.stroke(),n.fillPolygons&&(e.closePath(),e.fill())}}function sQe(e,t=[],n){if(!(t===void 0||t.length===0)){if(!n.useCurves||t.length<=2){Jae(e,t,n);return}e.moveTo(t[0][0],t[0][1]);for(let r=0;r<t.length-2;r++){let s=(t[r][0]+t[r+1][0])/2,o=(t[r][1]+t[r+1][1])/2;e.quadraticCurveTo(t[r][0],t[r][1],s,o)}e.quadraticCurveTo(t[t.length-2][0],t[t.length-2][1],t[t.length-1][0],t[t.length-1][1]),e.stroke(),n.fillPolygons&&(e.closePath(),e.fill())}}async function WO(e,t,n){let r=os(wc,n);if(!t||!e)return;let s=Zm(e);s.font=r.font,s.fillStyle=r.color;let o=1;for(let a=0;a<t.length;a++){let i=[],l=[];if([i,l]=Object.entries(t[a]),l.length>1&&l[1].length>0){let u=i[1]>0?`#${i[1]}`:"",c=`${i[0]} ${u}: ${l[1]}`;r.shadowColor&&r.shadowColor!==""&&(s.fillStyle=r.shadowColor,s.fillText(c,8,2+o*r.lineHeight)),s.fillStyle=r.labelColor,s.fillText(c,6,0+o*r.lineHeight),o+=1}}}async function GO(e,t,n){var o,a,i,l;let r=os(wc,n);if(!t||!e)return;let s=Zm(e);for(let u of t){s.font=r.font,s.strokeStyle=r.color,s.fillStyle=r.color,r.drawBoxes&&kv(s,u.box[0],u.box[1],u.box[2],u.box[3],r);let c=[];if(c.push(`face: ${Math.trunc(100*u.score)}%`),u.genderScore&&c.push(`${u.gender||""} ${Math.trunc(100*u.genderScore)}%`),u.age&&c.push(`age: ${u.age||""}`),u.iris&&c.push(`distance: ${u.iris}`),u.emotion&&u.emotion.length>0){let p=u.emotion.map(d=>`${Math.trunc(100*d.score)}% ${d.emotion}`);p.length>3&&(p.length=3),c.push(p.join(" "))}u.rotation&&u.rotation.angle&&u.rotation.gaze&&(u.rotation.angle.roll&&c.push(`roll: ${HS(u.rotation.angle.roll)}\xB0 yaw:${HS(u.rotation.angle.yaw)}\xB0 pitch:${HS(u.rotation.angle.pitch)}\xB0`),u.rotation.gaze.bearing&&c.push(`gaze: ${HS(u.rotation.gaze.bearing)}\xB0`)),c.length===0&&c.push("face"),s.fillStyle=r.color;for(let p=c.length-1;p>=0;p--){let d=Math.max(u.box[0],0),f=p*r.lineHeight+u.box[1];r.shadowColor&&r.shadowColor!==""&&(s.fillStyle=r.shadowColor,s.fillText(c[p],d+5,f+16)),s.fillStyle=r.labelColor,s.fillText(c[p],d+4,f+15)}if(s.lineWidth=1,u.mesh&&u.mesh.length>0){if(r.drawPoints)for(let p of u.mesh)VO(s,p[0],p[1],p[2],r);if(r.drawPolygons){if(s.lineWidth=1,u.mesh.length>450)for(let p=0;p<Ah.length/3;p++){let d=[Ah[p*3+0],Ah[p*3+1],Ah[p*3+2]].map(f=>u.mesh[f]);Jae(s,d,r)}if(u.annotations&&u.annotations.leftEyeIris&&u.annotations.leftEyeIris[0]){s.strokeStyle=r.useDepth?"rgba(255, 200, 255, 0.3)":r.color,s.beginPath();let p=Math.abs(u.annotations.leftEyeIris[3][0]-u.annotations.leftEyeIris[1][0])/2,d=Math.abs(u.annotations.leftEyeIris[4][1]-u.annotations.leftEyeIris[2][1])/2;s.ellipse(u.annotations.leftEyeIris[0][0],u.annotations.leftEyeIris[0][1],p,d,0,0,2*Math.PI),s.stroke(),r.fillPolygons&&(s.fillStyle=r.useDepth?"rgba(255, 255, 200, 0.3)":r.color,s.fill())}if(u.annotations&&u.annotations.rightEyeIris&&u.annotations.rightEyeIris[0]){s.strokeStyle=r.useDepth?"rgba(255, 200, 255, 0.3)":r.color,s.beginPath();let p=Math.abs(u.annotations.rightEyeIris[3][0]-u.annotations.rightEyeIris[1][0])/2,d=Math.abs(u.annotations.rightEyeIris[4][1]-u.annotations.rightEyeIris[2][1])/2;s.ellipse(u.annotations.rightEyeIris[0][0],u.annotations.rightEyeIris[0][1],p,d,0,0,2*Math.PI),s.stroke(),r.fillPolygons&&(s.fillStyle=r.useDepth?"rgba(255, 255, 200, 0.3)":r.color,s.fill())}if(r.drawGaze&&((a=(o=u.rotation)==null?void 0:o.gaze)==null?void 0:a.strength)&&((l=(i=u.rotation)==null?void 0:i.gaze)==null?void 0:l.bearing)&&u.annotations.leftEyeIris&&u.annotations.rightEyeIris&&u.annotations.leftEyeIris[0]&&u.annotations.rightEyeIris[0]){s.strokeStyle="pink",s.beginPath();let p=[u.annotations.leftEyeIris[0][0]+Math.sin(u.rotation.gaze.bearing)*u.rotation.gaze.strength*u.box[3],u.annotations.leftEyeIris[0][1]+Math.cos(u.rotation.gaze.bearing)*u.rotation.gaze.strength*u.box[2]];s.moveTo(u.annotations.leftEyeIris[0][0],u.annotations.leftEyeIris[0][1]),s.lineTo(p[0],p[1]);let d=[u.annotations.rightEyeIris[0][0]+Math.sin(u.rotation.gaze.bearing)*u.rotation.gaze.strength*u.box[3],u.annotations.rightEyeIris[0][1]+Math.cos(u.rotation.gaze.bearing)*u.rotation.gaze.strength*u.box[2]];s.moveTo(u.annotations.rightEyeIris[0][0],u.annotations.rightEyeIris[0][1]),s.lineTo(d[0],d[1]),s.stroke()}}}}}async function UO(e,t,n){var o;let r=os(wc,n);if(!t||!e)return;let s=Zm(e);s.lineJoin="round";for(let a=0;a<t.length;a++){if(s.strokeStyle=r.color,s.fillStyle=r.color,s.lineWidth=r.lineWidth,s.font=r.font,r.drawBoxes&&t[a].box&&((o=t[a].box)==null?void 0:o.length)===4&&(kv(s,t[a].box[0],t[a].box[1],t[a].box[2],t[a].box[3],r),r.drawLabels&&(r.shadowColor&&r.shadowColor!==""&&(s.fillStyle=r.shadowColor,s.fillText(`body ${100*t[a].score}%`,t[a].box[0]+3,1+t[a].box[1]+r.lineHeight,t[a].box[2])),s.fillStyle=r.labelColor,s.fillText(`body ${100*t[a].score}%`,t[a].box[0]+2,0+t[a].box[1]+r.lineHeight,t[a].box[2]))),r.drawPoints&&t[a].keypoints)for(let i=0;i<t[a].keypoints.length;i++)s.fillStyle=r.useDepth&&t[a].keypoints[i].position[2]?`rgba(${127.5+2*(t[a].keypoints[i].position[2]||0)}, ${127.5-2*(t[a].keypoints[i].position[2]||0)}, 255, 0.5)`:r.color,VO(s,t[a].keypoints[i].position[0],t[a].keypoints[i].position[1],0,r);if(r.drawLabels&&t[a].keypoints){s.font=r.font;for(let i of t[a].keypoints)s.fillStyle=r.useDepth&&i.position[2]?`rgba(${127.5+2*i.position[2]}, ${127.5-2*i.position[2]}, 255, 0.5)`:r.color,s.fillText(`${i.part} ${Math.trunc(100*i.score)}%`,i.position[0]+4,i.position[1]+4)}if(r.drawPolygons&&t[a].keypoints&&t[a].annotations)for(let i of Object.values(t[a].annotations))for(let l of i)sQe(s,l,r)}}async function jO(e,t,n){let r=os(wc,n);if(!t||!e)return;let s=Zm(e);s.lineJoin="round",s.font=r.font;for(let o of t){if(r.drawBoxes&&(s.strokeStyle=r.color,s.fillStyle=r.color,kv(s,o.box[0],o.box[1],o.box[2],o.box[3],r),r.drawLabels&&(r.shadowColor&&r.shadowColor!==""&&(s.fillStyle=r.shadowColor,s.fillText(`hand:${Math.trunc(100*o.score)}%`,o.box[0]+3,1+o.box[1]+r.lineHeight,o.box[2])),s.fillStyle=r.labelColor,s.fillText(`hand:${Math.trunc(100*o.score)}%`,o.box[0]+2,0+o.box[1]+r.lineHeight,o.box[2])),s.stroke()),r.drawPoints&&o.keypoints&&o.keypoints.length>0)for(let a of o.keypoints)s.fillStyle=r.useDepth?`rgba(${127.5+2*(a[2]||0)}, ${127.5-2*(a[2]||0)}, 255, 0.5)`:r.color,VO(s,a[0],a[1],0,r);if(r.drawLabels&&o.annotations){let a=(i,l)=>{!i||i.length===0||!i[0]||(s.fillStyle=r.useDepth?`rgba(${127.5+2*i[i.length-1][2]}, ${127.5-2*i[i.length-1][2]}, 255, 0.5)`:r.color,s.fillText(l,i[i.length-1][0]+4,i[i.length-1][1]+4))};s.font=r.font,a(o.annotations.index,"index"),a(o.annotations.middle,"middle"),a(o.annotations.ring,"ring"),a(o.annotations.pinky,"pinky"),a(o.annotations.thumb,"thumb"),a(o.annotations.palm,"palm")}if(r.drawPolygons&&o.annotations){let a=i=>{if(!(!i||i.length===0||!i[0]))for(let l=0;l<i.length;l++)s.beginPath(),s.strokeStyle=r.useDepth?`rgba(${127.5+2*i[l][2]}, ${127.5-2*i[l][2]}, 255, 0.5)`:r.color,s.moveTo(i[l>0?l-1:0][0],i[l>0?l-1:0][1]),s.lineTo(i[l][0],i[l][1]),s.stroke()};s.lineWidth=r.lineWidth,a(o.annotations.index),a(o.annotations.middle),a(o.annotations.ring),a(o.annotations.pinky),a(o.annotations.thumb)}}}async function HO(e,t,n){let r=os(wc,n);if(!t||!e)return;let s=Zm(e);s.lineJoin="round",s.font=r.font;for(let o of t)if(r.drawBoxes){if(s.strokeStyle=r.color,s.fillStyle=r.color,kv(s,o.box[0],o.box[1],o.box[2],o.box[3],r),r.drawLabels){let a=`${o.label} ${Math.round(100*o.score)}%`;r.shadowColor&&r.shadowColor!==""&&(s.fillStyle=r.shadowColor,s.fillText(a,o.box[0]+3,1+o.box[1]+r.lineHeight,o.box[2])),s.fillStyle=r.labelColor,s.fillText(a,o.box[0]+2,0+o.box[1]+r.lineHeight,o.box[2])}s.stroke()}}async function Qae(e,t,n){let r=os(wc,n);if(!t||!e)return;let s=Zm(e);s.lineJoin="round",s.font=r.font;for(let o=0;o<t.length;o++)if(r.drawBoxes){if(s.strokeStyle=r.color,s.fillStyle=r.color,kv(s,t[o].box[0],t[o].box[1],t[o].box[2],t[o].box[3],r),r.drawLabels){let a=`person #${o}`;r.shadowColor&&r.shadowColor!==""&&(s.fillStyle=r.shadowColor,s.fillText(a,t[o].box[0]+3,1+t[o].box[1]+r.lineHeight,t[o].box[2])),s.fillStyle=r.labelColor,s.fillText(a,t[o].box[0]+2,0+t[o].box[1]+r.lineHeight,t[o].box[2])}s.stroke()}}async function eie(e,t){if(!e||!t)return;Zm(t).drawImage(e,0,0)}async function tie(e,t,n){if(!t||!t.performance||!t||!e)return null;let r=en(),s=os(wc,n),o=Promise.all([GO(e,t.face,s),UO(e,t.body,s),jO(e,t.hand,s),HO(e,t.object,s),WO(e,t.gesture,s)]);return t.performance.draw=Math.trunc(en()-r),o}var oQe=e=>{let t=(p,d)=>Math.atan2(p[1]-d[1],p[0]-d[0]);if(!e.annotations.rightEyeIris||!e.annotations.leftEyeIris)return{bearing:0,strength:0};let n=[0,-.1],r=1,s=e.mesh[33][2]>e.mesh[263][2],o=s?e.mesh[473]:e.mesh[468],a=s?[(e.mesh[133][0]+e.mesh[33][0])/2,(e.mesh[133][1]+e.mesh[33][1])/2]:[(e.mesh[263][0]+e.mesh[362][0])/2,(e.mesh[263][1]+e.mesh[362][1])/2],i=s?[e.mesh[133][0]-e.mesh[33][0],e.mesh[23][1]-e.mesh[27][1]]:[e.mesh[263][0]-e.mesh[362][0],e.mesh[253][1]-e.mesh[257][1]],l=[(a[0]-o[0])/i[0]-n[0],r*(o[1]-a[1])/i[1]-n[1]],u=Math.sqrt(l[0]**2+l[1]**2);return u=Math.min(u,e.boxRaw[2]/2,e.boxRaw[3]/2),{bearing:(t([0,0],l)+Math.PI/2)%Math.PI,strength:u}},nie=(e,t)=>{let n=g=>{let x=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]);return g[0]/=x,g[1]/=x,g[2]/=x,g},r=(g,x)=>{let y=g[0]-x[0],b=g[1]-x[1],A=g[2]-x[2];return[y,b,A]},s=(g,x)=>{let y=g[1]*x[2]-g[2]*x[1],b=g[2]*x[0]-g[0]*x[2],A=g[0]*x[1]-g[1]*x[0];return[y,b,A]},o=g=>{let[x,y,b,A,v,w,k,I,N]=g,T,_,R;return A<1?A>-1?(R=Math.asin(A),_=Math.atan2(-k,x),T=Math.atan2(-w,v)):(R=-Math.PI/2,_=-Math.atan2(I,N),T=0):(R=Math.PI/2,_=Math.atan2(I,N),T=0),isNaN(T)&&(T=0),isNaN(_)&&(_=0),isNaN(R)&&(R=0),{pitch:2*-T,yaw:2*-_,roll:2*-R}},a=g=>{let x=(b,A,v,w)=>Math.atan2(w-A,v-b);return{pitch:x(g[10][1],g[10][2],g[152][1],g[152][2]),yaw:x(g[33][0],g[33][2],g[263][0],g[263][2]),roll:x(g[33][0],g[33][1],g[263][0],g[263][1])}},i=e.meshRaw;if(!i||i.length<300)return{angle:{pitch:0,yaw:0,roll:0},matrix:[1,0,0,0,1,0,0,0,1],gaze:{bearing:0,strength:0}};let l=Math.max(e.boxRaw[2]*t[0],e.boxRaw[3]*t[1])/1.5,u=[i[10],i[152],i[234],i[454]].map(g=>[g[0]*t[0]/l,g[1]*t[1]/l,g[2]]),c=n(r(u[1],u[0])),p=n(r(u[3],u[2])),d=n(s(p,c));p=s(c,d);let f=[p[0],p[1],p[2],c[0],c[1],c[2],d[0],d[1],d[2]],h=o(f),m=i.length===478?oQe(e):{bearing:0,strength:0};return{angle:h,matrix:f,gaze:m}};var qO=async(e,t)=>{var p,d,f,h;let n,r,s,o,a,i,l,u=[];e.state="run:face",n=en();let c=await VU(t,e.config);if(e.performance.face=Math.trunc(en()-n),!t.shape||t.shape.length!==4)return[];if(!c)return[];for(let m=0;m<c.length;m++){if(e.analyze("Get Face"),!c[m].tensor||c[m].tensor.isDisposedInternal){Ce("Face object is disposed:",c[m].tensor);continue}let g=nie(c[m],[t.shape[2],t.shape[1]]);e.analyze("Start Emotion:"),e.config.async?a=e.config.face.emotion.enabled?c7(c[m].tensor||ls([]),e.config,m,c.length):{}:(e.state="run:emotion",n=en(),a=e.config.face.emotion.enabled?await c7(c[m].tensor||ls([]),e.config,m,c.length):{},e.performance.emotion=Math.trunc(en()-n)),e.analyze("End Emotion:"),e.analyze("Start Description:"),e.config.async?l=e.config.face.description.enabled?i7(c[m].tensor||ls([]),e.config,m,c.length):[]:(e.state="run:description",n=en(),l=e.config.face.description.enabled?await i7(c[m].tensor||ls([]),e.config,m,c.length):[],e.performance.embedding=Math.trunc(en()-n)),e.analyze("End Description:"),e.config.async&&([r,o,a,i,l,s]=await Promise.all([r,o,a,i,l,s])),e.analyze("Finish Face:"),!e.config.face.iris.enabled&&((d=(p=c[m])==null?void 0:p.annotations)==null?void 0:d.leftEyeIris)&&((h=(f=c[m])==null?void 0:f.annotations)==null?void 0:h.rightEyeIris)&&(delete c[m].annotations.leftEyeIris,delete c[m].annotations.rightEyeIris);let x=c[m].annotations&&c[m].annotations.leftEyeIris&&c[m].annotations.leftEyeIris[0]&&c[m].annotations.rightEyeIris&&c[m].annotations.rightEyeIris[0]&&c[m].annotations.leftEyeIris.length>0&&c[m].annotations.rightEyeIris.length>0&&c[m].annotations.leftEyeIris[0]!==null&&c[m].annotations.rightEyeIris[0]!==null?Math.max(Math.abs(c[m].annotations.leftEyeIris[3][0]-c[m].annotations.leftEyeIris[1][0]),Math.abs(c[m].annotations.rightEyeIris[4][1]-c[m].annotations.rightEyeIris[2][1]))/t.shape[2]:0,y=e.config.face.detector.return?ln(c[m].tensor):null;ye(c[m].tensor),c[m].tensor&&delete c[m].tensor,u.push({...c[m],id:m,age:l.age,gender:l.gender,genderScore:l.genderScore,embedding:l.descriptor,emotion:a,iris:x!==0?Math.trunc(500/x/11.7)/100:0,rotation:g,tensor:y}),e.analyze("End Face")}return e.analyze("End FaceMesh:"),e.config.async&&(e.performance.face&&delete e.performance.face,e.performance.age&&delete e.performance.age,e.performance.gender&&delete e.performance.gender,e.performance.emotion&&delete e.performance.emotion),u};var rie=e=>{if(!e)return[];let t=[];for(let n=0;n<e.length;n++){let r=e[n].keypoints.find(l=>l.part==="leftWrist"),s=e[n].keypoints.find(l=>l.part==="rightWrist"),o=e[n].keypoints.find(l=>l.part==="nose");o&&r&&s&&r.position.y<o.position.y&&s.position.y<o.position.y?t.push({body:n,gesture:"i give up"}):o&&r&&r.position.y<o.position.y?t.push({body:n,gesture:"raise left hand"}):o&&s&&s.position.y<o.position.y&&t.push({body:n,gesture:"raise right hand"});let a=e[n].keypoints.find(l=>l.part==="leftShoulder"),i=e[n].keypoints.find(l=>l.part==="rightShoulder");a&&i&&t.push({body:n,gesture:`leaning ${a.position.y>i.position.y?"left":"right"}`})}return t},sie=e=>{if(!e)return[];let t=[];for(let n=0;n<e.length;n++)if(e[n].mesh&&e[n].mesh.length>450){let r=e[n].mesh[33][2]-e[n].mesh[263][2];Math.abs(r)<10?t.push({face:n,gesture:"facing center"}):t.push({face:n,gesture:`facing ${r<0?"left":"right"}`}),Math.abs(e[n].mesh[374][1]-e[n].mesh[386][1])/Math.abs(e[n].mesh[443][1]-e[n].mesh[450][1])<.2&&t.push({face:n,gesture:"blink left eye"}),Math.abs(e[n].mesh[145][1]-e[n].mesh[159][1])/Math.abs(e[n].mesh[223][1]-e[n].mesh[230][1])<.2&&t.push({face:n,gesture:"blink right eye"});let a=Math.min(100,500*Math.abs(e[n].mesh[13][1]-e[n].mesh[14][1])/Math.abs(e[n].mesh[10][1]-e[n].mesh[152][1]));a>10&&t.push({face:n,gesture:`mouth ${Math.trunc(a)}% open`});let i=e[n].mesh[152][2];Math.abs(i)>10&&t.push({face:n,gesture:`head ${i<0?"up":"down"}`})}return t},oie=e=>{if(!e)return[];let t=[];for(let n=0;n<e.length;n++){if(!e[n].annotations||!e[n].annotations.leftEyeIris||!e[n].annotations.leftEyeIris[0]||!e[n].annotations.rightEyeIris||!e[n].annotations.rightEyeIris[0])continue;let r=e[n].annotations.leftEyeIris[3][0]-e[n].annotations.leftEyeIris[1][0],s=e[n].annotations.leftEyeIris[4][1]-e[n].annotations.leftEyeIris[2][1],o=Math.abs(r*s),a=e[n].annotations.rightEyeIris[3][0]-e[n].annotations.rightEyeIris[1][0],i=e[n].annotations.rightEyeIris[4][1]-e[n].annotations.rightEyeIris[2][1],l=Math.abs(a*i),u=!1;Math.abs(o-l)/Math.max(o,l)<.25&&(u=!0,t.push({iris:n,gesture:"facing center"}));let p=Math.abs(e[n].mesh[33][0]-e[n].annotations.rightEyeIris[0][0])/e[n].box[2],d=Math.abs(e[n].mesh[263][0]-e[n].annotations.leftEyeIris[0][0])/e[n].box[2];(d>.06||p>.06)&&(u=!1),d>.06&&t.push({iris:n,gesture:"looking right"}),p>.06&&t.push({iris:n,gesture:"looking left"});let f=Math.abs(e[n].mesh[145][1]-e[n].annotations.rightEyeIris[0][1])/e[n].box[3],h=Math.abs(e[n].mesh[374][1]-e[n].annotations.leftEyeIris[0][1])/e[n].box[3];(h<.01||f<.01||h>.022||f>.022)&&(u=!1),(h<.01||f<.01)&&t.push({iris:n,gesture:"looking down"}),(h>.022||f>.022)&&t.push({iris:n,gesture:"looking up"}),u&&t.push({iris:n,gesture:"looking center"})}return t},aie=e=>{if(!e)return[];let t=[];for(let n=0;n<e.length;n++){let r=[];if(e[n].annotations)for(let[s,o]of Object.entries(e[n].annotations))s!=="palmBase"&&Array.isArray(o)&&o[0]&&r.push({name:s.toLowerCase(),position:o[0]});if(r&&r.length>0){let s=r.reduce((a,i)=>a.position[2]<i.position[2]?a:i);t.push({hand:n,gesture:`${s.name} forward`});let o=r.reduce((a,i)=>a.position[1]<i.position[1]?a:i);t.push({hand:n,gesture:`${o.name} up`})}if(e[n].keypoints){let s=yj(e[n].keypoints);for(let o of s)t.push({hand:n,gesture:o.name})}}return t};var vt={face:[],body:[],hand:[],gesture:[],object:[],persons:[],performance:{},timestamp:0};function iie(e){var r,s,o,a,i,l,u,c,p,d,f,h,m,g,x,y,b,A,v,w,k;if(!e)return{face:[],body:[],hand:[],gesture:[],object:[],persons:[],performance:{},timestamp:0};let t=Date.now()-e.timestamp,n=t<1e3?8-Math.log(t+1):1;if(vt.canvas=e.canvas,!vt.body||e.body.length!==vt.body.length)vt.body=JSON.parse(JSON.stringify(e.body));else for(let I=0;I<e.body.length;I++){let N=e.body[I].box.map((R,S)=>((n-1)*vt.body[I].box[S]+R)/n),T=e.body[I].boxRaw.map((R,S)=>((n-1)*vt.body[I].boxRaw[S]+R)/n),_=e.body[I].keypoints.map((R,S)=>({score:R.score,part:R.part,position:[vt.body[I].keypoints[S]?((n-1)*vt.body[I].keypoints[S].position[0]+R.position[0])/n:R.position[0],vt.body[I].keypoints[S]?((n-1)*vt.body[I].keypoints[S].position[1]+R.position[1])/n:R.position[1]],positionRaw:[vt.body[I].keypoints[S]?((n-1)*vt.body[I].keypoints[S].positionRaw[0]+R.positionRaw[0])/n:R.position[0],vt.body[I].keypoints[S]?((n-1)*vt.body[I].keypoints[S].positionRaw[1]+R.positionRaw[1])/n:R.position[1]]}));vt.body[I]={...e.body[I],box:N,boxRaw:T,keypoints:_}}if(!vt.hand||e.hand.length!==vt.hand.length)vt.hand=JSON.parse(JSON.stringify(e.hand));else for(let I=0;I<e.hand.length;I++){let N=e.hand[I].box.map((S,F)=>((n-1)*vt.hand[I].box[F]+S)/n),T=e.hand[I].boxRaw.map((S,F)=>((n-1)*vt.hand[I].boxRaw[F]+S)/n);vt.hand[I].keypoints.length!==e.hand[I].keypoints.length&&(vt.hand[I].keypoints=e.hand[I].keypoints);let _=e.hand[I].keypoints&&e.hand[I].keypoints.length>0?e.hand[I].keypoints.map((S,F)=>S.map((B,W)=>((n-1)*(vt.hand[I].keypoints[F][W]||1)+(B||0))/n)):[],R={};if(Object.keys(vt.hand[I].annotations).length!==Object.keys(e.hand[I].annotations).length&&(vt.hand[I].annotations=e.hand[I].annotations),e.hand[I].annotations)for(let S of Object.keys(e.hand[I].annotations))R[S]=e.hand[I].annotations[S]&&e.hand[I].annotations[S][0]?e.hand[I].annotations[S].map((F,B)=>F.map((W,q)=>((n-1)*vt.hand[I].annotations[S][B][q]+W)/n)):null;vt.hand[I]={...e.hand[I],box:N,boxRaw:T,keypoints:_,annotations:R}}if(!vt.face||e.face.length!==vt.face.length)vt.face=JSON.parse(JSON.stringify(e.face));else for(let I=0;I<e.face.length;I++){let N=e.face[I].box.map((R,S)=>((n-1)*vt.face[I].box[S]+R)/n),T=e.face[I].boxRaw.map((R,S)=>((n-1)*vt.face[I].boxRaw[S]+R)/n),_={matrix:[0,0,0,0,0,0,0,0,0],angle:{roll:0,yaw:0,pitch:0},gaze:{bearing:0,strength:0}};_.matrix=(r=e.face[I].rotation)==null?void 0:r.matrix,_.angle={roll:((n-1)*(((o=(s=vt.face[I].rotation)==null?void 0:s.angle)==null?void 0:o.roll)||0)+(((i=(a=e.face[I].rotation)==null?void 0:a.angle)==null?void 0:i.roll)||0))/n,yaw:((n-1)*(((u=(l=vt.face[I].rotation)==null?void 0:l.angle)==null?void 0:u.yaw)||0)+(((p=(c=e.face[I].rotation)==null?void 0:c.angle)==null?void 0:p.yaw)||0))/n,pitch:((n-1)*(((f=(d=vt.face[I].rotation)==null?void 0:d.angle)==null?void 0:f.pitch)||0)+(((m=(h=e.face[I].rotation)==null?void 0:h.angle)==null?void 0:m.pitch)||0))/n},_.gaze={bearing:((n-1)*(((x=(g=vt.face[I].rotation)==null?void 0:g.gaze)==null?void 0:x.bearing)||0)+(((b=(y=e.face[I].rotation)==null?void 0:y.gaze)==null?void 0:b.bearing)||0))/n,strength:((n-1)*(((v=(A=vt.face[I].rotation)==null?void 0:A.gaze)==null?void 0:v.strength)||0)+(((k=(w=e.face[I].rotation)==null?void 0:w.gaze)==null?void 0:k.strength)||0))/n},vt.face[I]={...e.face[I],rotation:_,box:N,boxRaw:T}}if(!vt.object||e.object.length!==vt.object.length)vt.object=JSON.parse(JSON.stringify(e.object));else for(let I=0;I<e.object.length;I++){let N=e.object[I].box.map((_,R)=>((n-1)*vt.object[I].box[R]+_)/n),T=e.object[I].boxRaw.map((_,R)=>((n-1)*vt.object[I].boxRaw[R]+_)/n);vt.object[I]={...e.object[I],box:N,boxRaw:T}}if(e.persons){let I=e.persons;if(!vt.persons||I.length!==vt.persons.length)vt.persons=JSON.parse(JSON.stringify(I));else for(let N=0;N<I.length;N++)vt.persons[N].box=I[N].box.map((T,_)=>((n-1)*vt.persons[N].box[_]+T)/n)}return e.gesture&&(vt.gesture=e.gesture),e.performance&&(vt.performance=e.performance),vt}function qS(e,t,n={order:2}){let r=0;for(let s=0;s<e.length;s++){let o=n.order===2?e[s]-t[s]:Math.abs(e[s]-t[s]);r+=n.order===2?o*o:o**n.order}return r}function lie(e,t,n={order:2}){let r=qS(e,t,n),s=n.order===2?Math.sqrt(r):r**(1/n.order);return Math.max(0,100-s)/100}function uie(e,t,n={order:2,threshold:0}){if(!Array.isArray(e)||!Array.isArray(t)||e.length<64||t.length===0||e.length!==t[0].length)return{index:-1,distance:Number.POSITIVE_INFINITY,similarity:0};let r=Number.MAX_SAFE_INTEGER,s=-1;for(let o=0;o<t.length;o++){let a=qS(e,t[o],{order:n.order});if(a<r&&(r=a,s=o),r<n.threshold)break}return r=n.order===2?Math.sqrt(r):r**(1/n.order),{index:s,distance:r,similarity:Math.max(0,100-r)/100}}function cie(e,t,n,r,s){var i,l,u,c,p,d,f,h,m,g,x,y,b,A,v,w;let o=0,a=[];for(let k of e){let I={id:o++,face:k,body:null,hands:{left:null,right:null},gestures:[],box:[0,0,0,0]};for(let F of t)k.box[0]>F.box[0]&&k.box[0]<F.box[0]+F.box[2]&&k.box[1]+k.box[3]>F.box[1]&&k.box[1]+k.box[3]<F.box[1]+F.box[3]&&(I.body=F);if(I.body)for(let F of n)F.box[0]+F.box[2]>I.body.box[0]&&F.box[0]+F.box[2]<I.body.box[0]+I.body.box[2]&&F.box[1]+F.box[3]>I.body.box[1]&&F.box[1]+F.box[3]<I.body.box[1]+I.body.box[3]&&I.hands&&(I.hands.left=F),F.box[0]<I.body.box[0]+I.body.box[2]&&F.box[0]>I.body.box[0]&&F.box[1]+F.box[3]>I.body.box[1]&&F.box[1]+F.box[3]<I.body.box[1]+I.body.box[3]&&I.hands&&(I.hands.right=F);for(let F of r)F.face!==void 0&&F.face===k.id?(i=I.gestures)==null||i.push(F):F.iris!==void 0&&F.iris===k.id?(l=I.gestures)==null||l.push(F):F.body!==void 0&&F.body===((u=I.body)==null?void 0:u.id)?(c=I.gestures)==null||c.push(F):F.hand!==void 0&&F.hand===((d=(p=I.hands)==null?void 0:p.left)==null?void 0:d.id)?(f=I.gestures)==null||f.push(F):F.hand!==void 0&&F.hand===((m=(h=I.hands)==null?void 0:h.right)==null?void 0:m.id)&&((g=I.gestures)==null||g.push(F));let N=[],T=[],_=F=>{F&&F.length===4&&(N.push(F[0],F[0]+F[2]),T.push(F[1],F[1]+F[3]))};_((x=I.face)==null?void 0:x.box),_((y=I.body)==null?void 0:y.box),_((A=(b=I.hands)==null?void 0:b.left)==null?void 0:A.box),_((w=(v=I.hands)==null?void 0:v.right)==null?void 0:w.box);let R=Math.min(...N),S=Math.min(...T);I.box=[R,S,Math.max(...N)-R,Math.max(...T)-S],s&&s[1]&&s[2]&&(I.boxRaw=[I.box[0]/s[2],I.box[1]/s[1],I.box[2]/s[2],I.box[3]/s[1]]),a.push(I)}return a}var KS=`
/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUA
AAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQu
bmV0IDQuMi4xMwAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxob
IxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgo
KCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgBAAEAAwEhAAIRAQMRAf/E
AB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAE
EQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZH
SElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1
tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEB
AQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXET
IjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFla
Y2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG
x8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+qaKACigApGOKAML
Xp8xlF5A7V4X8RtYs7PzfNImnx8sa8Kp9z3q2tEgp6angWs62ZZ5CTGoJ6DArGNz5p+UrID6EUrF
PUlW1EuN0XNW7PQ2L5j3JnoKXN0KijqNP0eYoqXBdgPuuo+ZPeupisWn2Jd4+0r924XgsQOCff3/
AJ1FzRKxDqGii6m3siiQ8F1XGfXI6YNWLfRbiRQMkcZI9fpTDluT2/h6Qy8gDPbtmtG38JeY480Z
5zSLUTZg8M28YwYxjAArXtdPt402qgHbpSaLWhma3o0Uqk7Nx9DWLaaVblgPs6qRyds2M/gRSQp9
zZOni2iWS2hlQ+kjYz9OMGrdjq89vIPPVhj+8M/lQyDq9P1WOYBlMZz1AOD+VdDaTiReOKulK0jO
tHmi0WDTlr0TyxRVhT8tJjIX+9SUxHXUV553BRQAVBcPhSBTSuxPY86+IGti0s5I7dsORy9fM3i6
8e8mfDO5P90ZrWWiJicNPpZZtxV/xrW0jQt4DOv6Vk2dEEdTY6BHuB25rpbPSo0QARjP0qTRI17W
wA/hFaMWmoQMgflQXYsDS142rU9tpqqenfNA7GgtihxkdKuRW6qMY/GkDZY8sY4Ap4hXbyB+VArk
EtuH4wPyrk/EGkOm+a3jw3suRQLc5i38SX9hJ9nnY+XnBUdPyNdFY6pa3KkkAE9l6f8AfJ/pSJT6
GhDmI+Zb4ZRycdv6ium0nUhKFydrelTsNnS2829RnrVgV6NKXNG55lWPLIM81Op+WrZkRMfmNNzT
A7GivPO4KKAEY4XNYWt3vkwPg4OK0giJdjw/xrqhm87Zs8tc7pX5A+leSajf6aHYJ50kn4AZpTep
rBWRm2Vobm4BXfyehPFdnpmnBFUY5rI2SN63tlToK0YI+KZpFF+3QdavwoKTLtoW0Toaswpk5pCb
LCxipAhoIuP2dKevHXoaYDylRyxhlwRQI4nxVoCXWZI1GfpXGtbSWjYPGP73+NIGupt6TqMsLruZ
ih4xnP5V09mQ+JLd8gn0xSYJnVaVdkook69K34zuUGunDS3Rx4qOzHVIp4rrOMY3NJQI7GivPO8K
KAILt9kZrz3xlebYiu8KCCWb0XvW0NFch6ysfO3jLVjfXLIn+pQkKorl7WxNxIPl71g2dUUdpo+l
pBGvHPet23iC8ihFosrxirkHQUFo0IF4FXI1O726CpKLacCrMJoJLYHAPpTwucHpSRJJ5e4AZI9x
UqpxzVpCuOC8cUpQUMRnXttuB4rjNdsYyeVwfXpmpGmcvcQyafMCFJjPY10eg34BUg4DcZP8jUO4
HaRq3lLNF+IHet7R7jz7c56rwa2wz9+xhiVeFy/T1PFegeaNPWigDsc0ZrzzvDNIaAM7VpNqdegr
xL4l6kywyRhseZ19lrdfAZL4jxYg3Fw20d63tJsdrDI5rm3Z3R0R0Mce1eKnQYAplIkWrMJ45oZS
NO3PHbNXIyfpSGWowSOasxLUiZdjFSqtNEMkUemKlAGKsRJjAppFAiORMjmsTVrNZEO4cfSoZSOD
1eJ7WXBUzQZ+7nkfSo7e2Ei+ZaMzxntjBX2NSU1Y6/wxqojiEFzkA8KTXYaUoWRyv3W5rSjpNHPX
+BmpSg8V6J5gUUAdhRXnneFFAGHrTfu5PpXzj8S70/aZtxzztXFbv4DKHxHI+H4GZiz9zxXXW8G3
GBXMjvLRXAx0oPGPSmMVeOnWrMTYpFI0bcg1fh54xmgovRcD3qxETSIZcRvzp+/BpEkqsBUqsM9K
q4Em4Gkxk0yRGXrVW6i8yFhkg+tJjRxGsWrxllkUMh9eK5uMz6bcebbnfG33kPcVkay2OntPKuo0
nhXI67c8qa7Lw3c+adjcEDGK1paSRhVV4s6A0or0jyRRQ1AHX0V553hRQBz+vNtt5z3xXzX8Qbdm
uic5YnOMdK3l8JnTXvlbwpYl+WySOgrp5YfLOOB9O1c62O7qQkc+9RsKChFPWp4DluOlSykaNruH
ArUgHShFNF2NT1qxGO3NBmyxGcE1N2560CFzjrUysO9JAPDDjFOVuKoQuSRTWouBkazbCa3cd8cV
wF7IISQccHBzUSWpV9C3o1x5b5GAjdQD1rs9DjC3kckbEhqKfxIzn8LOupRXqnkPccBSkUAzraK8
87wooA5rxMSI3HqK8B8bQl9Q8sffY5b/AAraXwkUviNrw9pH2W1ViMMRTdRjw4HpWNtDti9TPc4P
FQs2M5qdyyMHLcfjV63HTAoBGtap0wK0YxigpsuRDtVhVYd6GQydVwwIqdRnqKCR23I5pCMUW6gD
YNKuetAEise9KTxQBWuFyhrznxNZkXjFeN3I+tTIZg2OqmzmxNF0PO3vXp/g2+hukVl4zyPanTXv
JmVR+60dpThXpnlPceopWFAbnV0V553hSGgRynjC5FujOey14Ssp1HxNmTnc+a3kvcIpv37HoEYQ
QmMdVHSsnVbYJF5jVk0dsNzlruVIsl2wKxbjWrVHILjg1CRbZJb+ILHPzyhfStODWLQgFJFYd+el
UJM27HUIXxhga1Y5lLVLKLkMnoauxnPPrSEx7ShF+Y/n2qrc6xBbhizDAqkK1zJuvG9nbg8ZA681
ly/Ei052RO3uKAsZlx8QGd8xxvt9Aa1NH8dK7AXMcip64zigdkdrZX8F7EJLdwwNXMkrz1qRMRly
CK4TxmpidWI49felPYSOMmi80NIoOV6qRzXYeA5SskYPfirpfEjGr8LPWVHyD6U4CvQPL3ZItOYc
UDOoNFeed4Uhpks4H4iE/Z5MeleMeGULeLgjds10S+BGdL+Jc9OSBU2Huc5Nc74yvUtrcDBrJnZF
63PJdXvLy/lKWw46bvQVz82jXhkLO5Y+9ZlsYthcRnbIjY9R3q3awTRkEM3WmJI6C0ea3dGRsr1x
XY6TqW9FLHnjrUs0izpLK5DDjofSta3ckH09KRUkZuuTvFGdvPauE1Y3U6Mqbssf/rUxHPTaJPK2
ZmJPbBqzY6DCZh5xJC9s9aBJHU6dpemJjfEmfetJtI0+VPkUr/unFOxdiextHs33W07YHQHk11mk
Xb3KbZ1xIvcd6LEyWho4Nct41sTPYb16ipexCPPZN+wYGCvH1rrPAEJmvkPoc1VL4kZVvgZ6yFwK
cBXoHkkqinFaVyzo80GuE7WJRQSziPiGdthK5HQV4x4J/wBI8WPIewNdEvgRNL42emO/yj1UHNef
eNpRczbC+I17DvWT2OqJxc0sMK4TCisy41q0hfEkqj8aixdwTXNOlwvmqD9anS9tXH7uVG+hosO4
/wC0oOhrR0+6G4YNIEzsNEuCxAPNdjZruA4xxUmjINSjURksOlcbqFykbnjFA1sYGoassaknCqO5
rl7rxhGm7yBnBxuJq0rkSlYpw+NLlsfd5P8AerVsvHEqSBHwPVgcgVpyMyVXU3rXxcHYETAk+hru
/DWti6ZSTyOKzZqndHaxvvUGq2rQ+dYyqR24qWI8dvbr7LqDxyDAzXpvw6FvIxePGSM06Xxoyr/A
zviKFHNegeX1J41zUhXioGbuaSuM6wpCaBHG/EcA6HN/exxXjXw2jL67cv8A3Qa6H8CFR+NnoWpO
I4XI44rxLxrqjQzSEsQM1gdSPM9U1uR1YbmWIdXHf2rmpIb67YS28UrRlsLI3c/jW0VZGUpO5pW1
jfLNOjahawzwReYI5cjzMkDavHJ5/SrVv9uhtPtVxCPLBwzxnlT9KGghLU3tKvvPjHzbl7EGuisJ
GRxWLOg7nRXJEbDjmvSNK+aFSfSoZr0KutRkphc4NcRrdkVjL9aVio7Hk3iqS8ubhrWzUlsZY9kG
cZNc5D4aee5MclzJIFTzHAO0MfatqSOWu7bFS1srDUZEis0vIZoUxPvfcC+4/dx2xjr712XiTwXb
WmlQ6hol3cRhoFd4rlg3zY5wR0GelavQwjq7GD4etdVvSnk2wAB+9v8A8mvcfA2kXiRo0/UdcDis
ZnTTulqeoWqbUAJqWUb42X1FZlnjfjSwlGrr5S/eNdD4RkvLAAQ4yRyaUZcruVKl7TQ9I0G+mnzH
ckFwM8VuIK7ac3KF2eXiKapz5UWYxipNtMyNejNch0jSar3cjR27uoyQCRVRWom9DxTx54gu5fMi
lbKdMVjfCZPNlv5v9rFbVHpYqjGzbOn8SzFI9o715L4u0r7arYzk+lYdTqSujy7U/C0u4vHk+WwO
xuh9q3J9dgvbdVukMV1EwbDDgn04rZMwlHoZ+orZ6hfQ3RWVnQYCgZAq+8U0ln5NtBsV2yxYcfgK
JtW0CnB31LlroVwJ1nQLGDjeP7w+lb0dsFxjrWB0tHS6NuWPJ6A16ToUm63T3Gallr4S7cxiTjrX
PaxaF7dlVeSMUhxZ5jd+H7qCa4eF3DSE5x3zXN3Wk6jbyeaiFWUY6ZyPStYS5SalPmVipFbX0E4c
W0alvmPHJrag0rVvEE6LdljGpG2NRtQD+tW5XMI0uU9M8NeFo9PiQhecDIIrtrOMIoG3H4VlJm9t
C6CB06VPGM1IHLeItGS6uw+ORT7e3jsbQvj7gzUNam0JaWE+HN7NqOqX80n3FO1RXo8YzXdS+BHk
4z+KyzGPapcU2YIv7qQtiuaxvcaWqG4O6FwfSrS1JbPnrxoxkv7qIfejcitj4V2f2exumI+8+aKn
xHTT+G5d8Txlm4rjLxMsQwzWT3OiK0Mm6sEkVsAcjFc1d+FEmlGwEDPQVopaEuOpr6f4ZWNAu3tW
vHpAj5ZQcUFIWaDjGMVUMQ3cVDBmvbhY7QAV2nh+T/R1yeKhlrY31+b61FcQK6nIoJMi401WblRi
qr6PCw5UYq9y+YgOgWzNkRrx3xWjp+nx2v3FQcelAbmko9anQ4GBUNisPHWr1qMrQhS2K11HvmYV
hamcxSRZ5xRIqluS/DKAQQXZxyXrvo2FdlL4EeZjH+/ZbjNSZpswLNBrE1Gt7VE4ODVIlnh/j61F
j4lmeTGyUbq6LwdEqWbeX0YbhSqfEddP4Bddj4JIrhL5d8h7VjI6oLQqKNzelWre3yc4/ClFjaL6
wqBxxUUxwCKu5BmXRA6c+9ZjP83FSBoQuPs4BrsNBlUW659KmRrDY6G1lyQtW3Hy0lqQ1qVJnAbm
oy3b9KYJCqRj3o4zRctIlhjLHmpSuOBRbQOpLGpPFaES7UqkZzKN1KsEc87/AHUUmvPLTVGv72aQ
k7WJwKmRrQ3ud74Ltilgz4++2a6iNDXdS0gjyMU71my7GpqTbxSbMki3SViajTTHqkSeR/GeyZmg
nQHkEE1S+F+oPPavBL96I4/Cia1udVF+4dVrkW+Fq8+v4tjMDWUkdVJ6WM0cNV+F+MVmjUcZgqnP
1qpNNnkcVRLiZtxIS1UzzIF7mghlxUZpVQdq6nTVdAoAOKzkbQWhvwM6gMM1twOJYx3NOJE11Kt1
H1/pVVlwBkk+9NocXoOQ45FPj+fkUJFF2NSB700v/hTEty5ZpkjvVyUgcCq6GM9zC14/8Se6GcZQ
1574Xs5WkI2HBPHFQ1dm1KSSZ7Rotn9l0+KPHIHNacae1dy0Vjxaj5ptlhVp+2s2CJ9ppCKzuWNx
zSFc1SYrHNeNdIGpaYw25ZeRXmvheyk0jVpEdcLJ0q3ZxNKTa0O3vQHg/DNcHrsJDmsmjspnNzNt
fFIJ24GazOhC+azDmgZIOOKBsp3J2qSaZodubq58yQ4QAnmhGT3NO18pb7BORmu205LfYpyKVkWp
Oxr5gKYWoIZWgfGfloFq1qTPLubnGO1RPtxg4P0oBAkY/hBz6VNDDkZ6AU0W2WSdqkdKr9ZOaGSj
VtcLHmnOcgmmYvcz7mBLy3MbdD1q9ouiRK6bUAVeelOC1InPlidSsWMDFOCEdq3uefykqrinYqGy
rFvApMVka2DAowKAsMkRXQqwyDXn/iWyitNQ3qPl6itIvRoF8RXinW4tQ6HI6GuW8SIVBPalc6qe
5x9x97r3qruwTjrWZ0ksZ9TUmcDNAmZ9/wAoao63rR0+w22MLPtAzt6mghmfofiB76LdJBJBIp5D
d/oa7bSdWLIPnpDi9TM8TeKdas51XTbIyxd3J/pXS+E/EFxqNoFu7do5OmD60maHWrnZyDRkn/69
MlEyOR0xntVoNx+FUgYjPxg4FLCuWDZyKQr2RoRnP0qO+nEFpJITgAUzLqZnhu6+0rknOTXpOmwJ
Fbrt5yMmnHYyr6Oxb2ijaKLnPYMClwKQWK3n0hn+lachHOJ9pNNN0apQFzsY10a4v4hXQh0xpieQ
MA1XLZNjhK80cT8OdV+3Wl3A7ZZJCw+hrR1qLcjZ/CsbnfHRnFXseHJArOYYbrUs1uPhYbuatqFP
ByfSkMq3UIINYkto+87Tx6GkSxfsDbflGD7CtTw/pk4nzITtPIFMFudsukh4Rxz71paTpKwP5jcn
0qTRy0NORMDgVCqewoJTJgAoxjntTiTu7fWmFxAcnn1q3EPl+X8KZMi4gKqB1Peob/Tv7Us5bfeU
yOoq4R5nYxqT5I8xieH9J1DTbvyJELRg8ODwa9Ms5mSFV9BWiptbnNVrKdmif7Q1KLg96XIZc5Is
pNL5pqeUrmMtZs0jzV08phchaY00zH1p2ZNxjS1g+LdJOt6U9ssmxjyGp2urDjLlaZzng/wUPDqz
TSTmWeTrjpVjVk3Rvjr2rnqQ5dDvo1XUd2cTqSNk9OKxXGCeKxZ1DAxHTr2q5C/y8GokUhsz54qu
uCxzSQjQ0+FZblR2ro4bZYiMVQ0dBb7Qi5x0qzuG5QOh71LYErDufpSeWrHnimIXbjkUjLkH1Hem
gGxryc+tXI19KYmWegq9YLiLJ7mtqS945cS7QsWehqxA9dEjz4krPSxyZqbFFhGxUm6smjRM55Lk
HvSvNxXTY57kLT+9MNwKdhXGm5FIbkU7Bca1wMEVhaiuQcVhXWiZ14R6tHGanGBI2OtYkqEHjgVy
s9ErEeo6UBsHipKEZs5qpPdRxcbhx70NCSuybTNWihc5brW9Fq6vjMnFSdEIdDRi8RRKygZbHFbu
m6nb3RA3gMegNJhOm0jbXGOoxTuCc1Rz3FyoGKawz9KaAVcZqeMgCmIkB4FaUTbYwB6V00Fuzixb
0SFMuDU8Mlbs4UPeXHeiOXkUrDuXYnyKk3cVk0ap6HMxxketSMhrcwRC0dMMZFMQ3yzSeVQAeUaz
9Vj8uPd271nVV4m+GdpnHX67pCeKyLtBtNcR6xlk9RVeWTb3qRnO6trgttyIfm71z7ai8j7/AJmN
DNqUVa5Yi1AnjynHuBV+11YJhWWXcP8AZNSzqgmaEerSsf3NtIQP4mGKtRavdRgMIpVI9KjU0a7n
R6T43uYQI7qN2Tpkqciu503VVuQGAYZHQjFVc4alPlZrpKGAznpTwxOc9+lWjIlUACnM4XApiLNk
nmvnsK0NvpXZRVonmYqV52GsmanhXitTmFkSiJTSAvwrxUxXIrJ7miOfjf1pzNWxkRlqYWpgJupu
6gQbuahvIxPA6eo4pNXVioS5WmefakGhndH4INZs5DJXA10PaTurmLO21uKpSZqGMoXGnRzBiyjd
9Kx5rcQS428fSkjanLoaOliHGZFB56VswW+mtPufcBsGOAfmxz+tFkd8HpoaUx09FAtFY8DO71qb
Sms/Nb7RbecG6AEjFLS5c78t+p0djpVs9wsyQiJAdyr1rW+zqjErzSe559Sbk9S3C+MA1bjbgE1S
MSXzMVG0vNUI2tPKrAuCMnrVzNd0PhR49W/O2xrHmp4TxVMzQshpIzzQBehqesnuaI5VGzT2bitz
FEbNTC1ADS1JupgG6l3UAc14s04yR/aYRll+8BXCtLncDXFWjys9TCz5oW7GddH5qqNzWDOgQnC8
VSuo1kHzAGkPYopEY2+RWxV23Vzj5G/Kg3jWaNazhZuqNXS6TaKhB2c0jR1nJWOlhOxRxU4YkCgx
Y0OQatQyDbyaaFYe8uF4NY3iC9ltbVGj43NTIL3h7WzMihjzXVQXYYDdW9Cf2WcOJpfaRZ3g9KsQ
mupnCLIabGeaAL0LcVY3cVmzRHIxtUhetzEjZqjLUAIWpN1ArhupwagAfDKQ3Q1594v0c2bm6tx+
5Y8j+6ayrR5onThp8s7dzkZjuqAAmuBnqC7c0iwgtzSA0rWzjfGRW3ZadDu4AoNYo2rfS4v7orSh
05UA2r0pDbsTm29KRottBNyJ0wpJ9KhD7f6U0ikNWffIFBz60zVUW52ow4UcUN6EPcx44WsbgOmd
ua7TT5Bd24KHnFKnLlZFSN4koluLdueRWvp14swweG9DXoxldHlTjYtzGoo25qzEvwtUxas2jRPQ
5CNqkLVsYoYzUzdQA3dSFqBBmnqaBhuqhriCXTpVIzxUz+Fl03aSPI9QTypW2/dz0qKNw3SvOPZR
Mqin8VLKRcs3O4Cuk0w/MDjt1NBtHY6O2IIHY1pxgFaETIRwMkjtVSUEk4570MlFW5bap6dKzWm8
1tqH8aY+hp2FvGoGayNevVt7/ap4xzUvYjqTLtvLPcvJxSaVcyWsxTnFZlnT2t15xHmCtOBYwQy4
B9q7cPO+jPPxFO2qLEj5HWo42+aus4HpoX4W4FTF+KlotbHII9SFuK0MUNZqiLUDE3UbqBBupwag
Bc1DefPbyD/ZND2KjujyPWlKzuPesRZjHJXms9lMuw3StjnmphKDSLTJ7OfE3JrpbO4GQc9qlnRA
3LO82k5NbFvdADkjBoCSHyXIIIzgVQvdRigT7wzjgUzO1jHknlvG7qnp61etYFQDIpCZoqVijzXn
3iC8EmsOuaCGb/heR/s0ijkVv6fbxy3QMg5xmsnuX0Ldzut3+UYTPWk+2GJSe+M1pFtamcldalmx
1eO4XaThhWnC+TXqR2PHqL3maUJ4qRjxSEjj42qXdxVmaGs1MJoATfSbqBAG5p6mgAzTJTmNvpQU
tzzHXY83D/U1zF5FhjgV5r3Pa6FMsV5HWnLe7RhqBRdmTwagN2d2K2rPU1C5LAnPrUs6Iysbdrq6
f3gK0BrUKj/WClY05iM6xLOcQAj3NT29uznfKSzHuadzNu7NSBFjHNSm5VO9IRnajqoWMhTzXFtA
bvUfMduSeg702Qz0rS7FbTToQFwzjJqaGTFyfK5PQViyzUuFmuIdgGABya5u/vTaN5cnUHFUmLoZ
zyskwlgJweSK6zQdUEwVJeGr0aUrxPLxEfe0OrhPAqVjxWhznGRtUwatDK4jNxURbmkAm6jNABup
6tQAFqhupNtu59qUnZFwV5JHnWsHdIx96w5lz15rzT2uhRmt85xWbcxMnUGmZlB0bdxmrNvFIcfM
350mWjbs7YkDJY/jW5ZWW4jikWkdNp9mqYJFaJdEHHakUULu/VB1rLn1Ld/FgetMGYd/qWSQmSa0
/AemS32pfa7piLeLkg9z6UmQtz0W7uQ2cZx0A9BVzR7cAea6j2rPqX0L99KRat5A6Dk1wOoKZ52a
YfMORTYRLujiGWEq6/NWza2yKQVHNdOHerRy4laJo6TTnbbtb8KuM3Fdh5z3OJjbmpt3FaMxAtUZ
agBN1GaQBzTwaAAms3VbjERUGsa07RsdeFpuUuY4jUjljWTKK4j02RE4IpJYFk6imQkVl0xWarsO
mAEcUi0bNnZBR0rWtoguMCkUi21wI161mXuocEKaYXMS4u+pY/hVCSWSY4HT0pEmlouiSahdpEBl
mOceleiwWcNjClvHgJH97Hc1EmVFFi3Czy7mwIl/WtJbjP7uLgd/apQ2VNVvtsBhiPzdK5S4nAuR
nqOCaTGi9pcytPlU+XpmumtWII44rah8ZjiNIXRuWeNvvViQ/LXpJWPJbu7nCRvVkNxVsxBmqJmo
EPiXca0YLMuOlJsuKuPlsSi5IrNuG8s4HWs5VEkbwoOTKsk+FJY4rC1K53k1xTk5O7PSpwVNWRzt
4cms+WpKICtSLTETQj5q0YeBSGiys23pUguGxQMq3E59ayrm4x3yaAKiRtO2WPHcmhruKFxFajzZ
ScA44qRHoXhuMaLpxaUg6hcDLMf4F9KlhuDeXGASIl+8azZslYma68y48m1+7nFW5rtbRNhb5z1p
iMKbUg0zuW4A4rPgb7VdKXOMmpA7HRbMS7nUYiUda0lkQOBngVrS+JGdbWLRt2bAx5BqeQ/LXpnj
PQ4GJ+ashuK0MhWaoWcA0AaOmASMK7jRNPWYBmHyiuepO2x10qfcv6vYxCzYqoGK4HVYVTJrmb5l
c6oaM5TUJ8EgGsG4kLNUHT0M64OaqMMikSRsuKbnFMRLG3zVehOaGNE445NNlnVFpDMu6uie9Vo1
8z5mOAOST2pDK91cNN+5tsrH3PrW54a06KxT7fdrlh/q1Pc+tJ6IUdZGvHPLezMcnBOWbsPap5r3
ylFtbdT1xUWNWzU0/Zbwlgfmx8zGsHWtRHmMqE59aAMyNifvHPc1f0gtPdqkY5JosJHeNci2tktY
euPnNY+oXWZEVJNrZ9aun8SIq/CzodHuriIokhDIR1ronbKZr0o6o8ipoz//2Q==`,XS=`
/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsICAoIBwsKCQoNDAsNERwSEQ8PESIZGhQcKSQrKigk
JyctMkA3LTA9MCcnOEw5PUNFSElIKzZPVU5GVEBHSEX/2wBDAQwNDREPESESEiFFLicuRUVFRUVF
RUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUX/wAARCASwBLADASIA
AhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQFBgf/xABDEAEAAgECBAMECQIDBgUFAQAA
AQIDBBEFEiExE0FRBiJhcRQjMkJSgZGhsWLBJDNyFSVTY3OSNEPR4fAHFjWCokT/xAAYAQEAAwEA
AAAAAAAAAAAAAAAAAQIDBP/EACARAQEBAQADAQEBAQEBAAAAAAABAhEDITFBEjJRIhP/2gAMAwEA
AhEDEQA/APqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAKNTq8OkxzfNkisQC8eb1XtRNbzXT4q7eU2nu0MntRq/D8StMccvW29ZmdvgjsTyvZjxOLj
+s8WLxn8TFPXs6Oj9oct7c14rkxz22nrB2I49KOdTjelmszfmpMeUxv/AA28OqwZ4icWWtt/SUi4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmdo3nsPNe0Pt
Fh09Z0+DNWL7+9O/7A3eJcZppsV5raI27esvH6jX5ddM25p79Ilo59VbUZOe2Tm/PeGvfPfT2iKR
PLv1+DO678XmW/a97U6TtOyzTbTF538/T9WjTNecm9a7126tqk3rSYxY5ta1plRZqZNXGjyZcPXl
mZmsx+qjBrsuO16xM7eXRt04JrdTltk5OWJnfaWf0a2lty5MdZnfzSn+WOHiOutFpjHa9e8bQ2fp
+alYy462pk7zXbuxjPesbRS0f6ZZV1ET1tErzXFLHo+A+1ddZf6NrI8PJHa1vN6iJi0bxMTHwfOa
zhzd61v1846utwniM6DUdb3nBaNrVmd9vjC/ZVePYirBqMWppz4rxaPgtEAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItaK1m09ojcHnvarjM8P0vh49+a/eY8ng9D
h1fGM1rxjtGPfvbzdbjuTJxHX48cTPNltM/KsS9Dw7S49Jp6UpHaGe2vjz1y9J7LYK13vHWe7bj2
ex1tvM80ekuxW3RnW3Vm6P5jRx8H0+OYmMcb+bapo8GKPdpC6bQwtdHU8JpWkdJ/JweL6e23iU67
d4dubSqyVi9Zi0bwIs68XGp36TtEq7ZJmZmevzdbifCKWtbJinkt6eTgZPFw32t+sRurbWVzxs1y
Rv6T8V1NZNPtfq0seTm+Kevr+SZuxXjvaPiV8N4viycto9HseG6+uu08W6Rkj7UPmFck1tE1nlmP
Ld3eA8V8HVVi1pjq6Ma/pnqce/ERMTETHaUrKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAADW19+TQ5p/p2bLS4v04Zmt5VjeQeJ4bjnLqsupv+Ka1+ERLv4reTmcNxcuC
vy3l0qdI2hlr66sT02ot0ZV7qqrInruzrVZLGSZ37JjqgYTG0K5lbaFVhDT1Ub456RPweY4hixWi
eSdpjvD1eWejz3FNHWYtkpvFo9EIseb3tS3SerOms22rfpPqZKzvvHSYUz70TExG6Gdbs2rljeJ/
Mx5L0vEzPaelnOi98c9J2bFNTFpit47+a+PVUvx9T9nOIfT+GV5p3yY/ds67wvsXqpxau+G09Lx+
r3TqrEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV4ljnLw3U0jvO
O0fs2lWqyUw6XLkyfYrWZkHldBEV09eveG3Fq1mI3jd4vPrOIaid8G9MP3Y38k6fNrt/rMk9Ou8s
tfXXn49rGWInuy8SO/k5Gl1E3rG/fzbOe94wTy99mbRvTrMOOvNfJWsesywniukrG/jU6fF43WYN
TmtEeJtEQ06aSmK2+bNtEd+qfSO17unF9Hmvy1y13XWyVmN4tExLxVK8PmNq5NrT58zawam+m/yc
0Xj8NpRYSvQZ7xEOdqI3rPozxayNRXe0ct/ON03jmrKB5nV4q1yTO20Obmv4c+cx8HoeI6WZpNoj
q83niYmYscU0r8aJ6T1n49zeJ+Meqm1drb9J+Kd5p136StGVem9l9TbHxLDFp7W7+sS+q1nesT6w
+PcAzVjiGHftzQ+v4f8AJpv6On8jH9ZgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAABp8VrW/C9TW0ztOO3b5Nxp8VmI4bn37TWYB8f1HFtTfUfR9FWJmsdZ9I7MtJxDX5s
d8ta1y0xzteaR2277rcuhycP12SceLxMeWNpjttHwlu8I0mfQ1y+D7k5YmJmY36T36Ka43z/AF1t
cI1ds+qxVj7/AEej19PCw9HJ4NoK4OIU5Y35YmZdzVTGebVZabx5jJS+Tmns81rNLm1Wrzc9rVw4
Yibbem72mXTTS0w0M3BvEta1bWrM95ie5EanY87wXgNOL6XPfxraXLhra/W28bR/dzYzarBqJxRe
bzE7Rt5vWU9n8mPHOGmS0Ypnea1naJb+k9ncNLR7u2y/WcxXO4TOoyUrN6zD0FaW5Y3hu49FiwUi
KxCvLMR0hlW0jn6ukWw3iXjOJzbDlneOj3GaN6zDzfFOH+LE7SRGo83XNSZ2lbG2/WfdlvaT2cy6
rNFInlrv1mfJ37cK4PwTTxOoidRm2+/2/KFuyMp47XB4LivXiunrH2b2iH2qn2K/J8x4fGDNxTSZ
9Nh8OviRvTyfT6xtWI+DeXs9MNZubypASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAOZx6/LoOWPvWiHTcf2hiZ0e8fc2mf1E5+vP/AEeuSd7RC2uKtI6QjHfeINTfwtPf
Jvty9WPfbt/lucP03gxfJf7d/wBoReYpm97zaNeLb4Ims9Nt94auDjem1Wo5PFi1onylS+1o7l8V
bxvtupjDMdNkYtXS1+Stt+m63xImEJ4xjHER2ZxMUjeUTO3VRmydBbjLJqPi08mbeVOXJPq1sl5Q
Vbkz9+rRy35rxHqzmZlVEe/Ez5LRlW5iyfR6zffaIjq1OSNZps2a21rZInafSPJhxGMl9LStLRWM
lorM/A4dkrWbYfLZC2W/7K6eubX6b4RzT+W76K8b7G6X62cu3Sten59nsm3j+OXz3/0ANGIAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0OIYfpOHPijvNNo+fdvtXJO18k/
/OwPFYbz2ls3jx8VqW6xMdWPEdP9D4lkx/dt79flLLHbkxTPwY6nt2512ORTRzE2x4/dpE7cvkme
E4IrW3hRMxO8THRtU1FKWtvtvK2upx22rzRCtXkqzh2jtF7ZbT122b01ndnpuWuP3Z3+Ky20qDVv
fauzVy3mejZzNK8dVjqi87KLRLYtXruqvXzkQp7Qoid88R6rcl+WGlW0/Sa22mfhCZOq2x082ix6
jkm822pO8VrPdr4dNObVeDo8XW3uzMbzK+mvxT7szE27cvnu9j7PcNjSaXx8mOIzZevbrEeic5tN
+SZnpt8J4fHD9HXHO3PPW0x/DeBtJxx29vaAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAKNRim9Z5e89Nl4DzXtVh5babURHrSf7f3ec1+qnDorWrvvt5Pccb0n0zhmWk
Rvevv1+cPE2rGTFNZU26PFfxwa5dVkjelI2772nZnX6bbrEUq3o0d678u8wmuDL2ittvVjXdneeK
cGv4jpJ6U56+kS7+j118+GLXpakzHaWlp9NNY3tv+bbiYiNoQy1y30uyZJlrWmZnuym6q1iIJnop
yW2Te8bdWnnypQqzZOadokiIpSZntWN5lrxki19vNRxrUeBwnNNd+fJEY6/OejXLn3Xe/wDp9wyn
E8uo4lqqxblv7lJ26T6vpD5X7G8QycKzeBMbzMRM1/FH/wA/h9QwZ6ajDXLitvWzRgsAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL45w+dDrZvWv1OWd4+E+j2jX
12jx67TWw5Y6T2nzifU+rZ1y9eHwzDYxxEy18+DJodXfT5o96vafWPVbjyxDn1OOzHudbM0rt2UW
iI69mVtRXZq5tREb9VUoy2iIlRbJ0UX1VZ6btTLrI7V6yk62M2oisT1c7JmtkttVMUyZp6x0beDS
RWOvdKijDimvWd3G9pNRMfRcNfvZOb9Hpb0itJeP47k/3hgjaZnbaP1XxWW3T0movbNS0W645nbf
0nrMPpXs3xamoxdJiLbe/X1n8Uf3fKsOTw4jbaXo+EarJhtGTHMxeJ6xH7Sti9Zaj6x3HM4NxXFx
DS1mtoi8dJrv2l011QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AGjxLhODieOIye7kr9m8d4eM4to9RwjPXFa0ZIvG9bR0fQXmPbDFvTTZPOJmEWS/V8bs9R43NxLL
G8eFbePg1bajU5/s0l1ceKLx1hbjwRE9mOpx0y2uRTSZsm3PMw2aaKtIjo6kYo9EXpET0hVLXxYK
xC6MZvyx1lFs0RHfaPiCnU12pLyHGNDbUajBekWma2npWN3p8+opa20e9LSyZLxExTlpM+vdOdcZ
a9tPS8MyUvFrzWlI6727u1pYxYrbVmb7x+TQx6au3Nqcl7/0rcmW9axGnwZJj1novmxnZXV0fFp4
ZxLBPgTGK8xzXr5fOH0bFlpmxVyY7Rato3iYfNuG2x56Wrqa8s2jz+7Lu8O12bS6jkwzN6THNNI6
tvrN68Y4rxlx1vHa0bskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAA4XtTTm0OKfTJ/aXdcL2pyRGjwU362yb7fkJz9eTxxyZJjyltRXzUZK7TFtl9Lbwy06YzrHwa+
fJFd/wCVt8m0bQ0eS2qzcm+1K/an+zNZFL5M1pjFXeI72ky48eGnPkvNp27+TPU6nHpMfLXaIjpE
erk5dRMxOfN1mPeisfshW1ne1a1577Y6x5R3U0zze31FOWI6ze0byU098kRlzbxM9qrMlPDpyRMR
Md5Vt/Ihp5898mWZm1pjftE91uCt7fCI7dWeHDEW3t723l6rslqxWZnasR+SYhFbzhnfxJ2jyeq9
lcGXWZcmW0zWKxHLaI7794eJx5fpfEKabT8t8l5isddo3l9S4VjrwrRUwzSJt3tav3pdOL6Y6dXD
j8HFWm+/KsU4NRXPvtWazHquWVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAa+fXYNP9u8b+kdZBsDkZOO135cWOZn4y5Wu4xqctbe9y19Kp4njt6vi+PDm8DFMWybbzPlV
5PiGtz67UxbNbeKTtWIjaIXYpnwuaftT5tXJT3vmi1pMsrU5qIrG1V1a+5DCa7b9GFbRr5J6Wnbt
Cu+Wmk0m8956z8ZWZNorbfzcbX5rZslazPux3hUt41NTntktObJ13+zX1bek01r4/HzVm0bxPXy/
+bNfDgjVa2uOY92kdfg6ufJOKvLXtttVVSqbcta2vM7zXtHpLQy5ZtMd+vWd+7Zy3mdJHXra3f0c
vUarw7zFY5rT2hH1Lavnrgx81p3U49Pk4nE5L35MO/StfNRXR5tXnrS8W67WvfyiPSPi7uLHFK1p
jrtSsbR5Lc4RzsXBaYreP4l45esRD2HD9fnw6evvWvO3Tfr0aGk0U55ra0TFInv6uzgrXFXlx0i0
77RPlC83Yj+JW7oddqr6vHzTTw9/f6dod+L1t9m0T8pcbFSmPHER3892W0zPuz+jSbVvidkcqmfP
Sel7bekrI4n4dZnPWIrHeYnZee2Wpy8dEaml4npNZblw5qzb8M9JbYgAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAABEzFYmZnaI7yCXL1XGa0jJXT0571nbee27DiXEprp8nhbxG20W8
5cbD0ikfnKO+urTPvjoZdXqctdsmTaPSvRpWmsdZ6yztfaGplvv3lWW1tyRlz1x0vkn7Vo5atTNe
Y0+1o79V2KsZsvX7Ne5mwxnyTNvsx2iGneM/rCdRSuOsTasTt5kRFtpjqmOH4t4nk7estiMNa97R
Hwhna0iuKTEdmGWa4672nZtRele1N59Zlq6vLOSsYorEc07qcW65euzRvtXvPZy52naZ7ujr6fXV
rWdukREK8+njHgmZmPc67bq6ivVWhxxgxZLztNrT1mZ/SP4VZs0zaOvfp84WUtNsXLvtv3699+rU
z7+Jtt5qURqMnPpctaR1rMSw4ZoK57eNk6xHaJRh97Ltt7lo5Z+L1HAPZvVauZ2nFTSzMTzeJEz8
to6xPfvsZntPZ9rXxabmxzefdrv0j1dXh/BcmstW1qxTHHasR3+b0GPhGl+kWmd64dNEVjf73T7X
y8vy+Ddx6O3iRakxTH5RXrMw1/lX+3Itw2MFIraN48qRHdZi0cUjmmPen9noox1iO0fNzdXEYrTt
stcmd9aX0bJ+HePmiKTitO8TMLZ1cVjrMfqpz6ys4pjfrPRWZ9rXXptUit6zO+23VyaRHEc05L1/
w9J9ys/en1ljqdVbwYw452tlnl3jyjzbmmiMeKtYjpEbLeTXPUU8ee/+qjJpsV5rbkrFqzE1tEbT
DpYNbW21Mnu29fKWna0KbqTdjXXjld0cvQ63ltGHNPSfs2n+HUbS9c2s2UASqAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAOVxPWe99HpP8ArmP4b+r1EabT3yT3iOkesvMVtN7za07zad5l
XV5GmM9vVfEstvDx0jtaVVMlq+UJ18b5cMRvPeSuK87bUt+i2Z3PtG7zXpjkzXt6R+TXyTMzvM7t
ydHqZ+zhv1+Cv/ZuqvPTHMfOYaTMil1a1K2vHSLTELq2v+KWzThGo84rH5rq8JzedqR+ZeI7WnOS
34pYTafWXR/2Pln/AMyrKOCWnvmiPyR6O1y9585lhWJvl557Q6eo4T4dYiMvW3b3UanhldHpJtGX
e09unmjsT7eb1l4trI2t0hsZfrdNO0bzy+nzU20/+NmkzO9esz+TZxWis9dttvPv+Tn21jjaW8zn
26bTG3mp1M/Wzv3t0jyWXiKZJmsTERaZhXXDbNl8WaztWenxZLstPp5pau8frDtVrNMM5cfTfpMf
3aunxxbes9d/R09Dp8ebJi09ptFr3jtt2WyrW9wy1Jx132mK+Xq9PotT0iIU19ntLtExa3T47T+q
6nBaYvsZstZ+cT/LeMnUi0TXffo1s2m8Ws2/OIMWk5Jib5L328rS2t94Sh5TV4ppklpW6PT6rh+P
NbebTHyas8E081mZy5P2W6OFhjxNTE/hr/LoRO0Kvo9dPqctKzMxEx1la5t3tdnjnMs4noievcrO
yZjeFF1OSnNV0OG62cn1GWffj7Mz5w05joovzY7xes7TE7w0xrjPeex6Ua+j1UarBFu1o6Wj0lsN
3JfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrU5o0+nvlt92P3BxuM6nxNRGCs+7Tv8
2hToxm1r3m9utrTvMsonqyt7XTmcja0u3O6FMfi5t/u0/lzdJM81p9O3zdvHTwsUR5+bfPqOfX1h
dqV+3O7bs1+T31oqmI3TEM4rvCdkDGIIhlFd2daboS0NXG2bD6bufxXU1vlmu/u4us/N0+L1tTSx
kr9qk7w89j1FNZMV3jxLzvaJ8mer+LSOZqK2xZotbvljfr/89U453rXt9lse081xZtNjx7TGKu0t
DHlrevSevaN5Y6+tJ8c7VRNMt63n3ub+6/R54rERMztDYy4a5omclYmfxKcenrjtHLvtPrCnVmdb
eFe3JXmjy6eS/DrMuLVYsta9Mdt++6qLxO+0dEc8UmInr18iUfReHcXrqccb9Z27Q61Lb13eJ9nc
1Z35rTvE9avY4bTkpG8xEfB05vYxqybc07R281naGMREdoT5JQqy9mply7Q3bV3iXG1eXw7TWSka
c258t7+tpT5/BjT7MfHqndz12Z+M4lMMKyziUJJiN1WSu9fku23RaOgKNJqbaTU1t9yelo+D0cTE
xEx1iXmM1Nt3W4PqvFweDaffx9vjDbGvxz+TP66QDRiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAOJxzU73rp6z296zsZMkYsdr2naKxvLyObNOfNfJbvad1dXkaeOdpvsc2yuZVzfbfqybutwu
s5s8R92J3dvJb3tnO4HSMegtmt3nfZvYp8SZl0z45NfSK7onH1bNcfRFqnUKJr0Y7dVtq7prjEsK
0XVpEM6028mW20IHK41aPo3J6zs4ODhdcvPnvExFevNXpMOrxi/PlrTee7PLX6Pwa09uaNlKtHg9
dM3z5d7ReOu02nu0JzZMfblrv5R5uvrcdImZ26T1mYhxs1Os7RH93PZ7axuafNfLitvbaYU3yZYt
PXs9NwHhui1HBa5LVicsb81onrEuVqNNSuS8Y67dZ6xPZa59Il9uX41vEitImZme3q2Kxbxora0T
Md/ROSa4Ztkj7c9OafL5LuGYubmyX3iu/TfbdSfVnpvZLT/XZK233+Mbbva1xRXyiPk8pwbH4N6T
adq5a71n0tD1WDL4tPe6Xr0tDpz8YVnJHWEXYxbqlBedoef4tW0XraO09HdyztSZcbUz43C+ee9b
SVMaeOfqq7+jGckQ1Yz7+7v2RN/WXPXZPjci2+2yyJaVMuy+uSJlA2d+pNoVRbeDcSxyTE+TDDlt
pdRXLTynrHrDOyiyZeVFnY9TjvXJjres71tG8MnJ4Nqt4tp7T1jrV1nRL1x2cvABKAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAHJ49qfD09cNZ97JPX5PPw2uI6j6Vrsl/ux7tfk1mWr7dOM8iLdm
vfebREefRsWldw7SxqNbWbR7lPesrn3Vteo7dYjDpMGCvfbeXQ0uLlxRLRxROfUc34p6fCHYrXlr
EejqrjY8uzCYW7MZjdVKqK9VlaxCYrsnYExBMRMJRPZA8/xPHtmpP9W2xx76vhWOInvt/C7ike7N
vwzE9kcapGfhlevTaFbFo8RqJ5vy8/RoW09ek0msxHfp3dzNoLzp4zUmZpMbT8HJyYJi20X2n0lh
ZY1li/RaidBF4w2mK3jrHaFGp1lN+tptPp5IjBkid5mIp16TKu0abBPv33vPlM7z+iPdFNcWXU5I
tkrNce/b1W5db1nTaf3ax9q0fxDW1ebNk2phty1mOu09VOm8W19orEz23j1TwfSeERFuEYMddptW
d43dvBn21eKJ75KbW+cf/JcTgMxXTb3nbljz+TpcPmc2uyZO1KRtVtGVdi0bx07qJnllsRO6rNTe
N4XVamsy8mnvPwc3R2jPwe8TPbdlxXNOPSZfhWWpwO85OFzv57qrODkzeHntSe8Sn6Rv0a3EZ218
8nXekfr1a0ZLVnqx19dWb6demXybOO7lYMvNMdW9S/VVLo0us7tPHdtUtEwJiZU3jq2Jhham8CVG
PNODNTJXvWd3qcWSubFXJWd4tG8PK3pPd1OB6veLaa89Y61/u2xfxh5c/rsgNHOAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAANLimq+i6O0xPv392rdeZ4rq/pOqnlnelOkIt5F8Z7Wj27I2I6sb25YY
V1ImY3dbQ08LRc23vZp2j5OJG+XJWle9p2h6HHtbJXFT7OOIpX+7TxT31j5rycdTh+Dpz+XaG/sw
w18PHWseULN2trBE9UcrJKBhFU7JAQi0dEomegNDUYovM7x3jb5tO1ZvpbaTLtzRExWfWPJ08kbT
Ex5NXWYYyV5omYtHWJieyeDzuizfRs19Jn6TM7Ru1uMcJxZqTkw+5f4ebqa7SV1MR4tdrx2vEfy1
axqsNOTLjnLXytVXi3Xj8+nmsxTLM16d5npPyUzpekTtSK+U7vS6vQ/SYmK1vWPS1HOn2dvvvvE/
tDO5XlcO+LbfHSd/W3o6/BdDOXPTnj3Kz38rS6Wm4FNrRyRzTH3p6RH/AKvR8L4dXSzE3jmtHn5I
mbfqLV+m4dbLSsZInHjr3iI6zLpYaxS01rHuxHRHiT9mv6s67Vj1aqL6326MrWiYa+/Q54BxPaGe
XRZpj8MquB4+Xg8zPnB7SX30to379GxpK1xcHiKz5IS8xr8PLPixH2bftLTy05o6dHYyVjLhy0t1
izjZa3pMVv3iO/qz1G2L+NbSajbNyW7xLsY8kTDz+fJXFqKZN4iZnafi6WHL0iYlStI7OO+7axW2
crFl7dW9jvE9ULN+J3ZbdFGOy+AYWpEqN7afNXLj+1Wd23KrJVMvCzseh0+auow1yU7WhY4fCdV4
OadPefcvPuz6S7jol649Tl4AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV581NPhtkvO0R+4NPi2
r8DB4dJ9+/7Q83Po2NTqLanNbLfvPaPSFDHV66sZ5ET0hRknyW2lTtMyouz0c8usx2n7s7vScKwx
zc1vu/y85p+maJh6Th+SOWeveXR4/wDLm8v+nX5mUWa9bbrInolmu5jdTNkxYFk2Isr3TuCzeGMz
+THdEyDDJO9Ja823rt2XWnya946pGvktDXta0ztWu/ybvLE9dkcoOf4GbJPWK1j49VmLh9JtE33v
Mevb9G7WsW8l1ccREISophiJ2jpDYpijbaOjOuOJ8ujOdqxsgVcsUjaETYvbaFFrgu5lVsm0yUtu
ryg43H5m+GIj1XcJzePoL4pnrWGtxmfchr8JvfHS1622if3QljzTTLes+qrNjrkiYtCzPMxnm095
YZJ6boS5teB49Tqscza97VtvWvlv8V/FOF34RrIxTM2xXjelp/eHoeA6XnzReY3ivX/0dfivDcfE
9HbDbaLx1pb0lOs+jO7K8Lis3cN+0NKcd9PmthzV5clJ2mF9J9GHHVL108dm1SznYr/Ft0tuhLb8
mNohFbMhLWy0mJ3rPXvDvcO1karBG8/WV6Wj+7kWrvDDBlvpdRGSnbzj1hpjX4z8mOx6UYYstc2O
uSk71tG7Ns5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeXneJ62dVl5KT9VTt8Z9W9xbWclPo+O
fft9qfSHEU1pv48ftYST23ZTDC/p0YtlVuvVjMbM5+LCZjYGWGdrTPxiHY4ffaf3cjTxz1v6xMS6
Olty2iXVj/Dk8n+ndrkhnGRo1v8AFdW3RCrZ5uiYsqrboncSu508yjmZRYQt50TfowYTbYGVrKrT
uTZjvukQnYhMIGVY2ZxPVWyrHVCWzXpVXkt3TE7Va+W4K7X3jv1auTNy3jdba0RZpamfroQN7Hk3
6wr1GTaN2OOJiu6Mu98NvgDi8Wy74d/yZ8PiPAiO2zU4nb6qIn1bugjfFE/ASp1ke9u15mbbRDZ1
Mb823kx0Ontn1OOkedoJCvT8I03gaKsz9q/WW+isRWsVjtHRKyrhe0XCfpWL6Vgr9fjjrEfeh5fF
feH0V5Dj3DPoOo+k4a/U5J6xH3ZZ7z3228evytOk7NvFbo0cdols47bSybt7HbddHVqUs2aW3Qnq
xVeu8LILR3SlZw3V/R8nhXn6u0/pLuPMXjeHT4Zruf6jLPvR9mZ8/g1xrvpz+TH7HUAaMAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABRq9VXSYJyW79qx6yvmdo3l5viGs+maqYrO+OnSvx+KLeLZz2te1rZL2v
ed7WneZYWnZl5K72YV1xEyxmeqJljzIEWlVkszvbZp5soN3h2SJz3pP3odCnuWmPRxuERfJrZmtZ
mtY96fR28kbX3dXj/wAuTyf6bmK+9YX1s0cNtm3Sd4LFY2K23W1s16StiUJW7bp22RW3RluBuruz
mWEgrmCGWyNkoExKE1QlPmsqRDKeyBjaejWy2W3ttDUyz1QKslvehVqKTNosyyTvELabXptIJpaP
B39Ia2mz+JGpr51jdZefDx2hzuHZObNq58poJaGtjxJ2+LoaKP8ADRPo5+T3skx5OhpOmC0fBNQ0
5yTbn+bt8A0u9raiY6RHLVwY62mI6zMvaaHBGn0mPHt1iN5+aYVsACBXqMFNTgviyxvW0bSsAeE1
mkvw7V2w5Ote9besJx2er4rw2nEdNNekZa9aW9JeQjnxZLYskTW9Z2mJY7zz26fHrrdpbZsY7NGt
mxjvso1b9NmUwpx33XRO4K7VUTE1nmrvEx1bVo2VWiJE/XY4frY1WPlt0y17x6/FuPM0m+HJGTHO
1qu9pNVXVYt46Xj7VfRtnXXL5MfzexsALsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHM4jxOMFJphmJv529Dq
ZLfjDjPEIx450+K3v2+1MeUOHSOWFc3nJkmZnf4yujpVlqunOeFpV2nctLCZUXRM7MJtsWlRkv3Q
ky5NmpWt9RnrixVm17TtEQnJabXisRMzPSIew9n+CRoccajURvqLx5/chfOest642OGcIpoOG2w7
ROW9d72+LQvXevyejcPUU5M+SvpLeOataraw2a0dLbLqTtK1G3Es4lVWWUSoldFtmcXUbpidgXzK
GEW3TuCUSncnsDFMMLSms9EC6J6FpVzbZE5ALy0809ZbFr9GtfrEoFMzuuwz0Ueey3HbaBLDXe7i
tMOfwWnP9I+NZbuttvhs1uBRtXPb4SDm3iIvf57N7Dbl0VrS5+XrltEd+Z1Jx7cNms9N4TURRw3T
+PrcO3WszEvZOD7P6aYiMlvu16S7y1QAIAABxOPcLnUY/pWCv1tI96I+9DtgmXl68Biy7/NtUu3+
O8HnFa2s0tfd75KR5fFyMWTdhrPHVnX9R0cd21S3Rzsdm1iuqs256wrmGcT0RYSx5d047X02SMmO
esd49YRE9WcdSXhZ2O1p89NRji9J+cei1xMc3wXi+KZj1j1dTTaqmor06WjvWW+ddcu8XK8BZmAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAMMmWmKu952UZ9XFZmuP3revlDTtzWnmvO8q3XGmfHb9ZanV3yxtWeWn7y4es
vPNtDqZJ6Ts5mppvdl/XXRMyfGvSNlu/RVvtOzLfoipLT1VTKbSpvfogRkvtDVyZOhkyvQcA4Dzz
XV6yvTvTHMfvK+c9U3rkW+zvA/D21urr789cdZ8vi9KDb45rejl8Rry6iJ/FV1HP4vXbBTJEfYt1
+UpiHM295bXsqrO9l8QkZ0lZEqqLeyBZHZLGvZkhIndADKJ3TMoqWQMZ6pjsxll2jsCLSrmU2lFY
36gieyu0LJk3jbsga0wdqzK20QpyztQGprL/AFMrOE05NLkt6qdVWZxNrSe5o9vWBLiUjnzXn0vL
q555dHt8HOwV928/1z/LpzXxbYccRvzTB+jucOwxh0dI22mY3ltIrHLWIjyjZKyoAAAAACJiJjaY
3iXleM8InR5J1GniZw2n3oj7s/8Ao9Wi9a3rNbRE1mNpifNFnVs65XhcWTdt47bnFuF24dm8TFEz
p7T0/pn0a+HJux1OOrOux08d1ndqY7tillVkzExLOk7yd4YxGwluViJhE45raL0na0dtlWO0+bZr
1TKi+2zptZGTamT3b/tLacvJjiY3XaTWdYxZZ6/dtPm1zrv1z78fPcbwC7EAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhkyV
xUm152iAZWtFazNp2iGhm1Vss8uP3aevnKrNntqLdelI7VRHRnrX/HRjx/tZREVjZXeybW6KbWZt
pCZ6S08tN7Nmbb7zCrJtyoS5145bSx5mWafelr3tsKmS/o08uXyhlly7RPV2+AcBnPNdZrK+53pS
fP4ytnPVda4y4BwHxOXV6uvu96Unz+MvVxG0bQRG0bR2G0nHLb2gCUDX12LxtFmpHeazt82wT1gH
mMN4tWs+rcr2aEV8DU5sM/cvO3yb+O0csLUTSdrLphRE8tlkZI7Atr2ZMazDJVKTYSCawi7Ksq7z
1QERvLK3ZGPrKbyCrbdnMcsbeaa18/RhvvM7oGEwTG0JmYYTIML22a2e28xELM19oURPNO4lOem+
n3ZY5+prVnMc2GYU4/L4A0a15cNf6rz/AC6fC6+NxCPOuOu/5tHJTbHj+F5/l1+BYumXJMd9o3/d
MRXYASgAAAAAAABhlxUz4rY8lYtS0bTEvH8R4ffhmo6bzhtPu29Pg9mq1Gnx6rDbFmrzVsizq2df
zXkMWTeIbNL7tbXaHLwzUctvexWn3bmPL8WFnHVL326VZ91MfFVjvvVlz79kLrcf2m7j7bNHH3bl
J2SirLQoy4t1++7G0dBC/RanxI8PJPv18/WG241+alovSdrV6w6mDNGfFF4/OPSW2b1zeTPL1aAs
zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAVZ9RXBTe3WZ7R6iZOpzZq4ac1p+UermZMl89+a/byj0Ra9815ted59PQ32hlrXXRjH
DpCLX6ML5NlNsm/ZRqstfdXzbsZt06sLZNvNB1Za8RDWyZdo7q8udq5Mu/mIMt4md2lmy7JzZuWJ
dHgfBL8RvGo1MTXTxPSPx/8AstJ1XWpIs4BwSdbeNVqq/URPu0n73/s9hEREbRG0QUpWlYrWIisR
tER5JbSccur2gCUAAAAPM8Sry8Uyz67fwuxbzVPGsE49XGbvF42V4M0TEL33ERnktsxpk3sumK2j
admFdPFZ33VS2Mdui2J3UU6LYlFSsN2O5NkCyJ6K7T1TEsbAsxdpReerKkTFGMxvYEz0rsqtbbpC
b2VT1QEzuwtbaGUxspuJU3neWdKoiu8rq12gCI92YatLcublnzbEz1aOptyZqTuDHLfxN6R0+t5X
qdJhjBp6UiPLeXl9NSMnEKxHa1+bb8nrlvxUAAAAAAAAAAABTqtNj1eC2LLXeto/R43VabJw/VTh
ydY+7b1h7ho8V4dXiGlmvbJXrS3xRZ1fGv5rzeHN02bEW3cys3xZJx5ImtqztMS3MeTeGFjqlb2O
8btql3NpbZtYsnSBLeiWfdTjtutid+ghherHS5p0+f3vsX6T8Fkw181d4lMvEWdnHaGnw/UeNh5L
T7+PpPxbjdyWcvAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAo1Oprgr63ntAmTqdRqK4K9etp7Q5d7Wy2m953lNrWyWm953mVd77R0
Za1104xxlN9lV8qnJl2a9s3xUXX2ybsJyRDWtl3YWydEC+2VRkzeW6q+T4tbJm+KRdfK1cmWZnlr
vNp7RC/R6HU8SycmCk7ed57Q9ZwvgOn4fEXtHi5/O9o7fJaZ6z1uRyOEezVstq6jiEbV71xevzer
rWtKxWsRFY6REeSRrJxz22gCUAAAAAANbX6aNVpL0npMRvWfSXlKamsRMVvXm+EvZXjmpaPWHzfL
oNRjzXicfWJ8phfPxFejx72x7xMzK+sXiNoiXlq+Pi6fWV/VfTNqfLJl/WTg9Pji8R70LqvMV1Gq
j/zcv6yz+lanzzZP1lWpelTET6S81Gp1P/Gyf90s412rjtnyfqql6asREdWM9+jz9eJ6yP8Az7uh
odZqMt458tpB1JvEViI3/RhzRt13/R1MNaziiZiJn5K9ZNceKZiIiQcu/WekT+iYrWI3lzdTrs+8
8uW0fJzcur1Np/zsn6g79phVaIeetqNR/wAXJ/3SwnUaj/i5P+6UD0ldonum161h5mNRqP8Ai5P1
lNtRqJjacuT9Qd22WN5aGeZyZd/KHJy59RHbLf8AVq31Gp/4uT9ZEvS8Lr/vSs2npzRtL1z53wK+
oza/HW2XJNd99pmX0Rb8VAAAAAAAAAAAAAAcHj/C5yV+l4I9+v24jzj1cLFk8nu5jeNpeW41wmdL
knU6ev1Vp96sfdn/ANFdTrXG+eq1q5F2LLtbZoY8m8d11bbSydErsYsm+zZrO/zcnBm226uhiyRK
EtrvCrJDOJTeu8A1MWX6Lqq5N/dnpb5O5ExMbx2cPNTeJb/DM/iYPDtPvY+nzhri/jDy5/W6AuwA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAa2p1UYo5adbz+xbxMlvqJ1OqjDHLXree0ejmzNrWm953tPmTPWbWneZ7yoy5YhjrXXTjH8s75N
mtkyxt0VZM2/m175N1V03yTKubMLXVXybeYLLX2VXy7eam+b0bOg4VquJW+rry4/O9uyZOq3UjVm
9r25axMzPaIdvhns1kzbZddM0p5Y47z8/R2+HcF03Doi1a8+Xzvbv+TotJnjDXkt+K8ODHp8cY8N
IpSO0RCwF2YAAAAAAAAACvUZYw6fJkntWN3k8dfHz2vLucdz8mkjFE9bz1+UOZosX1UzPm0nqI/W
MYo9FlcPNklfFGeH/NshLGun+Cz6PtHZtVZWlRLS+jxPkRpIn7rdoupHTdA5s6SI+7H6Mfo+32Y2
+To3neSIiZ7A0IjPXpXLePlMotGW3272t85datKzHZjbTVnsDj+FG/2Y/RlGP4R+jo20u7H6N1Ql
o+H8I/REY957R+jpfReiK6eOYHLtj2tttH6KrY/6Y/R2c+kjeJiFVtLG24hxpw7/AHY/RRkw9O37
O99Hrt1YX0tfOBLjcGp4XF8c+u8fs9c4dcVcGemSI61nd3IneN1orQAAAAAAAAAAAAABFqxes1tE
TE9JiUgPKcX4RbRXnNgiZwWnrH4XPi28PdXpW9JraImsxtMS8pxXhF9DecuGJtgmf+1TWW2N/la1
L7N7T5e3Vy6W3hsYcvLbqzbO9jvvCzvDR0+XeO7crO6FmGSvRThy/RtVXJ92elvk2rRvDUzU7pl4
izsd2J3jeBpcNz+Lg5LT7+Pp+Xk3W7js5eAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs0NTrN96Yp6edkW8Wzm6+LNTq4pvTHO9vOfRoWtt
1mes95YWvs1s2fZldddOczLPLn2ju0MmebT3YZc2/mpm3qqllN1drsbZIhr3yzvtHf4AsvlYYseb
V5Yx4KTe0+UQ6nDvZ3UazbJqd8OKeu33peq0eh0+hxcmnxxWPOfOfm0mP+steT/ji8N9mKY9suum
L37+HHaPm9DSlaVitKxWsdohI0Y22gAgAAAAAAAAAABXnyRhw3yT92Nwef4xm8bVzET0rPJH5d12
CvLhho3rN9RWs9Z23n5y6O21YhrVYbdGOCfrrLPJRpv863zVS6FS09SvZj3lVZZRdPSqmnSWdrIE
ebOkK4ldTsgW1WKqd1oMZhEVZyRAImOjGI6rJ7IiATNd46qL02bHkiaxaoNGY2n4ImPgtyV2n0Vo
Gvlx7x2beiyTk08RPevSVUxux00+Fn2n7N+n5rRFb4AAAAAAAAAAAAAAACLVres1tETWekxKQHlu
L8InR2nPp43wz3j8P/s5dLveWrFqzW0bxPeJeV4xwmdFec+CJnDM9Y/CrY1xv8qvTZ+WYdbDk5oh
5zHk283U0eo3jaZZ2N5XYjrCnLSJhOK+8d1kxvCqzSwZvousrb7k9LfJ3nB1OLeJdLhufx9LEWn3
6e7LXN9Ofy5/W4AuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAETaKxMzO0Qi9646Ta07RDmZ9VbPbaOlI7Qi3i+c3TPUaqcu9adKfy0722ZXvFa9
XO1OrjrESxt66ZJmcjPUanlidmhkzTZVfLN5VWvsC2b7R3U3yqrZZtO1esz2h2+F+zWTUcuXXTNM
feKR3n5+iZLVbqRzNJo9TxHLyaekz62ntD1fDOA6fQbZL7Zc/wCKY6R8odLBgxabFGPDSKUjyiFj
SZkYa3aALKAAAAAAAAAAAAAADQ4pl2pTFH3p3n5Q33E12Tn1eSfKscsLZ+orS00eJqbW+Lfnu1tF
XaJnZsz3WpCfsyp00fWSvmPdVYOmSUDd8kR3InoQosy7JmUX7MdwZ17ro7KKT1XRPRAsrO0rYndr
79V1ZBaQiJ6JgCSIJASwrO07MpV2nqBlrv1a1o2bf2qtfLXaQUTO0sb05o3jv3ZXhjS20xEphW5h
yeJjjf7UdJWNKLziyRePsz0lux1SgAQAAAAAAAAAAAAAADG9K5KTS8Rato2mJZAPIcU4ZbQZuekT
OC3afT4NXFkmlntc2GmoxWx5K71tG0vHa/RX0GpmlutJ61t6wrY2xr8dXS5uesN+tt4ef0eaa223
2dnHk3juyreM81OaFGiy/RtZET9jJ7s/2bdutd2jqKeic3iNTsd8a2h1H0jTVtP2o6W+bZbOO+gA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABje9cdJt
adohGTLXFTmvO0fy52bJfU23t0pHaqLeL5xdK9Rnvqb+cUjtCi94xxvK3JetKuHrdZvaa1ljb10y
cnIs1Wt3naJc++TmVWvMz1YWybfMGdsm3eWek0mo4jm8PT0mfW3lDf4V7P5tdMZdRviwfvZ6/TaX
DpMMYsFIpWPTzXmf+steT8jn8L4Dp+HxF77Zc/4pjpHydYGjC3oAAAAAAAAAAAAAAAAADG9opS1p
7RG7zszN6WtPe0zLua+3Joss/wBOzhzG2OsL5+IrY09dsSyYRijbHEMvOChb7KjF0yS2LQ169Mso
S24noyrPVXWejNVKbTuw3T3REdQWU6LYlVvsyiUDPfqupPRr79VuOQX1lZEqoZxIMksd0gT2VT0l
bPZVbuCaW8i8bwr32WxbcGnkjaZa9p2ndv5qbw5+aNugLItF6TEtvTX5sMb969HMpfazc0d9stqe
vVZDdAQAAAAAAAAAAAAAAAADV1+iprtPOO/2u9bektoB4TJTJpNRbHkja1Z6uto8viVht+0HDvpG
H6Tjj6zHHvbecONw7Ltfkmeqmo6Ma69DXbbZTkr1mGWO3RneOaGbZRoM30fVzSelMnT83aef1FZ7
x3h1tBqfpGnjmn369LNc3sc3kzy9bQCzIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAa+q1dNNXr7157VhGp1Xh70x+9f9ocy283m1p5rz3mVbrjXHjt91lz
5c9+fJ1nyjyhdM8lZlOOIiqrUXikd+kMreunnI5XEdX4dZiZcG+XmtNl/F83PeeWWHDOGanieSKY
q+5H2rz2hMzWd1Iqx1yajJXHhrNrW6REeb1nCPZumn2z62Ivl7xTyr/6uhwzhGn4Zj2xxzZJ+1kn
vLoNJnjHW7TbbsAszAAAAAAAAAAAAAAAAAAAAaPFrbaSK/itEOXt0rDf4xb/ACa/GZacRvaF58Q2
IjasQnzPIhCU92tMbZGzHmotG10C6nZkwpPRmipIllEbMIZIE7solgmJBnCyk9VMM6z1BtVllEqK
z0WRILYlluriWcSDJVbusV27gwInaSWM9ECyZ3hqamnSWxFmOSOaqRx725bNnSZNs9J+OynVY+WZ
YYr7TE+nVaIr0Ais81Yn1hKAAAAAAAAAAAAAAAAAABExvG09peU4nov9n66L0j6q/WPg9Y1OJaON
ZpL0+9HWs/EWzeVz9PbmrEtnyc3h9reHy26TWdnSr2YX6657ijLXpLX0+onSamL/AHJ6W+Tbv2aW
ekTv16JzeI1Ox6KJiYiY7Slz+E6jxdN4dp3vj6fl5Og2clnKACAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeQRMxEbzO0Q08uqtkma4ulfO3r8lefUePMxWf
cjy9WvlzVxV6T1Z61/x0Y8f7Wc7Ur1lqVy+LqOWJ2hp6rXddon5rOF1tfmz5OkT0qzb8dWbxjp1c
biuuilJ5Z6r+IcQrixzEy8zl1E6rNt1tMztFY81sztU1eRucN4ffi2p5esRM72n0h7rS6XFo8FcO
CkVpX082nwXh3+z9FWLxHi36328vg6TZyW9ABAAAAAAAAAAAAAAAAAAAAAADj8Unm1tK/hqppHvw
y1k8/EMk+m0GOPeafiFpCZYwolnXspvHvLa9mF46gmnZmwozRUiUCBKYYsoBLOFbKAX0llEqqyzi
QXRLOJVRLOOwLIljZMEgrlhKyYYTAK5nZPN0RZjugUanHzVlz6xtLq361c+9eXItPpXX0dubTU+E
bL2lw2++O1fSW6m/VYAISAAAAAAAAAAAAAAAAAp1GbwcfTreelYEydcuMcRrM/L9nnlsV6wqpi2r
tv133mfWVkRyRtEdGFva7MzkYZNoamWN4bV4mYa9qztKIujhVppxGI8r1mJegeZpknBqKZY+7L0t
LRekWrO8TG8Ns/HJ5ZypAWZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAADS12fp4VJ6z9qVuq1HgUiI+3bpDl589cOKZmevqprXPTbx477rDJlrhr1nq4+s182tMRP
RqaziXiZJrWekNG17ZbxWJ336M5LXRbI3dLTJrs07RMY6fan1dHLrowY+X7MVjt6N3R6Kul0EbWm
s7bz8Z+LnabQX43r7Y53php/mXj+Dnv0f1JO1x/8ZxbUzj02O15mfLtD13AvZqnDds+pmMmo26el
XX0Wh0/D8EYtNjilY7+s/NstpOOTW7QBKgAAAAAAAAAAAAAAAAAAAAAADG88tLW9I3BwJtz6nNf1
vK/DHVqYJ3pzT5y3MPZeojOWMQylEKpTVjZnDCwkqzYQyRRICATCITAJZQxhMAshnEq4ZQC2srKq
qrIBZCWNZZgwswmFloVyCu0dFcx1WyrtCBhv5NTPHXds2U5o3hIz4ffbPt+KHUcTSW5c9Jme0u2v
VYAKpAAAAAAAAAAAAAAAAYZctcVOa35R6tLrltN795/YvknNqrfhpPLH92V5isd9mWq6fHjk6rn0
ZxG8KK5Jm/wbVZiYZtqrmkqL023bkxvCiY3lJHNyRG81mHS4Rn5sNsNp64+3yaWaNrzOzHBl+i6q
mT7s9J+S+ay8mex6EIneN47SNXKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAImYiJme0JafEs3h6fkidrZOn5eaLeJk7eOdm1Hi2vmtPTry/CHmOJcUvmvOPF1n09Pm
6HF9ZGm01qxO3R5vSY7XwzmzTy47zzTEd7en5Mfvt2/PURWdo3tvPrPlKymbktFqTtMTvHzbOLDG
f63JXbFX7FdnoODcDprZpq9TjiMMTvSn4vj8l5fxnrk91saPSa7i2hpOfbTVt5x1m0fLydzR6PDo
dPGHBXasd585n1lsRERG0dIF5OOe6tAEqgAAAAAAAAAAAAAAAAAAAAAAADX11+TRZrf0y2Gjxe22
gtH4piP3TPpXKwxtjhuYo9xq442iIblI2pC1RET2ILd9kxCqRjZmwlCSEohIJAQAAJZISDKGUd2M
MoBnVbVVCyAWVWeSuqyOwIlXZZKue4MJV2WWYT2QKbKL9YlfdRdIo35b7/Hd3KTzUrPrDh27uxpb
c2mpPwX/ABX9XAKpAAAAAAAAAAAAAACekTIp1eTwtJmv+GkyJn1oafeazbfpMzLR4jq/o8b823zX
6XNF8ERCvTcNpxLV5LauvPhx9Irv3lhztdtv8TtaWLicXrt03jzjzb2k1nid56ty3s/w+a7Uwzjn
1raejlarhmbhl/FpbxMO/fzj5p/ixSeXOvTtRfeI280ZI26tfDm3pWe63LaZx7qtGvniJ6tPLvOK
fOa9WzbJvTbza02jl3n5SSljscK1MajSxWZ96nSW88xw/VfQ9XMT9nfa3yemid43jtLeXsce88qQ
EqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADia3UTm1l4j7OP3Y/u
7Vp2rM+kPJW1PhYcmS0+9MzKm/jbwz31weMzbV8UppazPL9q0/BF4rk1GLDSNqxPWPhCnHmnNrtT
qPKteWPm6U6OdHaZvO+SaRNvhv12Ub/q3FhtrNVj0uKOt56z6R5y9zix1w4qY6RtWsREOJ7L6OKa
S2rvX6zNM7T6Vh3mmZyOfya7eACzIAAAAAAAAAAAAAAAAAAAAAAAAAAczjVvqMVfW/8AZ03I41bf
Lp6/OVs/UVrY47NyOzUxd4bUJpEbb3Z7IiOrKIVSjZhMLJYyhKIgmGUQSDESIEbJEgQmCITEAmGU
IiGUAyhZVhDOoM4Wx2VQtqBKuyyWEgqlhKyyuyBVaGtkbNmvk7A15l1eH2300R6TMORPSXT4ZO+O
8fFefEX63gEAAAAAAAAAAAAAAAq1WPxdLlp+Kkx+y1Fvsz8gjhaDauGK8sx07y3OE3m1tT6RaP4c
vU6yMNKUx73zT0ilY3l2eF6a+m0kRl/zbzz3+Ez5M8z26fJruW6wzYq5sV8d43raNpZjRzPPaTmx
5b6bJ9rHO3zb2WJ8GWPEscY9bgzxH2t62n19GWW0eHOzHU5XbjXZ1x8WTnz2iZ7S2M1IjH2+LX0V
KTqs8zO9ot0j8nUthi1J3UaOFMTfLFo6xMbS9BwHWTqdHOO8+/hnln5eTjYMFo1WTH5VnePzXcIm
2k4zlpPSmXy/hfF5eMfJns69OA2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAADG/2LfJ874rW845mubliY7bPoto5qzHrDz0+yePNF41OotaJ7RWNtpV1OtfHqZ715fhu
j8adNpcVfeyzE2/vLuanhOu1nEctIxTTFa/+ZPbZ3eHcF0vDbTfFE2yzG03t32+DokynXl9+leDB
TTYKYccbUpWIhYCzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAcXjE/4zDH9M/wAu04XF5/3jj/0f3Wz9
RUYmzDWxS2I7FSyjuzY1ZKpRKEygEwiWUIkGIk2QJNhKQhMIhkCYZQxhlAMoZwwZwgWQshVCyATL
CWc9ldpBhZXLOVdpQK7NfJPRdaWvknoDVvPvOnwuel4+TlXn3nS4VPvXj4QtEV0wAAAAAAAAAAAA
AAAAAVV02CmTxK4qRf8AFFeq0AAAanEsfPpZmO9Ji0NDLfkwdOsulrumiyzHlVzJrz4Ovoy26vB8
cTBa9NffLtMY77Rv8Yegx5ImkKdJoY1HC81Y+3OSbVn0mGGkmbY45u6tnrrTOu2xGO0RxCd+nNVj
qKxTV1vH2pjaGtnyzXXYdo96ZmGXEMk15b7/AGZiVerWPTYckZcNbx5wzc7hGbnxXxzPWk7x8pdF
0S9jh1OXgAlUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAcPjEf4/FP9H93ccXjMf4vDP9Mx+62fqKrx+S+GvibEFSsqyYwlVK
ZYsmIMoRKYJQIPIEiQ2ATCUQygCGUIhMAyhnDCGUIFkLIV1ZxIMpVWWSrsCuyqyyyq09ECq8tfJK
66jJ2Bp5J6upwn7dv9Lk5J951uE/av8AJaIrqAAAAAAAAAAAAAAAAAAAAAAq1Mc2myxPnWf4cmtu
XT9fR0tffk0WSe28bfq5Wbamm3326MtunwfK6PCv/AxPraZ/dz9PO97/AOqf5dHhdZrw7Dv3mOb9
XOxRFM+avpe38mvkPHf/AFWlrKba7Tzt99ZxKkfR7euyNXMTrtPHfa0z+zPiM/UR8Zj+Wbdu8HpN
M2bfzrV13M4dO2pyR61dNvj44/J/oAWZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADj8bj63BPzdhyeNx0wz8ZWz9RWri7Nmv
VrYu0NmqaRZHZlDGGSiwxZSgCEkCBCQSCQBMJRCYgEsoYx3Z17AlMIhlCBnDOGEM4AlhZZKq4KrK
7LLKrIFN2vdfZReAaObu6/CO9vk5OePR1uEd7fJeIrqAIAAAAAAAAAAAAAAAAAAAAGtxCk5NFliI
3mI32+XVyNTyZOHTee946PQKPoeDffw4777eW/yVs60xv+ZxOnr4Okx1t05KRv8Ao41Z5q3yed5m
XY1szXRZ5jvFJ/hxItP0aOSN9q7yrtr4f2tHFM5+KT16Yq/vK/iGSbXw4vO14UcPx5MGfNbPG18m
1oj4THRsTw7VanPXVYpi3gzMcnrvCnG11JOupwuN8+a3pEQ6jT4divjxWnJExa09pbjbM5HHu90A
JUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAHM41H1GOf6nTc/jEf4Ws+lls/UX45uGekNujTwdm5RNIthKIZKLDFlsiQIShIC
EgCUJ7AmGTGO7IDzZQhMSDJMMYZQgZwzhhDOATuqssmVdgVWVWWyqtCBTeVF19lF+wNLNG7q8I+9
8nLyupwnt+S8RXUAQAAAAAAAAAAAAAAAAAAAAAAItWL1mto3iY2lyrcLyUxzix2ia2nvPeK+jrCL
OrTVnxpanhuPPemSs8l6RtE7dJj0ldpNP9GwRSZ3neZmV4cR/Vs4AJQAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHi1d9H
M+kt5ra+vPoskfDdOfqK4mn7Q3aNHBPZu0W0RdDOGFWcKLCJZeTGQQlCQSgASBsCYZQxhlAJTAmA
TsmAgGcM4YQyjsgRLC3VnaVcgwsrt3Z2V2QK7tbJ1bN5a9waeWO7p8Knt8nNyebpcK8vkvlFdQBA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK9RXmwZI+ErEWjesx6wQeZwejeo0cccuW8
elpblJaaRGxVnCuss4ZrMvJEgCAASISCQIBlCYYpieoM0wx8k7gzIRueYM4Z79FcSy3QEsLJmWFp
BjaVVpZWlXMoGNmvkXXlr3kGtknu6XCf7OXkl1OEdl8orqgIAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAHmskcmtzV/rls0U62OXiWX4zErcc9GmkRfWVkSqqziWayxCPIANwBIhIJSxS
CRG6dwZwlhEs4BluMdzfqgZxLLdXuy3AmVdpZTKuZBjaVVpWWV2QlhZRdfZRcGpl7urwfrzfJy8r
rcH61vPyWitdMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHA4nHLxKZ9awnH2ZcY
jbW459aq8fZpfiI2IZwrqzhmsz3Ebm4JN0AMhCQSIASndiAziWUSriWcAyRujc80DM3RCfIETLCW
UsZEsJYSslXZAwlTddPZTkBp5e7r8Gj6rJPxhx8k9Xa4PG2C8/FaK10QAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAcfjcbZMFvnDWx9m5x2PqcNvS+zSxT7sNPxH62YZQwqzhRZO6UCB
KUAJTux3SDIRuAncQAmJZRLBMSgZ7iIAZRKd2DICUSlAljLCYWMLIFVukNfI2bNbIDTyT7zu8Ijb
Sz/qcG/2nf4T/wCE/wD2WnxWt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHL9oL
+Hw2cm28VvEuPptfgyVj6yIn0no7/FtJfW8NzYMe3PaPd39d3iMug1WktNc2C9dvPbeP1aZ9xF+v
T471tHu2iflK2HkqWmvaZj5Surqc9Ps5bx+alTHqYHm68S1Vf/NmfnC2vGNTXvyT84Ql6A3cSvHM
sfaxVn5Ssrxyv3sM/lKB1xza8bwT3pePyWV4tpZ+/MfOEjfGrXiGlt2zV/PotrqcN/s5aT/+wLRj
FontMSlAlKEgndO6IAZQljDIEgeQljLCzOVdkCu/SGrkbF56NPNeKxMzMRHxENe0+89DwuNtHHzl
5PJr8NcnLW3Pbf7r1nCZm2gpae8zMrz4i/W6AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAETETG0xukB4HVaeMHEtRi26RedvkyjBSfX9W77QYvC4xz7dMlYlrU7M929dWJLFc6aPK0q
7YLxPS0S22FlP6q38Zac0yR92s/KVc3tHfFf8tpbcsLRvB/dR/8ALLVnU0r9uL1+dZI1mnmdvGpv
6TOy6ym+Oto2tWJ+cJ/tW+KLK5KW+zes/KU7tG+h01p64qx8Y6NXNo6Y+uPJlp8rLf0rfG7MXtHa
0x8pZxqs9e2a8f8A7Oj7HaTHn0+f6RWM23LETfr6vRW4PoL99NT8ui7F4+vEdXXtnt+fVbXjGsr/
AOZE/OsPS29nuH27YrV+VpeV9pdPXhOtw49NG9Mld55+vXcTPd42I47qo7xSfyWV9oM8d8VJ/VxM
d8l46xWF9cV7en6o/qLfxp2I9ob+eCv/AHMo9op89P8A/wBORGmyT5R+qfo2X8P7n9Q/jTsx7RR5
6ef+4/8AuHftg/8A6cWcOSO9J/WEbWr3pY7Efzp2Lcfv5YK/9zWy8d1E/ZpSv5Oba1/+Hb9lc+LP
bFt87I7E/wAabWbiurvEx4nL/pjZzc2bJkn372t85ZXx55/BX85lucC0vPxnTxlnnjm32mOiZqUu
LJ2p4TwnVavNWaYbRTfre0bQ99pcH0bT0xb78vmtiIiNojaErMwAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAHnfarF7umzRHaZrLjYrdIen9ocPi8JyTt1xzF4eUw23rCm3R4r6bMy
wt6kdTaWLdjswmNoZontsCm0K5XWjopnuDC0dGpqG5bs08/daKV672MjbSaif6oh6Z5f2LtvptRX
0tEvUN3Jfo8f7cYve0eX4zV7B5z20xc/C8eSPuZIRficfXlcPaG7ino08HWIbePpLF2NuiyOyrHK
3fZFSwuovHVfaVF4QK5YWTM9UT0EKry6Ps1Tn4zjn8NZn9nOtLseydObiWW34cf918fWfk+PYANn
KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1WKM+ly4p+/WYeBxTNd6zG0xO0
vobw3FcP0bi2em20Tbmj5Srr418V9sa2Z7qKyzi07MXUylhaU7yjqhLCeiq3ddaFNxFYW7NLNG8t
zya+WO6Va9J7FW66mvwidnrXiPY3Ny8RyUn71Jj9Ht3RPjk19HK9pMHj8D1ER3rHN+jqqtTjjNps
uOe16zAifXzfTz7kNyndpYazS9qT0mszDdoxrsi6m8LazMq6zDOsq1ZEyrt1WWlXaUCqyq0rbKbi
Fdp6PReyFd8uqv8ACsfy83aXrPZHHto89/xX2/SP/dpj6y8vx6EBq5gAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAB5n2q03LfDqqx39y39npmlxbS/TOG5se29tuavzgWzeV4mtui2
O3RRSY2hdVhqO2MvI36iu9lUsrSrvDHn6spnmSiq5jooyV6tq1VV69RC32byTh43h8otMx+r6I+Z
aK/g8TwX7bXh9Mid4iW+fjl8n1ICWb57xLBOm4zqse20Tbmj8+qKdnS9q8PhcTw5tumSm0/OHMxz
0Za+uzx3sX1t0Zxurr1ZxvspWiZYWZbsbT0QK7KLrZVZJFaqt5vbezNOTg9J/FaZeJns93wCvLwb
T/GJn92uGHldIBowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuAPA67F9H4l
qMW20VvO3yRWW97T4fC4rXJHSMtI/WGhVlue3b473K2KzMML4+62tujG9pnozXaOSOVFMnVbmq1t
trJRW5E7wwvUxTvCyY6CHOt7moxz6Wh9PxTzYaT61h8x1MbZK/OH0zTf+Fxf6I/htj45vL9WgLMn
mvbPFvocGWO9L7fq85p5maw9d7VYvE4JkmPu2if3eW0+PasdFNOnxfF1Y2hlykRsmY+LJ0MZjZXa
eq2eyi8oQTO0KLdZWzPRjWu6VaqtHR73g0bcI0sf0Q8Nkq93wqNuFaWP+XDTDDytwBowAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAef9q8HNpcGaI60vtPyl56k9Iew49j8ThGe
PwxFv0l4zH2U26fDfTYiyJljvsjf4sm6vJ1hrXjq2MkqLdZEVbgbMx0auGdmzNt6iHN1Ub5af6of
TdPG2nxx6Vj+HzaaTm1+nx/iyVj930ysbViPRrj45vL9SAuyc7j1efguqj+jd4/T33rD3HEcPj8O
1GP8WOY/Z4TTT7sKadHhbcsZnaCJ3TPZk6VdrKbTutmP0U2nqgrGOsr8deiuI2X09EqKM1dt3uuG
f/jdN/06/wAPE546S9rwud+Gaaf+XH8NMMPK2wGjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAABrcRp4nDtRWPPHP8PCYusPoWSvNjtX1iYfPuWaXtX8MzCuvjfw32siu8ptXoxi
0wy5t4YulReqmazu2skbquURWFInddM7VYRGyL291KFnCcfj8e0le/Lbmn8n0N4b2Ur4nHLWmPsY
5e5a5+OXyXugBZmiY3iY9Xz7NjnTa3Ph/BeYj5PoTxftFg8Hjk2iOmWkW/Psrr418V5WrWd2faFc
V2jdnEMXWxntupmN7NiYU27iWML6dVMVnddjgVqMsdHr+CW5uE6f4Rt+7yuSsTDv+zWXn0WTHP3L
/tK+GHl+O0A1c4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Dn93W56/wDM
t/L3z59qp24jn+OS38lnpr4r7ZxHQ2TEstt3PXUrt27K57rr1VT0BjKnJPRbMqMs7QlV2fYvHvrd
VknyrEfu9m8f7FZI8fVU85iJewbT45NfQBKo817W4eulzxHaZrL0rje09ItwqbfhtBVs3leai8RD
KLw1sduesL606dWFdsZT1jdhNeq6K9DlhCVUU6s4jZnt1YzAhnM71dH2bycmszY/K1d/0c6OzY4R
fwuK4p8rTstn6z8k7HrwGzkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHz3
Vxvr80/8y38voTwGpj/F5/8AqT/JfjTx/WVeyY6FPspc9dZPVXaOq2WEwIUTVRmjo2rNfLHRI3vZ
DJycXtX8dZh7t879nsnhcbwz23tt+r6I2nxyb+gCVBzuPY/E4PqI9K7ui19fTxNBnp60n+Aj5/pJ
3jZu1aOnnltMNussdfXbm+l3ZM9URHREdZVXTuT1Nk7boQiOkJw28PU47/htEp5eivJPLMTCZ9Vv
x7mJ3iJ9UqNHk8XR4b+tIXuhxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
weqjbWZ4/wCZP8vePCaz/wDIaiP+Zb+UX408f0r9lOxWOifJhXWjfyYWllPRXYQxnrCrJHRd3YZI
6A1NJecHEsN/S0T+76bE7xE+r5dk93LW3pL6ZpMni6PDf8VIn9m2fjm8s9rgFmQxvHNS0esbMiew
PnHLyai9fS0w2aNfUTtrs3+uf5bGPqy068fF227KtSsdFlKqNGMV6myyY6sbdIQI8tlOWOi6Jhhk
j3RD0vA8nicMx9etZmHRcT2Zyb6XNT8N9/2dt0T449T2AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAHhdfG3E9TH9cvdPEcXjk4zqI/q3L8aeP6xr2TsxpLOekMK6mFo6qpXSrm
OqBixvHSVmzC4OfqK7S9/wAByeLwbTW9K7fo8Fqo6Paeyl+fglI/Da0NcMPK7QC7AAB8313TiOf/
AKk/y2MHWrX4jG3E9R/1Lfyv0/aFNOrHxuU7LI7MMayGTVlHWUXhNe6Z6wIUsb9d1m20q7dkDpez
N9tRqKT5xEvRvKez9+Xis1/FSYerb5+OTyf6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAB43j9eXjN/jWJ/Z7J5L2mry8Upb8VIF8f6aGOey2eynHvOy7bowrrYSxZSwQJ2YXZ
92N4BoanrEvVexmTm4blr+HJ/aHltRHSXofYm/1Wrp5RaJaYY+X49WA0c4AD51xONuKan/qW/lbp
+0MOLRtxbU/9SU4J7KadWPjep2WQrr2WRPRk1TvsndXMpiRCb9FNu0rbTuqvKBscCjfi9PhWZeue
V9n434rafTHL1TfPxy+T/QAszAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHmv
avHtfTZfnV6VxPajHzcNrf8ABeJFs/XnMcr4no18c+6vr2YadkY2YM57sEDLyY37Mo7MMnYGlqO0
vQ+xNfqNVb1tEfs87qZ2rL0/sVX/AHdnt65P7Q0wx8vx6UBo5wAHz/jUbcX1PT78qtO2vaCnJxjP
8Zif2amnnspp04+OjWejKJ6MKdmcMmyJn4m5ZHzEVPMwtJv0VZLbQDqezcb8RzT6Y/7vUPM+ytZt
n1OTyiIh6Ztn45N/6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABocbxeLw
nUR5xXm/Rvq8+OMuDJjntaswEeBxT0bNZ6NatZpNqz3rO0rqsdO3PxlaWEMpY+aqWXkryT0ZT2V3
7A0dVPuy9f7G124NM/iyT/Z4zWT7sw957MYfB4Fp4/FE2/WWmGHldcBowAAeM9qKcvFeb8VIly9P
0nq7ntbTbVYL+tJj93CwT76unR4/jo0nozhhTsy3Y1sWljM9Ce7HyQIm3RRlttVbaWrnt0Sh6n2U
x8vD8mSfv3/h3XN4Bi8Lg2nj8Uc36y6TeOPXugCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAPD8RxeBxXUU26Tbmj8+quro+02Lw+I4ssdslNvzhzazvDPbq8d7GW7Dfqz2VzG
0s2qd+iu/Zn5Ksk9BVztX1mI8930zh2LwOHabH+HHWP2fNYp4+vwYvxXiP3fUqxtWIjyjZtj45/L
faQFmQADzftfj3w6fJ6WmHmsP23rvaqnNwqLfhvEvIYZ+sV038bo0noy36MK9oZQxrdMyrlnMbMZ
QKrS1M07zEestq/RRjr4utwY/wAV4j91p9V18fQdJj8LR4ccfdpEfsuREbREJbuMAAAAAAAAAAAA
BAJAAAAEAJEAJQAJQAJEAJQAJQAJEACUJAQlAJEAJQAJQJAAAEAJEAJBAAAJAABAJEJAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwvanDzaPFmjvjv8A
tLztJ3h7HjGHx+FainnFeaPnHV4vFbeIU038VbHeGF+kso7Mb9mTdhKnLK3dRm7SIrHhGPxeP6Sv
9cT/AHfSnz72Zx+J7Q45/BWZ/Z9BbZ+OXyfQBZQABzeP4/E4NqI9Ii36S8Ng/wAx9C4jTxOH6ivr
jn+Hz3B/mQi/GvjdCnWNlsdI2V07LIlg6USrt2ZzZXMoFV+zPhGLxeOaavpbm/RVltEN72Yx+Jxm
b7dKUmf7L5+s9/HtRA2cqRACRACRACRACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCQQCRACRACRCQBCQBCQB
ACRACRACRACRACL1i9LVntMbPATTwdRkxT3pea/u+gPE8Xx+DxrPHlaYt+qNfGvjvtXXsi0dOrKk
dEXjZg6VMtbP2bMtXUdpEV0/Y2nNxbNf8OP+727xvsXH+N1U/wBEfy9k3nxyb+gCVQAGOWvNivX1
rMPnGGOXNNfOJ2fSZ6w+dZKeHxDPX8N7R+6L8a+L63KdoZ7q6zvEMpnowdKJ6ywmWUyqvIKM0vQ+
x+D6rU55+9aKx+TzWa36vbezmDwODYenW+95/Nphj5L6dQBo5wAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAEiAAAEoA
AAAAAAAAAAAAAEAkEAkRuAkQbgkQAkQAkQAkQAl5T2nx8nEMOT8dNv0l6pwfarHvpcGWPu32/WCr
YvK4mOem6b9mGKd4Z3idmFdka0y1c892zfpMtLPaNpEV6D2Kj/Eauf6YeweQ9ieuTVz8K/3evbT4
5NfQBKoAA8FxCvJxrUx/XMvevD8Zry8fz/Haf2RfjTx/6RSOnRMyypHu9kXjowrqVSrvPRnZVl6V
kK0775MsUjvadn0nT4ow6bFijtSsVfPuFYvpPGtNTy54mfy6vorXDm8l9pEC7JIgBIgBIgBIgBIg
BIgBIhIAgBIhIAgBIgBIIBIAAhIAhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA
AAAAAAAAABAJQkAEAAAAAAAAAAjc3BIjdG4Mkbo5kcwMjdhzHMDPc3V8xzAs3N1fMjmBZubq+Y5g
Wbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmTzAz3N2HMnmBlu5ftFTx
OEZJ/DMW/d0t2rxKni8N1FPWkiZ9eS08e7Cy8dGGn6UhZaJljXZGnmc3UT3dPP2cnUT78xCIV6j2
H/8A9c/6f7vXPI+w8bU1U+vL/d63du5NfUiDcVSIAS8b7RV5eOb/AIqRL2TyXtNX/e2KfXH/AHlF
+NPH/pr4+2xcxx0hFpY11K7R16KM32ZWz3UaidqSgrc9kcPicWyZJjfw6T+727y3sXh2xarN+K0V
h6lvPjj3e0ASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAAAkQAkQAkAAAAAAAAAAAAAAA
EgAAAAAAAAAAAAAAAAAAAAAgAAABKDcAN0bgkY8xzAyRux5kcwM9zdXNkTcFm6OZXzMeYFvMibKu
ZHMC2bo51U2RuC2bom6rc3BZzom6sBZzI52ADPnOdggFnMc6skFnMc6rc3BbznOp3RzAv50c6nml
HMC/nOf4qOY5wX85zqOc5wbHOc7X5znBsc6edr85zg2ec52vzpi4NjmY5bROG+/bllVzsNTk5dLl
n0pP8BHmMHWNmzt0aum8obm08vVjfrtnxztR0mXHzTvaZdjVRMTLkZo6yiFen9iZ2pqY/wBP93rN
3kPY+/LfPX1rE/u9XzN3HfqzdO6vmTuIZ7m7Hc3Bnu8t7TR/vHBP9E/y9Pu837SV31umn+if5Rfi
/j/01MMb1hjkrtKzBG0bMsmOZY11tOYamr6Und0LUc7XT7u3rJPqL8er9lcPhcFpbzyWm39v7O00
+FYvA4Zpsc94xxu227jv1IAgAAAAAAAAABKAAAASgASgBIgBIgBIgBIhIAAAAAAAAAAAAAAAAAAC
UACUJAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAg3AEbomQZbo3YzLGbAz3RNlc3YzcFs2YzdVN2
M2Bdzom6nmNwW86JurTAMuY3REJ2BB1ZRVMVBhsbSsiqeUFXLucq3lTygp5TlXcpygp5TlXcpygp
5TlXcqOUFXKjlXcrGYBXysdlswiYBVMdUTCyY6sZBWxlnMMZgGLGZZSwkDdHMiWO4MuY5mEyjcFn
N1OdVzHMC3nTzqeY5gX85zqOZPMC+Lqdbk20eb/RKOZr8QybaK/XvtH7iZ9aGlp2luzT3fg19NHS
OjbmPcYX67XH1XSZ9XIzRvMuzrK7zLkZYmYnciunb9lZ5dTk+OP+71cXeP8AZnJ/ip2nf3J/l6iL
/Fu5L9bMWZczXi6YuIbEWTzKIuyiwLt3nuO25uI4a/hx7/rLuczg8TicvFLbfdpEK6+NPH/phhjo
stLGkctUWnoxrrU3j1cnWTzZq1jzl1clo5Zcu8c+txR63iP3Tn6pv4+g4o5cVI9IiGe7CJ2iE7t3
GyN2O6dwSINwSISAlAAlACRAAlAAlACRACRCQAAAAAAAAAASgASISAAAAAAAAAAAAACQAAAAAAAA
AAAAAASAAAAAAAAAAAAAAAAIAAAQCAJljuljsCJlhMs9mOwMJYys5TkBVsjZdyHICrZPKt5E8oK4
qmKrOVOwMIqyirPY2Bjyp2ZbAI2NmSARsbMgEbI2ZAMdjZICNkbMkSCNmOzJEgx2YyzljMAwlhKy
WEwCuWErJhhMArlhLOWEgxljMpljIImWMyTKJA3N0IBO5vux3NwZbnMx3NwZczT4jf3MdPW27a3a
fJOq1XNP2KdIRfi+J2trSYfcjeF+Wm1OicVeWIiN9kai8xjY12ORqultnI1Ecsujq79XP1FovWYI
rTgeq+j8QrWZ+3Mx+r2UXeC0WG2Ti2kiN5mL807eUREvbzbaejefHJv62Iv8WUXa0WTFhVtRdlF2
rz9WUXBtc7jR9dqc2T1ttHyhvZMvJitb0jdq6XHNcNenWVN3028U99WRj6Kb02be3Tq18/SN2Lpc
3UdN9nOmZrqKX/DaJ/d0svvTLRzV3jomK6+Pd1vvWJj0ZczT0mXxNJht60hfFnQ4qu3N1cWTEgs3
Tur5k7gz3N2O5uDM3Y7m4MtxBuCQASIASIASAAAAAAACRCQAAAAAAAAEoSAAAAAAAAAAAlAAlCQA
AAAAAAAAAAASAAAAAAAAAAAAIASgAAAEJAQJQCNkbMgGOyOVnsAw5TlZ7GwMOVPKy2NgY7GzIBGx
skA2AAAAAAAAAAQkBAEghEskAxYzDPZGwK5hjMLJhjMAqmGEwumrCagomFcw2JqqtUFEsLLrV82F
o7gqljKyYYTGwMZRKUSCAQAboJnaN5Bjkneu0d5W4ccViIiOzHFWbTzNumP1Zarr8eeRMbxDW1Mx
NO67NbkhzNVnmInqzaOZrL93JyZeV0M1++7S02jvxDWxhxx033tPpC8Z6rrezWjmZyazJG2/u03h
2vFibTHoqvamiwVwY+nLGzV0+SZ1Mx8G0/45tOhzJ5lXMc3UVXRdlF1HP+iYsDPLPPy49/tz1+Te
pSIr0ho6ak5Ms5J8o2q6NImOrHV7XX488ypzTtHXo0s9t6zG7c1G1qz6ubeZiZ3UatXJG3yauSO7
cvMTEx5tPLb3prPRMVr0HB8vicNxf0+7+kt+LOJwTJyY/Bnz3tH93X36N58cWvq6LSyiyndMSlC7
mZcymLJiwLosmJVRLKLAtiU7q4lMSCzc3YxJuDMRuAlKAEgAAAlAkAAAAAABKAEgAAAAAJAAAAAA
AAAAAAAEgAAAAAAAAAAAAAkAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAhIAAACAAAASgAAAAAAEAAAA
hGzJAImGMwzQDDZjNVuyNgUTVhNGxysZqDVmiu1G5NN2M4waM0+DCaN2cbGcQNGaMZq3JxMJxA1J
qx2bU4kU09slorWNwa20z02RXHbJbl26QvtFovbHWkxEdJt5y2MOHlr2U1W3jx+1hiw8vSO63lmI
XRTaEWmtY6snRHO1VpmJ+DjavpSZl2s8b7y4HFcnh0n0gha5ebJN55KRM2mdoiPN6fh+kpwXh0Wy
RHj5Otp/s5Ps1p62y31+em9aTMYt/OfVfxTiPjZ52naI7fBrI5t66xz5+a1rW7yx0eSL6iZjtEOX
qNbSletom3lENjh2fbHzbbWt3iVozruc+5ztWubf4M4ybpQ2Oboyrva0Vjza8WdDR4OkXt3n9ldX
kaePP9VtYqctYhdvt5oivTeCZ2YOxXk6ubqMfV0b9mrljfqlFcq88k7z2U5axeItDa1OPessuC8P
ya7XRWYnwqdbT/ZMilvIu4dpslNdixXja8Y5tt85djZdbDWnGOesRtXFtuw6T27No5Kx2OrKYQlC
ExKJgBnEpiyvdlEgsizKLKollFgWxLKJVRLKJBbEp3VxLKJBnuMWQJEbpBIAAAJAAAABIAAAAAAA
lAJAAAAAAAAAAAAAASAAAAAAAAAAAAAJAAAABAJABAlAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAA
AAABAJQAAAAgAABAAI2EoBGyJhkgGPKxmqxAKpownHC+YRMdN5BrTj67R3bOn01o7p01Iv71u89o
b9a7LfBTfS1vWI2jf12VfQPSW8KX2mas+NC2iv6xMNfJpMnLtEbuuxtMRCtzF55NR5rPps1N/ctP
y6uHreE6nXZ4pak48X3rT06fB7fNeI33cbX6mI32R/MWu7XF116aDSRhxbRERs8f499bkyZeeKae
kzE2mdon81/tfxDLGOunwbzlzbx08oaHBvZHJlx48mrvaa94pu04y617576rNGLRRM0397JEd/lu
9Dw/S3x4qxffo6mm4NjwUiKY4iI9Ib1dHFY6QIaNabbrYrLfrpJtaK1rMzPZb/s+05IpP59OyLeJ
k7eNfRaOc1ue32I7fGXYpi5Y77M8OGMeOKxHSFsU3Y29deZMzirl6dlVvhLatCjJHeYQv1rXnps1
8k9/VsW6qLVmZIi1rzitlvFKRvaZ2h6TSaenC9FFY+3brM+sqeG8Prp4+kZ+lvuxPkr1mqm95nfp
DXM459676a2q1dsV7XietvNno78+CJn1cjX6mOeIm0bR33dfRU5NJjidt9t5afjG/V6JZ7I2QMNh
nyo2BhsMuVG3wAhMSbbQRAMolnE+iuGUSCyJZRKuGUSCyJZK4llEgyZMYTuCUsYSCQASISAAAlCQ
AAAAAAEoASCASAAAAAAAAAAAAlACRACQAAAAAAAAAEgCEoASCAAAAAAAAAAAAAAAAAAAAAAABAAA
AAAAAAAISAIAAAAAAQAAACASgAAAQJAQAAhIDHZhln3do7z0WS18mWsajHjmes7pg3dNi5aRMNqO
yvDHTpPRaigHZhN4hHRlaVN59JY3zRENLUavaO+yq0iNVlitJ6vNcR1MVi0zO0era1/Ea0rPvbz5
PM5MWp45qvo2GZrhmfrsnpHpHzTCseEcM/2vrr8Q1Eb4qzy44nziPN63HpYiIiI7LNHoqabBTFii
IpSNohuVxrKtWMEejPwY9G1FFmHB4mWJn7MdfnIM9JpIx15to5pbUaas/a6rqViI7MxPxqX0UT1r
O3wVzpbR2hviP5i03Y5s6a879FNtHljydhExCv8AMTPJXBnRZbz0iG5ptFjwe/l96zctMVamTJtE
yTMibu1VrdTzRMR0j0ed4lr64MVpm0RERvMz5NvX62uOJ69XhOKX1HH9bHDtFvNYnfJeOy0Z2ojX
6jjnEq6fRUmccTvN/J9H0eKcOnx45neaxEbubwHgOHg+milI3vP2resu3Wu0JQmITsmISDHZHKz2
JgFc1RMLJhGwK9iIZ7MZgEdgmAEwyiWCdwWRLKJVxKYsC2JTuriWUSDNlEsIlMAySx3SCRCQSIAS
AAACRACQAAAAAAASIASAAAAAAAAAAAAAAACRACRACQASIAAAAAAAAAAAAAAAAAAAAAAAAQCUAAAA
AAAAAAIAAAAAAAAQAAAAAACBICBICAAEJAQJQCJcLjuS2ny6fPG/LWdpd1o8T0X07SXx/e7wCdJx
Wa0jmneHQpxPDMdZmJfNtZm49weZrh0/j4o7VtSZ2+Uw0/8A7o49k92vBLc/ntFohFW9PqGXimOI
6Tu1L8T3eCx6r2t1O3JwvHjifO99v7t/Bwf2l1PXU6rS6eJ8qUm8x+so5TsekzcSjbvs4mt4rzW5
K2mbT0itesy2cHsvbvqtbmyz5xERWP2jd1tJwrTaONsOKtZ8585+cnDrzmn4Rq+IZObUROHD32n7
Vv8A0ej0uhxaXFGPFSK1j0bkY4jyZRVZVXFGUVWbGwKsk8mObekNrSW3pWf1a2aYjHbm7bNnQ1id
PW0TvuDdhJEbQABMsLW2R0ZTMQrvfbz2YWzVhpanUxEd0dWkW5c8R5uXxDX1w4pnfr5Q19XxKuOJ
2neXltVqtVxbV/RdJ715+1bypANfiOu1HENV9C0MTfNeesx2rD1PAeBYuE6aKx72W3W9/WVnBuB4
eF4dqRzZbdb5J72l160WVK02ZxCYhOwI23TsnY2BGxsnYBjsiYZsZBjMMZZSgGEolMsQDdG6NwZ7
piVe6YkFsSziVMWZRILolMSriWUSCyJTuwhMSDMRCQSI3SAlACRCQAAEoAEoASAAAAAAAAACUACR
ACQAAAAAAAAAAAAASAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAABAAAAAAAAAAAAACBKAAAAAAAQ
JQAAAhICEbJAYTWJ7wx8KvpC0BV4ceieWGewDHlNmWwCNjZICNhIDmcZredBecdpiY69FXCOLW+i
UiZidukulmxxlx2paN4mNng+K4+I8Hy2yaTfl37TXetoCPfRxfp1qi3F48ofKMvtvxak8s6LDv61
rZji9rPaLUf5PC+bfttS0q8q3p9W/wBrRMdpUZuKdN99nzvFqPbTVz7nD8OKs+do2/mW3h4D7Xaq
ZnPrtNpqz35aRaYOHY9Zk4pNt9rR+rl6zi+OnS+WN57Rv1lXp/YrNaYtruL6zNPnGO3hxP6O5w/2
f0HDuun09Yv55Le9afznqcOvO4tBreMTHu30unnva0bWt8on+70nDuE4OHYYx4Kbesz3tPrMuhGO
IjpDOKrK9YVpsyiGUQnYGOyUgI2SlAIEmwMWMs9kTAMJYzDOYRMArmGErZhhMArlHmzmGMwDE3Ts
bAbs4swj5pgFkSziVcM4BZEsolXDKAZwyhjCYBkACQhIAAAAAAAJAAAAAAAAAAAAAAAAAAAShIAA
AAAAAAJAAAAAAAAAAAAAABAJEAAAAAAAAAAAAAAAIEoBKAAAAAAAAAAAAAAABAlAAAAAAAIAAAAA
BAkBAkBAkBAlACEgMZjdjbFW8bWrEx8YWANb6Fp+bfwab+vLDKMFK9qxH5L0bAr8OPRPKz2AY7J2
SbAjYZAI2E7AIEgIEgIEgMdkSy2NgY7MdlmyNoBXsxmFuyNgVTVjNV3KjlBRNTlXTVHKCrlIqt5T
lBhEMohlFerLlBjEMohMVTEARDKCITsAk2AEgAAAkAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAD/
2Q==`;async function aQe(e){let t=(s,o="application/octet-stream")=>fetch(`data:${o};base64,${s}`).then(a=>a.blob()),n,r;switch(e.config.warmup){case"face":n=await t(KS);break;case"body":case"full":n=await t(XS);break;default:n=null}if(n){let s=await createImageBitmap(n);r=await e.detect(s,e.config),s.close()}return r}async function iQe(e){return new Promise(t=>{let n;switch(e.config.warmup){case"face":n="data:image/jpeg;base64,"+KS;break;case"full":case"body":n="data:image/jpeg;base64,"+XS;break;default:n=null}let r;typeof Image!="undefined"?r=new Image:Ee.Image&&(r=new Ee.Image),r.onload=async()=>{let s=Zo(r.naturalWidth,r.naturalHeight);if(!s)Ce("Warmup: Canvas not found"),t({});else{let o=s.getContext("2d");o&&o.drawImage(r,0,0);let a=await e.image(s),i=await e.detect(a.tensor,e.config);t(i)}},n?r.src=n:t(null)})}async function lQe(e){let t=s=>Buffer.from(s,"base64"),n;if(e.config.warmup==="face"&&(n=t(KS)),(e.config.warmup==="body"||e.config.warmup==="full")&&(n=t(XS)),!n)return null;let r;if(typeof void 0!="undefined"){let s=(void 0).decodeJpeg(n),o=s.expandDims(0);e.tf.dispose(s),r=await e.detect(o,e.config),e.tf.dispose(o)}else e.config.debug&&Ce("Warmup tfjs-node not loaded");return r}async function pie(e,t){let n=en();if(e.state="warmup",t&&(e.config=os(e.config,t)),!e.config.warmup||e.config.warmup==="none")return{error:"null"};let r;return new Promise(async s=>{typeof createImageBitmap=="function"?r=await aQe(e):typeof Image!="undefined"||Ee.Canvas!==void 0?r=await iQe(e):r=await lQe(e);let o=en();e.config.debug&&Ce("Warmup",e.config.warmup,Math.round(o-n),"ms"),e.emit("warmup"),s(r)})}var m1,Iv,Cv,ZS,fie=class{constructor(t){nt(this,"version");nt(this,"config");nt(this,"result");nt(this,"state");nt(this,"process");nt(this,"tf");nt(this,"env");nt(this,"draw");nt(this,"models");nt(this,"events");nt(this,"faceTriangulation");nt(this,"faceUVMap");nt(this,"performance");E1(this,m1,void 0);E1(this,Iv,void 0);E1(this,Cv,void 0);nt(this,"gl");nt(this,"analyze",(...t)=>{if(!_1(this,Iv))return;let n=this.tf.engine().state.numTensors,r=_1(this,m1);R1(this,m1,n);let s=n-r;s!==0&&Ce(...t,s)});E1(this,ZS,t=>{if(!_1(this,Cv))return null;if(!t)return"input is not defined";if(this.env.node&&!(t instanceof Vt))return"input must be a tensor";try{this.tf.getBackend()}catch(n){return"backend not loaded"}return null});nt(this,"similarity",lie);nt(this,"distance",qS);nt(this,"match",uie);nt(this,"emit",t=>{var n;this.events&&this.events.dispatchEvent&&((n=this.events)==null||n.dispatchEvent(new Event(t)))});K5(),this.env=Ee,Ec.wasmPath=`https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${qw}/dist/`,Ec.modelBasePath=this.env.browser?"../models/":"file://models/",Ec.backend=this.env.browser?"humangl":"tensorflow",this.version=qR,Object.defineProperty(this,"version",{value:qR}),this.config=JSON.parse(JSON.stringify(Ec)),Object.seal(this.config),t&&(this.config=os(this.config,t)),this.tf=bh,this.state="idle",R1(this,m1,0),R1(this,Iv,!1),R1(this,Cv,!1),this.performance={backend:0,load:0,image:0,frames:0,cached:0,changed:0,total:0,draw:0},this.events=typeof EventTarget!="undefined"?new EventTarget:void 0,this.models=new wv,this.draw={options:wc,canvas:(n,r)=>eie(n,r),face:(n,r,s)=>GO(n,r,s),body:(n,r,s)=>UO(n,r,s),hand:(n,r,s)=>jO(n,r,s),gesture:(n,r,s)=>WO(n,r,s),object:(n,r,s)=>HO(n,r,s),person:(n,r,s)=>Qae(n,r,s),all:(n,r,s)=>tie(n,r,s)},this.result={face:[],body:[],hand:[],gesture:[],object:[],performance:{},timestamp:0,persons:[]},this.process={tensor:null,canvas:null},this.faceTriangulation=GU,this.faceUVMap=UU,this.gl=fr,this.emit("create")}reset(){let t=this.config.backend;this.config=JSON.parse(JSON.stringify(Ec)),this.config.backend=t}validate(t){return kT(Ec,t||this.config)}image(t){return rx(t,this.config)}async segmentation(t,n){return qae(t,n,this.config)}enhance(t){return a7(t)}async init(){await jS(this,!0),await this.tf.ready(),vU(this.env)}async load(t){this.state="load";let n=en(),r=Object.values(this.models).filter(a=>a).length;t&&(this.config=os(this.config,t)),Ee.initial&&(this.config.debug&&Ce(`version: ${this.version}`),this.config.debug&&Ce(`tfjs version: ${this.tf.version_core}`),await jS(this)||Ce("error: backend check failed"),await Xw(),this.env.browser&&(this.config.debug&&Ce("configuration:",this.config),this.config.debug&&Ce("tf flags:",this.tf.ENV.flags))),await Xae(this),Ee.initial&&this.config.debug&&Ce("tf engine state:",this.tf.engine().state.numBytes,"bytes",this.tf.engine().state.numTensors,"tensors"),Ee.initial=!1,Object.values(this.models).filter(a=>a).length!==r&&(await Zae(this),this.emit("load"));let o=Math.trunc(en()-n);o>(this.performance.load||0)&&(this.performance.load=o)}next(t=this.result){return iie(t)}async warmup(t){return pie(this,t)}async detect(t,n){return this.state="detect",new Promise(async r=>{var x,y,b,A,v,w,k,I,N,T,_,R,S,F,B,W,q,K,J,Q,ee,ue;this.state="config";let s,o;this.config=os(this.config,n),this.state="check";let a=_1(this,ZS).call(this,t);a&&(Ce(a,t),r({error:a}));let i=en();await jS(this),await this.load(),s=en(),this.state="image";let l=rx(t,this.config);if(this.process=l,this.performance.image=Math.trunc(en()-s),this.analyze("Get Image:"),!l.tensor){this.config.debug&&Ce("could not convert input to tensor"),r({error:"could not convert input to tensor"});return}this.emit("image"),s=en(),this.config.skipFrame=await kU(this.config,l.tensor),this.performance.frames||(this.performance.frames=0),this.performance.cached||(this.performance.cached=0),this.performance.frames++,this.config.skipFrame&&this.performance.cached++,this.performance.changed=Math.trunc(en()-s),this.analyze("Check Changed:");let u=[],c=[],p=[],d=[];this.state="detect:face",this.config.async?(u=this.config.face.enabled?qO(this,l.tensor):[],this.performance.face&&delete this.performance.face):(s=en(),u=this.config.face.enabled?await qO(this,l.tensor):[],o=Math.trunc(en()-s),o>0&&(this.performance.face=o)),this.config.async&&(this.config.body.maxDetected===-1||this.config.hand.maxDetected===-1)&&(u=await u),this.analyze("Start Body:"),this.state="detect:body";let f=this.config.body.maxDetected===-1?os(this.config,{body:{maxDetected:this.config.face.enabled?1*u.length:1}}):this.config;this.config.async?(((x=this.config.body.modelPath)==null?void 0:x.includes("posenet"))?c=this.config.body.enabled?g7(l.tensor,f):[]:((y=this.config.body.modelPath)==null?void 0:y.includes("blazepose"))?c=this.config.body.enabled?IO(l.tensor,f):[]:((b=this.config.body.modelPath)==null?void 0:b.includes("efficientpose"))?c=this.config.body.enabled?_O(l.tensor,f):[]:((A=this.config.body.modelPath)==null?void 0:A.includes("movenet"))&&(c=this.config.body.enabled?$O(l.tensor,f):[]),this.performance.body&&delete this.performance.body):(s=en(),((v=this.config.body.modelPath)==null?void 0:v.includes("posenet"))?c=this.config.body.enabled?await g7(l.tensor,f):[]:((w=this.config.body.modelPath)==null?void 0:w.includes("blazepose"))?c=this.config.body.enabled?await IO(l.tensor,f):[]:((k=this.config.body.modelPath)==null?void 0:k.includes("efficientpose"))?c=this.config.body.enabled?await _O(l.tensor,f):[]:((I=this.config.body.modelPath)==null?void 0:I.includes("movenet"))&&(c=this.config.body.enabled?await $O(l.tensor,f):[]),o=Math.trunc(en()-s),o>0&&(this.performance.body=o)),this.analyze("End Body:"),this.analyze("Start Hand:"),this.state="detect:hand";let h=this.config.hand.maxDetected===-1?os(this.config,{hand:{maxDetected:this.config.face.enabled?2*u.length:1}}):this.config;this.config.async?(((T=(N=this.config.hand.detector)==null?void 0:N.modelPath)==null?void 0:T.includes("handdetect"))?p=this.config.hand.enabled?v7(l.tensor,h):[]:((R=(_=this.config.hand.detector)==null?void 0:_.modelPath)==null?void 0:R.includes("handtrack"))&&(p=this.config.hand.enabled?C7(l.tensor,h):[]),this.performance.hand&&delete this.performance.hand):(s=en(),((F=(S=this.config.hand.detector)==null?void 0:S.modelPath)==null?void 0:F.includes("handdetect"))?p=this.config.hand.enabled?await v7(l.tensor,h):[]:((W=(B=this.config.hand.detector)==null?void 0:B.modelPath)==null?void 0:W.includes("handtrack"))&&(p=this.config.hand.enabled?await C7(l.tensor,h):[]),o=Math.trunc(en()-s),o>0&&(this.performance.hand=o)),this.analyze("End Hand:"),this.analyze("Start Object:"),this.state="detect:object",this.config.async?(((q=this.config.object.modelPath)==null?void 0:q.includes("nanodet"))?d=this.config.object.enabled?OO(l.tensor,this.config):[]:((K=this.config.object.modelPath)==null?void 0:K.includes("centernet"))&&(d=this.config.object.enabled?MO(l.tensor,this.config):[]),this.performance.object&&delete this.performance.object):(s=en(),((J=this.config.object.modelPath)==null?void 0:J.includes("nanodet"))?d=this.config.object.enabled?await OO(l.tensor,this.config):[]:((Q=this.config.object.modelPath)==null?void 0:Q.includes("centernet"))&&(d=this.config.object.enabled?await MO(l.tensor,this.config):[]),o=Math.trunc(en()-s),o>0&&(this.performance.object=o)),this.analyze("End Object:"),this.state="detect:await",this.config.async&&([u,c,p,d]=await Promise.all([u,c,p,d])),this.state="detect:gesture";let m=[];this.config.gesture.enabled&&(s=en(),m=[...sie(u),...rie(c),...aie(p),...oie(u)],this.config.async?this.performance.gesture&&delete this.performance.gesture:this.performance.gesture=Math.trunc(en()-s)),this.performance.total=Math.trunc(en()-i);let g=((ue=(ee=this.process)==null?void 0:ee.tensor)==null?void 0:ue.shape)||[];this.result={face:u,body:c,hand:p,gesture:m,object:d,performance:this.performance,canvas:this.process.canvas,timestamp:Date.now(),get persons(){return cie(u,c,p,m,g)}},ye(l.tensor),this.emit("detect"),this.state="idle",r(this.result)})}};m1=new WeakMap,Iv=new WeakMap,Cv=new WeakMap,ZS=new WeakMap;return uQe;})();
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
