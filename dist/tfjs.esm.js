
  /*
  Human library
  homepage: <https://github.com/vladmandic/human>
  author: <https://github.com/vladmandic>'
  */

var cG=Object.create,Xh=Object.defineProperty,pG=Object.getPrototypeOf,mG=Object.prototype.hasOwnProperty,fG=Object.getOwnPropertyNames,dG=Object.getOwnPropertyDescriptor;var hG=r=>Xh(r,"__esModule",{value:!0});var Ht=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),We=(r,e)=>{for(var t in e)Xh(r,t,{get:e[t],enumerable:!0})},gG=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of fG(e))!mG.call(r,n)&&n!=="default"&&Xh(r,n,{get:()=>e[n],enumerable:!(t=dG(e,n))||t.enumerable});return r},pc=r=>gG(hG(Xh(r!=null?cG(pG(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var oT=Ht(()=>{});var zT=Ht((LT,c_)=>{(function(r,e,t){function n(i){var l=this,u=a();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(i),l.s0<0&&(l.s0+=1),l.s1-=u(i),l.s1<0&&(l.s1+=1),l.s2-=u(i),l.s2<0&&(l.s2+=1),u=null}function o(i,l){return l.c=i.c,l.s0=i.s0,l.s1=i.s1,l.s2=i.s2,l}function s(i,l){var u=new n(i),c=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,u),p.state=function(){return o(u,{})}),p}function a(){var i=4022871197,l=function(u){u=u.toString();for(var c=0;c<u.length;c++){i+=u.charCodeAt(c);var p=.02519603282416938*i;i=p>>>0,p-=i,p*=i,i=p>>>0,p-=i,i+=p*4294967296}return(i>>>0)*23283064365386963e-26};return l}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(LT,typeof c_=="object"&&c_,typeof define=="function"&&define)});var VT=Ht((BT,p_)=>{(function(r,e,t){function n(a){var i=this,l="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var c=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^c^c>>>8},a===(a|0)?i.x=a:l+=a;for(var u=0;u<l.length+64;u++)i.x^=l.charCodeAt(u)|0,i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function s(a,i){var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(BT,typeof p_=="object"&&p_,typeof define=="function"&&define)});var WT=Ht((GT,m_)=>{(function(r,e,t){function n(a){var i=this,l="";i.next=function(){var c=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(c^c<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:l+=a;for(var u=0;u<l.length+64;u++)i.x^=l.charCodeAt(u)|0,u==l.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function s(a,i){var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(GT,typeof m_=="object"&&m_,typeof define=="function"&&define)});var UT=Ht((jT,f_)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var u=i.x,c=i.i,p,m,f;return p=u[c],p^=p>>>7,m=p^p<<24,p=u[c+1&7],m^=p^p>>>10,p=u[c+3&7],m^=p^p>>>3,p=u[c+4&7],m^=p^p<<7,p=u[c+7&7],p=p^p<<13,m^=p^p<<9,u[c]=m,i.i=c+1&7,m};function l(u,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],u.x=f,u.i=0,p=256;p>0;--p)u.next()}l(i,a)}function o(a,i){return i.x=a.x.slice(),i.i=a.i,i}function s(a,i){a==null&&(a=+new Date);var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.x&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(jT,typeof f_=="object"&&f_,typeof define=="function"&&define)});var qT=Ht((HT,d_)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var u=i.w,c=i.X,p=i.i,m,f;return i.w=u=u+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,i.i=p,f+(u^u>>>16)|0};function l(u,c){var p,m,f,d,h,g=[],x=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,x=Math.max(x,c.length)),f=0,d=-32;d<x;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;u.w=h,u.X=g,u.i=f}l(i,a)}function o(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function s(a,i){a==null&&(a=+new Date);var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.X&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(HT,typeof d_=="object"&&d_,typeof define=="function"&&define)});var XT=Ht((KT,h_)=>{(function(r,e,t){function n(a){var i=this,l="";i.next=function(){var c=i.b,p=i.c,m=i.d,f=i.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,i.b=c=c<<20^c>>>12^p,i.c=p=p-m|0,i.d=m<<16^p>>>16^f,i.a=f-c|0},i.a=0,i.b=0,i.c=2654435769|0,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):l+=a;for(var u=0;u<l.length+20;u++)i.b^=l.charCodeAt(u)|0,i.next()}function o(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function s(a,i){var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(KT,typeof h_=="object"&&h_,typeof define=="function"&&define)});var g_=Ht(()=>{});var YT=Ht((i_e,xg)=>{(function(r,e){var t=this,n=256,o=6,s=52,a="random",i=e.pow(n,o),l=e.pow(2,s),u=l*2,c=n-1,p;function m(w,_,I){var E=[];_=_==!0?{entropy:!0}:_||{};var $=g(h(_.entropy?[w,b(r)]:w==null?x():w,3),E),D=new f(E),O=function(){for(var M=D.g(o),G=i,j=0;M<l;)M=(M+j)*n,G*=n,j=D.g(1);for(;M>=u;)M/=2,G/=2,j>>>=1;return(M+j)/G};return O.int32=function(){return D.g(4)|0},O.quick=function(){return D.g(4)/4294967296},O.double=O,g(b(D.S),r),(_.pass||I||function(M,G,j,U){return U&&(U.S&&d(U,D),M.state=function(){return d(D,{})}),j?(e[a]=M,G):M})(O,$,"global"in _?_.global:this==e,_.state)}e["seed"+a]=m;function f(w){var _,I=w.length,E=this,$=0,D=E.i=E.j=0,O=E.S=[];for(I||(w=[I++]);$<n;)O[$]=$++;for($=0;$<n;$++)O[$]=O[D=c&D+w[$%I]+(_=O[$])],O[D]=_;(E.g=function(M){for(var G,j=0,U=E.i,H=E.j,q=E.S;M--;)G=q[U=c&U+1],j=j*n+q[c&(q[U]=q[H=c&H+G])+(q[H]=G)];return E.i=U,E.j=H,j})(n)}function d(w,_){return _.i=w.i,_.j=w.j,_.S=w.S.slice(),_}function h(w,_){var I=[],E=typeof w,$;if(_&&E=="object")for($ in w)try{I.push(h(w[$],_-1))}catch(D){}return I.length?I:E=="string"?w:w+"\0"}function g(w,_){for(var I=w+"",E,$=0;$<I.length;)_[c&$]=c&(E^=_[c&$]*19)+I.charCodeAt($++);return b(_)}function x(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(t.crypto||t.msCrypto).getRandomValues(w)),b(w)}catch(E){var _=t.navigator,I=_&&_.plugins;return[+new Date,t,I,t.screen,b(r)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(e.random(),r),typeof xg=="object"&&xg.exports){xg.exports=m;try{p=g_()}catch(w){}}else typeof define=="function"&&define.amd&&define(function(){return m})})([],Math)});var x_=Ht((a_e,ZT)=>{var OU=zT(),PU=VT(),MU=WT(),LU=UT(),zU=qT(),BU=XT(),mu=YT();mu.alea=OU;mu.xor128=PU;mu.xorwow=MU;mu.xorshift7=LU;mu.xor4096=zU;mu.tychei=BU;ZT.exports=mu});var Rp=Ht(()=>{});var RM=Ht(()=>{});var FM=Ht(()=>{});var OM=Ht((Ix,DC)=>{var $C=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};function t(){return Q.buffer!=He&&sr(Q.buffer),ct}function n(){return Q.buffer!=He&&sr(Q.buffer),mt}function o(){return Q.buffer!=He&&sr(Q.buffer),Yt}function s(){return Q.buffer!=He&&sr(Q.buffer),cn}function a(){return Q.buffer!=He&&sr(Q.buffer),Un}var i=typeof e!="undefined"?e:{},l,u;i.ready=new Promise(function(N,R){l=N,u=R});var c={},p;for(p in i)i.hasOwnProperty(p)&&(c[p]=i[p]);var m=[],f="./this.program",d=function(N,R){throw R},h=!1,g=!1,x=!1,b=!1;h=typeof window=="object",g=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",b=!h&&!x&&!g;var w=i.ENVIRONMENT_IS_PTHREAD||!1;w&&(He=i.buffer);var _="";function I(N){return i.locateFile?i.locateFile(N,_):_+N}var E,$,D,O,M,G;if(x){g?_=Rp().dirname(_)+"/":_=__dirname+"/",E=function(R,B){return M||(M=require("fs")),G||(G=Rp()),R=G.normalize(R),M.readFileSync(R,B?null:"utf8")},D=function(R){var B=E(R,!0);return B.buffer||(B=new Uint8Array(B)),fe(B.buffer),B},process.argv.length>1&&(f=process.argv[1].replace(/\\/g,"/")),m=process.argv.slice(2),process.on("uncaughtException",function(N){if(!(N instanceof ym))throw N}),process.on("unhandledRejection",yi),d=function(N){process.exit(N)},i.inspect=function(){return"[Emscripten Module object]"};var j;try{j=RM()}catch(N){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),N}global.Worker=j.Worker}else b?(typeof read!="undefined"&&(E=function(R){return read(R)}),D=function(R){var B;return typeof readbuffer=="function"?new Uint8Array(readbuffer(R)):(B=read(R,"binary"),fe(typeof B=="object"),B)},typeof scriptArgs!="undefined"?m=scriptArgs:typeof arguments!="undefined"&&(m=arguments),typeof quit=="function"&&(d=function(N){quit(N)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(h||g)&&(g?_=self.location.href:typeof document!="undefined"&&document.currentScript&&(_=document.currentScript.src),typeof r!="undefined"&&r&&(_=r),_.indexOf("blob:")!==0?_=_.substr(0,_.lastIndexOf("/")+1):_="",x?(E=function(R,B){return M||(M=require("fs")),G||(G=Rp()),R=G.normalize(R),M.readFileSync(R,B?null:"utf8")},D=function(R){var B=E(R,!0);return B.buffer||(B=new Uint8Array(B)),fe(B.buffer),B}):(E=function(N){var R=new XMLHttpRequest;return R.open("GET",N,!1),R.send(null),R.responseText},g&&(D=function(N){var R=new XMLHttpRequest;return R.open("GET",N,!1),R.responseType="arraybuffer",R.send(null),new Uint8Array(R.response)}),$=function(N,R,B){var K=new XMLHttpRequest;K.open("GET",N,!0),K.responseType="arraybuffer",K.onload=function(){if(K.status==200||K.status==0&&K.response){R(K.response);return}B()},K.onerror=B,K.send(null)}),O=function(N){document.title=N});x&&typeof performance=="undefined"&&(global.performance=FM().performance);var U=i.print||console.log.bind(console),H=i.printErr||console.warn.bind(console);for(p in c)c.hasOwnProperty(p)&&(i[p]=c[p]);c=null,i.arguments&&(m=i.arguments),i.thisProgram&&(f=i.thisProgram),i.quit&&(d=i.quit);var q=Atomics.load,X=Atomics.store,ne=Atomics.compareExchange,Y;i.wasmBinary&&(Y=i.wasmBinary);var re=i.noExitRuntime||!0;typeof WebAssembly!="object"&&yi("no native wasm support detected");var Q,ie,ce=!1,ae;function fe(N,R){N||yi("Assertion failed: "+R)}function de(N){var R=i["_"+N];return fe(R,"Cannot call unknown function "+N+", make sure it is exported"),R}function xe(N,R,B,K,be){var he={string:function(Hr){var cc=0;if(Hr!=null&&Hr!==0){var VI=(Hr.length<<2)+1;cc=ac(VI),Ke(Hr,cc,VI)}return cc},array:function(Hr){var cc=ac(Hr.length);return St(Hr,cc),cc}};function ye(Hr){return R==="string"?ve(Hr):R==="boolean"?Boolean(Hr):Hr}var Te=de(N),_t=[],kr=0;if(K)for(var gr=0;gr<K.length;gr++){var Ha=he[B[gr]];Ha?(kr===0&&(kr=xm()),_t[gr]=Ha(K[gr])):_t[gr]=K[gr]}var uc=Te.apply(null,_t);return uc=ye(uc),kr!==0&&ic(kr),uc}function we(N,R,B,K){B=B||[];var be=B.every(function(ye){return ye==="number"}),he=R!=="string";return he&&be&&!K?de(N):function(){return xe(N,R,B,arguments,K)}}function De(N,R,B){for(var K=R+B,be="";!(R>=K);){var he=N[R++];if(!he)return be;if(!(he&128)){be+=String.fromCharCode(he);continue}var ye=N[R++]&63;if((he&224)==192){be+=String.fromCharCode((he&31)<<6|ye);continue}var Te=N[R++]&63;if((he&240)==224?he=(he&15)<<12|ye<<6|Te:he=(he&7)<<18|ye<<12|Te<<6|N[R++]&63,he<65536)be+=String.fromCharCode(he);else{var _t=he-65536;be+=String.fromCharCode(55296|_t>>10,56320|_t&1023)}}return be}function ve(N,R){return N?De(n(),N,R):""}function Ge(N,R,B,K){if(!(K>0))return 0;for(var be=B,he=B+K-1,ye=0;ye<N.length;++ye){var Te=N.charCodeAt(ye);if(Te>=55296&&Te<=57343){var _t=N.charCodeAt(++ye);Te=65536+((Te&1023)<<10)|_t&1023}if(Te<=127){if(B>=he)break;R[B++]=Te}else if(Te<=2047){if(B+1>=he)break;R[B++]=192|Te>>6,R[B++]=128|Te&63}else if(Te<=65535){if(B+2>=he)break;R[B++]=224|Te>>12,R[B++]=128|Te>>6&63,R[B++]=128|Te&63}else{if(B+3>=he)break;R[B++]=240|Te>>18,R[B++]=128|Te>>12&63,R[B++]=128|Te>>6&63,R[B++]=128|Te&63}}return R[B]=0,B-be}function Ke(N,R,B){return Ge(N,n(),R,B)}function at(N){for(var R=0,B=0;B<N.length;++B){var K=N.charCodeAt(B);K>=55296&&K<=57343&&(K=65536+((K&1023)<<10)|N.charCodeAt(++B)&1023),K<=127?++R:K<=2047?R+=2:K<=65535?R+=3:R+=4}return R}function St(N,R){t().set(N,R)}function Tt(N,R){return N%R>0&&(N+=R-N%R),N}var He,ct,mt,Lt,kn,Yt,cn,Pr,Un;function sr(N){He=N,i.HEAP8=ct=new Int8Array(N),i.HEAP16=Lt=new Int16Array(N),i.HEAP32=Yt=new Int32Array(N),i.HEAPU8=mt=new Uint8Array(N),i.HEAPU16=kn=new Uint16Array(N),i.HEAPU32=cn=new Uint32Array(N),i.HEAPF32=Pr=new Float32Array(N),i.HEAPF64=Un=new Float64Array(N)}var vn=i.INITIAL_MEMORY||16777216;if(w)Q=i.wasmMemory,He=i.buffer;else if(i.wasmMemory)Q=i.wasmMemory;else if(Q=new WebAssembly.Memory({initial:vn/65536,maximum:2147483648/65536,shared:!0}),!(Q.buffer instanceof SharedArrayBuffer))throw H("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Q&&(He=Q.buffer),vn=He.byteLength,sr(He);var Ur,_r=[],pn=[],Rn=[],Ml=[],Va=[],Os=!1,gi=!1;w||pn.push({func:function(){Gh()}});function lm(){if(!w){if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;)Ah(i.preRun.shift());rc(_r)}}function Ll(){Os=!0,!w&&rc(pn)}function Sy(){w||rc(Rn)}function Th(){w||(gi=!0)}function mn(){if(!w){if(i.postRun)for(typeof i.postRun=="function"&&(i.postRun=[i.postRun]);i.postRun.length;)Ty(i.postRun.shift());rc(Va)}}function Ah(N){_r.unshift(N)}function Ty(N){Va.unshift(N)}var xi=0,Ga=null,zl=null;function Ay(N){fe(!w,"addRunDependency cannot be used in a pthread worker"),xi++,i.monitorRunDependencies&&i.monitorRunDependencies(xi)}function Ey(N){if(xi--,i.monitorRunDependencies&&i.monitorRunDependencies(xi),xi==0&&(Ga!==null&&(clearInterval(Ga),Ga=null),zl)){var R=zl;zl=null,R()}}i.preloadedImages={},i.preloadedAudios={};function yi(N){i.onAbort&&i.onAbort(N),w&&console.error("Pthread aborting at "+new Error().stack),N+="",H(N),ce=!0,ae=1,N="abort("+N+"). Build with -s ASSERTIONS=1 for more info.";var R=new WebAssembly.RuntimeError(N);throw u(R),R}function Eh(N,R){return String.prototype.startsWith?N.startsWith(R):N.indexOf(R)===0}var tc="data:application/octet-stream;base64,";function Dh(N){return Eh(N,tc)}var Dy="file://";function $h(N){return Eh(N,Dy)}var fn="tfjs-backend-wasm-threaded-simd.wasm";Dh(fn)||(fn=I(fn));function Rh(N){try{if(N==fn&&Y)return new Uint8Array(Y);if(D)return D(N);throw"both async and sync fetching of the wasm failed"}catch(R){yi(R)}}function $y(){if(!Y&&(h||g)){if(typeof fetch=="function"&&!$h(fn))return fetch(fn,{credentials:"same-origin"}).then(function(N){if(!N.ok)throw"failed to load wasm binary file at '"+fn+"'";return N.arrayBuffer()}).catch(function(){return Rh(fn)});if($)return new Promise(function(N,R){$(fn,function(B){N(new Uint8Array(B))},R)})}return Promise.resolve().then(function(){return Rh(fn)})}function Ry(){var N={a:vb};function R(ye,Te){var _t=ye.exports;if(i.asm=_t,Ur=i.asm.F,ie=Te,!w){var kr=Ae.unusedWorkers.length;Ae.unusedWorkers.forEach(function(gr){Ae.loadWasmModuleToWorker(gr,function(){--kr||Ey("wasm-instantiate")})})}}w||Ay("wasm-instantiate");function B(ye){R(ye.instance,ye.module)}function K(ye){return $y().then(function(Te){return WebAssembly.instantiate(Te,N)}).then(ye,function(Te){H("failed to asynchronously prepare wasm: "+Te),yi(Te)})}function be(){return!Y&&typeof WebAssembly.instantiateStreaming=="function"&&!Dh(fn)&&!$h(fn)&&typeof fetch=="function"?fetch(fn,{credentials:"same-origin"}).then(function(ye){var Te=WebAssembly.instantiateStreaming(ye,N);return Te.then(B,function(_t){return H("wasm streaming compile failed: "+_t),H("falling back to ArrayBuffer instantiation"),K(B)})}):K(B)}if(i.instantiateWasm)try{var he=i.instantiateWasm(N,R);return he}catch(ye){return H("Module.instantiateWasm callback failed with error: "+ye),!1}return be().catch(u),{}}var Fy={9816:function(){throw"Canceled!"},9834:function(N,R){setTimeout(function(){OI(N,R)},0)}};function Fh(){Ae.initRuntime()}function rc(N){for(;N.length>0;){var R=N.shift();if(typeof R=="function"){R(i);continue}var B=R.func;typeof B=="number"?R.arg===void 0?Ur.get(B)():Ur.get(B)(R.arg):B(R.arg===void 0?null:R.arg)}}function um(N,R){if(N<=0||N>t().length||N&!0||R<0)return-28;if(R==0)return 0;R>=2147483647&&(R=Infinity);var B=Atomics.load(o(),lc>>2),K=0;if(B==N){var be=Atomics.compareExchange(o(),lc>>2,B,0);if(be==B&&(--R,K=1,R<=0))return 1}var he=Atomics.notify(o(),N>>2,R);if(he>=0)return he+K;throw"Atomics.notify returned an unexpected value "+he}i._emscripten_futex_wake=um;function Oy(N){if(w)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!N)throw"Internal Error! Null pthread_ptr in killThread!";o()[N+12>>2]=0;var R=Ae.pthreads[N];R.worker.terminate(),Ae.freeThreadData(R),Ae.runningWorkers.splice(Ae.runningWorkers.indexOf(R.worker),1),R.worker.pthread=void 0}function Py(N){if(w)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!N)throw"Internal Error! Null pthread_ptr in cancelThread!";var R=Ae.pthreads[N];R.worker.postMessage({cmd:"cancel"})}function My(N){if(w)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!N)throw"Internal Error! Null pthread_ptr in cleanupThread!";var R=Ae.pthreads[N];if(R){o()[N+12>>2]=0;var B=R.worker;Ae.returnWorkerToPool(B)}}var Ae={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var N=Math.min(4,Math.max(1,(navigator.hardwareConcurrency||1)/2)),R=0;R<N;++R)Ae.allocateUnusedWorker()},initRuntime:function(){for(var N=Vl(228),R=0;R<228/4;++R)s()[N/4+R]=0;o()[N+12>>2]=N;var B=N+152;o()[B>>2]=B;for(var K=Vl(512),R=0;R<128;++R)s()[K/4+R]=0;Atomics.store(s(),N+100>>2,K),Atomics.store(s(),N+40>>2,N),qb(N,!g,1),FI(N)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;Ae.threadExitHandlers.length>0;)Ae.threadExitHandlers.pop()();w&&sc()&&RI()},runExitHandlersAndDeinitThread:function(N,R){Atomics.store(s(),N+56>>2,1),Atomics.store(s(),N+60>>2,0),Ae.runExitHandlers(),Atomics.store(s(),N+4>>2,R),Atomics.store(s(),N+0>>2,1),um(N+0,2147483647),qb(0,0,0)},threadExit:function(N){var R=sc();R&&(Ae.runExitHandlersAndDeinitThread(R,N),w&&postMessage({cmd:"exit"}))},threadCancel:function(){Ae.runExitHandlersAndDeinitThread(sc(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var N in Ae.pthreads){var R=Ae.pthreads[N];R&&R.worker&&Ae.returnWorkerToPool(R.worker)}Ae.pthreads={};for(var B=0;B<Ae.unusedWorkers.length;++B){var K=Ae.unusedWorkers[B];K.terminate()}Ae.unusedWorkers=[];for(var B=0;B<Ae.runningWorkers.length;++B){var K=Ae.runningWorkers[B],R=K.pthread;Ae.freeThreadData(R),K.terminate()}Ae.runningWorkers=[]},freeThreadData:function(N){if(!!N){if(N.threadInfoStruct){var R=o()[N.threadInfoStruct+100>>2];o()[N.threadInfoStruct+100>>2]=0,gm(R),gm(N.threadInfoStruct)}N.threadInfoStruct=0,N.allocatedOwnStack&&N.stackBase&&gm(N.stackBase),N.stackBase=0,N.worker&&(N.worker.pthread=null)}},returnWorkerToPool:function(N){Ae.runWithoutMainThreadQueuedCalls(function(){delete Ae.pthreads[N.pthread.threadInfoStruct],Ae.unusedWorkers.push(N),Ae.runningWorkers.splice(Ae.runningWorkers.indexOf(N),1),Ae.freeThreadData(N.pthread),N.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(N){o()[BI>>2]=0;try{N()}finally{o()[BI>>2]=1}},receiveObjectTransfer:function(N){},loadWasmModuleToWorker:function(N,R){N.onmessage=function(B){var K=B.data,be=K.cmd;if(N.pthread&&(Ae.currentProxiedOperationCallerThread=N.pthread.threadInfoStruct),K.targetThread&&K.targetThread!=sc()){var he=Ae.pthreads[K.targetThread];he?he.worker.postMessage(B.data,K.transferList):console.error('Internal error! Worker sent a message "'+be+'" to target pthread '+K.targetThread+", but that thread no longer exists!"),Ae.currentProxiedOperationCallerThread=void 0;return}if(be==="processQueuedMainThreadWork")Ub();else if(be==="spawnThread")Bh(B.data);else if(be==="cleanupThread")My(K.thread);else if(be==="killThread")Oy(K.thread);else if(be==="cancelThread")Py(K.thread);else if(be==="loaded")N.loaded=!0,R&&R(N),N.runPthread&&(N.runPthread(),delete N.runPthread);else if(be==="print")U("Thread "+K.threadId+": "+K.text);else if(be==="printErr")H("Thread "+K.threadId+": "+K.text);else if(be==="alert")alert("Thread "+K.threadId+": "+K.text);else if(be==="exit"){var ye=N.pthread&&Atomics.load(s(),N.pthread.threadInfoStruct+64>>2);ye&&Ae.returnWorkerToPool(N)}else if(be==="exitProcess")try{uG(K.returnCode)}catch(Te){if(Te instanceof ym)return;throw Te}else be==="cancelDone"?Ae.returnWorkerToPool(N):be==="objectTransfer"?Ae.receiveObjectTransfer(B.data):B.data.target==="setimmediate"?N.postMessage(B.data):H("worker sent an unknown command "+be);Ae.currentProxiedOperationCallerThread=void 0},N.onerror=function(B){H("pthread sent an error! "+B.filename+":"+B.lineno+": "+B.message)},x&&(N.on("message",function(B){N.onmessage({data:B})}),N.on("error",function(B){N.onerror(B)}),N.on("exit",function(B){})),N.postMessage({cmd:"load",urlOrBlob:i.mainScriptUrlOrBlob||r,wasmMemory:Q,wasmModule:ie})},allocateUnusedWorker:function(){var N=I("tfjs-backend-wasm-threaded-simd.worker.js");Ae.unusedWorkers.push(new Worker(N))},getNewWorker:function(){return Ae.unusedWorkers.length==0&&(Ae.allocateUnusedWorker(),Ae.loadWasmModuleToWorker(Ae.unusedWorkers[0])),Ae.unusedWorkers.length>0?Ae.unusedWorkers.pop():null},busySpinWait:function(N){for(var R=performance.now()+N;performance.now()<R;);}};function Ly(N,R){LI(N,R),ic(N)}i.establishStackSpace=Ly;function zy(){return re}i.getNoExitRuntime=zy;function By(N,R){return Ur.get(N)(R)}i.invokeEntryPoint=By;function Vy(N,R,B,K){yi("Assertion failed: "+ve(N)+", at: "+[R?ve(R):"unknown filename",B,K?ve(K):"unknown function"])}function Gy(N,R){var B=_main(N,R)}var Bl;x?Bl=function(){var N=process.hrtime();return N[0]*1e3+N[1]/1e6}:w?Bl=function(){return performance.now()-i.__performance_now_clock_drift}:typeof dateNow!="undefined"?Bl=dateNow:Bl=function(){return performance.now()};function Wy(N){return o()[DI()>>2]=N,N}function jy(N,R){if(w)return Wa(1,1,N,R)}function Uy(N,R){if(N==R)postMessage({cmd:"processQueuedMainThreadWork"});else if(w)postMessage({targetThread:N,cmd:"processThreadQueue"});else{var B=Ae.pthreads[N],K=B&&B.worker;if(!K)return;K.postMessage({cmd:"processThreadQueue"})}return 1}function Hy(){yi()}function qy(N,R,B){var K=Jy(R,B);return Fy[N].apply(null,K)}function Ky(N,R){}function Xy(N,R,B){if(N<=0||N>t().length||N&!0)return-28;if(h){if(Atomics.load(o(),N>>2)!=R)return-6;for(var be=performance.now(),he=be+B,ye=Atomics.exchange(o(),lc>>2,N);;){if(be=performance.now(),be>he)return ye=Atomics.exchange(o(),lc>>2,0),-73;if(ye=Atomics.exchange(o(),lc>>2,0),ye==0)break;if(Ub(),Atomics.load(o(),N>>2)!=R)return-6;ye=Atomics.exchange(o(),lc>>2,N)}return 0}else{var K=Atomics.wait(o(),N>>2,R,B);if(K==="timed-out")return-73;if(K==="not-equal")return-6;if(K==="ok")return 0;throw"Atomics.wait returned an unexpected value "+K}}function Yy(N,R,B){n().copyWithin(N,R,R+B)}function Zy(){return x?require("os").cpus().length:navigator.hardwareConcurrency}function Wa(N,R){for(var B=arguments.length-2,K=xm(),be=B,he=ac(be*8),ye=he>>3,Te=0;Te<B;Te++){var _t=arguments[2+Te];a()[ye+Te]=_t}var kr=MI(N,be,he,R);return ic(K),kr}var cm=[],pm=[];function Jy(N,R){pm.length=0;var B;for(R>>=2;B=n()[N++];){var K=B<105;K&&R&1&&R++,pm.push(K?a()[R++>>1]:o()[R]),++R}return pm}function Qy(N,R,B){cm.length=R;for(var K=B>>3,be=0;be<R;be++)cm[be]=a()[K+be];var he=N<0,ye=he?Fy[-N-1]:kb[N];return ye.apply(null,cm)}function eb(){return n().length}function tb(N){try{return Q.grow(N-He.byteLength+65535>>>16),sr(Q.buffer),1}catch(R){}}function rb(N){var R=eb();if(N<=R)return!1;var B=2147483648;if(N>B)return!1;for(var K=1;K<=4;K*=2){var be=R*(1+.2/K);be=Math.min(be,N+100663296);var he=Math.min(B,Tt(Math.max(N,be),65536)),ye=tb(he);if(ye)return!0}return!1}var Je={inEventHandler:0,removeAllEventListeners:function(){for(var N=Je.eventHandlers.length-1;N>=0;--N)Je._removeHandler(N);Je.eventHandlers=[],Je.deferredCalls=[]},registerRemoveEventListeners:function(){Je.removeEventListenersRegistered||(Ml.push(Je.removeAllEventListeners),Je.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(N,R,B){function K(ye,Te){if(ye.length!=Te.length)return!1;for(var _t in ye)if(ye[_t]!=Te[_t])return!1;return!0}for(var be in Je.deferredCalls){var he=Je.deferredCalls[be];if(he.targetFunction==N&&K(he.argsList,B))return}Je.deferredCalls.push({targetFunction:N,precedence:R,argsList:B}),Je.deferredCalls.sort(function(ye,Te){return ye.precedence<Te.precedence})},removeDeferredCalls:function(N){for(var R=0;R<Je.deferredCalls.length;++R)Je.deferredCalls[R].targetFunction==N&&(Je.deferredCalls.splice(R,1),--R)},canPerformEventHandlerRequests:function(){return Je.inEventHandler&&Je.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!Je.canPerformEventHandlerRequests())for(var N=0;N<Je.deferredCalls.length;++N){var R=Je.deferredCalls[N];Je.deferredCalls.splice(N,1),--N,R.targetFunction.apply(null,R.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(N,R){for(var B=0;B<Je.eventHandlers.length;++B)Je.eventHandlers[B].target==N&&(!R||R==Je.eventHandlers[B].eventTypeString)&&Je._removeHandler(B--)},_removeHandler:function(N){var R=Je.eventHandlers[N];R.target.removeEventListener(R.eventTypeString,R.eventListenerFunc,R.useCapture),Je.eventHandlers.splice(N,1)},registerOrRemoveHandler:function(N){var R=function(be){++Je.inEventHandler,Je.currentEventHandler=N,Je.runDeferredCalls(),N.handlerFunc(be),Je.runDeferredCalls(),--Je.inEventHandler};if(N.callbackfunc)N.eventListenerFunc=R,N.target.addEventListener(N.eventTypeString,R,N.useCapture),Je.eventHandlers.push(N),Je.registerRemoveEventListeners();else for(var B=0;B<Je.eventHandlers.length;++B)Je.eventHandlers[B].target==N.target&&Je.eventHandlers[B].eventTypeString==N.eventTypeString&&Je._removeHandler(B--)},queueEventHandlerOnThread_iiii:function(N,R,B,K,be){var he=xm(),ye=ac(12);o()[ye>>2]=B,o()[ye+4>>2]=K,o()[ye+8>>2]=be,Hb(0,N,637534208,R,K,ye),ic(he)},getTargetThreadForEventCallback:function(N){switch(N){case 1:return 0;case 2:return Ae.currentProxiedOperationCallerThread;default:return N}},getNodeNameForTarget:function(N){return N?N==window?"#window":N==screen?"#screen":N&&N.nodeName?N.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function nb(N){var R=at(N)+1,B=Vl(R);return Ke(N,B,R),B}function ob(N,R,B,K){var be=xm(),he=ac(12),ye=0;R&&(ye=nb(R)),o()[he>>2]=ye,o()[he+4>>2]=B,o()[he+8>>2]=K,Hb(0,N,657457152,0,ye,he),ic(be)}function sb(N,R,B,K){R=R?ve(R):"",ob(N,R,B,K)}function ib(N){return N>2?ve(N):N}var ab=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function lb(N){N=ib(N);var R=ab[N]||(typeof document!="undefined"?document.querySelector(N):void 0);return R}function mm(N){return lb(N)}function Oh(N,R,B){var K=mm(N);if(!K)return-4;if(K.canvasSharedPtr&&(o()[K.canvasSharedPtr>>2]=R,o()[K.canvasSharedPtr+4>>2]=B),K.offscreenCanvas||!K.controlTransferredOffscreen){K.offscreenCanvas&&(K=K.offscreenCanvas);var be=!1;if(K.GLctxObject&&K.GLctxObject.GLctx){var he=K.GLctxObject.GLctx.getParameter(2978);be=he[0]===0&&he[1]===0&&he[2]===K.width&&he[3]===K.height}K.width=R,K.height=B,be&&K.GLctxObject.GLctx.viewport(0,0,R,B)}else if(K.canvasSharedPtr){var ye=o()[K.canvasSharedPtr+8>>2];return sb(ye,N,R,B),1}else return-4;return 0}function Ph(N,R,B){return w?Wa(2,1,N,R,B):Oh(N,R,B)}function ub(N,R,B){var K=mm(N);return K?Oh(N,R,B):Ph(N,R,B)}function cb(N){}function pb(N,R){}function mb(N){var R=N.getExtension("ANGLE_instanced_arrays");if(R)return N.vertexAttribDivisor=function(B,K){R.vertexAttribDivisorANGLE(B,K)},N.drawArraysInstanced=function(B,K,be,he){R.drawArraysInstancedANGLE(B,K,be,he)},N.drawElementsInstanced=function(B,K,be,he,ye){R.drawElementsInstancedANGLE(B,K,be,he,ye)},1}function fb(N){var R=N.getExtension("OES_vertex_array_object");if(R)return N.createVertexArray=function(){return R.createVertexArrayOES()},N.deleteVertexArray=function(B){R.deleteVertexArrayOES(B)},N.bindVertexArray=function(B){R.bindVertexArrayOES(B)},N.isVertexArray=function(B){return R.isVertexArrayOES(B)},1}function db(N){var R=N.getExtension("WEBGL_draw_buffers");if(R)return N.drawBuffers=function(B,K){R.drawBuffersWEBGL(B,K)},1}function hb(N){return!!(N.multiDrawWebgl=N.getExtension("WEBGL_multi_draw"))}var ft={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function(R){ft.lastError||(ft.lastError=R)},getNewId:function(N){for(var R=ft.counter++,B=N.length;B<R;B++)N[B]=null;return R},getSource:function(N,R,B,K){for(var be="",he=0;he<R;++he){var ye=K?o()[K+he*4>>2]:-1;be+=ve(o()[B+he*4>>2],ye<0?void 0:ye)}return be},createContext:function(N,R){var B=N.getContext("webgl",R);if(!B)return 0;var K=ft.registerContext(B,R);return K},registerContext:function(N,R){var B=Vl(8);o()[B+4>>2]=sc();var K={handle:B,attributes:R,version:R.majorVersion,GLctx:N};return N.canvas&&(N.canvas.GLctxObject=K),ft.contexts[B]=K,(typeof R.enableExtensionsByDefault=="undefined"||R.enableExtensionsByDefault)&&ft.initExtensions(K),B},makeContextCurrent:function(N){return ft.currentContext=ft.contexts[N],i.ctx=ja=ft.currentContext&&ft.currentContext.GLctx,!(N&&!ja)},getContext:function(N){return ft.contexts[N]},deleteContext:function(N){ft.currentContext===ft.contexts[N]&&(ft.currentContext=null),typeof Je=="object"&&Je.removeAllHandlersOnTarget(ft.contexts[N].GLctx.canvas),ft.contexts[N]&&ft.contexts[N].GLctx.canvas&&(ft.contexts[N].GLctx.canvas.GLctxObject=void 0),gm(ft.contexts[N].handle),ft.contexts[N]=null},initExtensions:function(N){if(N||(N=ft.currentContext),!N.initExtensionsDone){N.initExtensionsDone=!0;var R=N.GLctx;mb(R),fb(R),db(R),R.disjointTimerQueryExt=R.getExtension("EXT_disjoint_timer_query"),hb(R);var B=R.getSupportedExtensions()||[];B.forEach(function(K){K.indexOf("lose_context")<0&&K.indexOf("debug")<0&&R.getExtension(K)})}},populateUniformTable:function(N){for(var R=ft.programs[N],B=ft.programInfos[N]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},K=B.uniforms,be=ja.getProgramParameter(R,35718),he=0;he<be;++he){var ye=ja.getActiveUniform(R,he),Te=ye.name;B.maxUniformLength=Math.max(B.maxUniformLength,Te.length+1),Te.slice(-1)=="]"&&(Te=Te.slice(0,Te.lastIndexOf("[")));var _t=ja.getUniformLocation(R,Te);if(_t){var kr=ft.getNewId(ft.uniforms);K[Te]=[ye.size,kr],ft.uniforms[kr]=_t;for(var gr=1;gr<ye.size;++gr){var Ha=Te+"["+gr+"]";_t=ja.getUniformLocation(R,Ha),kr=ft.getNewId(ft.uniforms),ft.uniforms[kr]=_t}}}}},gb=["default","low-power","high-performance"];function xb(N,R){var B=R>>2,K=o()[B+(24>>2)],be={alpha:!!o()[B+(0>>2)],depth:!!o()[B+(4>>2)],stencil:!!o()[B+(8>>2)],antialias:!!o()[B+(12>>2)],premultipliedAlpha:!!o()[B+(16>>2)],preserveDrawingBuffer:!!o()[B+(20>>2)],powerPreference:gb[K],failIfMajorPerformanceCaveat:!!o()[B+(28>>2)],majorVersion:o()[B+(32>>2)],minorVersion:o()[B+(36>>2)],enableExtensionsByDefault:o()[B+(40>>2)],explicitSwapControl:o()[B+(44>>2)],proxyContextToMainThread:o()[B+(48>>2)],renderViaOffscreenBackBuffer:o()[B+(52>>2)]},he=mm(N);if(!he||be.explicitSwapControl)return 0;var ye=ft.createContext(he,be);return ye}function yb(N,R){return xb(N,R)}var nc={mappings:{},buffers:[null,[],[]],printChar:function(N,R){var B=nc.buffers[N];R===0||R===10?((N===1?U:H)(De(B,0)),B.length=0):B.push(R)},varargs:void 0,get:function(){nc.varargs+=4;var N=o()[nc.varargs-4>>2];return N},getStr:function(N){var R=ve(N);return R},get64:function(N,R){return N}};function Mh(N){return w?Wa(3,1,N):0}function Lh(N,R,B,K,be){if(w)return Wa(4,1,N,R,B,K,be)}function zh(N,R,B,K){if(w)return Wa(5,1,N,R,B,K);for(var be=0,he=0;he<B;he++){for(var ye=o()[R+he*8>>2],Te=o()[R+(he*8+4)>>2],_t=0;_t<Te;_t++)nc.printChar(N,n()[ye+_t]);be+=Te}return o()[K>>2]=be,0}function bb(N){var R=Ae.threadExitHandlers.pop();N&&R()}function wb(N,R){Ae.threadExitHandlers.push(function(){Ur.get(N)(R)})}function Bh(N){if(w)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var R=Ae.getNewWorker();if(R.pthread!==void 0)throw"Internal error!";if(!N.pthread_ptr)throw"Internal error, no pthread ptr!";Ae.runningWorkers.push(R);for(var B=Vl(128*4),K=0;K<128;++K)o()[B+K*4>>2]=0;var be=N.stackBase+N.stackSize,he=Ae.pthreads[N.pthread_ptr]={worker:R,stackBase:N.stackBase,stackSize:N.stackSize,allocatedOwnStack:N.allocatedOwnStack,threadInfoStruct:N.pthread_ptr},ye=he.threadInfoStruct>>2;Atomics.store(s(),ye+(64>>2),N.detached),Atomics.store(s(),ye+(100>>2),B),Atomics.store(s(),ye+(40>>2),he.threadInfoStruct),Atomics.store(s(),ye+(80>>2),N.stackSize),Atomics.store(s(),ye+(76>>2),be),Atomics.store(s(),ye+(104>>2),N.stackSize),Atomics.store(s(),ye+(104+8>>2),be),Atomics.store(s(),ye+(104+12>>2),N.detached);var Te=$I(),_t=Te+40;Atomics.store(s(),ye+(172>>2),_t),R.pthread=he;var kr={cmd:"run",start_routine:N.startRoutine,arg:N.arg,threadInfoStruct:N.pthread_ptr,stackBase:N.stackBase,stackSize:N.stackSize};R.runPthread=function(){kr.time=performance.now(),R.postMessage(kr,N.transferList)},R.loaded&&(R.runPthread(),delete R.runPthread)}function _b(N,R,B,K){if(typeof SharedArrayBuffer=="undefined")return H("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!N)return H("pthread_create called with a null thread pointer!"),28;var be=[],he=0;if(w&&(be.length===0||he))return PI(687865856,N,R,B,K);if(he)return he;var ye=0,Te=0,_t=0;R&&R!=-1?(ye=o()[R>>2],ye+=81920,Te=o()[R+8>>2],_t=o()[R+12>>2]!==0):ye=2097152;var kr=Te==0;kr?Te=zI(16,ye):(Te-=ye,fe(Te>0));for(var gr=Vl(228),Ha=0;Ha<228>>2;++Ha)s()[(gr>>2)+Ha]=0;o()[N>>2]=gr,o()[gr+12>>2]=gr;var uc=gr+152;o()[uc>>2]=uc;var Hr={stackBase:Te,stackSize:ye,allocatedOwnStack:kr,detached:_t,startRoutine:B,pthread_ptr:gr,arg:K,transferList:be};return w?(Hr.cmd="spawnThread",postMessage(Hr,be)):Bh(Hr),0}function Vh(N){if(w)return Wa(6,1,N);switch(N){case 30:return 16384;case 85:var R=2147483648;return R/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return Wy(28),-1}w||Ae.initMainThreadBlock();var ja,kb=[null,jy,Ph,Mh,Lh,zh,Vh],vb={e:Vy,r:Gy,x:Uy,b:Hy,y:qy,j:Ky,c:Xy,d:um,f:Bl,p:Yy,z:Zy,u:Qy,q:rb,v:ub,i:cb,t:pb,w:yb,m:Mh,n:Lh,g:zh,o:Fh,a:Q||i.wasmMemory,k:bb,l:wb,h:_b,s:Vh},EI=Ry(),Gh=i.___wasm_call_ctors=function(){return(Gh=i.___wasm_call_ctors=i.asm.A).apply(null,arguments)},Cb=i._init=function(){return(Cb=i._init=i.asm.B).apply(null,arguments)},Ib=i._register_tensor=function(){return(Ib=i._register_tensor=i.asm.C).apply(null,arguments)},Nb=i._dispose_data=function(){return(Nb=i._dispose_data=i.asm.D).apply(null,arguments)},Sb=i._dispose=function(){return(Sb=i._dispose=i.asm.E).apply(null,arguments)},Tb=i._Abs=function(){return(Tb=i._Abs=i.asm.G).apply(null,arguments)},Ab=i._Add=function(){return(Ab=i._Add=i.asm.H).apply(null,arguments)},Eb=i._AddN=function(){return(Eb=i._AddN=i.asm.I).apply(null,arguments)},Db=i._All=function(){return(Db=i._All=i.asm.J).apply(null,arguments)},$b=i._Any=function(){return($b=i._Any=i.asm.K).apply(null,arguments)},Rb=i._ArgMax=function(){return(Rb=i._ArgMax=i.asm.L).apply(null,arguments)},Fb=i._AvgPool=function(){return(Fb=i._AvgPool=i.asm.M).apply(null,arguments)},Ob=i._BatchMatMul=function(){return(Ob=i._BatchMatMul=i.asm.N).apply(null,arguments)},Pb=i._Ceil=function(){return(Pb=i._Ceil=i.asm.O).apply(null,arguments)},Mb=i._ClipByValue=function(){return(Mb=i._ClipByValue=i.asm.P).apply(null,arguments)},Lb=i._Conv2D=function(){return(Lb=i._Conv2D=i.asm.Q).apply(null,arguments)},zb=i._Conv2DBackpropInput=function(){return(zb=i._Conv2DBackpropInput=i.asm.R).apply(null,arguments)},Bb=i._Cos=function(){return(Bb=i._Cos=i.asm.S).apply(null,arguments)},Vb=i._CropAndResize=function(){return(Vb=i._CropAndResize=i.asm.T).apply(null,arguments)},Gb=i._Cumsum=function(){return(Gb=i._Cumsum=i.asm.U).apply(null,arguments)},Wb=i._DepthToSpace=function(){return(Wb=i._DepthToSpace=i.asm.V).apply(null,arguments)},Wh=i._DepthwiseConv2dNative=function(){return(Wh=i._DepthwiseConv2dNative=i.asm.W).apply(null,arguments)},jh=i._Equal=function(){return(jh=i._Equal=i.asm.X).apply(null,arguments)},Uh=i._Exp=function(){return(Uh=i._Exp=i.asm.Y).apply(null,arguments)},fm=i._FlipLeftRight=function(){return(fm=i._FlipLeftRight=i.asm.Z).apply(null,arguments)},oc=i._Floor=function(){return(oc=i._Floor=i.asm._).apply(null,arguments)},jb=i._FloorDiv=function(){return(jb=i._FloorDiv=i.asm.$).apply(null,arguments)},dm=i._FusedBatchNorm=function(){return(dm=i._FusedBatchNorm=i.asm.aa).apply(null,arguments)},Z=i._FusedConv2D=function(){return(Z=i._FusedConv2D=i.asm.ba).apply(null,arguments)},se=i._FusedDepthwiseConv2D=function(){return(se=i._FusedDepthwiseConv2D=i.asm.ca).apply(null,arguments)},ke=i._Gather=function(){return(ke=i._Gather=i.asm.da).apply(null,arguments)},lt=i._GatherNd=function(){return(lt=i._GatherNd=i.asm.ea).apply(null,arguments)},Zt=i._Greater=function(){return(Zt=i._Greater=i.asm.fa).apply(null,arguments)},zt=i._GreaterEqual=function(){return(zt=i._GreaterEqual=i.asm.ga).apply(null,arguments)},tt=i._LeakyRelu=function(){return(tt=i._LeakyRelu=i.asm.ha).apply(null,arguments)},rt=i._Less=function(){return(rt=i._Less=i.asm.ia).apply(null,arguments)},Ir=i._LessEqual=function(){return(Ir=i._LessEqual=i.asm.ja).apply(null,arguments)},bi=i._Log=function(){return(bi=i._Log=i.asm.ka).apply(null,arguments)},wi=i._LogicalAnd=function(){return(wi=i._LogicalAnd=i.asm.la).apply(null,arguments)},Hh=i._Max=function(){return(Hh=i._Max=i.asm.ma).apply(null,arguments)},hm=i._MaxPool=function(){return(hm=i._MaxPool=i.asm.na).apply(null,arguments)},Cn=i._Maximum=function(){return(Cn=i._Maximum=i.asm.oa).apply(null,arguments)},Ua=i._Mean=function(){return(Ua=i._Mean=i.asm.pa).apply(null,arguments)},qh=i._Min=function(){return(qh=i._Min=i.asm.qa).apply(null,arguments)},kV=i._Minimum=function(){return(kV=i._Minimum=i.asm.ra).apply(null,arguments)},vV=i._MirrorPad=function(){return(vV=i._MirrorPad=i.asm.sa).apply(null,arguments)},CV=i._Multiply=function(){return(CV=i._Multiply=i.asm.ta).apply(null,arguments)},IV=i._Neg=function(){return(IV=i._Neg=i.asm.ua).apply(null,arguments)},NV=i._NonMaxSuppressionV3=function(){return(NV=i._NonMaxSuppressionV3=i.asm.va).apply(null,arguments)},SV=i._NonMaxSuppressionV4=function(){return(SV=i._NonMaxSuppressionV4=i.asm.wa).apply(null,arguments)},TV=i._NonMaxSuppressionV5=function(){return(TV=i._NonMaxSuppressionV5=i.asm.xa).apply(null,arguments)},AV=i._NotEqual=function(){return(AV=i._NotEqual=i.asm.ya).apply(null,arguments)},EV=i._OneHot=function(){return(EV=i._OneHot=i.asm.za).apply(null,arguments)},DV=i._PadV2=function(){return(DV=i._PadV2=i.asm.Aa).apply(null,arguments)},$V=i._Pow=function(){return($V=i._Pow=i.asm.Ba).apply(null,arguments)},RV=i._Prelu=function(){return(RV=i._Prelu=i.asm.Ca).apply(null,arguments)},FV=i._Prod=function(){return(FV=i._Prod=i.asm.Da).apply(null,arguments)},OV=i._RealDiv=function(){return(OV=i._RealDiv=i.asm.Ea).apply(null,arguments)},PV=i._Relu=function(){return(PV=i._Relu=i.asm.Fa).apply(null,arguments)},MV=i._Relu6=function(){return(MV=i._Relu6=i.asm.Ga).apply(null,arguments)},LV=i._ResizeBilinear=function(){return(LV=i._ResizeBilinear=i.asm.Ha).apply(null,arguments)},zV=i._Reverse=function(){return(zV=i._Reverse=i.asm.Ia).apply(null,arguments)},BV=i._RotateWithOffset=function(){return(BV=i._RotateWithOffset=i.asm.Ja).apply(null,arguments)},VV=i._Round=function(){return(VV=i._Round=i.asm.Ka).apply(null,arguments)},GV=i._Rsqrt=function(){return(GV=i._Rsqrt=i.asm.La).apply(null,arguments)},WV=i._ScatterNd=function(){return(WV=i._ScatterNd=i.asm.Ma).apply(null,arguments)},jV=i._SelectV2=function(){return(jV=i._SelectV2=i.asm.Na).apply(null,arguments)},UV=i._Sigmoid=function(){return(UV=i._Sigmoid=i.asm.Oa).apply(null,arguments)},HV=i._Sin=function(){return(HV=i._Sin=i.asm.Pa).apply(null,arguments)},qV=i._Softmax=function(){return(qV=i._Softmax=i.asm.Qa).apply(null,arguments)},KV=i._Sqrt=function(){return(KV=i._Sqrt=i.asm.Ra).apply(null,arguments)},XV=i._Square=function(){return(XV=i._Square=i.asm.Sa).apply(null,arguments)},YV=i._SquaredDifference=function(){return(YV=i._SquaredDifference=i.asm.Ta).apply(null,arguments)},ZV=i._Step=function(){return(ZV=i._Step=i.asm.Ua).apply(null,arguments)},JV=i._StridedSlice=function(){return(JV=i._StridedSlice=i.asm.Va).apply(null,arguments)},QV=i._Sub=function(){return(QV=i._Sub=i.asm.Wa).apply(null,arguments)},eG=i._Sum=function(){return(eG=i._Sum=i.asm.Xa).apply(null,arguments)},tG=i._Tan=function(){return(tG=i._Tan=i.asm.Ya).apply(null,arguments)},rG=i._Tanh=function(){return(rG=i._Tanh=i.asm.Za).apply(null,arguments)},nG=i._Tile=function(){return(nG=i._Tile=i.asm._a).apply(null,arguments)},oG=i._TopK=function(){return(oG=i._TopK=i.asm.$a).apply(null,arguments)},sG=i._Transpose=function(){return(sG=i._Transpose=i.asm.ab).apply(null,arguments)},iG=i.__FusedMatMul=function(){return(iG=i.__FusedMatMul=i.asm.bb).apply(null,arguments)},Vl=i._malloc=function(){return(Vl=i._malloc=i.asm.cb).apply(null,arguments)},gm=i._free=function(){return(gm=i._free=i.asm.db).apply(null,arguments)},DI=i.___errno_location=function(){return(DI=i.___errno_location=i.asm.eb).apply(null,arguments)},$I=i._emscripten_get_global_libc=function(){return($I=i._emscripten_get_global_libc=i.asm.fb).apply(null,arguments)},sc=i._pthread_self=function(){return(sc=i._pthread_self=i.asm.gb).apply(null,arguments)},RI=i.___pthread_tsd_run_dtors=function(){return(RI=i.___pthread_tsd_run_dtors=i.asm.hb).apply(null,arguments)},Ub=i._emscripten_main_thread_process_queued_calls=function(){return(Ub=i._emscripten_main_thread_process_queued_calls=i.asm.ib).apply(null,arguments)},aG=i._emscripten_current_thread_process_queued_calls=function(){return(aG=i._emscripten_current_thread_process_queued_calls=i.asm.jb).apply(null,arguments)},FI=i._emscripten_register_main_browser_thread_id=function(){return(FI=i._emscripten_register_main_browser_thread_id=i.asm.kb).apply(null,arguments)},OI=i.__emscripten_do_dispatch_to_thread=function(){return(OI=i.__emscripten_do_dispatch_to_thread=i.asm.lb).apply(null,arguments)},PI=i._emscripten_sync_run_in_main_thread_4=function(){return(PI=i._emscripten_sync_run_in_main_thread_4=i.asm.mb).apply(null,arguments)},MI=i._emscripten_run_in_main_runtime_thread_js=function(){return(MI=i._emscripten_run_in_main_runtime_thread_js=i.asm.nb).apply(null,arguments)},Hb=i.__emscripten_call_on_thread=function(){return(Hb=i.__emscripten_call_on_thread=i.asm.ob).apply(null,arguments)},lG=i._emscripten_tls_init=function(){return(lG=i._emscripten_tls_init=i.asm.pb).apply(null,arguments)},qb=i.__emscripten_thread_init=function(){return(qb=i.__emscripten_thread_init=i.asm.qb).apply(null,arguments)},xm=i.stackSave=function(){return(xm=i.stackSave=i.asm.rb).apply(null,arguments)},ic=i.stackRestore=function(){return(ic=i.stackRestore=i.asm.sb).apply(null,arguments)},ac=i.stackAlloc=function(){return(ac=i.stackAlloc=i.asm.tb).apply(null,arguments)},LI=i._emscripten_stack_set_limits=function(){return(LI=i._emscripten_stack_set_limits=i.asm.ub).apply(null,arguments)},zI=i._memalign=function(){return(zI=i._memalign=i.asm.vb).apply(null,arguments)},BI=i.__emscripten_allow_main_runtime_queued_calls=9808,lc=i.__emscripten_main_thread_futex=11432;i.cwrap=we,i.PThread=Ae,i.PThread=Ae,i.wasmMemory=Q,i.ExitStatus=ym;var Kh;function ym(N){this.name="ExitStatus",this.message="Program terminated with exit("+N+")",this.status=N}zl=function N(){Kh||Kb(),Kh||(zl=N)};function Kb(N){if(N=N||m,xi>0)return;if(w){l(i),Ll(),postMessage({cmd:"loaded"});return}if(lm(),xi>0)return;function R(){Kh||(Kh=!0,i.calledRun=!0,!ce&&(Ll(),Sy(),l(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),mn()))}i.setStatus?(i.setStatus("Running..."),setTimeout(function(){setTimeout(function(){i.setStatus("")},1),R()},1)):R()}i.run=Kb;function uG(N,R){if(!(R&&re&&N===0)){if(!R&&w)throw postMessage({cmd:"exitProcess",returnCode:N}),new ym(N);re||(Ae.terminateAllThreads(),ae=N,Th(),i.onExit&&i.onExit(N),ce=!0),d(N,new ym(N))}}if(i.preInit)for(typeof i.preInit=="function"&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();return w&&(re=!1,Ae.initWorker()),Kb(),e.ready}}();typeof Ix=="object"&&typeof DC=="object"?DC.exports=$C:typeof define=="function"&&define.amd?define([],function(){return $C}):typeof Ix=="object"&&(Ix.WasmBackendModuleThreadedSimd=$C)});var MM=Ht((Nx,RC)=>{var FC=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};var t=typeof e!="undefined"?e:{},n,o;t.ready=new Promise(function(Z,se){n=Z,o=se});var s={},a;for(a in t)t.hasOwnProperty(a)&&(s[a]=t[a]);var i=[],l="./this.program",u=function(Z,se){throw se},c=!1,p=!1,m=!1,f=!1;c=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f=!c&&!m&&!p;var d="";function h(Z){return t.locateFile?t.locateFile(Z,d):d+Z}var g,x,b,w,_,I;m?(p?d=Rp().dirname(d)+"/":d=__dirname+"/",g=function(se,ke){return _||(_=require("fs")),I||(I=Rp()),se=I.normalize(se),_.readFileSync(se,ke?null:"utf8")},b=function(se){var ke=g(se,!0);return ke.buffer||(ke=new Uint8Array(ke)),U(ke.buffer),ke},process.argv.length>1&&(l=process.argv[1].replace(/\\/g,"/")),i=process.argv.slice(2),process.on("uncaughtException",function(Z){if(!(Z instanceof jb))throw Z}),process.on("unhandledRejection",Os),u=function(Z){process.exit(Z)},t.inspect=function(){return"[Emscripten Module object]"}):f?(typeof read!="undefined"&&(g=function(se){return read(se)}),b=function(se){var ke;return typeof readbuffer=="function"?new Uint8Array(readbuffer(se)):(ke=read(se,"binary"),U(typeof ke=="object"),ke)},typeof scriptArgs!="undefined"?i=scriptArgs:typeof arguments!="undefined"&&(i=arguments),typeof quit=="function"&&(u=function(Z){quit(Z)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(c||p)&&(p?d=self.location.href:typeof document!="undefined"&&document.currentScript&&(d=document.currentScript.src),r&&(d=r),d.indexOf("blob:")!==0?d=d.substr(0,d.lastIndexOf("/")+1):d="",g=function(Z){var se=new XMLHttpRequest;return se.open("GET",Z,!1),se.send(null),se.responseText},p&&(b=function(Z){var se=new XMLHttpRequest;return se.open("GET",Z,!1),se.responseType="arraybuffer",se.send(null),new Uint8Array(se.response)}),x=function(Z,se,ke){var lt=new XMLHttpRequest;lt.open("GET",Z,!0),lt.responseType="arraybuffer",lt.onload=function(){if(lt.status==200||lt.status==0&&lt.response){se(lt.response);return}ke()},lt.onerror=ke,lt.send(null)},w=function(Z){document.title=Z});var E=t.print||console.log.bind(console),$=t.printErr||console.warn.bind(console);for(a in s)s.hasOwnProperty(a)&&(t[a]=s[a]);s=null,t.arguments&&(i=t.arguments),t.thisProgram&&(l=t.thisProgram),t.quit&&(u=t.quit);var D;t.wasmBinary&&(D=t.wasmBinary);var O=t.noExitRuntime||!0;typeof WebAssembly!="object"&&Os("no native wasm support detected");var M,G=!1,j;function U(Z,se){Z||Os("Assertion failed: "+se)}function H(Z){var se=t["_"+Z];return U(se,"Cannot call unknown function "+Z+", make sure it is exported"),se}function q(Z,se,ke,lt,Zt){var zt={string:function(Cn){var Ua=0;if(Cn!=null&&Cn!==0){var qh=(Cn.length<<2)+1;Ua=fm(qh),ie(Cn,Ua,qh)}return Ua},array:function(Cn){var Ua=fm(Cn.length);return ce(Cn,Ua),Ua}};function tt(Cn){return se==="string"?re(Cn):se==="boolean"?Boolean(Cn):Cn}var rt=H(Z),Ir=[],bi=0;if(lt)for(var wi=0;wi<lt.length;wi++){var Hh=zt[ke[wi]];Hh?(bi===0&&(bi=jh()),Ir[wi]=Hh(lt[wi])):Ir[wi]=lt[wi]}var hm=rt.apply(null,Ir);return hm=tt(hm),bi!==0&&Uh(bi),hm}function X(Z,se,ke,lt){ke=ke||[];var Zt=ke.every(function(tt){return tt==="number"}),zt=se!=="string";return zt&&Zt&&!lt?H(Z):function(){return q(Z,se,ke,arguments,lt)}}var ne=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function Y(Z,se,ke){for(var lt=se+ke,Zt=se;Z[Zt]&&!(Zt>=lt);)++Zt;if(Zt-se>16&&Z.subarray&&ne)return ne.decode(Z.subarray(se,Zt));for(var zt="";se<Zt;){var tt=Z[se++];if(!(tt&128)){zt+=String.fromCharCode(tt);continue}var rt=Z[se++]&63;if((tt&224)==192){zt+=String.fromCharCode((tt&31)<<6|rt);continue}var Ir=Z[se++]&63;if((tt&240)==224?tt=(tt&15)<<12|rt<<6|Ir:tt=(tt&7)<<18|rt<<12|Ir<<6|Z[se++]&63,tt<65536)zt+=String.fromCharCode(tt);else{var bi=tt-65536;zt+=String.fromCharCode(55296|bi>>10,56320|bi&1023)}}return zt}function re(Z,se){return Z?Y(xe,Z,se):""}function Q(Z,se,ke,lt){if(!(lt>0))return 0;for(var Zt=ke,zt=ke+lt-1,tt=0;tt<Z.length;++tt){var rt=Z.charCodeAt(tt);if(rt>=55296&&rt<=57343){var Ir=Z.charCodeAt(++tt);rt=65536+((rt&1023)<<10)|Ir&1023}if(rt<=127){if(ke>=zt)break;se[ke++]=rt}else if(rt<=2047){if(ke+1>=zt)break;se[ke++]=192|rt>>6,se[ke++]=128|rt&63}else if(rt<=65535){if(ke+2>=zt)break;se[ke++]=224|rt>>12,se[ke++]=128|rt>>6&63,se[ke++]=128|rt&63}else{if(ke+3>=zt)break;se[ke++]=240|rt>>18,se[ke++]=128|rt>>12&63,se[ke++]=128|rt>>6&63,se[ke++]=128|rt&63}}return se[ke]=0,ke-Zt}function ie(Z,se,ke){return Q(Z,xe,se,ke)}function ce(Z,se){de.set(Z,se)}function ae(Z,se){return Z%se>0&&(Z+=se-Z%se),Z}var fe,de,xe,we,De,ve,Ge,Ke,at;function St(Z){fe=Z,t.HEAP8=de=new Int8Array(Z),t.HEAP16=we=new Int16Array(Z),t.HEAP32=ve=new Int32Array(Z),t.HEAPU8=xe=new Uint8Array(Z),t.HEAPU16=De=new Uint16Array(Z),t.HEAPU32=Ge=new Uint32Array(Z),t.HEAPF32=Ke=new Float32Array(Z),t.HEAPF64=at=new Float64Array(Z)}var Tt=t.INITIAL_MEMORY||16777216,He,ct=[],mt=[],Lt=[],kn=[],Yt=!1;mt.push({func:function(){Fh()}});function cn(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)vn(t.preRun.shift());Ga(ct)}function Pr(){Yt=!0,Ga(mt)}function Un(){Ga(Lt)}function sr(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)Ur(t.postRun.shift());Ga(kn)}function vn(Z){ct.unshift(Z)}function Ur(Z){kn.unshift(Z)}var _r=0,pn=null,Rn=null;function Ml(Z){_r++,t.monitorRunDependencies&&t.monitorRunDependencies(_r)}function Va(Z){if(_r--,t.monitorRunDependencies&&t.monitorRunDependencies(_r),_r==0&&(pn!==null&&(clearInterval(pn),pn=null),Rn)){var se=Rn;Rn=null,se()}}t.preloadedImages={},t.preloadedAudios={};function Os(Z){t.onAbort&&t.onAbort(Z),Z+="",$(Z),G=!0,j=1,Z="abort("+Z+"). Build with -s ASSERTIONS=1 for more info.";var se=new WebAssembly.RuntimeError(Z);throw o(se),se}function gi(Z,se){return String.prototype.startsWith?Z.startsWith(se):Z.indexOf(se)===0}var lm="data:application/octet-stream;base64,";function Ll(Z){return gi(Z,lm)}var Sy="file://";function Th(Z){return gi(Z,Sy)}var mn="tfjs-backend-wasm.wasm";Ll(mn)||(mn=h(mn));function Ah(Z){try{if(Z==mn&&D)return new Uint8Array(D);if(b)return b(Z);throw"both async and sync fetching of the wasm failed"}catch(se){Os(se)}}function Ty(){if(!D&&(c||p)){if(typeof fetch=="function"&&!Th(mn))return fetch(mn,{credentials:"same-origin"}).then(function(Z){if(!Z.ok)throw"failed to load wasm binary file at '"+mn+"'";return Z.arrayBuffer()}).catch(function(){return Ah(mn)});if(x)return new Promise(function(Z,se){x(mn,function(ke){Z(new Uint8Array(ke))},se)})}return Promise.resolve().then(function(){return Ah(mn)})}function xi(){var Z={a:Ry};function se(tt,rt){var Ir=tt.exports;t.asm=Ir,M=t.asm.i,St(M.buffer),He=t.asm.o,Va("wasm-instantiate")}Ml("wasm-instantiate");function ke(tt){se(tt.instance)}function lt(tt){return Ty().then(function(rt){return WebAssembly.instantiate(rt,Z)}).then(tt,function(rt){$("failed to asynchronously prepare wasm: "+rt),Os(rt)})}function Zt(){return!D&&typeof WebAssembly.instantiateStreaming=="function"&&!Ll(mn)&&!Th(mn)&&typeof fetch=="function"?fetch(mn,{credentials:"same-origin"}).then(function(tt){var rt=WebAssembly.instantiateStreaming(tt,Z);return rt.then(ke,function(Ir){return $("wasm streaming compile failed: "+Ir),$("falling back to ArrayBuffer instantiation"),lt(ke)})}):lt(ke)}if(t.instantiateWasm)try{var zt=t.instantiateWasm(Z,se);return zt}catch(tt){return $("Module.instantiateWasm callback failed with error: "+tt),!1}return Zt().catch(o),{}}function Ga(Z){for(;Z.length>0;){var se=Z.shift();if(typeof se=="function"){se(t);continue}var ke=se.func;typeof ke=="number"?se.arg===void 0?He.get(ke)():He.get(ke)(se.arg):ke(se.arg===void 0?null:se.arg)}}function zl(){Os()}function Ay(Z,se,ke){xe.copyWithin(Z,se,se+ke)}function Ey(){return xe.length}function yi(Z){try{return M.grow(Z-fe.byteLength+65535>>>16),St(M.buffer),1}catch(se){}}function Eh(Z){var se=Ey(),ke=2147483648;if(Z>ke)return!1;for(var lt=1;lt<=4;lt*=2){var Zt=se*(1+.2/lt);Zt=Math.min(Zt,Z+100663296);var zt=Math.min(ke,ae(Math.max(Z,Zt),65536)),tt=yi(zt);if(tt)return!0}return!1}var tc={mappings:{},buffers:[null,[],[]],printChar:function(Z,se){var ke=tc.buffers[Z];se===0||se===10?((Z===1?E:$)(Y(ke,0)),ke.length=0):ke.push(se)},varargs:void 0,get:function(){tc.varargs+=4;var Z=ve[tc.varargs-4>>2];return Z},getStr:function(Z){var se=re(Z);return se},get64:function(Z,se){return Z}};function Dh(Z){return 0}function Dy(Z,se,ke,lt,Zt){}function $h(Z,se,ke,lt){for(var Zt=0,zt=0;zt<ke;zt++){for(var tt=ve[se+zt*8>>2],rt=ve[se+(zt*8+4)>>2],Ir=0;Ir<rt;Ir++)tc.printChar(Z,xe[tt+Ir]);Zt+=rt}return ve[lt>>2]=Zt,0}function fn(){return 6}function Rh(Z){return ve[Wh()>>2]=Z,Z}function $y(Z){switch(Z){case 30:return 16384;case 85:var se=2147483648;return se/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return Rh(28),-1}var Ry={a:zl,d:Ay,e:Eh,f:Dh,c:Dy,b:$h,g:fn,h:$y},Fy=xi(),Fh=t.___wasm_call_ctors=function(){return(Fh=t.___wasm_call_ctors=t.asm.j).apply(null,arguments)},rc=t._init=function(){return(rc=t._init=t.asm.k).apply(null,arguments)},um=t._register_tensor=function(){return(um=t._register_tensor=t.asm.l).apply(null,arguments)},Oy=t._dispose_data=function(){return(Oy=t._dispose_data=t.asm.m).apply(null,arguments)},Py=t._dispose=function(){return(Py=t._dispose=t.asm.n).apply(null,arguments)},My=t._Abs=function(){return(My=t._Abs=t.asm.p).apply(null,arguments)},Ae=t._Add=function(){return(Ae=t._Add=t.asm.q).apply(null,arguments)},Ly=t._AddN=function(){return(Ly=t._AddN=t.asm.r).apply(null,arguments)},zy=t._All=function(){return(zy=t._All=t.asm.s).apply(null,arguments)},By=t._Any=function(){return(By=t._Any=t.asm.t).apply(null,arguments)},Vy=t._ArgMax=function(){return(Vy=t._ArgMax=t.asm.u).apply(null,arguments)},Gy=t._AvgPool=function(){return(Gy=t._AvgPool=t.asm.v).apply(null,arguments)},Bl=t._BatchMatMul=function(){return(Bl=t._BatchMatMul=t.asm.w).apply(null,arguments)},Wy=t._Ceil=function(){return(Wy=t._Ceil=t.asm.x).apply(null,arguments)},jy=t._ClipByValue=function(){return(jy=t._ClipByValue=t.asm.y).apply(null,arguments)},Uy=t._Conv2D=function(){return(Uy=t._Conv2D=t.asm.z).apply(null,arguments)},Hy=t._Conv2DBackpropInput=function(){return(Hy=t._Conv2DBackpropInput=t.asm.A).apply(null,arguments)},qy=t._Cos=function(){return(qy=t._Cos=t.asm.B).apply(null,arguments)},Ky=t._CropAndResize=function(){return(Ky=t._CropAndResize=t.asm.C).apply(null,arguments)},Xy=t._Cumsum=function(){return(Xy=t._Cumsum=t.asm.D).apply(null,arguments)},Yy=t._DepthToSpace=function(){return(Yy=t._DepthToSpace=t.asm.E).apply(null,arguments)},Zy=t._DepthwiseConv2dNative=function(){return(Zy=t._DepthwiseConv2dNative=t.asm.F).apply(null,arguments)},Wa=t._Equal=function(){return(Wa=t._Equal=t.asm.G).apply(null,arguments)},cm=t._Exp=function(){return(cm=t._Exp=t.asm.H).apply(null,arguments)},pm=t._FlipLeftRight=function(){return(pm=t._FlipLeftRight=t.asm.I).apply(null,arguments)},Jy=t._Floor=function(){return(Jy=t._Floor=t.asm.J).apply(null,arguments)},Qy=t._FloorDiv=function(){return(Qy=t._FloorDiv=t.asm.K).apply(null,arguments)},eb=t._FusedBatchNorm=function(){return(eb=t._FusedBatchNorm=t.asm.L).apply(null,arguments)},tb=t._FusedConv2D=function(){return(tb=t._FusedConv2D=t.asm.M).apply(null,arguments)},rb=t._FusedDepthwiseConv2D=function(){return(rb=t._FusedDepthwiseConv2D=t.asm.N).apply(null,arguments)},Je=t._Gather=function(){return(Je=t._Gather=t.asm.O).apply(null,arguments)},nb=t._GatherNd=function(){return(nb=t._GatherNd=t.asm.P).apply(null,arguments)},ob=t._Greater=function(){return(ob=t._Greater=t.asm.Q).apply(null,arguments)},sb=t._GreaterEqual=function(){return(sb=t._GreaterEqual=t.asm.R).apply(null,arguments)},ib=t._LeakyRelu=function(){return(ib=t._LeakyRelu=t.asm.S).apply(null,arguments)},ab=t._Less=function(){return(ab=t._Less=t.asm.T).apply(null,arguments)},lb=t._LessEqual=function(){return(lb=t._LessEqual=t.asm.U).apply(null,arguments)},mm=t._Log=function(){return(mm=t._Log=t.asm.V).apply(null,arguments)},Oh=t._LogicalAnd=function(){return(Oh=t._LogicalAnd=t.asm.W).apply(null,arguments)},Ph=t._Max=function(){return(Ph=t._Max=t.asm.X).apply(null,arguments)},ub=t._MaxPool=function(){return(ub=t._MaxPool=t.asm.Y).apply(null,arguments)},cb=t._Maximum=function(){return(cb=t._Maximum=t.asm.Z).apply(null,arguments)},pb=t._Mean=function(){return(pb=t._Mean=t.asm._).apply(null,arguments)},mb=t._Min=function(){return(mb=t._Min=t.asm.$).apply(null,arguments)},fb=t._Minimum=function(){return(fb=t._Minimum=t.asm.aa).apply(null,arguments)},db=t._MirrorPad=function(){return(db=t._MirrorPad=t.asm.ba).apply(null,arguments)},hb=t._Multiply=function(){return(hb=t._Multiply=t.asm.ca).apply(null,arguments)},ft=t._Neg=function(){return(ft=t._Neg=t.asm.da).apply(null,arguments)},gb=t._NonMaxSuppressionV3=function(){return(gb=t._NonMaxSuppressionV3=t.asm.ea).apply(null,arguments)},xb=t._NonMaxSuppressionV4=function(){return(xb=t._NonMaxSuppressionV4=t.asm.fa).apply(null,arguments)},yb=t._NonMaxSuppressionV5=function(){return(yb=t._NonMaxSuppressionV5=t.asm.ga).apply(null,arguments)},nc=t._NotEqual=function(){return(nc=t._NotEqual=t.asm.ha).apply(null,arguments)},Mh=t._OneHot=function(){return(Mh=t._OneHot=t.asm.ia).apply(null,arguments)},Lh=t._PadV2=function(){return(Lh=t._PadV2=t.asm.ja).apply(null,arguments)},zh=t._Pow=function(){return(zh=t._Pow=t.asm.ka).apply(null,arguments)},bb=t._Prelu=function(){return(bb=t._Prelu=t.asm.la).apply(null,arguments)},wb=t._Prod=function(){return(wb=t._Prod=t.asm.ma).apply(null,arguments)},Bh=t._RealDiv=function(){return(Bh=t._RealDiv=t.asm.na).apply(null,arguments)},_b=t._Relu=function(){return(_b=t._Relu=t.asm.oa).apply(null,arguments)},Vh=t._Relu6=function(){return(Vh=t._Relu6=t.asm.pa).apply(null,arguments)},ja=t._ResizeBilinear=function(){return(ja=t._ResizeBilinear=t.asm.qa).apply(null,arguments)},kb=t._Reverse=function(){return(kb=t._Reverse=t.asm.ra).apply(null,arguments)},vb=t._RotateWithOffset=function(){return(vb=t._RotateWithOffset=t.asm.sa).apply(null,arguments)},EI=t._Round=function(){return(EI=t._Round=t.asm.ta).apply(null,arguments)},Gh=t._Rsqrt=function(){return(Gh=t._Rsqrt=t.asm.ua).apply(null,arguments)},Cb=t._ScatterNd=function(){return(Cb=t._ScatterNd=t.asm.va).apply(null,arguments)},Ib=t._SelectV2=function(){return(Ib=t._SelectV2=t.asm.wa).apply(null,arguments)},Nb=t._Sigmoid=function(){return(Nb=t._Sigmoid=t.asm.xa).apply(null,arguments)},Sb=t._Sin=function(){return(Sb=t._Sin=t.asm.ya).apply(null,arguments)},Tb=t._Softmax=function(){return(Tb=t._Softmax=t.asm.za).apply(null,arguments)},Ab=t._Sqrt=function(){return(Ab=t._Sqrt=t.asm.Aa).apply(null,arguments)},Eb=t._Square=function(){return(Eb=t._Square=t.asm.Ba).apply(null,arguments)},Db=t._SquaredDifference=function(){return(Db=t._SquaredDifference=t.asm.Ca).apply(null,arguments)},$b=t._Step=function(){return($b=t._Step=t.asm.Da).apply(null,arguments)},Rb=t._StridedSlice=function(){return(Rb=t._StridedSlice=t.asm.Ea).apply(null,arguments)},Fb=t._Sub=function(){return(Fb=t._Sub=t.asm.Fa).apply(null,arguments)},Ob=t._Sum=function(){return(Ob=t._Sum=t.asm.Ga).apply(null,arguments)},Pb=t._Tan=function(){return(Pb=t._Tan=t.asm.Ha).apply(null,arguments)},Mb=t._Tanh=function(){return(Mb=t._Tanh=t.asm.Ia).apply(null,arguments)},Lb=t._Tile=function(){return(Lb=t._Tile=t.asm.Ja).apply(null,arguments)},zb=t._TopK=function(){return(zb=t._TopK=t.asm.Ka).apply(null,arguments)},Bb=t._Transpose=function(){return(Bb=t._Transpose=t.asm.La).apply(null,arguments)},Vb=t.__FusedMatMul=function(){return(Vb=t.__FusedMatMul=t.asm.Ma).apply(null,arguments)},Gb=t._malloc=function(){return(Gb=t._malloc=t.asm.Na).apply(null,arguments)},Wb=t._free=function(){return(Wb=t._free=t.asm.Oa).apply(null,arguments)},Wh=t.___errno_location=function(){return(Wh=t.___errno_location=t.asm.Pa).apply(null,arguments)},jh=t.stackSave=function(){return(jh=t.stackSave=t.asm.Qa).apply(null,arguments)},Uh=t.stackRestore=function(){return(Uh=t.stackRestore=t.asm.Ra).apply(null,arguments)},fm=t.stackAlloc=function(){return(fm=t.stackAlloc=t.asm.Sa).apply(null,arguments)};t.cwrap=X;var oc;function jb(Z){this.name="ExitStatus",this.message="Program terminated with exit("+Z+")",this.status=Z}Rn=function Z(){oc||dm(),oc||(Rn=Z)};function dm(Z){if(Z=Z||i,_r>0||(cn(),_r>0))return;function se(){oc||(oc=!0,t.calledRun=!0,!G&&(Pr(),Un(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),sr()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),se()},1)):se()}if(t.run=dm,t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();return dm(),e.ready}}();typeof Nx=="object"&&typeof RC=="object"?RC.exports=FC:typeof define=="function"&&define.amd?define([],function(){return FC}):typeof Nx=="object"&&(Nx.WasmBackendModule=FC)});var IB=Ht((CB,hI)=>{(function(r,e,t){function n(i){var l=this,u=a();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(i),l.s0<0&&(l.s0+=1),l.s1-=u(i),l.s1<0&&(l.s1+=1),l.s2-=u(i),l.s2<0&&(l.s2+=1),u=null}function o(i,l){return l.c=i.c,l.s0=i.s0,l.s1=i.s1,l.s2=i.s2,l}function s(i,l){var u=new n(i),c=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,u),p.state=function(){return o(u,{})}),p}function a(){var i=4022871197,l=function(u){u=String(u);for(var c=0;c<u.length;c++){i+=u.charCodeAt(c);var p=.02519603282416938*i;i=p>>>0,p-=i,p*=i,i=p>>>0,p-=i,i+=p*4294967296}return(i>>>0)*23283064365386963e-26};return l}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(CB,typeof hI=="object"&&hI,typeof define=="function"&&define)});var SB=Ht((NB,gI)=>{(function(r,e,t){function n(a){var i=this,l="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var c=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^c^c>>>8},a===(a|0)?i.x=a:l+=a;for(var u=0;u<l.length+64;u++)i.x^=l.charCodeAt(u)|0,i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function s(a,i){var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(NB,typeof gI=="object"&&gI,typeof define=="function"&&define)});var AB=Ht((TB,xI)=>{(function(r,e,t){function n(a){var i=this,l="";i.next=function(){var c=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(c^c<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:l+=a;for(var u=0;u<l.length+64;u++)i.x^=l.charCodeAt(u)|0,u==l.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function s(a,i){var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(TB,typeof xI=="object"&&xI,typeof define=="function"&&define)});var DB=Ht((EB,yI)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var u=i.x,c=i.i,p,m,f;return p=u[c],p^=p>>>7,m=p^p<<24,p=u[c+1&7],m^=p^p>>>10,p=u[c+3&7],m^=p^p>>>3,p=u[c+4&7],m^=p^p<<7,p=u[c+7&7],p=p^p<<13,m^=p^p<<9,u[c]=m,i.i=c+1&7,m};function l(u,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],u.x=f,u.i=0,p=256;p>0;--p)u.next()}l(i,a)}function o(a,i){return i.x=a.x.slice(),i.i=a.i,i}function s(a,i){a==null&&(a=+new Date);var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.x&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(EB,typeof yI=="object"&&yI,typeof define=="function"&&define)});var RB=Ht(($B,bI)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var u=i.w,c=i.X,p=i.i,m,f;return i.w=u=u+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,i.i=p,f+(u^u>>>16)|0};function l(u,c){var p,m,f,d,h,g=[],x=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,x=Math.max(x,c.length)),f=0,d=-32;d<x;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;u.w=h,u.X=g,u.i=f}l(i,a)}function o(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function s(a,i){a==null&&(a=+new Date);var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(u.X&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})($B,typeof bI=="object"&&bI,typeof define=="function"&&define)});var OB=Ht((FB,wI)=>{(function(r,e,t){function n(a){var i=this,l="";i.next=function(){var c=i.b,p=i.c,m=i.d,f=i.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,i.b=c=c<<20^c>>>12^p,i.c=p=p-m|0,i.d=m<<16^p>>>16^f,i.a=f-c|0},i.a=0,i.b=0,i.c=2654435769|0,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):l+=a;for(var u=0;u<l.length+20;u++)i.b^=l.charCodeAt(u)|0,i.next()}function o(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function s(a,i){var l=new n(a),u=i&&i.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,m=(l.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(FB,typeof wI=="object"&&wI,typeof define=="function"&&define)});var MB=Ht((PB,wy)=>{(function(r,e,t){var n=256,o=6,s=52,a="random",i=t.pow(n,o),l=t.pow(2,s),u=l*2,c=n-1,p;function m(w,_,I){var E=[];_=_==!0?{entropy:!0}:_||{};var $=g(h(_.entropy?[w,b(e)]:w==null?x():w,3),E),D=new f(E),O=function(){for(var M=D.g(o),G=i,j=0;M<l;)M=(M+j)*n,G*=n,j=D.g(1);for(;M>=u;)M/=2,G/=2,j>>>=1;return(M+j)/G};return O.int32=function(){return D.g(4)|0},O.quick=function(){return D.g(4)/4294967296},O.double=O,g(b(D.S),e),(_.pass||I||function(M,G,j,U){return U&&(U.S&&d(U,D),M.state=function(){return d(D,{})}),j?(t[a]=M,G):M})(O,$,"global"in _?_.global:this==t,_.state)}function f(w){var _,I=w.length,E=this,$=0,D=E.i=E.j=0,O=E.S=[];for(I||(w=[I++]);$<n;)O[$]=$++;for($=0;$<n;$++)O[$]=O[D=c&D+w[$%I]+(_=O[$])],O[D]=_;(E.g=function(M){for(var G,j=0,U=E.i,H=E.j,q=E.S;M--;)G=q[U=c&U+1],j=j*n+q[c&(q[U]=q[H=c&H+G])+(q[H]=G)];return E.i=U,E.j=H,j})(n)}function d(w,_){return _.i=w.i,_.j=w.j,_.S=w.S.slice(),_}function h(w,_){var I=[],E=typeof w,$;if(_&&E=="object")for($ in w)try{I.push(h(w[$],_-1))}catch(D){}return I.length?I:E=="string"?w:w+"\0"}function g(w,_){for(var I=w+"",E,$=0;$<I.length;)_[c&$]=c&(E^=_[c&$]*19)+I.charCodeAt($++);return b(_)}function x(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(w)),b(w)}catch(E){var _=r.navigator,I=_&&_.plugins;return[+new Date,r,I,r.screen,b(e)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),e),typeof wy=="object"&&wy.exports){wy.exports=m;try{p=g_()}catch(w){}}else typeof define=="function"&&define.amd?define(function(){return m}):t["seed"+a]=m})(typeof self!="undefined"?self:PB,[],Math)});var _I=Ht((cWt,LB)=>{var bne=IB(),wne=SB(),_ne=AB(),kne=DB(),vne=RB(),Cne=OB(),ec=MB();ec.alea=bne;ec.xor128=wne;ec.xorwow=_ne;ec.xorshift7=kne;ec.xor4096=vne;ec.tychei=Cne;LB.exports=ec});var mV=Ht(()=>{});var bm={};We(bm,{bin:()=>JI,browser:()=>oN,default:()=>xG,dependencies:()=>nN,description:()=>jI,devDependencies:()=>tN,jsdelivr:()=>KI,license:()=>eN,main:()=>HI,miniprogram:()=>ZI,module:()=>qI,name:()=>GI,private:()=>UI,repository:()=>QI,scripts:()=>rN,types:()=>YI,unpkg:()=>XI,version:()=>WI});var GI="@tensorflow/tfjs",WI="3.5.0",jI="An open-source machine learning framework.",UI=!1,HI="dist/tf.node.js",qI="dist/index.js",KI="dist/tf.min.js",XI="dist/tf.min.js",YI="dist/index.d.ts",ZI="dist/miniprogram",JI={"tfjs-custom-module":"dist/tools/custom_module/cli.js"},QI={type:"git",url:"https://github.com/tensorflow/tfjs.git"},eN="Apache-2.0",tN={"@babel/core":"^7.9.0","@babel/polyfill":"^7.10.4","@babel/preset-env":"^7.9.5","@rollup/plugin-commonjs":"^11.0.2","@rollup/plugin-node-resolve":"^7.1.1","@rollup/plugin-typescript":"^3.0.0","@types/argparse":"^1.0.38","@types/jasmine":"2.8.7","@types/node":"~10.17.50","@types/shelljs":"^0.8.4","@types/yargs":"^15.0.7","clang-format":"~1.2.2",commander:"~2.14.1",jasmine:"3.1.0","jasmine-core":"~3.1.0",karma:"~6.3.2","karma-browserstack-launcher":"~1.6.0","karma-chrome-launcher":"~2.2.0","karma-firefox-launcher":"~1.1.0","karma-jasmine":"~1.1.1","karma-typescript":"~5.5.1","karma-typescript-es6-transform":"^5.5.1","npm-run-all":"~4.1.3",rimraf:"~2.6.2",rollup:"~2.3.2","rollup-plugin-babel":"^4.4.0","rollup-plugin-terser":"~7.0.2","rollup-plugin-visualizer":"~4.2.2",shelljs:"~0.8.1","ts-node":"~8.8.2",tslint:"~5.11.0","tslint-no-circular-imports":"~0.5.0",typescript:"3.5.3",yalc:"1.0.0-pre.50"},rN={build:"tsc && yarn build-cli && yarn bundle","build-ci":"tsc && yarn build-cli && yarn bundle-ci",bundle:"rollup -c","bundle-ci":"rollup -c --ci","build-core":"cd ../tfjs-core && yarn && yarn build","build-core-ci":"cd ../tfjs-core && yarn && yarn build-ci","build-layers":"cd ../tfjs-layers && yarn && yarn build","build-layers-ci":"cd ../tfjs-layers && yarn && yarn build-ci","build-converter":"cd ../tfjs-converter && yarn && yarn build","build-converter-ci":"cd ../tfjs-converter && yarn && yarn build-ci","build-data":"cd ../tfjs-data && yarn && yarn build","build-data-ci":"cd ../tfjs-data && yarn && yarn build-ci","build-backend-cpu":"cd ../tfjs-backend-cpu && yarn && yarn build","build-backend-cpu-ci":"cd ../tfjs-backend-cpu && yarn && yarn build-ci","build-backend-webgl":"cd ../tfjs-backend-webgl && yarn && yarn build","build-backend-webgl-ci":"cd ../tfjs-backend-webgl && yarn && yarn build-ci","build-deps":"yarn build-core && yarn build-layers && yarn build-converter && yarn build-data && yarn build-backend-cpu && yarn build-backend-webgl","build-deps-ci":"yarn build-core-ci && yarn build-layers-ci && yarn build-converter-ci && yarn build-data-ci && yarn build-backend-cpu-ci && yarn build-backend-webgl-ci","build-cli":"tsc --project ./tools/custom_module/tsconfig.json && chmod +x ./dist/tools/custom_module/cli.js","run-custom-build":"ts-node -s ./tools/custom_module/cli.ts","build-npm":"./scripts/build-npm.sh","link-local":"yalc link","publish-local":"yarn build-npm && yalc push","publish-npm":"npm publish",lint:"tslint -p . -t verbose",test:"yarn && yarn build-deps && yarn build && karma start","test-dev":"karma start","test-tools":"ts-node --project ./tools/custom_module/tsconfig.json run_tools_tests.ts","test-ci":"./scripts/test-ci.sh"},nN={"@tensorflow/tfjs-backend-cpu":"3.5.0","@tensorflow/tfjs-backend-webgl":"3.5.0","@tensorflow/tfjs-converter":"3.5.0","@tensorflow/tfjs-core":"3.5.0","@tensorflow/tfjs-data":"3.5.0","@tensorflow/tfjs-layers":"3.5.0",argparse:"^1.0.10",chalk:"^4.1.0","core-js":"3","regenerator-runtime":"^0.13.5",yargs:"^16.0.3"},oN={"node-fetch":!1,util:!1,crypto:!1},xG={name:GI,version:WI,description:jI,private:UI,main:HI,module:qI,jsdelivr:KI,unpkg:XI,types:YI,miniprogram:ZI,bin:JI,repository:QI,license:eN,devDependencies:tN,scripts:rN,dependencies:nN,browser:oN};var wm={};We(wm,{browser:()=>kN,default:()=>yG,dependencies:()=>_N,description:()=>aN,devDependencies:()=>bN,engines:()=>gN,jsdelivr:()=>cN,"jsnext:main":()=>fN,license:()=>yN,main:()=>uN,miniprogram:()=>hN,module:()=>dN,name:()=>sN,private:()=>lN,repository:()=>xN,scripts:()=>wN,sideEffects:()=>vN,types:()=>mN,unpkg:()=>pN,version:()=>iN});var sN="@tensorflow/tfjs-core",iN="3.5.0",aN="Hardware-accelerated JavaScript library for machine intelligence",lN=!1,uN="dist/tf-core.node.js",cN="dist/tf-core.min.js",pN="dist/tf-core.min.js",mN="dist/index.d.ts",fN="dist/index.js",dN="dist/index.js",hN="dist/miniprogram",gN={yarn:">= 1.3.2"},xN={type:"git",url:"https://github.com/tensorflow/tfjs-core.git"},yN="Apache-2.0",bN={"@bazel/bazelisk":"^1.3.0","@bazel/typescript":"^0.27.8","@rollup/plugin-commonjs":"^11.0.2","@rollup/plugin-node-resolve":"^7.1.1","@rollup/plugin-typescript":"^3.0.0","@tensorflow/tfjs-backend-cpu":"link:../tfjs-backend-cpu","@types/jasmine":"~3.0.0","@types/node":"~9.6.0","@types/node-fetch":"~2.1.2","clang-format":"~1.2.4",jasmine:"~3.1.0","jasmine-core":"~3.1.0",karma:"6.3.1","karma-browserstack-launcher":"~1.6.0","karma-chrome-launcher":"~2.2.0","karma-jasmine":"~1.1.0","karma-typescript":"~4.1.1","npm-run-all":"~4.1.3",rimraf:"~2.6.2",rollup:"~2.3.2","rollup-plugin-terser":"~5.3.0","rollup-plugin-visualizer":"~3.3.2",shelljs:"~0.8.3","ts-node":"~8.8.2",tslint:"~5.11.0","tslint-no-circular-imports":"~0.5.0",typescript:"3.5.3",yalc:"~1.0.0-pre.21",yargs:"~13.2.2"},wN={"build-ci":"./scripts/enumerate-tests.js --ci && tsc && yarn bundle-ci && yarn build-test-snippets",build:"node ./scripts/enumerate-tests.js && tsc && yarn bundle",bundle:"rollup -c","bundle-ci":"rollup -c --ci","build-npm":"./scripts/build-npm.sh","build-deps":"yarn build && yarn build-cpu-backend","build-cpu-backend":"cd ../tfjs-backend-cpu && yarn && yarn build","build-cpu-backend-ci":"cd ../tfjs-backend-cpu && yarn && yarn build-ci","build:bazel":"bazelisk build //...","build-test-snippets":"yarn tsc --project ./scripts/test_snippets/tsconfig.json","format-all":"clang-format -i -style=Google --glob=src/**/*.ts","link-local":"yalc link","publish-local":"rimraf dist/ && yarn build && rollup -c && yalc push","publish-npm":"npm publish",lint:"tslint -p . -t verbose",coverage:"KARMA_COVERAGE=1 karma start --browsers='Chrome' --singleRun",test:"yarn && yarn build-deps && karma start","test-dev":"karma start","test-ci":"./scripts/test-ci.sh","test-webworker":"karma start --worker","run-browserstack":"karma start --browserstack","test-bundle-size":"./scripts/test-bundle-size.js","test-node":"rimraf dist/ && yarn build-deps && yarn build && ts-node --transpile-only --skip-ignore -P tsconfig.test.json dist/test_node.js","test-node-dev":"tsc && ts-node --transpile-only --skip-ignore -P tsconfig.test.json dist/test_node.js","test-node-ci":"ts-node --transpile-only -P tsconfig.test.json  dist/test_node.js","test-async-backends":"rimraf dist/ && yarn build && ts-node --transpile-only -P tsconfig.test.json dist/test_async_backends.js","test-async-backends-ci":"ts-node --transpile-only -P tsconfig.test.json dist/test_async_backends.js","test-snippets":"yarn build && yarn build-cpu-backend && ts-node -P tsconfig.test.json ./scripts/test_snippets/test_snippets.ts","test-snippets-ci":"ts-node -P tsconfig.test.json ./scripts/test_snippets/test_snippets.ts"},_N={"@types/offscreencanvas":"~2019.3.0","@types/seedrandom":"2.4.27","@types/webgl-ext":"0.0.30","node-fetch":"~2.6.1",seedrandom:"2.4.3"},kN={"node-fetch":!1,util:!1,crypto:!1,worker_threads:!1},vN=["./dist/index.js","./dist/engine.js","./dist/tensor.js","./dist/base_side_effects.js","./dist/flags.js","./dist/platforms/*.js","./dist/register_all_gradients.js","./dist/public/chained_ops/*.js","./dist/io/*.js"],yG={name:sN,version:iN,description:aN,private:lN,main:uN,jsdelivr:cN,unpkg:pN,types:mN,"jsnext:main":fN,module:dN,miniprogram:hN,engines:gN,repository:xN,license:yN,devDependencies:bN,scripts:wN,dependencies:_N,browser:kN,sideEffects:vN};var _m={};We(_m,{browser:()=>BN,default:()=>bG,dependencies:()=>zN,description:()=>NN,devDependencies:()=>PN,jsdelivr:()=>AN,"jsnext:main":()=>$N,license:()=>ON,main:()=>TN,miniprogram:()=>FN,module:()=>RN,name:()=>CN,peerDependencies:()=>LN,private:()=>SN,scripts:()=>MN,types:()=>DN,unpkg:()=>EN,version:()=>IN});var CN="@tensorflow/tfjs-data",IN="3.5.0",NN="TensorFlow Data API in JavaScript",SN=!1,TN="dist/tf-data.node.js",AN="dist/tf-data.min.js",EN="dist/tf-data.min.js",DN="dist/index.d.ts",$N="dist/index.js",RN="dist/index.js",FN="dist/miniprogram",ON="Apache-2.0",PN={"@rollup/plugin-commonjs":"^11.0.2","@rollup/plugin-node-resolve":"^7.1.1","@rollup/plugin-typescript":"^3.0.0","@tensorflow/tfjs-backend-cpu":"3.5.0","@tensorflow/tfjs-core":"3.5.0","@tensorflow/tfjs-layers":"3.5.0","@types/jasmine":"~2.5.53","@types/seedrandom":"^2.4.27","@types/utf8":"~2.1.6","clang-format":"~1.2.2","http-server":"~0.12.3",jasmine:"3.1.0","jasmine-core":"~3.1.0",karma:"~6.3.1","karma-chrome-launcher":"~2.2.0","karma-firefox-launcher":"~1.1.0","karma-jasmine":"~1.1.1","karma-typescript":"~5.5.1","karma-typescript-es6-transform":"^5.0.2",rimraf:"~2.6.2",rollup:"~2.3.2","rollup-plugin-terser":"~7.0.2","rollup-plugin-visualizer":"~3.3.2","ts-node":"~7.0.0",tslint:"~6.1.3","tslint-no-circular-imports":"^0.7.0",typescript:"3.5.3",yalc:"^1.0.0-pre.50"},MN={build:"tsc && yarn bundle","build-ci":"tsc && yarn bundle-ci",bundle:"rollup -c","bundle-ci":"rollup -c --ci","build-core":"cd ../tfjs-core && yarn && yarn build","build-core-ci":"cd ../tfjs-core && yarn && yarn build-ci","build-layers":"cd ../tfjs-layers && yarn && yarn build","build-backend-cpu":"cd ../tfjs-backend-cpu && yarn && yarn build","build-backend-cpu-ci":"cd ../tfjs-backend-cpu && yarn && yarn build-ci","build-layers-ci":"cd ../tfjs-layers && yarn && yarn build-ci","build-deps":"yarn build-core && yarn build-layers && yarn build-backend-cpu","build-deps-ci":"yarn build-core-ci && yarn build-layers-ci && yarn build-backend-cpu-ci","build-npm":"./scripts/build-npm.sh","link-local":"yalc link","publish-local":"rimraf dist/ && yarn build-npm && yalc push","publish-npm":"npm publish",test:"yarn && yarn build-deps && yarn build && ts-node --transpile-only --project tsconfig.test.json src/test_node.ts","test-dev":"tsc && ts-node --transpile-only --project tsconfig.test.json src/test_node.ts","test-browsers":"karma start --browsers='Chrome,Firefox'","test-ci":"ts-node --transpile-only --skip-ignore -P tsconfig.test.json src/test_node.ts","test-snippets":"yarn && yarn build-deps && yarn build && ts-node --skip-ignore --project tsconfig.test.json ./scripts/test_snippets.ts","test-snippets-ci":"ts-node --skip-ignore --project tsconfig.test.json ./scripts/test_snippets.ts",lint:"tslint -p . -t verbose"},LN={"@tensorflow/tfjs-core":"3.5.0",seedrandom:"~2.4.3"},zN={"@types/node-fetch":"^2.1.2","node-fetch":"~2.6.1"},BN={fs:!1,"node-fetch":!1,string_decoder:!1,crypto:!1},bG={name:CN,version:IN,description:NN,private:SN,main:TN,jsdelivr:AN,unpkg:EN,types:DN,"jsnext:main":$N,module:RN,miniprogram:FN,license:ON,devDependencies:PN,scripts:MN,peerDependencies:LN,dependencies:zN,browser:BN};var km={};We(km,{default:()=>wG,description:()=>WN,devDependencies:()=>QN,jsdelivr:()=>YN,"jsnext:main":()=>KN,license:()=>jN,main:()=>HN,miniprogram:()=>JN,module:()=>XN,name:()=>VN,peerDependencies:()=>tS,private:()=>UN,scripts:()=>eS,types:()=>qN,unpkg:()=>ZN,version:()=>GN});var VN="@tensorflow/tfjs-layers",GN="3.5.0",WN="TensorFlow layers API in JavaScript",jN="Apache-2.0 AND MIT",UN=!1,HN="dist/tf-layers.node.js",qN="dist/index.d.ts",KN="dist/index.js",XN="dist/index.js",YN="dist/tf-layers.min.js",ZN="dist/tf-layers.min.js",JN="dist/miniprogram",QN={"@babel/polyfill":"^7.8.7","@rollup/plugin-commonjs":"^11.0.2","@rollup/plugin-node-resolve":"^7.1.1","@rollup/plugin-typescript":"^3.0.0","@tensorflow/tfjs-backend-cpu":"3.5.0","@tensorflow/tfjs-backend-webgl":"3.5.0","@tensorflow/tfjs-core":"3.5.0","@types/jasmine":"~2.5.53","clang-format":"~1.2.2","http-server":"~0.12.3",jasmine:"~3.1.0","jasmine-core":"~3.1.0",karma:"~6.3.1","karma-browserstack-launcher":"~1.6.0","karma-chrome-launcher":"~2.2.0","karma-firefox-launcher":"~1.1.0","karma-jasmine":"~1.1.1","karma-typescript":"~5.5.1","karma-typescript-es6-transform":"^5.0.2",rimraf:"~2.6.2",rollup:"~2.3.2","rollup-plugin-terser":"~7.0.2","rollup-plugin-visualizer":"~3.3.2","ts-node":"~8.8.2",tslint:"~6.1.3","tslint-no-circular-imports":"^0.7.0",typescript:"3.5.3",yalc:"~1.0.0-pre.50"},eS={prep:"yarn install && yarn build-ci",build:"tsc && yarn bundle","build-ci":"tsc && yarn bundle-ci",bundle:"rollup -c","bundle-ci":"rollup -c --ci","build-core":"cd ../tfjs-core && yarn && yarn build","build-backend-cpu":"cd ../tfjs-backend-cpu && yarn && yarn build","build-backend-cpu-ci":"cd ../tfjs-backend-cpu && yarn && yarn build-ci","build-backend-webgl":"cd ../tfjs-backend-webgl && yarn && yarn build","build-backend-webgl-ci":"cd ../tfjs-backend-webgl && yarn && yarn build-ci","build-core-ci":"cd ../tfjs-core && yarn && yarn build-ci","build-deps":"yarn build-core && yarn build-backend-cpu && yarn build-backend-webgl","build-deps-ci":"yarn build-core-ci && yarn build-backend-cpu-ci && yarn build-backend-webgl-ci","build-npm":"./scripts/build-npm.sh",format:"./tools/clang_format_ts.sh","link-local":"yalc link","publish-local":"yarn build-npm && yalc push","publish-npm":"npm publish",test:"yarn && yarn build-deps && karma start","test-dev":"karma start","test-ci":"./scripts/test-ci.sh","test-snippets":"yarn && yarn build-deps && yarn build && ts-node --skip-ignore -s ./scripts/test_snippets.ts","test-snippets-ci":"ts-node --skip-ignore -s ./scripts/test_snippets.ts","run-browserstack":"karma start --browsers='bs_chrome_mac' --singleRun --reporters='dots,karma-typescript'",lint:"tslint -p . -t verbose"},tS={"@tensorflow/tfjs-core":"3.5.0"},wG={name:VN,version:GN,description:WN,license:jN,private:UN,main:HN,types:qN,"jsnext:main":KN,module:XN,jsdelivr:YN,unpkg:ZN,miniprogram:JN,devDependencies:QN,scripts:eS,peerDependencies:tS};var vm={};We(vm,{default:()=>_G,description:()=>oS,devDependencies:()=>hS,jsdelivr:()=>cS,"jsnext:main":()=>iS,license:()=>fS,main:()=>sS,miniprogram:()=>pS,module:()=>aS,name:()=>rS,peerDependencies:()=>dS,repository:()=>mS,scripts:()=>gS,types:()=>lS,unpkg:()=>uS,version:()=>nS});var rS="@tensorflow/tfjs-converter",nS="3.5.0",oS="Tensorflow model converter for javascript",sS="dist/tf-converter.node.js",iS="dist/index.js",aS="dist/index.js",lS="dist/index.d.ts",uS="dist/tf-converter.min.js",cS="dist/tf-converter.min.js",pS="dist/miniprogram",mS={type:"git",url:"https://github.com/tensorflow/tfjs-converter.git"},fS="Apache-2.0",dS={"@tensorflow/tfjs-core":"3.5.0"},hS={"@rollup/plugin-commonjs":"^11.0.2","@rollup/plugin-node-resolve":"^7.1.1","@rollup/plugin-replace":"^2.3.3","@rollup/plugin-typescript":"^3.0.0","@tensorflow/tfjs-backend-cpu":"3.5.0","@tensorflow/tfjs-core":"3.5.0","@types/argparse":"^1.0.38","@types/deep-equal":"^1.0.1","@types/jasmine":"~2.8.6","@types/long":"~3.0.32","@types/node-fetch":"1.6.9",ajv:"~6.3.0",argparse:"^1.0.10","babel-core":"~6.26.3","babel-plugin-external-helpers":"~6.22.0","babel-preset-env":"~1.7.0","clang-format":"~1.2.2",copyfiles:"~1.2.0","deep-equal":"^1.0.1","jasmine-core":"~3.5.0","node-fetch":"~2.6.1",opn:"~5.1.0",protobufjs:"~6.8.6",rimraf:"~2.6.2",rollup:"~2.3.2","rollup-plugin-terser":"~7.0.2","rollup-plugin-visualizer":"~3.3.2","ts-morph":"^7.1.3","ts-node":"~8.8.2",tslint:"~6.1.3","tslint-no-circular-imports":"~0.7.0",typescript:"3.5.3",yalc:"~1.0.0-pre.50"},gS={build:"yarn gen-json --test && yarn gen-kernel2ops && tsc && yarn bundle","build-ci":"yarn gen-json --test && yarn gen-kernel2ops && tsc && yarn bundle-ci",bundle:"rollup -c","bundle-ci":"rollup -c --ci","build-core":"cd ../tfjs-core && yarn && yarn build","build-backend-cpu":"cd ../tfjs-backend-cpu && yarn && yarn build","build-backend-cpu-ci":"cd ../tfjs-backend-cpu && yarn && yarn build-ci","build-core-ci":"cd ../tfjs-core && yarn && yarn build-ci","build-deps":"yarn build-core && yarn build-backend-cpu","build-deps-ci":"yarn build-core-ci && yarn build-backend-cpu","build-npm":"./scripts/build-npm.sh","link-local":"yalc link","publish-local":"yarn build-npm && yalc push","publish-npm":"npm publish",test:"yarn && yarn build-deps && yarn build && yarn gen-json --test && yarn gen-kernel2ops && ts-node --transpile-only -P tsconfig.test.json src/run_tests.ts","test-ci":"ts-node --transpile-only --skip-ignore -P tsconfig.test.json src/run_tests.ts","test-dev":"tsc && ts-node --transpile-only -P tsconfig.test.json src/run_tests.ts","test-snippets":"yarn && yarn build-deps && yarn build && ts-node --skip-ignore -s ./scripts/test_snippets.ts","test-snippets-ci":"ts-node --skip-ignore -s ./scripts/test_snippets.ts",lint:"tslint -p . -t verbose","make-version":"sh -c ./scripts/make-version","gen-doc":"ts-node -s ./scripts/gen_doc.ts","gen-json":"ts-node -s ./scripts/gen_json.ts","model-summary":"ts-node -s ./tools/model_summary.ts",pb2json:"ts-node -s ./tools/pb2json_converter.ts","build-pip-package":"yarn gen-json --test && cd python && ./build-pip-package.sh --test /tmp/tfjs-pips","run-python-tests":"yarn gen-json --test && cd python && ./run-python-tests.sh","gen-kernel2ops":"ts-node -s scripts/kernels_to_ops.ts --out metadata/kernel2op.json"},_G={name:rS,version:nS,description:oS,main:sS,"jsnext:main":iS,module:aS,types:lS,unpkg:uS,jsdelivr:cS,miniprogram:pS,repository:mS,license:fS,peerDependencies:dS,devDependencies:hS,scripts:gS};var kG=1e-7,vG=1e-4,qa=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Ps=class{refCount(e){return Hn("refCount")}incRef(e){return Hn("incRef")}timerAvailable(){return!0}time(e){return Hn("time")}read(e){return Hn("read")}readSync(e){return Hn("readSync")}numDataIds(){return Hn("numDataIds")}disposeData(e,t){return Hn("disposeData")}write(e,t,n){return Hn("write")}move(e,t,n,o,s){return Hn("move")}memory(){return Hn("memory")}floatPrecision(){return Hn("floatPrecision")}epsilon(){return this.floatPrecision()===32?kG:vG}dispose(){return Hn("dispose")}};function Hn(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function xS(r){let e=r.length,t=0,n=0;for(;e>0;)n=Math.random()*e|0,e--,t=r[e],r[e]=r[n],r[n]=t}function CG(r,e){if(r.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${e.length}`);let t=r.length,n,o,s=0;for(;t>0;)s=Math.random()*t|0,t--,n=r[t],o=e[t],r[t]=r[s],e[t]=e[s],r[s]=n,e[s]=o}function mc(r,e,t){return Math.max(r,Math.min(e,t))}function IG(r){return r%2==0?r:r+1}function NG(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function SG(r,e){let t=Math.random();return e*t+(1-t)*r}function TG(r,e){let t=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(e[n]);t+=o*o}return t}function T(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function At(r,e,t=""){T(Xr(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function Fn(r){T(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function bo(r,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(r)||ir(r)&&!t)for(let n=0;n<r.length;++n)bo(r[n],e,t);else e.push(r);return e}function nt(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function AG(r){return r.length===0}function Xr(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function ot(r){return r%1==0}function EG(r){if(Math.tanh!=null)return Math.tanh(r);if(r===Infinity)return 1;if(r===-Infinity)return-1;{let e=Math.exp(2*r);return(e-1)/(e+1)}}function DG(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}function $G(r){let e=new Uint32Array(r);for(let t=0;t<r;++t)e[t]=t;return xS(e),e}function Gl(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function RG(r,e=n=>0,t){return new Promise((n,o)=>{let s=0,a=()=>{if(r()){n();return}s++;let i=e(s);if(t!=null&&s>=t){o();return}setTimeout(a,i)};a()})}function FG(r,e){let t=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let o=r.slice();return o[n]=e/t,o}function tr(r,e){let t=e.length;return r=r==null?e.map((n,o)=>o):[].concat(r),T(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),T(r.every(n=>ot(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function Xb(r,e){let t=[],n=[],o=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||o?null:tr(e,r).sort(),a=0;for(let i=0;i<r.length;++i){if(s!=null){if(s[a]===i&&r[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${r[i]}' is not 1`);(s[a]==null||s[a]>i)&&r[i]===1&&(t.push(r[i]),n.push(i)),s[a]<=i&&a++}r[i]!==1&&(t.push(r[i]),n.push(i))}return{newShape:t,keptDims:n}}function Yb(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${r}`);return t}function Zb(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function Jb(r,e){for(let t=0;t<r.length;t++){let n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function Qb(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function OG(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function ir(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array}function Yh(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function ew(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function wo(r){return typeof r=="string"||r instanceof String}function yS(r){return typeof r=="boolean"}function bS(r){return typeof r=="number"}function fc(r){return Array.isArray(r)?fc(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array?"int32":bS(r)?"float32":wo(r)?"string":yS(r)?"bool":"float32"}function Ms(r){return!!(r&&r.constructor&&r.call&&r.apply)}function dc(r,e){for(let t=e;t<r;++t)if(r%t==0)return t;return r}function Ls(r){let e=r.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function wS(r,e,t,n=!1){let o=new Array;if(e.length===1){let s=e[0]*(n?2:1);for(let a=0;a<s;a++)o[a]=t[r+a]}else{let s=e[0],a=e.slice(1),i=a.reduce((l,u)=>l*u)*(n?2:1);for(let l=0;l<s;l++)o[l]=wS(r+l*i,a,t,n)}return o}function Wl(r,e,t=!1){if(r.length===0)return e[0];let n=r.reduce((o,s)=>o*s)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return wS(0,r,e,t)}function Cm(r,e){let t=hc(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function hc(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function PG(r,e){let t=r.reduce((n,o)=>n*o,1);if(e==null||e==="float32")return Wl(r,new Float32Array(t));if(e==="int32")return Wl(r,new Int32Array(t));if(e==="bool")return Wl(r,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Im(r){r.forEach(e=>{T(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function MG(r,e,t){if(e===0)return 0;if(e===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=t[o]*r[o];return n}function LG(r,e,t){if(e===0)return[];if(e===1)return[r];let n=new Array(e);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/t[o]),r-=n[o]*t[o];return n[n.length-1]=r,n}function Nm(r){return r&&r.then&&typeof r.then=="function"}var _S="tfjsflags",Zh=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=zG,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let o=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Nm(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let e=this.getQueryParams(this.global.location.search);_S in e&&e[_S].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=BG(o,s)})}};function zG(r){let e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(VG(e,n[0],n[1]),n.join("="))),e}function VG(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function BG(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function W(){return tw}var tw=null;function kS(r){tw=r}var rw;function nw(){if(rw==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");rw=r}return rw}function GG(){let r=nw();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function Sm(r,e){let t=GG();if(t.has(r))return t.get(r);{let n=e();return t.set(r,n),t.get(r)}}var zs="Abs",_i="Acos",ki="Acosh",On="Add",_o="AddN",vi="All",Ci="Any",ko="ArgMax",Ka="ArgMin",Ii="Asin",Ni="Asinh",Si="Atan",Ti="Atanh",Ai="Atan2",vo="AvgPool",gc="AvgPoolGrad",Xa="AvgPool3D",xc="AvgPool3DGrad",Co="BatchMatMul",Ya="BatchToSpaceND",yc="Bincount",vS="BroadcastTo",qn="Cast",Io="Ceil",Kn="ClipByValue",bc="Complex",Za="ComplexAbs",Bs="Concat",No="Conv2D",wc="Conv2DBackpropFilter",So="Conv2DBackpropInput",Ja="Conv3D",_c="Conv3DBackpropFilterV2",kc="Conv3DBackpropInputV2",To="Cos",Ei="Cosh",Ao="Cumsum",Di="CropAndResize",vc="DenseBincount",$i="DepthToSpace",Eo="DepthwiseConv2dNative",Cc="DepthwiseConv2dNativeBackpropFilter",Ic="DepthwiseConv2dNativeBackpropInput",Nc="Diag",Qa="Dilation2D",Tm="Dilation2DBackpropInput",Am="Dilation2DBackpropFilter",Do="RealDiv",Sc="Einsum",Ri="Elu",Tc="EluGrad",Fi="Erf",Oi="Equal",$o="Exp",Vs="ExpandDims",Pi="Expm1",Ac="FFT",el="Fill",Mi="FlipLeftRight",Ro="Floor",Fo="FloorDiv",Oo="FusedBatchNorm",Gs="GatherV2",Li="GatherNd",zi="Greater",Po="GreaterEqual",Xn="Identity",Ec="IFFT",Dc="Imag",Bi="IsFinite",Vi="IsInf",Gi="IsNan",Mo="LeakyRelu",Wi="Less",ji="LessEqual",$c="LinSpace",Lo="Log",Ui="Log1p",Hi="LogicalAnd",jl="LogicalNot",Ul="LogicalOr",CS="LogSoftmax",tl="LRN",Rc="LRNGrad",zo="Max",Bo="Maximum",Vo="MaxPool",Fc="MaxPoolGrad",rl="MaxPool3D",Oc="MaxPool3DGrad",Pc="MaxPoolWithArgmax",Go="Mean",Wo="Min",jo="Minimum",Uo="MirrorPad",qi="Mod",Mc="Multinomial",Ho="Multiply",Ws="Neg",Ki="NotEqual",Xi="NonMaxSuppressionV3",Yi="NonMaxSuppressionV4",Zi="NonMaxSuppressionV5",js="OnesLike",qo="OneHot",Us="Pack",Ko="PadV2",Mne="Pool",Xo="Pow",Yo="Prelu",Ji="Prod",nl="Range",Lc="Real",Qi="Reciprocal",Zo="Relu",Hs="Reshape",ol="ResizeNearestNeighbor",zc="ResizeNearestNeighborGrad",Jo="ResizeBilinear",Bc="ResizeBilinearGrad",Qo="Relu6",es="Reverse",ts="Round",rs="Rsqrt",ea="ScatterNd",qs="Select",ta="Selu",Ks="Slice",ns="Sin",ra="Sinh",na="Sign",os="Sigmoid",oa="Softplus",ss="Sqrt",is="Sum",sl="SpaceToBatchND",Xs="SplitV",as="Softmax",Vc="SparseReshape",Gc="SparseToDense",ls="SquaredDifference",il="Square",sa="StridedSlice",us="Sub",cs="Tan",ps="Tanh",Pn="Tile",ia="TopK",Wc="Transform",ms="Transpose",jc="Unique",Ys="Unpack",al="UnsortedSegmentSum",Zs="ZerosLike",Yn="Step",Em="FromPixels",aa="RotateWithOffset",Js="_FusedMatMul",Qs="FusedConv2D",ei="FusedDepthwiseConv2D";var Uc=Sm("kernelRegistry",()=>new Map),Dm=Sm("gradRegistry",()=>new Map);function $m(r,e){let t=ow(r,e);return Uc.get(t)}function sw(r){return Dm.get(r)}function Jh(r){let e=Uc.entries(),t=[];for(;;){let{done:n,value:o}=e.next();if(n)break;let[s,a]=o,[i]=s.split("_");i===r&&t.push(a)}return t}function Hl(r){let{kernelName:e,backendName:t}=r,n=ow(e,t);Uc.has(n)&&console.warn(`The kernel '${e}' for backend '${t}' is already registered`),Uc.set(n,r)}function IS(r){let{kernelName:e}=r;Dm.has(e)&&W().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),Dm.set(e,r)}function Vne(r,e){let t=ow(r,e);if(!Uc.has(t))throw new Error(`The kernel '${r}' for backend '${e}' is not registered`);Uc.delete(t)}function Gne(r){if(!Dm.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);Dm.delete(r)}function Wne(r,e){Jh(r).forEach(n=>{let o=Object.assign({},n,{backendName:e});Hl(o)})}function ow(r,e){return`${e}_${r}`}var y={};We(y,{arraysEqual:()=>Xr,assert:()=>T,assertNonNegativeIntegerDimensions:()=>Im,assertNonNull:()=>Fn,assertShapesMatch:()=>At,bytesFromStringArray:()=>ew,bytesPerElement:()=>Yh,checkConversionForErrors:()=>Jb,clamp:()=>mc,computeStrides:()=>Ls,createScalarValue:()=>WG,createShuffledIndices:()=>$G,decodeString:()=>qc,distSquared:()=>TG,encodeString:()=>ll,fetch:()=>UG,flatten:()=>bo,getArrayFromDType:()=>Zb,getTypedArrayFromDType:()=>Yb,hasEncodingLoss:()=>OG,indexToLoc:()=>LG,inferDtype:()=>fc,inferFromImplicitShape:()=>FG,isBoolean:()=>yS,isFunction:()=>Ms,isInt:()=>ot,isNumber:()=>bS,isPromise:()=>Nm,isScalarShape:()=>AG,isString:()=>wo,isTypedArray:()=>ir,isValidDtype:()=>Qb,locToIndex:()=>MG,makeOnesTypedArray:()=>Cm,makeZerosNestedTypedArray:()=>PG,makeZerosTypedArray:()=>hc,nearestDivisor:()=>dc,nearestLargerEven:()=>IG,now:()=>ql,parseAxisParam:()=>tr,randUniform:()=>SG,repeatedTry:()=>RG,rightPad:()=>Gl,shuffle:()=>xS,shuffleCombo:()=>CG,sizeFromShape:()=>nt,sizeToSquarishShape:()=>DG,squeezeShape:()=>Xb,sum:()=>NG,tanh:()=>EG,toNestedArray:()=>Wl,toTypedArray:()=>Hc});function WG(r,e){return e==="string"?ll(r):Hc([r],e)}function jG(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Hc(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=bo(r)),W().getBool("DEBUG")&&Jb(r,e),jG(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){let t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function ql(){return W().platform.now()}function UG(r,e){return W().platform.fetch(r,e)}function ll(r,e="utf-8"){return e=e||"utf-8",W().platform.encode(r,e)}function qc(r,e="utf-8"){return e=e||"utf-8",W().platform.decode(r,e)}var iw=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new NS)}profileKernel(e,t,n){let o,s=()=>{o=n()},a,i=ql();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let u of o)u.dataSync();a=Promise.resolve({kernelMs:ql()-i})}if(W().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<o.length;u++){let c=o[u];c.data().then(p=>{HG(p,c.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:o,inputs:s,extraInfo:a}=e;n.forEach(i=>{Promise.all([i.data(),o,a]).then(l=>{this.logger.logKernelProfile(t,i,l[0],l[1],s,l[2])})})}};function HG(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var NS=class{logKernelProfile(e,t,n,o,s,a){let i=typeof o=="number"?Gl(`${o}ms`,9):o.error,l=Gl(e,25),u=t.rank,c=t.size,p=Gl(t.shape.toString(),14),m="";for(let f in s){let d=s[f];if(d!=null){let h=d.shape||t.shape,g=h.length;m+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${l}	%c${i}	%c${u}D ${p}	%c${c}	%c${m}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function SS(r,e,t){let n={},o={};for(let l=0;l<e.length;l++)n[e[l].id]=!0;for(let l=0;l<r.length;l++){let u=r[l],c=u.inputs;for(let p in c){let m=c[p],f=!1;for(let d=0;d<e.length;d++)if(n[m.id]){u.outputs.forEach(h=>n[h.id]=!0),f=!0,o[u.id]=!0;break}if(f)break}}let s={};s[t.id]=!0;let a={};for(let l=r.length-1;l>=0;l--){let u=r[l],c=u.inputs;for(let p=0;p<u.outputs.length;p++)if(s[u.outputs[p].id]){for(let m in c)s[c[m].id]=!0,a[u.id]=!0;break}}let i=[];for(let l=0;l<r.length;l++){let u=r[l];if(o[u.id]&&a[u.id]){let c={};for(let m in u.inputs){let f=u.inputs[m];n[f.id]&&(c[m]=f)}let p=Object.assign({},u);p.inputs=c,p.outputs=u.outputs,i.push(p)}}return i}function TS(r,e,t,n){for(let o=e.length-1;o>=0;o--){let s=e[o],a=[];if(s.outputs.forEach(l=>{let u=r[l.id];u!=null?a.push(u):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let i=s.gradient(a);for(let l in s.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);let u=t(()=>i[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=s.inputs[l];if(!Xr(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=u;else{let p=r[c.id];r[c.id]=n(p,u),p.dispose()}}}}var AS=20,Rm=3,aw=7;function ES(r,e,t,n){let o=Ls(e),s=qG(r,e,t,o),a=e.length,i=Qh(r,e,t,o,s),l=["Tensor"];return n&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(i.map(u=>"    "+u).join(`
`)),l.join(`
`)}function qG(r,e,t,n){let o=nt(e),s=n[n.length-1],a=new Array(s).fill(0),i=e.length,l=t==="complex64"?Om(r):r;if(i>1)for(let u=0;u<o/s;u++){let c=u*s;for(let p=0;p<s;p++)a[p]=Math.max(a[p],Fm(l[c+p],0,t).length)}return a}function Fm(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(aw))} + ${parseFloat(r[1].toFixed(aw))}j`:wo(r)?n=`'${r}'`:t==="bool"?n=DS(r):n=parseFloat(r.toFixed(aw)).toString(),Gl(n,e)}function DS(r){return r===0?"false":"true"}function Qh(r,e,t,n,o,s=!0){let a=t==="complex64"?2:1,i=e[0],l=e.length;if(l===0){if(t==="complex64"){let h=Om(r);return[Fm(h[0],0,t)]}return t==="bool"?[DS(r[0])]:[r[0].toString()]}if(l===1){if(i>AS){let g=Rm*a,x=Array.from(r.slice(0,g)),b=Array.from(r.slice((i-Rm)*a,i*a));return t==="complex64"&&(x=Om(x),b=Om(b)),["["+x.map((w,_)=>Fm(w,o[_],t)).join(", ")+", ..., "+b.map((w,_)=>Fm(w,o[i-Rm+_],t)).join(", ")+"]"]}let h=t==="complex64"?Om(r):Array.from(r);return["["+h.map((g,x)=>Fm(g,o[x],t)).join(", ")+"]"]}let u=e.slice(1),c=n.slice(1),p=n[0]*a,m=[];if(i>AS){for(let h=0;h<Rm;h++){let g=h*p,x=g+p;m.push(...Qh(r.slice(g,x),u,t,c,o,!1))}m.push("...");for(let h=i-Rm;h<i;h++){let g=h*p,x=g+p;m.push(...Qh(r.slice(g,x),u,t,c,o,h===i-1))}}else for(let h=0;h<i;h++){let g=h*p,x=g+p;m.push(...Qh(r.slice(g,x),u,t,c,o,h===i-1))}let f=l===2?",":"";m[0]="["+m[0]+f;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+f;let d=`,
`;for(let h=2;h<l;h++)d+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":d),m}function Om(r){let e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}var ut=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=nt(e),n!=null){let o=n.length;T(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Zb(t,this.size),this.strides=Ls(e)}set(e,...t){t.length===0&&(t=[0]),T(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let o of e){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let o=0;o<e.length-1;++o)n+=this.strides[o]*e[o];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ti().makeTensor(this.values,this.shape,this.dtype)}},ti=null,Kc=null,KG=null;function $S(r){ti=r}function RS(r){Kc=r}function FS(r){KG=r}var Pe=class{constructor(e,t,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=nt(e),this.strides=Ls(e),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Kc.buffer(this.shape,this.dtype,e)}bufferSync(){return Kc.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Wl(this.shape,e,this.dtype==="complex64")}arraySync(){return Wl(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=ti().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>qc(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();let e=ti().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>qc(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await ti().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(ti().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Kc.print(this,e)}clone(){return this.throwIfDisposed(),Kc.clone(this)}toString(e=!1){let t=this.dataSync();return ES(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Kc.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),ti().makeVariable(this,e,t,n)}};Object.defineProperty(Pe,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function F(){return Sm("Tensor",()=>Pe)}F();var ul=class extends Pe{constructor(e,t,n,o){super(e.shape,e.dtype,e.dataId,o);this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Xr(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ti().disposeTensor(this),this.dataId=e.dataId,ti().incRef(this,null)}dispose(){ti().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ul,Symbol.hasInstance,{value:r=>r instanceof Pe&&r.assign!=null&&r.assign instanceof Function});var Zn={};We(Zn,{assertTypesMatch:()=>fw,getTensorsInContainer:()=>Pm,isTensorInList:()=>YG,makeTypesMatch:()=>je});var lw;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(lw||(lw={}));var uw;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(uw||(uw={}));var cw;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(cw||(cw={}));var pw;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(pw||(pw={}));var mw;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(mw||(mw={}));var XG={float32:pw,int32:uw,bool:cw,complex64:mw};function ar(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return XG[r][e]}function Kl(r){return ar(r,"int32")}function je(r,e){if(r.dtype===e.dtype)return[r,e];let t=ar(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function fw(r,e){T(r.dtype===e.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${e.dtype}) input must match`)}function YG(r,e){return e.some(t=>t.id===r.id)}function Pm(r){let e=[],t=new Set;return OS(r,e,t),e}function OS(r,e,t){if(r==null)return;if(r instanceof Pe){e.push(r);return}if(!ZG(r))return;let n=r;for(let o in n){let s=n[o];t.has(s)||(t.add(s),OS(s,e,t))}}function ZG(r){return Array.isArray(r)||typeof r=="object"}function dw(r){return r.kernelName!=null}var hw=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Xl=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new hw}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new iw(this.backendInstance),!0}setupRegisteredKernels(){Jh(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Jh(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof Ps)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(a=>o<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),o=n.backend,s=this.readSync(t),a=o.refCount(t);o.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=t(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,t,n){e();try{let o=n();return t(),o}catch(o){throw t(),o}}nextTensorId(){return Xl.nextTensorId++}nextVariableId(){return Xl.nextVariableId++}clone(e){let t=A.runKernel(Xn,{x:e}),n={x:e},o=a=>({x:()=>{let i="float32",l={x:a},u={dtype:i};return A.runKernel(qn,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],o,s,{}),t}runKernel(e,t,n){if(!($m(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let o=this.backend.numDataIds(),s=0;n.forEach(l=>{s+=l.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=o-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],o=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let l,u=dw(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(dw(e)){let{kernelName:d,inputs:h,attrs:g}=e;this.backendName==null&&this.backend;let x=$m(d,this.backendName);T(x!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),i=()=>{let b=this.backend.numDataIds();l=x.kernelFunc({inputs:h,attrs:g,backend:this.backend});let w=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,b,w);let _=w.map(I=>{if(I.rank!=null)return I;let{dataId:E,shape:$,dtype:D}=I;return this.makeTensorFromDataId(E,$,D)});if(o){let I=this.getTensorsForGradient(d,h,_);n=this.saveTensorsForBackwardMode(I)}return _}}else{let{forwardFunc:d}=e,h=g=>{!o||(n=g.map(x=>this.keep(this.clone(x))))};i=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>d(this.backend,h));let x=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,x),x}}let{inputs:c,attrs:p}=e,m=dw(e)?null:e.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(f=this.profiler.profileKernel(u,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs)}),o&&this.addTapeNode(u,c,t,m,n,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(d=>c[d]!=null?c[d].shape:null),outputShapes:t.map(d=>d.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let o=sw(e);if(o!=null){let s=o.inputsToSave||[],a=o.outputsToSave||[],i;o.saveAllInputs?(T(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(u=>t[u])):i=s.map(u=>t[u]);let l=n.filter((u,c)=>a[c]);return i.concat(l)}return[]}makeTensor(e,t,n,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=e;n==="string"&&wo(e[0])&&(s=e.map(l=>ll(l)));let a=o.write(s,t,n),i=new Pe(t,n,a,this.nextTensorId());if(this.trackTensor(i,o),n==="string"){let l=this.state.tensorInfo.get(a),u=ew(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return i}makeTensorFromDataId(e,t,n,o){n=n||"float32";let s=new Pe(t,n,e,this.nextTensorId());return this.trackTensor(s,o),s}makeVariable(e,t=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));let s=new ul(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*Yh(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ul||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*Yh(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,o,s,a){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},l=sw(e);l!=null&&(o=l.gradFunc),o!=null&&(i.gradient=u=>(u=u.map((c,p)=>{if(c==null){let m=n[p],f=hc(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return c}),o(u.length>1?u:u[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Pm(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(e,t,n,o=!1){if(T(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));T(s instanceof Pe,()=>"The result y returned by f() must be a tensor.");let a=SS(this.state.activeTape,t,s);if(!o&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[s.id]=n==null?JG(s.shape):n,TS(i,a,u=>this.tidy(u),QG);let l=t.map(u=>i[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(e){return T(Ms(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{T(t.every(i=>i instanceof Pe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};t.forEach((i,l)=>{o[l]=i});let s=(i,l)=>(n=e(...t,l),T(n.value instanceof Pe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),T(Ms(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(i,l)=>{let u=n.gradFunc(i,l),c=Array.isArray(u)?u:[u];T(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),T(c.every(m=>m instanceof Pe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((m,f)=>{p[f]=()=>m}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){let t=ql(),n=await this.backend.time(e);return n.wallMs=ql()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new hw;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Xl.nextTensorId=0;Xl.nextVariableId=0;function JG(r){let e=Cm(nt(r),"float32");return A.makeTensor(e,r,"float32")}function gw(){let r=nw();if(r._tfengine==null){let e=new Zh(r);r._tfengine=new Xl(e)}return kS(r._tfengine.ENV),$S(()=>r._tfengine),r._tfengine}var A=gw();function QG(r,e){let t={a:r,b:e};return A.runKernel(On,t)}var Yl={};We(Yl,{isBrowser:()=>xw,isMobile:()=>tW});function eW(){return typeof navigator!="undefined"&&navigator!=null}function tW(r){if(r||eW()){if(r||(r=navigator),r.product==="ReactNative")return!0;let e=r.userAgent||r.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function xw(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var fs=W();fs.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});fs.registerFlag("IS_BROWSER",()=>xw());fs.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");fs.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));fs.registerFlag("PROD",()=>!1);fs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>fs.getBool("DEBUG"));fs.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);fs.registerFlag("IS_TEST",()=>!1);fs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);fs.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);function Tr(r,e){let t=r;if(ir(r))return e==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(t)||ir(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(r)&&W().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&PS(r,n,[]),n}function PS(r,e,t){if(t=t||[],!Array.isArray(r)&&!ir(r)){T(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}T(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),T(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);let n=e.slice(1);for(let o=0;o<r.length;++o)PS(r[o],n,t.concat(o))}function MS(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function k(r,e,t,n="numeric"){if(r instanceof Pe)return MS(n,r.dtype,e,t),r;let o=fc(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),MS(n,o,e,t),r==null||!ir(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let l=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}let s=Tr(r,o);!ir(r)&&!Array.isArray(r)&&(r=[r]);let i=o!=="string"?Hc(r,o):bo(r,[],!0);return A.makeTensor(i,s,o)}function la(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,a)=>k(s,`${e}[${a}]`,t,n))}var LS="__op";function S(r){let e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+LS;let o=(...s)=>{A.startScope(t);try{let a=n(...s);return Nm(a)&&console.error("Cannot return a Promise inside of tidy."),A.endScope(a),a}catch(a){throw A.endScope(null),a}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}function rW(r,e){let t=k(r,"real","complex"),n=k(e,"imag","complex");At(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:t,imag:n};return A.runKernel(bc,o)}var In=S({complex_:rW});function Yr(r,e,t,n){if(n==null&&(n=fc(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!ir(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Im(e);let o=nt(e),s=nt(t);T(o===s,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${s}`);for(let a=0;a<t.length;++a){let i=t[a],l=a===t.length-1?i!==nt(e.slice(a)):!0;T(t[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!ir(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Hc(r,n):bo(r,[],!0),A.makeTensor(r,e,n)}function Mr(r,e,t){let n=Tr(r,t);return Yr(r,e,n,t)}var Mm={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var eg=4;async function zS(r,e){let t=[],n=[],o=Array.isArray(r)?r.map(a=>a.name):Object.keys(r);for(let a=0;a<o.length;++a){let i=o[a],l=Array.isArray(r)?r[a].tensor:r[i];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);let u={name:i,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(async p=>{let m=await l.bytes(),f=m.reduce((g,x)=>g+x.length,0)+eg*m.length,d=new Uint8Array(f),h=0;for(let g=0;g<m.length;g++){let x=m[g],b=new Uint8Array(new Uint32Array([x.length]).buffer);d.set(b,h),h+=eg,d.set(x,h),h+=x.length}p(d)});n.push(c)}else n.push(l.data());e!=null&&(u.group=e),t.push(u)}let s=await Promise.all(n);return{data:nW(s),specs:t}}function tg(r,e){let t={},n,o=0;for(let s of e){let a=s.name,i=s.dtype,l=s.shape,u=nt(l),c;if("quantization"in s){let p=s.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${s.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${s.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=Mm[p.dtype],f=r.slice(o,o+u*m),d=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(i==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=g*p.scale+p.min}}else if(p.dtype==="float16")n===void 0&&(n=oW()),c=n(d);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(i==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=u*m}else if(i==="string"){let p=nt(s.shape);c=[];for(let m=0;m<p;m++){let f=new Uint32Array(r.slice(o,o+eg))[0];o+=eg;let d=new Uint8Array(r.slice(o,o+f));c.push(d),o+=f}}else{let p=Mm[i],m=r.slice(o,o+u*p);if(i==="float32")c=new Float32Array(m);else if(i==="int32")c=new Int32Array(m);else if(i==="bool")c=new Uint8Array(m);else if(i==="complex64"){c=new Float32Array(m);let f=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let x=0;x<f.length;x++)f[x]=c[x*2],d[x]=c[x*2+1];let h=Mr(f,l,"float32"),g=Mr(d,l,"float32");t[a]=In(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=u*p}i!=="complex64"&&(t[a]=Mr(c,l,i))}return t}function nW(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0,t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(e),o=0;return t.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var yw=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function BS(r){return yw?Buffer.byteLength(r):new Blob([r]).size}function VS(r){if(yw)return Buffer.from(r).toString("base64");let e=new Uint8Array(r),t="";for(let n=0,o=e.length;n<o;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function GS(r){if(yw){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function Xc(r){if(r.length===1)return r[0];let e=0;r.forEach(o=>{e+=o.byteLength});let t=new Uint8Array(e),n=0;return r.forEach(o=>{t.set(new Uint8Array(o),n),n+=o.byteLength}),t.buffer}function bw(r){let e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);let t=r.split(e);return t[t.length-1]}function ri(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:BS(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:BS(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function sW(){let r=t=>{let n=t<<13,o=0;for(;(n&8388608)==0;)o-=8388608,n<<=1;return n&=~8388608,o+=947912704,n|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function iW(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function aW(){let r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function oW(){let r=sW(),e=iW(),t=aW();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let a=0;a<n.length;a++){let i=n[a],l=r[t[i>>10]+(i&1023)]+e[i>>10];s[a]=l}return new Float32Array(o)}}var It=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return It.instance==null&&(It.instance=new It),It.instance}static registerSaveRouter(e){It.getInstance().saveRouters.push(e)}static registerLoadRouter(e){It.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return It.getHandlers(e,"save")}static getLoadHandlers(e,t){return It.getHandlers(e,"load",t)}static getHandlers(e,t,n){let o=[];return(t==="load"?It.getInstance().loadRouters:It.getInstance().saveRouters).forEach(a=>{let i=a(e,n);i!==null&&o.push(i)}),o}},WS=r=>It.registerSaveRouter(r),jS=r=>It.registerLoadRouter(r),US=r=>It.getSaveHandlers(r),HS=(r,e)=>It.getLoadHandlers(r,e);var ww="tensorflowjs",_w=1,Zl="models_store",cl="model_info_store";function qS(){if(!W().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function kw(r){let e=r.result;e.createObjectStore(Zl,{keyPath:"modelPath"}),e.createObjectStore(cl,{keyPath:"modelPath"})}var ua=class{constructor(e){if(this.indexedDB=qS(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,o)=>{let s=this.indexedDB.open(ww,_w);s.onupgradeneeded=()=>kw(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(Zl,"readonly"),u=i.objectStore(Zl).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(u.result.modelArtifacts)},u.onerror=c=>(a.close(),o(u.error)),i.oncomplete=()=>a.close()}else{let i=ri(t),l=a.transaction(cl,"readwrite"),u=l.objectStore(cl),c=u.put({modelPath:this.modelPath,modelArtifactsInfo:i}),p;c.onsuccess=()=>{p=a.transaction(Zl,"readwrite");let f=p.objectStore(Zl).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});f.onsuccess=()=>n({modelArtifactsInfo:i}),f.onerror=d=>{u=l.objectStore(cl);let h=u.delete(this.modelPath);h.onsuccess=()=>(a.close(),o(f.error)),h.onerror=g=>(a.close(),o(f.error))}},c.onerror=m=>(a.close(),o(c.error)),l.oncomplete=()=>{p==null?a.close():p.oncomplete=()=>a.close()}}},s.onerror=a=>o(s.error)})}};ua.URL_SCHEME="indexeddb://";var KS=r=>W().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(ua.URL_SCHEME)?lW(r.slice(ua.URL_SCHEME.length)):null;It.registerSaveRouter(KS);It.registerLoadRouter(KS);function lW(r){return new ua(r)}function uW(r){return r.startsWith(ua.URL_SCHEME)?r.slice(ua.URL_SCHEME.length):r}var vw=class{constructor(){this.indexedDB=qS()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(ww,_w);n.onupgradeneeded=()=>kw(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(cl,"readonly"),i=s.objectStore(cl).getAll();i.onsuccess=()=>{let l={};for(let u of i.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},i.onerror=l=>(o.close(),t(i.error)),s.oncomplete=()=>o.close()},n.onerror=o=>t(n.error)})}async removeModel(e){return e=uW(e),new Promise((t,n)=>{let o=this.indexedDB.open(ww,_w);o.onupgradeneeded=()=>kw(o),o.onsuccess=()=>{let s=o.result,a=s.transaction(cl,"readwrite"),i=a.objectStore(cl),l=i.get(e),u;l.onsuccess=()=>{if(l.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let c=i.delete(e),p=()=>{u=s.transaction(Zl,"readwrite");let f=u.objectStore(Zl).delete(e);f.onsuccess=()=>t(l.result.modelArtifactsInfo),f.onerror=d=>n(l.error)};c.onsuccess=p,c.onerror=m=>(p(),s.close(),n(l.error))}},l.onerror=c=>(s.close(),n(l.error)),a.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var ca="/",Yc="tensorflowjs_models",XS="info",cW="model_topology",pW="weight_specs",mW="weight_data",fW="model_metadata";function YS(r){return{info:[Yc,r,XS].join(ca),topology:[Yc,r,cW].join(ca),weightSpecs:[Yc,r,pW].join(ca),weightData:[Yc,r,mW].join(ca),modelMetadata:[Yc,r,fW].join(ca)}}function dW(r){let e=r.split(ca);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(ca)}function hW(r){return r.startsWith(pa.URL_SCHEME)?r.slice(pa.URL_SCHEME.length):r}var pa=class{constructor(e){if(!W().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=YS(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),o=ri(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,VS(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return e.signature!=null&&(s.signature=e.signature),e.userDefinedMetadata!=null&&(s.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(s.modelInitializer=e.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(s){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=GS(a),t}};pa.URL_SCHEME="localstorage://";var ZS=r=>W().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(pa.URL_SCHEME)?gW(r.slice(pa.URL_SCHEME.length)):null;It.registerSaveRouter(ZS);It.registerLoadRouter(ZS);function gW(r){return new pa(r)}var Cw=class{constructor(){T(W().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),T(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Yc+ca,n=ca+XS;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(n)){let a=dW(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=hW(e);let t=YS(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return this.LS.removeItem(t.info),this.LS.removeItem(t.topology),this.LS.removeItem(t.weightSpecs),this.LS.removeItem(t.weightData),n}};var Zc="://",Zr=class{constructor(){this.managers={}}static getInstance(){return Zr.instance==null&&(Zr.instance=new Zr),Zr.instance}static registerManager(e,t){T(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Zc)&&(e=e.slice(0,e.indexOf(Zc))),T(e.length>0,()=>"scheme must not be an empty string.");let n=Zr.getInstance();T(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function rg(r){if(r.indexOf(Zc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Zr.getSchemes().join(",")}`);return{scheme:r.split(Zc)[0],path:r.split(Zc)[1]}}async function JS(r,e,t=!1){T(r!==e,()=>`Old path and new path are the same: '${r}'`);let n=It.getLoadHandlers(r);T(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),T(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=It.getSaveHandlers(e);T(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),T(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);let a=s[0],i=rg(r).scheme,l=rg(r).path,u=i===rg(r).scheme,c=await o.load();t&&u&&await Zr.getManager(i).removeModel(l);let p=await a.save(c);return t&&!u&&await Zr.getManager(i).removeModel(l),p.modelArtifactsInfo}async function QS(){let r=Zr.getSchemes(),e={};for(let t of r){let n=await Zr.getManager(t).listModels();for(let o in n){let s=t+Zc+o;e[s]=n[o]}}return e}async function eT(r){let e=rg(r);return Zr.getManager(e.scheme).removeModel(e.path)}async function tT(r,e){return JS(r,e,!1)}async function rT(r,e){return JS(r,e,!0)}var nT=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if(W().get("IS_BROWSER")){W().setPlatform("browser",new nT);try{Zr.registerManager(pa.URL_SCHEME,new Cw)}catch(r){}try{Zr.registerManager(ua.URL_SCHEME,new vw)}catch(r){}}var xW={importFetch:()=>oT()},Iw;var sT=class{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return W().global.fetch!=null?W().global.fetch(e,t):(Iw==null&&(Iw=xW.importFetch()),Iw(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};W().get("IS_NODE")&&W().setPlatform("node",new sT);function Ce(r,e="float32",t){return e=e||"float32",Im(r),new ut(r,e,t)}function yW(r,e){let t=k(r,"x","cast");if(!Qb(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:t},o={dtype:e};return A.runKernel(qn,n,o)}var oe=S({cast_:yW});function bW(r){let t={x:k(r,"x","clone","string_or_numeric")};return A.runKernel(Xn,t)}var Mn=S({clone_:bW});function Nw(r,e=!1){console.log(r.toString(e))}gw();var wW={buffer:Ce,cast:oe,clone:Mn,print:Nw};RS(wW);var Ar={};We(Ar,{browserFiles:()=>lT,browserHTTPRequest:()=>pT,concatenateArrayBuffers:()=>Xc,copyModel:()=>tT,decodeWeights:()=>tg,encodeWeights:()=>zS,fromMemory:()=>fT,getLoadHandlers:()=>HS,getModelArtifactsInfoForJSON:()=>ri,getSaveHandlers:()=>US,http:()=>sg,isHTTPScheme:()=>og,listModels:()=>QS,loadWeights:()=>uT,moveModel:()=>rT,registerLoadRouter:()=>jS,registerSaveRouter:()=>WS,removeModel:()=>eT,weightsLoaderFactory:()=>Aw,withSaveHandler:()=>dT});var _W="model",kW=".json",vW=".weights.bin";function iT(r){return new Promise(e=>setTimeout(e)).then(r)}var pl=class{constructor(e){if(!W().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(pl.URL_SCHEME)&&(e=e.slice(pl.URL_SCHEME.length)),(e==null||e.length===0)&&(e=_W),this.modelTopologyFileName=e+kW,this.weightDataFileName=e+vW}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};e.signature!=null&&(o.signature=e.signature),e.userDefinedMetadata!=null&&(o.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(o.modelInitializer=e.modelInitializer);let s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor;if(a.download=this.modelTopologyFileName,a.href=s,await iT(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await iT(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ri(e)}}}};pl.URL_SCHEME="downloads://";var aT=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.files=e}async load(){let e=this.files[0],t=this.files.slice(1);return new Promise((n,o)=>{let s=new FileReader;s.onload=a=>{let i=JSON.parse(a.target.result),l=i.modelTopology;if(l==null){o(new Error(`modelTopology field is missing from file ${e.name}`));return}t.length===0&&n({modelTopology:l});let u=i.weightsManifest;if(u==null){o(new Error(`weightManifest field is missing from file ${e.name}`));return}let c;try{c=this.checkManifestAndWeightFiles(u,t)}catch(d){o(d);return}let p=[],m=[],f=[];u.forEach(d=>{d.paths.forEach(h=>{m.push(h),f.push(null)}),p.push(...d.weights)}),u.forEach(d=>{d.paths.forEach(h=>{let g=new FileReader;g.onload=x=>{let b=x.target.result,w=m.indexOf(h);if(f[w]=b,f.indexOf(null)===-1){let _={modelTopology:l,weightSpecs:p,weightData:Xc(f),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy};i.signature!=null&&(_.signature=i.signature),i.userDefinedMetadata!=null&&(_.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(_.modelInitializer=i.modelInitializer),n(_)}},g.onerror=x=>o(`Failed to weights data from file of path '${h}'.`),g.readAsArrayBuffer(c[h])})})},s.onerror=a=>o(`Failed to read model topology and weights manifest JSON from file '${e.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(e)})}checkManifestAndWeightFiles(e,t){let n=[],o=t.map(a=>bw(a.name)),s={};for(let a of e)a.paths.forEach(i=>{let l=bw(i);if(n.indexOf(l)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${l}'`);if(n.push(l),o.indexOf(l)===-1)throw new Error(`Weight file with basename '${l}' is not provided.`);s[i]=t[o.indexOf(l)]});if(n.length!==t.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${t.length}).`);return s}},IW=r=>W().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(pl.URL_SCHEME)?CW(r.slice(pl.URL_SCHEME.length)):null;It.registerSaveRouter(IW);function CW(r="model"){return new pl(r)}function lT(r){return new aT(r)}function Sw(r,e,t,n){a(r),t=t==null?0:t,n=n==null?1:n,i(t,n);let o=0,s=l=>(l.then(u=>{let c=t+ ++o/r.length*(n-t);return e(c),u}),l);function a(l){T(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function i(l,u){T(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),T(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),T(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(r.map(s))}async function Tw(r,e){e==null&&(e={});let t=e.fetchFunc==null?W().platform.fetch:e.fetchFunc,n=r.map(p=>t(p,e.requestInit,{isBinary:!0})),o=0,s=.5,i=(e.onProgress==null?await Promise.all(n):await Sw(n,e.onProgress,o,s)).map(p=>p.arrayBuffer()),l=.5,u=1;return e.onProgress==null?await Promise.all(i):await Sw(i,e.onProgress,l,u)}async function uT(r,e="",t,n){return Aw(a=>Tw(a,{requestInit:n}))(r,e,t)}function Aw(r){return async(e,t="",n)=>{let o=e.map(()=>!1),s={},a=n!=null?n.map(()=>!1):[],i=[];if(e.forEach((f,d)=>{let h=0;f.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,b=Mm[x]*nt(g.shape),w=()=>{o[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:g,groupOffset:h,sizeBytes:b})};n!=null?n.forEach((_,I)=>{_===g.name&&(w(),a[I]=!0)}):w(),i.push(g.name),h+=b})}),!a.every(f=>f)){let f=n.filter((d,h)=>!a[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let l=o.reduce((f,d,h)=>(d&&f.push(h),f),[]),u=[];l.forEach(f=>{e[f].paths.forEach(d=>{let h=t+(t.endsWith("/")?"":"/")+d;u.push(h)})});let c=await r(u),p={},m=0;return l.forEach(f=>{let d=e[f].paths.length,h=0;for(let _=0;_<d;_++)h+=c[m+_].byteLength;let g=new ArrayBuffer(h),x=new Uint8Array(g),b=0;for(let _=0;_<d;_++){let I=new Uint8Array(c[m+_]);x.set(I,b),b+=I.byteLength}s[f].forEach(_=>{let I=g.slice(_.groupOffset,_.groupOffset+_.sizeBytes),E=tg(I,[_.manifestEntry]);for(let $ in E)p[$]=E[$]}),m+=d}),p}}var NW="application/octet-stream",SW="application/json",ng=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(T(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=W().platform.fetch,T(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&T(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};e.signature!=null&&(o.signature=e.signature),e.userDefinedMetadata!=null&&(o.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(o.modelInitializer=e.modelInitializer),t.body.append("model.json",new Blob([JSON.stringify(o)],{type:SW}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:NW}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:ri(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(d){let h=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?h+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":h+=" Please make sure the server is serving valid JSON for this request.",new Error(h)}let n=t.modelTopology,o=t.weightsManifest,s=t.generatedBy,a=t.convertedBy,i=t.format,l=t.signature,u=t.userDefinedMetadata;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let c,p;o!=null&&([c,p]=await this.loadWeights(o));let m={modelTopology:n,weightSpecs:c,weightData:p,generatedBy:s,convertedBy:a,format:i};l!=null&&(m.signature=l),u!=null&&(m.userDefinedMetadata=u);let f=t.modelInitializer;return f&&(m.modelInitializer=f),m}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=TW(t),s=this.weightPathPrefix||n,a=[];for(let c of e)a.push(...c.weights);let i=[],l=[];for(let c of e)for(let p of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(p)):i.push(s+p+o);this.weightUrlConverter&&i.push(...await Promise.all(l));let u=await Tw(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,Xc(u)]}};ng.URL_SCHEME_REGEX=/^https?:\/\//;function TW(r){let e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),o=t>e?r.substring(t):"";return[n+"/",o]}function og(r){return r.match(ng.URL_SCHEME_REGEX)!=null}var cT=(r,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>og(n)):t=og(r),t)return sg(r,e)}return null};It.registerSaveRouter(cT);It.registerLoadRouter(cT);function sg(r,e){return new ng(r,e)}function pT(r,e){return sg(r,e)}var ig=class{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}},mT=class{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}};function fT(r,e,t,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new ig(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ig({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ig({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:n}))}function dT(r){return new mT(r)}var gT={};We(gT,{confusionMatrix:()=>hT});function AW(r,e,t=!1,n=!1){let o=k(r,"a","matMul"),s=k(e,"b","matMul");[o,s]=je(o,s);let a={a:o,b:s},i={transposeA:t,transposeB:n};return A.runKernel(Co,a,i)}var ze=S({matMul_:AW});function EW(r,e,t=1,n=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let s={indices:k(r,"indices","oneHot","int32")},a={depth:e,onValue:t,offValue:n};return A.runKernel(qo,s,a)}var ds=S({oneHot_:EW});function DW(r,e){let t=k(r,"x","transpose");if(e==null&&(e=t.shape.map((s,a)=>a).reverse()),T(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(s=>{T(s>=0&&s<t.rank,()=>`All entries in 'perm' must be between 0 and ${t.rank-1} but got ${e}`)}),t.rank<=1)return t.clone();let n={x:t},o={perm:e};return A.runKernel(ms,n,o)}var Ue=S({transpose_:DW});function $W(r,e,t){let n=k(r,"labels","confusionMatrix"),o=k(e,"predictions","confusionMatrix");T(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),T(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),T(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),T(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),T(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=ds(oe(n,"int32"),t),a=ds(oe(o,"int32"),t),i=Ue(s),l=ze(i,a);return oe(l,"int32")}var hT=S({confusionMatrix_:$W});var ag={};We(ag,{fromPixels:()=>zW,fromPixelsAsync:()=>MW,toPixels:()=>LW});function Ew(r,e,t){if(Fn(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Tr(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Yr(r,e,n,t)}var Jc;function xT(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,o=!1,s=!1,a=!1,i=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(o){let d=2;if(o&&r.readyState<d)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if($m(Em,A.backendName)!=null){let d={pixels:r},h={numChannels:e};return A.runKernel(Em,d,h)}let[u,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p;a?p=r.getContext("2d").getImageData(0,0,u,c).data:n||t?p=r.data:(s||o||i)&&(Jc==null&&(Jc=document.createElement("canvas").getContext("2d")),Jc.canvas.width=u,Jc.canvas.height=c,Jc.drawImage(r,0,0,u,c),p=Jc.getImageData(0,0,u,c).data);let m;if(e===4)m=new Int32Array(p);else{let d=u*c;m=new Int32Array(d*e);for(let h=0;h<d;h++)for(let g=0;g<e;++g)m[h*e+g]=p[h*4+g]}return Ew(m,[c,u,e],"int32")}function RW(r){return r!=null&&r.data instanceof Uint8Array}function FW(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function OW(r){return r!=null&&r.width!==0&&r.height!==0}function PW(r){return FW()&&!(r instanceof ImageBitmap)&&OW(r)&&!RW(r)}async function MW(r,e=3){let t=null;if(W().getBool("WRAP_TO_IMAGEBITMAP")&&PW(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch(o){n=null}n!=null&&n.width===r.width&&n.height===r.height?t=n:t=r}else t=r;return xT(t,e)}async function LW(r,e){let t=k(r,"img","toPixels");if(!(r instanceof Pe)){let u=t;t=oe(u,"int32"),u.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let[n,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);let a=await t.data(),i=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(o*n*4);for(let u=0;u<n*o;++u){let c=[0,0,0,255];for(let m=0;m<s;m++){let f=a[u*s+m];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(c[0]=f*i,c[1]=f*i,c[2]=f*i):c[m]=f*i}let p=u*4;l[p+0]=Math.round(c[0]),l[p+1]=Math.round(c[1]),l[p+2]=Math.round(c[2]),l[p+3]=Math.round(c[3])}if(e!=null){e.width=o,e.height=n;let u=e.getContext("2d"),c=new ImageData(l,o,n);u.putImageData(c,0,0)}return t!==r&&t.dispose(),l}var zW=S({fromPixels_:xT});var lg={};We(lg,{prepareAndValidate:()=>yT});function yT(r,e){let t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(nt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=e.shape,s=o[o.length-1],a=1;for(let p=0;p<o.length-1;++p)a*=o[p];let i=r.shape,l=o.slice();l.pop();let u=1;for(let p=s;p<t;++p)u*=i[p],l.push(i[p]);let c=[...Ls(r.shape).map(p=>p/u),1].slice(0,s);return[l,a,u,c]}var ug={};We(ug,{calculateShapes:()=>bT,validateInput:()=>cg,validateUpdateShape:()=>Dw});function Dw(r,e,t){let n=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(t.rank-o))throw new Error(s+` Output shape length < ${n+(t.rank-o)}`);if(t.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let a=0;a<o;++a)if(t.shape[a]!==e.shape[a])throw new Error(s+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-o;++a)if(t.shape[a+o]!==r[a+n])throw new Error(s+` updates.shape[${a+o}] (${t.shape[a+o]}) != shape[${a+o}] (${r[a+o]})`)}function cg(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}Dw(t,e,r)}function bT(r,e,t){let n=e.shape.length,o=n>1?e.shape[n-1]:1,s=t.length,a=1;for(let p=o;p<s;++p)a*=t[p];let i=o<1?1:o,l=nt(e.shape)/i,u=[...Ls(t.slice(0,o)),1],c=nt(t);return{sliceRank:o,numUpdates:l,sliceSize:a,strides:u,outputSize:c}}var rr={};We(rr,{assertParamsValid:()=>BW,computeFlatOffset:()=>GW,computeOutShape:()=>wT,getNormalizedAxes:()=>AT,isSliceContinous:()=>VW,maskToAxes:()=>pg,parseSliceParams:()=>$w,sliceInfo:()=>WW,startForAxis:()=>ST,startIndicesWithElidedDims:()=>CT,stopForAxis:()=>TT,stopIndicesWithElidedDims:()=>IT,stridesForAxis:()=>NT,stridesWithElidedDims:()=>_T});function BW(r,e,t){let n=r.shape.length;T(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),T(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)T(e[o]+t[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${e[o]+t[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function pg(r){let e=[],t=0;for(;r>0;)r&1&&e.push(t),r/=2,t++;return e}function wT(r,e,t){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((e[o]-r[o])/t[o]);return n}function _T(r,e,t,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function kT(r,e,t){return t<=r?t:t-(e-1)}function vT(r,e){let t=[];for(let n=0;n<r;n++)t.push(e+n);return t}function AT(r,e,t,n,o,s,a,i,l){let u=r.length,c=new Array(u),p=new Array(u),m=new Array(u);if(e.length&&t>0){let f=e[0],d=t+1;c=CT(a,f,d,n,r),p=IT(i,f,d,o,r),m=_T(s,f,d,r)}else for(let f=0;f<u;f++)c[f]=ST(a,n,s,r,f,l),p[f]=TT(i,o,s,r,f,l),m[f]=NT(s,f,l);return{begin:c,end:p,strides:m}}function CT(r,e,t,n,o){let s=[...o],a=vT(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=0;else{let l=kT(e,t,i),u=n[l];r&1<<l&&(u=0),s[i]=u}return s}function IT(r,e,t,n,o){let s=[...o],a=vT(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{let l=kT(e,t,i),u=n[l];r&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[i]=u}for(let i=0;i<s.length;i++){let l=o[i];s[i]<0&&(s[i]+=l),s[i]=mc(0,s[i],o[i])}return s}function NT(r,e,t){let n=r[e];return(t&1<<e||n==null)&&(n=1),n}function ST(r,e,t,n,o,s){let a=e[o],i=t[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let l=n[o];return a<0&&(a+=l),a=mc(0,a,l-1),a}function TT(r,e,t,n,o,s){let a=e[o],i=t[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let l=n[o];return a<0&&(a+=l),i>0?a=mc(0,a,l):a=mc(-1,a,l-1),a}function VW(r,e,t){let n=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){n=o;break}for(let o=n+1;o<t.length;o++)if(e[o]>0||t[o]!==r[o])return!1;return!0}function GW(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function $w(r,e,t){let n,o=r.shape.length;typeof e=="number"?n=[e,...new Array(o-1).fill(0)]:e.length<o?n=e.concat(new Array(o-e.length).fill(0)):n=e.slice(),n.forEach(a=>{T(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((a,i)=>a>=0?a:(T(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),r.shape[i]-n[i])),[n,s]}function WW(r,e,t,n,o,s,a,i,l){let u=e.slice(),c=t.slice(),p=n;n==null&&(p=new Array(u.length));let m=pg(a);if(m.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(a!==0&&i!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(a!==0&&l!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let f=r.length-u.length,d=pg(i),h=r.slice();d.forEach($=>{u[$]=0,c[$]=1,h.splice($,0,1)});let{begin:g,end:x,strides:b}=AT(h,m,f,u,c,p,o,s,a);u=g,c=x,p=b;let w=pg(l);w.forEach($=>{c[$]=u[$]+1,p[$]=1});let _=wT(u,c,p),I=_.filter(($,D)=>w.indexOf(D)===-1);return{nonStrided:p.every($=>$===1),$begin:u,$end:c,$strides:p,size:_,newShape:h,outShape:I}}var J={};We(J,{Serializable:()=>mg,SerializationMap:()=>ma,registerClass:()=>dn});var mg=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},ma=class{constructor(){this.classNameMap={}}static getMap(){return ma.instance==null&&(ma.instance=new ma),ma.instance}static register(e){ma.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function dn(r){T(r.className!=null,()=>"Class being registered does not have the static className property defined."),T(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),T(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ma.register(r)}var ET={};We(ET,{TEST_EPSILON_FLOAT16:()=>DT,encodeStrings:()=>$T,expectArrayBuffersEqual:()=>YW,expectArraysClose:()=>UW,expectArraysEqual:()=>qW,expectNumbersClose:()=>KW,expectPromiseToFail:()=>HW,expectValuesInRange:()=>XW,testEpsilon:()=>Rw});var jW=.001,DT=.1;function UW(r,e,t){return t==null&&(t=Rw()),Fw(r,e,(n,o)=>Ow(n,o,t))}function Rw(){return A.backend.floatPrecision()===32?jW:DT}function Fw(r,e,t){let n=!0;if((ir(r)||ir(e))&&(n=!1),ir(r)&&ir(e)&&(n=!0),n){let a=r.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(r)&&Array.isArray(e)){let a=Tr(r),i=Tr(e);if(!Xr(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}let o=ir(r)?r:bo(r),s=ir(e)?e:bo(e);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let a=0;a<s.length;++a){let i=o[a],l=s[a];if(!t(i,l))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${l}.
Actual:   ${o}.
Expected: ${s}.`)}}function HW(r,e){r().then(()=>e.fail(),()=>e())}function qW(r,e){let t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return wo(r)||wo(r[0])||wo(e)||wo(e[0])?Fw(r,t,(n,o)=>n==o):Fw(r,e,(n,o)=>Ow(n,o,0))}function KW(r,e,t){if(t==null&&(t=Rw()),!Ow(r,e,t))throw new Error(`Numbers differ: actual === ${r}, expected === ${e}`)}function Ow(r,e,t){return!isFinite(r)&&!isFinite(e)?!0:!(isNaN(r)||isNaN(e)||Math.abs(r-e)>t)}function XW(r,e,t){for(let n=0;n<r.length;n++)if(r[n]<e||r[n]>t)throw new Error(`Value out of range:${r[n]} low: ${e}, high: ${t}`)}function YW(r,e){expect(new Float32Array(r)).toEqual(new Float32Array(e))}function $T(r){for(let e=0;e<r.length;e++){let t=r[e];Array.isArray(t)?$T(t):r[e]=ll(t)}return r}var ZW="3.5.0";function yae(){W().set("PROD",!0)}function bae(){W().set("DEBUG",!0)}function wae(){W().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Pw(r){W().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}FS(Pw);function _ae(){A.disposeVariables()}function hs(){return A}function Lm(){return A.memory()}function kae(r){return A.profile(r)}function V(r,e){return A.tidy(r,e)}function Ee(r){Pm(r).forEach(t=>t.dispose())}function Et(r){return A.keep(r)}function vae(r){return A.time(r)}function JW(r){return A.setBackend(r)}function Cae(){return A.ready()}function Iae(){return A.backendName}function Nae(r){A.removeBackend(r)}function Sae(r){return A.findBackend(r)}function Tae(r){return A.findBackendFactory(r)}function Qc(r,e,t=1){return A.registerBackend(r,e,t)}function RT(){return A.backend}function Aae(r,e){W().setPlatform(r,e)}function QW(r,e){let t=k(r,"a","add"),n=k(e,"b","add");[t,n]=je(t,n);let o={a:t,b:n};return A.runKernel(On,o)}var ee=S({add_:QW});function ej(r,e){let t=k(r,"a","floorDiv"),n=k(e,"b","floorDiv");[t,n]=je(t,n);let o={a:t,b:n};return A.runKernel(Fo,o)}var Jl=S({floorDiv_:ej});function tj(r,e){let t=k(r,"a","div"),n=k(e,"b","div");if([t,n]=je(t,n),t.dtype==="int32"&&n.dtype==="int32")return Jl(t,n);let o={a:t,b:n},s={};return A.runKernel(Do,o,s)}var me=S({div_:tj});function rj(r,e){let t=k(r,"a","mul"),n=k(e,"b","mul");[t,n]=je(t,n);let o={a:t,b:n};return A.runKernel(Ho,o)}var P=S({mul_:rj});function nj(r){let e=k(r,"x","abs");if(e.dtype==="complex64"){let t={x:e};return A.runKernel(Za,t)}else{let t={x:e};return A.runKernel(zs,t)}}var Nt=S({abs_:nj});function oj(r){let t={x:k(r,"x","acos")};return A.runKernel(_i,t)}var zm=S({acos_:oj});function sj(r){let t={x:k(r,"x","acosh")};return A.runKernel(ki,t)}var Bm=S({acosh_:sj});function ij(r){T(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),T(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let e=r.map((o,s)=>k(o,`tensors${s}`,"addN")),t=e[0];e.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!Xr(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=e;return A.runKernel(_o,n)}var Mw=S({addN_:ij});function aj(r,e=null,t=!1){let o={x:k(r,"x","all","bool")},s={axis:e,keepDims:t};return A.runKernel(vi,o,s)}var Ql=S({all_:aj});function lj(r,e=null,t=!1){let o={x:k(r,"x","any","bool")},s={axis:e,keepDims:t};return A.runKernel(Ci,o,s)}var ml=S({any_:lj});function uj(r,e=0){let n={x:k(r,"x","argMax")},o={axis:e};return A.runKernel(ko,n,o)}var fl=S({argMax_:uj});function cj(r,e=0){let n={x:k(r,"x","argMin")},o={axis:e};return A.runKernel(Ka,n,o)}var Vm=S({argMin_:cj});function pj(r){let t={x:k(r,"x","asin")};return A.runKernel(Ii,t)}var Gm=S({asin_:pj});function mj(r){let t={x:k(r,"x","asinh")};return A.runKernel(Ni,t)}var Wm=S({asinh_:mj});function fj(r){let t={x:k(r,"x","atan")};return A.runKernel(Si,t)}var jm=S({atan_:fj});function dj(r,e){let t=k(r,"a","atan2"),n=k(e,"b","atan2");[t,n]=je(t,n);let o={a:t,b:n};return A.runKernel(Ai,o)}var Um=S({atan2_:dj});function hj(r){let t={x:k(r,"x","atanh")};return A.runKernel(Ti,t)}var Hm=S({atanh_:hj});function gj(r,e,t,n,o="NHWC",s){let a=r[3],i=[...e,a],l=FT(o);return eu(r,i,t,s,n,null,null,l)}function Lw(r,e,t,n,o,s,a="channelsLast"){let[i,l]=fg(e),u;if(a==="channelsLast")u=[i,l,r[3],r[3]];else if(a==="channelsFirst")u=[i,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return eu(r,u,t,n,o,s,!1,a)}function xj(r,e,t,n,o,s,a="NDHWC"){let[i,l,u]=zw(e),c,p;if(a==="NDHWC")p="channelsLast",c=[i,l,u,r[4],r[4]];else if(a==="NCDHW")p="channelsFirst",c=[i,l,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return OT(r,c,t,n,o,!1,p,s)}function eu(r,e,t,n,o,s,a=!1,i="channelsLast"){let[l,u,c,p]=[-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,p]=r;else if(i==="channelsFirst")[l,p,u,c]=r;else throw new Error(`Unknown dataFormat ${i}`);let[m,f,,d]=e,[h,g]=fg(t),[x,b]=fg(n),w=ep(m,x),_=ep(f,b),{padInfo:I,outHeight:E,outWidth:$}=yj(o,u,c,h,g,w,_,s,i),D=a?d*p:d,O;return i==="channelsFirst"?O=[l,D,E,$]:i==="channelsLast"&&(O=[l,E,$,D]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:p,outHeight:E,outWidth:$,outChannels:D,padInfo:I,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:_,dilationHeight:x,dilationWidth:b,inShape:r,outShape:O,filterShape:e}}function OT(r,e,t,n,o,s=!1,a="channelsLast",i){let[l,u,c,p,m]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,p,m]=r;else if(a==="channelsFirst")[l,m,u,c,p]=r;else throw new Error(`Unknown dataFormat ${a}`);let[f,d,h,,g]=e,[x,b,w]=zw(t),[_,I,E]=zw(n),$=ep(f,_),D=ep(d,I),O=ep(h,E),{padInfo:M,outDepth:G,outHeight:j,outWidth:U}=bj(o,u,c,p,x,b,w,$,D,O,i),H=s?g*m:g,q;return a==="channelsFirst"?q=[l,H,G,j,U]:a==="channelsLast"&&(q=[l,G,j,U,H]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:p,inChannels:m,outDepth:G,outHeight:j,outWidth:U,outChannels:H,padInfo:M,strideDepth:x,strideHeight:b,strideWidth:w,filterDepth:f,filterHeight:d,filterWidth:h,effectiveFilterDepth:$,effectiveFilterHeight:D,effectiveFilterWidth:O,dilationDepth:_,dilationHeight:I,dilationWidth:E,inShape:r,outShape:q,filterShape:e}}function wj(r,e,t,n,o){n==null&&(n=Bw(r,e,t));let s=r[0],a=r[1],i=tu((s-e+2*n)/t+1,o),l=tu((a-e+2*n)/t+1,o);return[i,l]}function _j(r,e,t,n,o,s){o==null&&(o=Bw(r,e,n));let a=r[0],i=r[1],l=r[2],u=tu((a-e+2*o)/n+1,s),c=tu((i-e+2*o)/n+1,s),p=tu((l-e+2*o)/n+1,s);return[u,c,p,t]}function Bw(r,e,t,n=1){let o=ep(e,n);return Math.floor((r[0]*(t-1)-t+o)/2)}function fg(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function zw(r){return typeof r=="number"?[r,r,r]:r}function ep(r,e){return e<=1?r:r+(r-1)*(e-1)}function yj(r,e,t,n,o,s,a,i,l){let u,c,p;if(typeof r=="number"){u={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=wj([e,t],s,n,r,i);c=f[0],p=f[1]}else if(r==="same"){c=Math.ceil(e/n),p=Math.ceil(t/o);let m=Math.max(0,(c-1)*n+s-e),f=Math.max(0,(p-1)*o+a-t),d=Math.floor(m/2),h=m-d,g=Math.floor(f/2),x=f-g;u={top:d,bottom:h,left:g,right:x,type:"SAME"}}else if(r==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-s+1)/n),p=Math.ceil((t-a+1)/o);else if(typeof r=="object"){let m=l==="channelsLast"?r[1][0]:r[2][0],f=l==="channelsLast"?r[1][1]:r[2][1],d=l==="channelsLast"?r[2][0]:r[3][0],h=l==="channelsLast"?r[2][1]:r[3][1];u={top:m,bottom:f,left:d,right:h,type:m===0&&f===0&&d===0&&h===0?"VALID":"EXPLICIT"},c=tu((e-s+m+f)/n+1,i),p=tu((t-a+d+h)/o+1,i)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:u,outHeight:c,outWidth:p}}function bj(r,e,t,n,o,s,a,i,l,u,c){let p,m,f,d;if(typeof r=="number"){p={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=_j([e,t,n,1],i,1,o,r,c);m=g[0],f=g[1],d=g[2]}else if(r==="same"){m=Math.ceil(e/o),f=Math.ceil(t/s),d=Math.ceil(n/a);let h=(m-1)*o+i-e,g=(f-1)*s+l-t,x=(d-1)*a+u-n,b=Math.floor(h/2),w=h-b,_=Math.floor(g/2),I=g-_,E=Math.floor(x/2),$=x-E;p={top:_,bottom:I,left:E,right:$,front:b,back:w,type:"SAME"}}else if(r==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((e-i+1)/o),f=Math.ceil((t-l+1)/s),d=Math.ceil((n-u+1)/a);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outDepth:m,outHeight:f,outWidth:d}}function tu(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ln(r){let[e,t,n]=fg(r);return e===1&&t===1&&n===1}function vr(r,e){return Ln(r)||Ln(e)}function FT(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function kj(r,e){let n={x:k(r,"x","reshape","string_or_numeric")},o={shape:e};return A.runKernel(Hs,n,o)}var L=S({reshape_:kj});function vj(r,e,t,n,o){let s=k(r,"x","avgPool","float32"),a=1;T(vr(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let i=s,l=!1;s.rank===3&&(l=!0,i=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),T(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),o!=null&&T(ot(n),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let u={x:i},c={filterSize:e,strides:t,pad:n,dimRoundingMode:o},p=A.runKernel(vo,u,c);return p=oe(p,s.dtype),l?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var fa=S({avgPool_:vj});function Cj(r,e,t,n,o,s="NDHWC"){let a=k(r,"x","avgPool3d","float32"),i=a,l=!1;a.rank===4&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),T(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),T(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),o!=null&&T(ot(n),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let u={x:i},c={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},p=A.runKernel(Xa,u,c);return p=oe(p,i.dtype),l?L(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var qm=S({avgPool3d_:Cj});function Ij(r,e=0){T(r.length>=1,()=>"Pass at least one tensor to concat");let t=la(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return Mn(t[0]);let n=t,o={axis:e};return A.runKernel(Bs,n,o)}var Qe=S({concat_:Ij});function Nj(r){let t={x:k(r,"x","sigmoid")};return A.runKernel(os,t)}var Er=S({sigmoid_:Nj});function Sj(r,e,t){let n=k(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:e,size:t};return A.runKernel(Ks,o,s)}var Fe=S({slice_:Sj});function Tj(r){let t={x:k(r,"x","tanh")};return A.runKernel(ps,t)}var gs=S({tanh_:Tj});function Aj(r,e,t,n,o,s){let a=k(r,"forgetBias","basicLSTMCell"),i=k(e,"lstmKernel","basicLSTMCell"),l=k(t,"lstmBias","basicLSTMCell"),u=k(n,"data","basicLSTMCell"),c=k(o,"c","basicLSTMCell"),p=k(s,"h","basicLSTMCell"),m=Qe([u,p],1),f=ze(m,i),d=ee(f,l),h=d.shape[0],g=d.shape[1]/4,x=[h,g],b=Fe(d,[0,0],x),w=Fe(d,[0,g],x),_=Fe(d,[0,g*2],x),I=Fe(d,[0,g*3],x),E=ee(P(Er(b),gs(w)),P(c,Er(ee(a,_)))),$=P(gs(E),Er(I));return[E,$]}var Ej=S({basicLSTMCell_:Aj});function Dj(r,e,t){let n=k(r,"x","batchToSpaceND"),o=e.reduce((i,l)=>i*l);T(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),T(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),T(n.shape[0]%o==0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);let s={x:n},a={blockShape:e,crops:t};return A.runKernel(Ya,s,a)}var da=S({batchToSpaceND_:Dj});function PT(r){let e;return r.rank===0||r.rank===1?e=L(r,[1,1,1,r.size]):r.rank===2?e=L(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}function $j(r,e,t,n,o,s){s==null&&(s=.001);let a=k(r,"x","batchNorm"),i=k(e,"mean","batchNorm"),l=k(t,"variance","batchNorm"),u;o!=null&&(u=k(o,"scale","batchNorm"));let c;n!=null&&(c=k(n,"offset","batchNorm")),T(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),T(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),T(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:PT(a),scale:u,offset:c,mean:i,variance:l},f={varianceEpsilon:s},d=A.runKernel(Oo,m,f);return L(d,a.shape)}var Jn=S({batchNorm_:$j});function Rj(r,e,t,n,o,s){let a=k(r,"x","batchNorm"),i=k(e,"mean","batchNorm"),l=k(t,"variance","batchNorm"),u;o!=null&&(u=k(o,"scale","batchNorm"));let c;return n!=null&&(c=k(n,"offset","batchNorm")),T(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),T(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),T(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&T(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&T(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Jn(a,i,l,c,u,s)}var Vw=S({batchNorm2d_:Rj});function Fj(r,e,t,n,o,s){let a=k(r,"x","batchNorm"),i=k(e,"mean","batchNorm"),l=k(t,"variance","batchNorm"),u;o!=null&&(u=k(o,"scale","batchNorm"));let c;return n!=null&&(c=k(n,"offset","batchNorm")),T(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),T(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),T(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&T(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&T(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Jn(a,i,l,c,u,s)}var Gw=S({batchNorm3d_:Fj});function Oj(r,e,t,n,o,s){let a=k(r,"x","batchNorm"),i=k(e,"mean","batchNorm"),l=k(t,"variance","batchNorm"),u;o!=null&&(u=k(o,"scale","batchNorm"));let c;return n!=null&&(c=k(n,"offset","batchNorm")),T(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),T(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),T(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&T(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&T(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Jn(a,i,l,c,u,s)}var Ww=S({batchNorm4d_:Oj});function Pj(r,e,t){let n=k(r,"x","bincount"),o=k(e,"weights","bincount");T(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),T(t>=0,()=>`size must be non-negative, but got ${t}.`),T(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},a={size:t};return A.runKernel(yc,s,a)}var jw=S({bincount_:Pj});function Mj(r,e){let t=k(r,"broadcastTo","x"),n=t.shape;if(e.some(u=>!(u>0)||u%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=L(t,u)}let o=t.shape,s=Array.from(e);for(let u=e.length-1;u>=0;u--)if(o[u]===e[u])s[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(s.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return Mn(t);let i={x:t},l={reps:s};return A.runKernel(Pn,i,l)}var ha=S({broadcastTo_:Mj});function Lj(r){let t={x:k(r,"x","ceil")};return A.runKernel(Io,t)}var Km=S({ceil_:Lj});function zj(r,e,t){let n=k(r,"x","clipByValue");T(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);let o={x:n},s={clipValueMin:e,clipValueMax:t};return A.runKernel(Kn,o,s)}var lr=S({clipByValue_:zj});function Bj(r){return Qe(r,0)}var Uw=S({concat1d_:Bj});function Vj(r,e){return Qe(r,e)}var Hw=S({concat2d_:Vj});function Gj(r,e){return Qe(r,e)}var qw=S({concat3d_:Gj});function Wj(r,e){return Qe(r,e)}var Kw=S({concat4d_:Wj});function jj(r,e,t,n,o="NHWC",s=[1,1],a){let i=k(r,"x","conv2d"),l=k(e,"filter","conv2d"),u=i,c=!1;i.rank===3&&(c=!0,u=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),T(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),T(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),a!=null&&T(ot(n),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`);let p=o==="NHWC"?u.shape[3]:u.shape[1];T(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),T(vr(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let m={x:u,filter:l},f={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},d=A.runKernel(No,m,f);return c?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Jr=S({conv2d_:jj});function Uj(r,e,t,n,o="NWC",s=1,a){let i=k(r,"x","conv1d"),l=k(e,"filter","conv1d"),u=i,c=!1;i.rank===2&&(c=!0,u=L(i,[1,i.shape[0],i.shape[1]])),T(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),T(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),a!=null&&T(ot(n),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`),T(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),T(vr(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),T(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=L(l,[1,l.shape[0],l.shape[1],l.shape[2]]),m=L(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Jr(m,p,[1,t],n,"NHWC",[1,s],a);return c?L(g,[g.shape[2],g.shape[3]]):L(g,[g.shape[0],g.shape[2],g.shape[3]])}var ru=S({conv1d_:Uj});function Hj(r,e,t,n,o,s="NHWC",a){T(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let i=r,l=e,u=!1;e.rank===3&&(u=!0,l=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,r[0],r[1],r[2]]),T(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),T(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),T(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let c=s==="NHWC"?i[3]:i[1],p=s==="NHWC"?l.shape[3]:l.shape[1];T(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),T(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),a!=null&&T(ot(o),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let m={dy:l,filter:t},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,inputShape:i},d=A.runKernel(So,m,f);return u?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var tp=S({conv2DBackpropInput_:Hj});function qj(r,e,t,n,o,s){let a=k(r,"x","conv2dTranspose"),i=k(e,"filter","conv2dTranspose");return tp(t,a,i,n,o,"NHWC",s)}var nu=S({conv2dTranspose_:qj});function Kj(r,e,t,n,o="NDHWC",s=[1,1,1]){let a=k(r,"x","conv3d"),i=k(e,"filter","conv3d"),l=a,u=!1;a.rank===4&&(u=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),T(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),T(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),T(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),T(vr(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),T(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let c={x:l,filter:i},p={strides:t,pad:n,dataFormat:o,dilations:s},m=A.runKernel(Ja,c,p);return u?L(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Xm=S({conv3d_:Kj});function Xj(r,e,t,n,o){T(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let s=r,a=e,i=!1;e.rank===4&&(i=!0,a=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let l=s[4],u=a.shape[4];T(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),T(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),T(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),T(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),T(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);let c={dy:a,filter:t},p={pad:o,strides:n,inputShape:s},m=A.runKernel(kc,c,p);return i?L(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var dg=S({conv3DBackpropInput_:Xj});function Yj(r,e,t,n,o){let s=k(r,"x","conv3dTranspose"),a=k(e,"filter","conv3dTranspose");return dg(t,s,a,n,o)}var Xw=S({conv3dTranspose_:Yj});function Zj(r){let t={x:k(r,"x","cos")};return A.runKernel(To,t)}var ga=S({cos_:Zj});function Jj(r){let t={x:k(r,"x","cosh")};return A.runKernel(Ei,t)}var ou=S({cosh_:Jj});function Qj(r,e=0,t=!1,n=!1){let s={x:k(r,"x","cumsum")},a={axis:e,exclusive:t,reverse:n};return A.runKernel(Ao,s,a)}var su=S({cumsum_:Qj});function e4(r,e,t,n=!1){let o=k(r,"x","denseBincount"),s=k(e,"weights","denseBincount");T(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),T(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),T(t>=0,()=>`size must be non-negative, but got ${t}.`),T(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let a={x:o,weights:s},i={size:t,binaryOutput:n};return A.runKernel(vc,a,i)}var Yw=S({denseBincount_:e4});function t4(r,e,t="NHWC"){let n=k(r,"x","depthToSpace"),o=t==="NHWC"?n.shape[1]:n.shape[2],s=t==="NHWC"?n.shape[2]:n.shape[3],a=t==="NHWC"?n.shape[3]:n.shape[1];T(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${n.shape}`),T(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${n.shape}`),T(a%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${n.shape}`);let i={x:n},l={blockSize:e,dataFormat:t};return A.runKernel($i,i,l)}var Ym=S({depthToSpace_:t4});function r4(r,e,t,n,o="NHWC",s=[1,1],a){let i=k(r,"x","depthwiseConv2d"),l=k(e,"filter","depthwiseConv2d"),u=i,c=!1;i.rank===3&&(c=!0,u=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),T(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),T(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),T(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),a!=null&&T(ot(n),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`);let p={x:u,filter:l},m={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},f=A.runKernel(Eo,p,m);return c?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var xs=S({depthwiseConv2d_:r4});function n4(r){let t={x:k(r,"x","diag")};return A.runKernel(Nc,t)}var o4=S({diag_:n4});function s4(r,e,t,n,o=[1,1],s="NHWC"){let a=k(r,"x","dilation2d"),i=k(e,"filter","dilation2d");T(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),T(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),T(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=a,u=!1;a.rank===3&&(l=L(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);let c={x:l,filter:i},p={strides:t,pad:n,dilations:o},m=A.runKernel(Qa,c,p);return u?L(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Zm=S({dilation2d_:s4});function i4(r,e){let t=r.length,n=[];for(let o=0;o<t;o++){let s=t-1-o,a=r[s]||1;(e[e.length-1-o]||1)>1&&a===1&&n.unshift(s)}return n}function kt(r,e){let t=[];for(let n=0;n<e.length;n++){let o=r[r.length-n-1],s=e.length-n-1,a=e[s];(o==null||o===1&&a>1)&&t.unshift(s)}return t}function Be(r,e){let t=[],n=Math.max(r.length,e.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let a=e[e.length-o-1];if(a==null&&(a=1),s===1)t.unshift(a);else if(a===1)t.unshift(s);else if(s!==a){let i=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(i)}else t.unshift(s)}return t}function a4(r,e){let t=k(r,"a","equal"),n=k(e,"b","equal");[t,n]=je(t,n),Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(Oi,o)}var Nn=S({equal_:a4});function l4(r,e,t){let n=k(e,"a","where"),o=k(t,"b","where"),s=k(r,"condition","where","bool"),a=Be(Be(s.shape,n.shape),o.shape),i=ha(s,a),l=ha(n,a),u=ha(o,a),c={condition:i,t:l,e:u};return A.runKernel(qs,c)}var Dt=S({where_:l4});function u4(r){let t={x:k(r,"x","zerosLike")};return A.runKernel(Zs,t)}var Ie=S({zerosLike_:u4});function c4(r,e){let t=k(r,"a","div"),n=k(e,"b","div");[t,n]=je(t,n);let o=me(t,n),s=Ie(o),a=Nn(n,s);return Dt(a,s,o)}var Jm=S({divNoNan_:c4});function p4(r,e){let t=k(r,"t1","dot"),n=k(e,"t2","dot");T((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);let o=t.rank===1?t.size:t.shape[1],s=n.rank===1?n.size:n.shape[0];if(T(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),t.rank===1&&n.rank===1){let a=L(t,[1,-1]),i=L(n,[-1,1]),l=ze(a,i);return L(l,[])}else if(t.rank===1&&n.rank===2){let a=L(t,[1,-1]),i=L(n,[n.shape[0],n.shape[1]]),l=ze(a,i);return L(l,[l.size])}else if(t.rank===2&&n.rank===1){let a=L(n,[-1,1]),i=ze(t,a);return L(i,[i.size])}else{let a=L(n,[n.shape[0],n.shape[1]]);return ze(t,a)}}var Zw=S({dot_:p4});function m4(r,...e){let t=e.map((o,s)=>k(o,`tensors${s}`,"einsum")),n={equation:r};return A.runKernel(Sc,t,n)}var Jw=S({einsum_:m4});function f4(r){let t={x:k(r,"x","elu")};return A.runKernel(Ri,t)}var ys=S({elu_:f4});function d4(r){let e=k(r,"x","erf");T(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=oe(e,"float32"));let t={x:e};return A.runKernel(Fi,t)}var Qm=S({erf_:d4});function h4(r){let t={x:k(r,"x","exp")};return A.runKernel($o,t)}var Jt=S({exp_:h4});function g4(r,e=0){let t=k(r,"x","expandDims","string_or_numeric");T(e<=t.rank,()=>"Axis must be <= rank of the tensor");let n={input:t},o={dim:e};return A.runKernel(Vs,n,o)}var ur=S({expandDims_:g4});function x4(r){let t={x:k(r,"x","expm1")};return A.runKernel(Pi,t)}var ef=S({expm1_:x4});function y4(r,e){let t=k(r,"x","tile","string_or_numeric");T(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let n={x:t},o={reps:e};return A.runKernel(Pn,n,o)}var zn=S({tile_:y4});function b4(r,e,t,n="float32"){e==null&&(e=r);let o=Ce([r,e],n),s=r<=e?r:e;for(let i=0;i<s;++i)o.set(1,i,i);let a=L(o.toTensor(),[r,e]);if(t==null)return a;if(t.length===1)return zn(ur(a,0),[t[0],1,1]);if(t.length===2)return zn(ur(ur(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return zn(ur(ur(ur(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var rp=S({eye_:b4});function xa(r,e,t){let n={shape:r,value:e,dtype:t};return A.runKernel(el,{},n)}function w4(r){let t={x:k(r,"x","floor")};return A.runKernel(Ro,t)}var bs=S({floor_:w4});function _4(r,e,t=0,n=0){let o=k(r,"x","gather"),s=k(e,"indices","gather","int32"),a={x:o,indices:s},i={axis:t,batchDims:n};return A.runKernel(Gs,a,i)}var Qn=S({gather_:_4});function k4(r,e){let t=k(r,"a","greater"),n=k(e,"b","greater");[t,n]=je(t,n),Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(zi,o)}var nr=S({greater_:k4});function v4(r,e){let t=k(r,"a","greaterEqual"),n=k(e,"b","greaterEqual");[t,n]=je(t,n),Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(Po,o)}var hn=S({greaterEqual_:v4});function C4(r){let t={input:k(r,"input","imag")};return A.runKernel(Dc,t)}var iu=S({imag_:C4});function I4(r){let t={x:k(r,"x","isFinite")};return A.runKernel(Bi,t)}var Qw=S({isFinite_:I4});function N4(r){let t={x:k(r,"x","isInf")};return A.runKernel(Vi,t)}var e_=S({isInf_:N4});function S4(r){let t={x:k(r,"x","isNaN")};return A.runKernel(Gi,t)}var tf=S({isNaN_:S4});function T4(r,e=.2){let n={x:k(r,"x","leakyRelu")},o={alpha:e};return A.runKernel(Mo,n,o)}var ya=S({leakyRelu_:T4});function A4(r,e){let t=k(r,"a","less"),n=k(e,"b","less");[t,n]=je(t,n),Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(Wi,o)}var au=S({less_:A4});function E4(r,e){let t=k(r,"a","lessEqual"),n=k(e,"b","lessEqual");[t,n]=je(t,n),Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(ji,o)}var Bn=S({lessEqual_:E4});function t_(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:e,num:t};return A.runKernel($c,{},n)}function D4(r,e=5,t=1,n=1,o=.5){let s=k(r,"x","localResponseNormalization");T(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),T(ot(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=s,i=!1;s.rank===3&&(i=!0,a=L(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:a},u={depthRadius:e,bias:t,alpha:n,beta:o},c=A.runKernel(tl,l,u);return i?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var rf=S({localResponseNormalization_:D4});function $4(r){let t={x:k(r,"x","log")};return A.runKernel(Lo,t)}var cr=S({log_:$4});function R4(r){let t={x:k(r,"x","log1p")};return A.runKernel(Ui,t)}var lu=S({log1p_:R4});function F4(r){return T(Ms(r),()=>"The f passed in grad(f) must be a function"),(e,t)=>{let n=k(e,"x","tf.grad","string_or_numeric"),o=t!=null?k(t,"dy","tf.grad"):null;return A.tidy(()=>{let{value:s,grads:a}=A.gradients(()=>r(n),[n],o);return o!=null&&At(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),hg(a),a[0]})}}function O4(r){return T(Ms(r),()=>"The f passed in grads(f) must be a function"),(e,t)=>{T(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=la(e,"args","tf.grads","string_or_numeric"),o=t!=null?k(t,"dy","tf.grads"):null;return A.tidy(()=>{let{value:s,grads:a}=A.gradients(()=>r(...n),n,o);return o!=null&&At(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),hg(a),a})}}function P4(r){return T(Ms(r),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{T(e instanceof Pe,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),T(t==null||t instanceof Pe,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=A.gradients(()=>r(e),[e],t);return hg(n),{grad:n[0],value:o}}}function M4(r){return T(Ms(r),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{T(Array.isArray(e)&&e.every(o=>o instanceof Pe),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),T(t==null||t instanceof Pe,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=A.gradients(()=>r(...e),e,t);return t!=null&&At(n.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),hg(n.grads),n}}function gg(r,e){T(Ms(r),()=>"The f passed in variableGrads(f) must be a function"),T(e==null||Array.isArray(e)&&e.every(u=>u instanceof ul),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=e!=null;if(!t){e=[];for(let u in A.registeredVariables)e.push(A.registeredVariables[u])}let n=t?e.filter(u=>!u.trainable):null,o=e.length;e=e.filter(u=>u.trainable),T(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:a,grads:i}=A.gradients(r,e,null,s);T(i.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),T(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let l={};return e.forEach((u,c)=>{i[c]!=null&&(l[u.name]=i[c])}),n!=null&&n.forEach(u=>l[u.name]=null),{value:a,grads:l}}function Qr(r){return A.customGrad(r)}function hg(r){if(r.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function L4(r){let t={x:k(r,"x","neg")};return A.runKernel(Ws,t)}var qe=S({neg_:L4});function z4(r){let t={x:k(r,"x","softplus")};return A.runKernel(oa,t)}var eo=S({softplus_:z4});function B4(r){let e=k(r,"x","logSigmoid");return Qr(n=>({value:qe(eo(qe(n))),gradFunc:a=>P(a,Er(qe(n)))}))(e)}var r_=S({logSigmoid_:B4});function V4(r,e=null,t=!1){let o={x:k(r,"x","max")},s={reductionIndices:e,keepDims:t};return A.runKernel(zo,o,s)}var pr=S({max_:V4});function G4(r,e){let t=k(r,"a","sub"),n=k(e,"b","sub");[t,n]=je(t,n);let o={a:t,b:n};return A.runKernel(us,o)}var pe=S({sub_:G4});function W4(r,e=null,t=!1){let n=k(r,"x","sum");n.dtype==="bool"&&(n=oe(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return A.runKernel(is,o,s)}var ge=S({sum_:W4});function j4(r,e=-1){let t=k(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Qr((o,s)=>{let a=!0,i=pr(o,e,!0),l=pe(o,i),u=pe(oe(l,"float32"),cr(ge(Jt(l),e,a)));return s([u]),{value:u,gradFunc:(p,m)=>{let[f]=m,d=!0,h=Jt(f);return pe(p,P(ge(p,e,d),h))}}})(t)}var uu=S({logSoftmax_:j4});function n_(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function MT(r,e,t){let n=r.length+e.length,o=[],s=0,a=0;for(let i=0;i<n;i++)t.indexOf(i)===-1?o.push(r[s++]):o.push(e[a++]);return o}function o_(r,e){let t=[],n=r.length;for(let s=0;s<n;s++)e.indexOf(s)===-1&&t.push(r[s]);let o=e.map(s=>r[s]);return[t,o]}function to(r,e){let t=e.map(n=>1);return MT(r,t,e)}function U4(r,e,t){T(n_(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function s_(r,e){if(n_(r,e))return null;let t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function nf(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function H4(r,e){let t=[];for(let n=e-r;n<e;++n)t.push(n);return t}function q4(r,e=null,t=!1){let n=k(r,"x","logSumExp"),o=tr(e,n.shape),s=pr(n,o,!0),a=pe(n,s),i=Jt(a),l=ge(i,o),u=cr(l),c=ee(L(s,u.shape),u);if(t){let p=to(c.shape,o);return L(c,p)}return c}var of=S({logSumExp_:q4});function K4(r,e){let t=k(r,"a","logicalAnd","bool"),n=k(e,"b","logicalAnd","bool");Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(Hi,o)}var yr=S({logicalAnd_:K4});function X4(r){let t={x:k(r,"x","logicalNot","bool")};return A.runKernel(jl,t)}var ba=S({logicalNot_:X4});function Y4(r,e){let t=k(r,"a","logicalOr","bool"),n=k(e,"b","logicalOr","bool");Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(Ul,o)}var cu=S({logicalOr_:Y4});function Z4(r,e){let t=k(r,"a","logicalXor","bool"),n=k(e,"b","logicalXor","bool");return Be(t.shape,n.shape),yr(cu(r,e),ba(yr(r,e)))}var i_=S({logicalXor_:Z4});function J4(r,e,t,n,o){let s=k(r,"x","maxPool"),a=1,i=s,l=!1;s.rank===3&&(l=!0,i=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),T(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),T(vr(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),o!=null&&T(ot(n),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let u={x:i},c={filterSize:e,strides:t,pad:n,dimRoundingMode:o},p=A.runKernel(Vo,u,c);return l?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var wa=S({maxPool_:J4});function Q4(r,e=[1,1,1],t,n,o,s="NDHWC"){let a=k(r,"x","maxPool3d"),i=a,l=!1;a.rank===4&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),T(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),T(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),o!=null&&T(ot(n),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let u={x:i},c={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},p=A.runKernel(rl,u,c);return l?L(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var sf=S({maxPool3d_:Q4});function eU(r,e,t,n,o=!1){let a={x:k(r,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:n,includeBatchInIndex:o},l=A.runKernel(Pc,a,i);return{result:l[0],indexes:l[1]}}var a_=S({maxPoolWithArgmax_:eU});function tU(r,e){let t=k(r,"a","maximum"),n=k(e,"b","maximum");[t,n]=je(t,n),t.dtype==="bool"&&(t=oe(t,"int32"),n=oe(n,"int32")),Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(Bo,o)}var en=S({maximum_:tU});function rU(r,e=null,t=!1){let o={x:k(r,"x","mean")},s={axis:e,keepDims:t};return A.runKernel(Go,o,s)}var dt=S({mean_:rU});function ht(r,e="float32"){if(e==="complex64"){let n=ht(r,"float32"),o=ht(r,"float32");return In(n,o)}let t=hc(nt(r),e);return A.makeTensor(t,r,e)}function Qt(r,e="float32"){if(e==="complex64"){let n=Qt(r,"float32"),o=ht(r,"float32");return In(n,o)}let t=Cm(nt(r),e);return A.makeTensor(t,r,e)}function nU(r,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=k(r,"x","meshgrid",r instanceof Pe?r.dtype:"float32");if(e===void 0)return[n];let o=k(e,"y","meshgrid",e instanceof Pe?e.dtype:"float32"),s=nt(n.shape),a=nt(o.shape);return t==="xy"?(n=L(n,[1,-1]),o=L(o,[-1,1]),[ze(Qt([a,1],n.dtype),n),ze(o,Qt([1,s],o.dtype))]):(n=L(n,[-1,1]),o=L(o,[1,-1]),[ze(n,Qt([1,a],n.dtype)),ze(Qt([s,1],o.dtype),o)])}function oU(r,e=null,t=!1){let o={x:k(r,"x","min")},s={axis:e,keepDims:t};return A.runKernel(Wo,o,s)}var ni=S({min_:oU});function sU(r,e){let t=k(r,"a","minimum"),n=k(e,"b","minimum");[t,n]=je(t,n),t.dtype==="bool"&&(t=oe(t,"int32"),n=oe(n,"int32")),Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(jo,o)}var ws=S({minimum_:sU});function iU(r,e,t){T(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let n=k(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");T(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);let o=t==="reflect"?1:0;for(let i=0;i<n.rank;i++)T(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),T(e[i][0]>=0&&e[i][0]<=n.shape[i]-o&&e[i][1]>=0&&e[i][1]<=n.shape[i]-o,()=>`Padding in dimension ${i} cannot be greater than or equal to ${n.shape[i]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:e,mode:t},a={x:n};return A.runKernel(Uo,a,s)}var af=S({mirrorPad_:iU});function aU(r,e){let t=k(r,"a","mod"),n=k(e,"b","mod");[t,n]=je(t,n);let o={a:t,b:n};return A.runKernel(qi,o)}var lf=S({mod_:aU});function lU(r){let e=k(r,"x","square"),t={};return A.runKernel("Square",{x:e},t)}var Me=S({square_:lU});function uU(r,e=null,t=!1){r=k(r,"x","moments");let n=tr(e,r.shape),o=dt(r,n,t),s=o.shape;t||(s=to(o.shape,n));let a=Me(pe(oe(r,"float32"),L(o,s))),i=dt(a,n,t);return{mean:o,variance:i}}var np=S({moments_:uU});function cU(r,e,t,n){let o=k(e,"data","multiRNNCell"),s=la(t,"c","multiRNNCell"),a=la(n,"h","multiRNNCell"),i=o,l=[];for(let p=0;p<r.length;p++){let m=r[p](i,s[p],a[p]);l.push(m[0]),l.push(m[1]),i=m[1]}let u=[],c=[];for(let p=0;p<l.length;p+=2)u.push(l[p]),c.push(l[p+1]);return[u,c]}var pU=S({multiRNNCell_:cU});function mU(r,e,t,n=!1){let o=k(r,"logits","multinomial"),s=o.size,a=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();let l={logits:a===1?L(o,[1,-1]):o},u={numSamples:e,seed:t,normalized:n},c=A.runKernel(Mc,l,u);return a===1?L(c,[c.size]):c}var l_=S({multinomial_:mU});function fU(r,e){let t=k(r,"a","notEqual"),n=k(e,"b","notEqual");[t,n]=je(t,n),Be(t.shape,n.shape);let o={a:t,b:n};return A.runKernel(Ki,o)}var ro=S({notEqual_:fU});function dU(r){let t={x:k(r,"x","onesLike")};return A.runKernel(js,t)}var or=S({onesLike_:dU});function hU(r,e){let t=k(r,"v1","outerProduct"),n=k(e,"v2","outerProduct");T(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);let o=L(t,[-1,1]),s=L(n,[1,-1]);return ze(o,s)}var gU=S({outerProduct_:hU});function xU(r,e,t=0){let n=k(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:e,constantValue:t},s={x:n};return A.runKernel(Ko,s,o)}var Lr=S({pad_:xU});function yU(r,e,t=0){return T(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Lr(r,[e],t)}var bU=S({pad1d_:yU});function wU(r,e,t=0){return T(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Lr(r,e,t)}var _U=S({pad2d_:wU});function kU(r,e,t=0){return T(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Lr(r,e,t)}var vU=S({pad3d_:kU});function CU(r,e,t=0){return T(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Lr(r,e,t)}var IU=S({pad4d_:CU});function NU(r,e,t){let n=k(r,"x","spaceToBatchND");T(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),T(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),T(n.shape.reduce((a,i,l)=>l>0&&l<=e.length?a&&(i+t[l-1][0]+t[l-1][1])%e[l-1]==0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let o={x:n},s={blockShape:e,paddings:t};return A.runKernel(sl,o,s)}var _a=S({spaceToBatchND_:NU});function AU(r,e,t,n,o,s){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=k(r,"x","maxPool"),i=a,l=!1;a.rank===3&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),T(vr(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let u=Lw(i.shape,e,s,o,n),c=[u.dilationHeight,u.dilationWidth],p;n==="same"?p=TU([u.filterHeight,u.filterWidth],c):p=[[0,0],[0,0]];let m=c[0]===1&&c[1]===1,[f,d]=SU([u.inHeight,u.inWidth],c,p),h=m?n:"valid",g=m?i:_a(i,c,f),b=(t==="avg"?()=>fa(g,e,s,h):()=>wa(g,e,s,h))(),w=m?b:da(b,c,d);return l?L(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function SU(r,e,t){let n=t.map(c=>c[0]),o=t.map(c=>c[1]),s=r.concat(n,o),a=e.map((c,p)=>(c-s[p]%c)%c),i=o.map((c,p)=>c+a[p]),l=e.map((c,p)=>[n[p],i[p]]),u=e.map((c,p)=>[0,a[p]]);return[l,u]}function TU(r,e){let n=r.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),o=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-o[i]);return n.map((a,i)=>[o[i],s[i]])}var u_=S({pool_:AU});function EU(r,e){let t=k(r,"base","pow"),n=k(e,"exp","pow");[t,n]=je(t,n);let o={a:t,b:n};return A.runKernel(Xo,o)}var zr=S({pow_:EU});function DU(r,e){let t=k(r,"x","prelu"),n=k(e,"alpha","prelu"),o={x:t,alpha:n};return A.runKernel(Yo,o)}var ka=S({prelu_:DU});function $U(r,e=null,t=!1){let n=k(r,"x","prod");n.dtype==="bool"&&(n=oe(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return A.runKernel(Ji,o,s)}var pu=S({prod_:$U});function RU(r,e,t){let n=nt(r),o=null;if(t==null||t==="float32")o=new Float32Array(n);else if(t==="int32")o=new Int32Array(n);else if(t==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<n;s++)o[s]=e();return A.makeTensor(o,r,t)}var FU=S({rand_:RU});var yg=pc(x_());var op=class{constructor(e,t,n,o,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=yg.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let e,t,n=!1;for(;!n;){let o,s,a;do o=2*this.random()-1,s=2*this.random()-1,a=o*o+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*o*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},y_=class{constructor(e,t,n,o){this.alpha=e,this.beta=1/t,this.dtype=n;let s=o||Math.random();this.randu=yg.alea(s.toString()),this.randn=new op(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,o,s,a;for(;;){do o=this.randn.nextValue(),a=1+this.c*o;while(a<=0);if(a*=a*a,e=o*o,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},b_=class{constructor(e=0,t=1,n,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=yg.alea(o)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function VU(r,e,t=1,n="float32",o){if(t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new y_(e,t,n,o),a=Ce(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var GU=S({randomGamma_:VU});function WU(r,e=0,t=1,n,o){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new op(e,t,n,!1,o),a=Ce(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var bg=S({randomNormal_:WU});function jU(r,e=0,t=1,n="float32",o){let s=Ce(r,n),a=new b_(e,t,null,o);for(let i=0;i<s.values.length;i++)s.values[i]=a.nextValue();return s.toTensor()}var _s=S({randomUniform_:jU});function sp(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:e,step:t,dtype:n};return A.runKernel(nl,{},o)}function UU(r){let t={input:k(r,"input","real")};return A.runKernel(Lc,t)}var dl=S({real_:UU});function HU(r){let t={x:k(r,"x","reciprocal")};return A.runKernel(Qi,t)}var uf=S({reciprocal_:HU});function qU(r){let t={x:k(r,"x","relu")};return A.runKernel(Zo,t)}var Dr=S({relu_:qU});function KU(r){let t={x:k(r,"x","relu6")};return A.runKernel(Qo,t)}var fu=S({relu6_:KU});function XU(r,e){let n={x:k(r,"x","reverse")},o={dims:e};return A.runKernel(es,n,o)}var qt=S({reverse_:XU});function YU(r){let e=k(r,"x","reverse");return T(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),qt(e,0)}var ZU=S({reverse1d_:YU});function JU(r,e){let t=k(r,"x","reverse");return T(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),qt(t,e)}var QU=S({reverse2d_:JU});function eH(r,e){let t=k(r,"x","reverse");return T(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),qt(t,e)}var tH=S({reverse3d_:eH});function rH(r,e){let t=k(r,"x","reverse");return T(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),qt(t,e)}var nH=S({reverse4d_:rH});function oH(r){let t={x:k(r,"x","round")};return A.runKernel(ts,t)}var cf=S({round_:oH});function sH(r){let t={x:k(r,"x","rsqrt")};return A.runKernel(rs,t)}var du=S({rsqrt_:sH});function le(r,e){if((ir(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&ir(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Yr(r,[],[],e)}function iH(r){let t={x:k(r,"x","selu")};return A.runKernel(ta,t)}var hu=S({selu_:iH});function aH(r,e,t,n,o,s=[1,1],a="NHWC"){let i=k(r,"x","separableConv2d"),l=k(e,"depthwiseFilter","separableConv2d"),u=k(t,"pointwiseFilter","separableConv2d"),c=i,p=!1;if(i.rank===3&&(p=!0,c=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");T(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),T(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),T(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),T(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),T(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let m=l.shape[2],f=l.shape[3];T(u.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${u.shape[2]}.`);let d=xs(c,l,n,o,a,s),g=Jr(d,u,1,"valid",a);return p?L(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var pf=S({separableConv2d_:aH});async function lH(r,e){let t=k(r,"x","setdiff1d"),n=k(e,"y","setdiff1d");T(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),T(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),T(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await t.data(),s=await n.data(),a=new Set(s),i=0;for(let c=0;c<o.length;c++)a.has(o[c])||i++;let l=new ut([i],t.dtype),u=new ut([i],"int32");for(let c=0,p=0;c<o.length;c++)a.has(o[c])||(l.values[p]=o[c],u.values[p]=c,p++);return[l.toTensor(),u.toTensor()]}var w_=lH;function uH(r){let t={x:k(r,"x","sign")};return A.runKernel(na,t)}var mf=S({sign_:uH});function cH(r){let t={x:k(r,"x","sin")};return A.runKernel(ns,t)}var gu=S({sin_:cH});function pH(r){let t={x:k(r,"x","sinh")};return A.runKernel(ra,t)}var xu=S({sinh_:pH});function mH(r,e,t){let n=k(r,"x","slice1d");return T(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Fe(n,[e],[t])}var ff=S({slice1d_:mH});function fH(r,e,t){let n=k(r,"x","slice2d");return T(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Fe(n,e,t)}var wg=S({slice2d_:fH});function dH(r,e,t){let n=k(r,"x","slice3d");return T(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Fe(n,e,t)}var df=S({slice3d_:dH});function hH(r,e,t){let n=k(r,"x","slice4d");return T(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Fe(n,e,t)}var ip=S({slice4d_:hH});function gH(r,e=-1){let t=k(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let n={logits:t},o={dim:e};return A.runKernel(as,n,o)}var va=S({softmax_:gH});function xH(r){T(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let e={input:r};return A.runKernel(Ac,e)}var Ca=S({fft_:xH});function yH(r){T(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let e={input:r};return A.runKernel(Ec,e)}var oi=S({ifft_:yH});function bH(r){let e=r.shape[r.shape.length-1],t=r.size/e,n;if(e<=2){let o=L(r,[t,e]);n=oi(o)}else{let o=[t,2*(e-1)],s=L(dl(r),[t,e]),a=L(iu(r),[t,e]),i=qt(Fe(s,[0,1],[t,e-2]),1),l=P(qt(Fe(a,[0,1],[t,e-2]),1),le(-1)),u=Qe([s,i],1),c=Qe([a,l],1),p=L(In(u,c),[o[0],o[1]]);n=oi(p)}if(n=dl(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=L(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var yu=S({irfft_:bH});function wH(r,e,t=0){let o={x:k(r,"x","split")},s={numOrSizeSplits:e,axis:t};return A.runKernel(Xs,o,s)}var mr=S({split_:wH});function _H(r,e){T(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1],n=r.size/t,o;if(e!=null&&e<t){let d=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=e,o=Fe(r,d,h),t=e}else if(e!=null&&e>t){let d=r.shape.map(h=>h);d[r.shape.length-1]=e-t,o=Qe([r,ht(d)],r.shape.length-1),t=e}else o=r;let s=Ie(o),a=L(In(o,s),[n,t]),i=Ca(a),l=Math.floor(t/2)+1,u=dl(i),c=iu(i),p=mr(u,[l,t-l],u.shape.length-1),m=mr(c,[l,t-l],c.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=l,L(In(p[0],m[0]),f)}var Ia=S({rfft_:_H});function kH(r){let t={x:k(r,"x","sqrt")};return A.runKernel(ss,t)}var gt=S({sqrt_:kH});function vH(r,e){let t=k(r,"a","squaredDifference"),n=k(e,"b","squaredDifference");[t,n]=je(t,n),Be(t.shape,n.shape);let o={a:t,b:n},s={};return A.runKernel(ls,o,s)}var bu=S({squaredDifference_:vH});function CH(r,e){let t=k(r,"x","squeeze");return L(t,Xb(t.shape,e).newShape)}var Sn=S({squeeze_:CH});function IH(r,e=0){let t=la(r,"tensors","stack","string_or_numeric");T(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&T(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let n=t,o={axis:e};return A.runKernel(Us,n,o)}var Bt=S({stack_:IH});function NH(r,e=0){let n={x:k(r,"x","step")},o={alpha:e};return A.runKernel(Yn,n,o)}var ks=S({step_:NH});function SH(r,e,t,n,o=0,s=0,a=0,i=0,l=0){let c={x:k(r,"x","stridedSlice")},p={begin:e,end:t,strides:n,beginMask:o,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};return A.runKernel(sa,c,p)}var hf=S({stridedSlice_:SH});function TH(r){let t={x:k(r,"x","tan")};return A.runKernel(cs,t)}var gf=S({tan_:TH});function Vt(r,e){Fn(r);let t=Tr(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Yr(r,null,t,e)}function si(r,e,t){if(Fn(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Tr(r,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Yr(r,e,n,t)}function AH(r,e,t){if(Fn(r),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Tr(r,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Yr(r,e,n,t)}function EH(r,e,t){if(Fn(r),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Tr(r,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Yr(r,e,n,t)}function DH(r,e,t){if(Fn(r),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Tr(r,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,Yr(r,e,n,t)}function $H(r,e=1,t=!0){let n=k(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);let s={x:n},a={k:e,sorted:t},[i,l]=A.runKernel(ia,s,a);return{values:i,indices:l}}var xf=S({topk_:$H});function RH(r,e=0,t=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new op(e,t,n,!0,o),a=Ce(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var wu=S({truncatedNormal_:RH});function FH(r,e=0){let t=k(r,"x","unique","string_or_numeric");T(t.rank>0,()=>"The input tensor must be at least 1D");let n={x:t},o={axis:e},[s,a]=A.runKernel(jc,n,o);return{values:s,indices:a}}var ap=S({unique_:FH});function OH(r,e,t){let n=k(r,"x","unsortedSegmentSum"),o=k(e,"segmentIds","unsortedSegmentSum","int32");T(ot(t),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},a={numSegments:t};return A.runKernel(al,s,a)}var yf=S({unsortedSegmentSum_:OH});function PH(r,e=0){let t=k(r,"x","unstack","string_or_numeric");T(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let n={value:t},o={axis:e};return A.runKernel(Ys,n,o)}var fr=S({unstack_:PH});function __(r,e=!0,t,n){return A.makeVariable(r,e,t,n)}function _g(r,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let n=Ce(r,"int32"),o=Ce([t.length,r.length],"int32");for(let s=0;s<t.length;s++){let a=n.indexToLoc(t[s]),i=s*r.length;o.values.set(a,i)}return o.toTensor()}async function MH(r){let e=k(r,"condition","whereAsync","bool"),t=await e.data(),n=_g(e.shape,t);return r!==e&&e.dispose(),n}var bf=MH;async function LH(r,e,t){let n=k(r,"tensor","boolMask"),o=k(e,"mask","boolMask","bool"),s=t==null?0:t,a=o.rank,i=n.shape;T(a>0,()=>"mask cannot be scalar"),At(i.slice(s,s+a),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let h=s;h<s+a;h++)l*=i[h];let u=i.slice(0,s).concat([l],i.slice(s+a)),c=L(n,u),p=L(o,[-1]),m=await bf(p),f=Sn(m,[1]),d=Qn(c,f,s);return r!==n&&n.dispose(),e!==o&&o.dispose(),f.dispose(),c.dispose(),p.dispose(),m.dispose(),d}var aIe=LH;function zH(r,e="euclidean",t=null,n=!1){r=k(r,"x","norm");let o=JT(r,e,t),s=o.shape;if(n){let a=tr(t,r.shape);s=to(o.shape,a)}return L(o,s)}function JT(r,e,t=null){if(r.rank===0)return Nt(r);if(r.rank!==1&&t===null)return JT(L(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return ge(Nt(r),t);if(e===Infinity)return pr(Nt(r),t);if(e===-Infinity)return ni(Nt(r),t);if(e==="euclidean"||e===2)return gt(ge(zr(Nt(r),le(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return pr(ge(Nt(r),t[0]),t[1]-1);if(e===Infinity)return pr(ge(Nt(r),t[1]),t[0]);if(e===-Infinity)return ni(ge(Nt(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return gt(ge(Me(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var lp=S({norm_:zH});function BH(r,e,t,n,o=!0){let s=k(r,"v","movingAverage"),a=k(e,"x","movingAverage"),i=k(t,"decay","movingAverage");fw(s,a),T(Xr(s.shape,a.shape),()=>"Shape mismatch in v and x");let l=le(1),u=pe(l,i),c=P(pe(a,s),u);if(o){T(n!=null,()=>"When using zeroDebias: true, step is required.");let p=k(n,"step","movingAverage");c=me(c,pe(l,zr(i,p)))}return ee(s,c)}var RIe=S({movingAverage_:BH});function VH(r,e,t){let n=k(r,"indices","scatterND","int32"),o=k(e,"updates","scatterND");cg(o,n,t);let s={indices:n,updates:o},a={shape:t};return A.runKernel(ea,s,a)}var QT=S({scatterND_:VH});function e1(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let a=e.size;if(!(e.rank===0||e.rank===1&&a===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function GH(r,e,t,n=0){let o=k(r,"sparseIndices","sparseToDense","int32"),s=k(e,"sparseValues","sparseToDense"),a=k(n,"defaultValue","sparseToDense",s.dtype);e1(o,s,t,a);let i={sparseIndices:o,sparseValues:s,defaultValue:a},l={outputShape:t};return A.runKernel(Gc,i,l)}var kg=S({sparseToDense_:GH});function WH(r,e){let t=k(e,"indices","gatherND","int32"),o={params:k(r,"x","gatherND"),indices:t};return A.runKernel(Li,o)}var t1=S({gatherND_:WH});function r1(r,e){if(e==null)return r.shape.slice();if(Xr(r.shape,e))return e;if(r.shape.length===e.length){let t=[];for(let n=0;n<r.shape.length;n++)e[n]==null&&r.shape[n]!=null?t.push(r.shape[n]):t.push(e[n]);return t}return e}function jH(r,e,t,n){let o=k(r,"x","dropout");if(T(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),T(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return r instanceof Pe?o.clone():o;let s=r1(o,t),a=1-e,i=me(bs(ee(_s(s,0,1,"float32",n),a)),a);return P(o,i)}var n1=S({dropout_:jH});function o1(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function vg(r,e,t){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let a=2*Math.PI*s/(r+n-1);o[s]=e-t*Math.cos(a)}return Vt(o,"float32")}async function UH(r,e,t=1){let n=k(r,"predictions","inTopK"),o=k(e,"targets","inTopK");T(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),T(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),At(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];T(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let a=await n.data(),i=await o.data(),[l,u]=[a.length/s,s],c=Yb("bool",l);for(let p=0;p<l;p++){let m=p*u,f=a.subarray(m,m+u),d=[];for(let h=0;h<f.length;h++)d.push({value:f[h],index:h});d.sort((h,g)=>g.value-h.value),c[p]=0;for(let h=0;h<t;h++)if(d[h].index===i[p]){c[p]=1;break}}return r!==n&&n.dispose(),e!==o&&o.dispose(),Mr(c,o.shape,"bool")}var xNe=UH;var no={};We(no,{conv2d:()=>s1,depthwiseConv2d:()=>i1,matMul:()=>a1});function HH(r,e,t,n,o,s="NHWC",a){let i=r;r.rank===3&&(i=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=e;l.rank===3&&(l=L(e,[1,e.shape[0],e.shape[1],e.shape[2]])),T(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),T(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),T(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let u=s==="NHWC"?i.shape[3]:i.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];T(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),T(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),a!=null&&T(ot(o),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let p={x:i,dy:l},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,filterShape:t};return A.runKernel(wc,p,m)}var up=S({conv2DBackpropFilter_:HH});function _u(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return P(r,ks(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function ku(r,e){let t=e,n=kt(r.shape,e.shape);return n.length>0&&(t=ge(t,n)),L(t,r.shape)}function vu(r,e,t,n){if(e==="linear")return r;if(e==="relu")return Dr(r);if(e==="elu")return ys(r);if(e==="relu6")return fu(r);if(e==="prelu")return ka(r,t);if(e==="leakyrelu")return ya(r,n);if(e==="sigmoid")return Er(r);throw new Error(`Unknown fused activation ${e}.`)}var Cu=(r,e)=>!(r>0)||e==="linear";function qH({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",Cu(A.state.gradientDepth,l)===!1){let I=Jr(r,e,t,n,o,s,a);return i!=null&&(I=ee(I,i)),vu(I,l,u,c)}let p=k(r,"x","conv2d"),m=k(e,"filter","conv2d"),f=p,d=!1;p.rank===3&&(d=!0,f=L(p,[1,p.shape[0],p.shape[1],p.shape[2]])),T(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),T(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),a!=null&&T(ot(n),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`),T(f.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${m.shape[2]}.`),T(vr(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),T(o==="NHWC",()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);let h=eu(f.shape,m.shape,t,s,n,a),g;i!=null&&(g=k(i,"bias","fused conv2d"),[g]=je(g,p),Be(h.outShape,g.shape));let x;u!=null&&(x=k(u,"prelu weights","fused conv2d"));let b=(I,E)=>{let[$,D,O,M]=E,G=_u(I,O,l);T(Ln(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let j=tp(D.shape,G,$,t,n),U=up(D,G,$.shape,t,n),H=[j,U];if(M!=null){let q=ku(M,G);H.push(q)}return H},w={x:f,filter:m,bias:g,preluActivationWeights:x},_={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?Qr((E,$,D)=>{let O=A.runKernel(Qs,w,_);return D([$,E,O]),d&&(O=L(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:b}})(f,m):Qr((E,$,D,O)=>{let M=A.runKernel(Qs,w,_);return O([$,E,M,D]),d&&(M=L(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(f,m,g)}var s1=S({fusedConv2d_:qH});function KH(r,e,t,n,o,s=[1,1],a){let i=r;r.rank===3&&(i=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let l=e;l.rank===3&&(l=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u={x:i,dy:l},c={strides:n,pad:o,dimRoundingMode:a,dilations:s,filterShape:t};return A.runKernel(Cc,u,c)}var Cg=S({depthwiseConv2dNativeBackpropFilter_:KH});function XH(r,e,t,n,o,s=[1,1],a){let i=e,l=!1;e.rank===3&&(l=!0,i=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u={dy:i,filter:t},c={strides:n,pad:o,dimRoundingMode:a,dilations:s,inputShape:r},p=A.runKernel(Ic,u,c);return l?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ig=S({depthwiseConv2dNativeBackpropInput_:XH});function YH({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(Cu(A.state.gradientDepth,l)===!1){let I=xs(r,e,t,n,o,s,a);return i!=null&&(I=ee(I,i)),vu(I,l,u,c)}let p=k(r,"x","depthwiseConv2d"),m=k(e,"filter","depthwiseConv2d"),f=p,d=!1;p.rank===3&&(d=!0,f=L(p,[1,p.shape[0],p.shape[1],p.shape[2]])),T(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),T(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),T(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),T(vr(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),a!=null&&T(ot(n),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${n}.`);let h=eu(f.shape,m.shape,t,s,n,a,!0),g;i!=null&&(g=k(i,"bias","fused conv2d"),[g]=je(g,p),Be(h.outShape,g.shape));let x;u!=null&&(x=k(u,"prelu weights","fused depthwiseConv2d"));let b=(I,E)=>{T(Ln(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[$,D,O,M]=E,G=_u(I,O,l),j=Ig(D.shape,G,$,t,n,s,a),U=Cg(D,G,$.shape,t,n,s,a);if(M!=null){let H=ku(g,G);return[j,U,H]}return[j,U]},w={x:f,filter:m,bias:g,preluActivationWeights:x},_={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?Qr((E,$,D)=>{let O=A.runKernel(ei,w,_);return D([$,E,O]),d&&(O=L(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:b}})(f,m):Qr((E,$,D,O)=>{let M=A.runKernel(ei,w,_);return O([$,E,M,D]),d&&(M=L(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(f,m,g)}var i1=S({fusedDepthwiseConv2d_:YH});function ZH({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:i}){if(Cu(A.state.gradientDepth,s)===!1){let M=ze(r,e,t,n);return o!=null&&(M=ee(M,o)),vu(M,s,a,i)}let l=k(r,"a","fused matMul"),u=k(e,"b","fused matMul");[l,u]=je(l,u);let c=t?l.shape[l.rank-2]:l.shape[l.rank-1],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],m=t?l.shape[l.rank-1]:l.shape[l.rank-2],f=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=l.shape.slice(0,-2),h=u.shape.slice(0,-2),g=nt(d),x=nt(h);T(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),T(Xr(d,h),()=>`Error in fused matMul: outer dimensions (${d}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),T(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${n} must match.`);let b=l.shape.slice(0,-2).concat([m,f]),w=t?L(l,[g,c,m]):L(l,[g,m,c]),_=n?L(u,[x,f,p]):L(u,[x,p,f]),I;o!=null&&(I=k(o,"bias","fused matMul"),[I]=je(I,l),Be(b,I.shape));let E;a!=null&&(E=k(a,"prelu weights","fused matMul"));let $=(M,G)=>{let[j,U,H,q]=G,X=_u(L(M,H.shape),H,s),ne,Y;if(!t&&!n?(ne=ze(X,U,!1,!0),Y=ze(j,X,!0,!1)):!t&&n?(ne=ze(X,U,!1,!1),Y=ze(X,j,!0,!1)):t&&!n?(ne=ze(U,X,!1,!0),Y=ze(j,X,!1,!1)):(ne=ze(U,X,!0,!0),Y=ze(X,j,!0,!0)),o!=null){let re=ku(q,X);return[ne,Y,re]}else return[ne,Y]},D={a:w,b:_,bias:I,preluActivationWeights:E},O={transposeA:t,transposeB:n,activation:s,leakyreluAlpha:i};return o==null?Qr((G,j,U)=>{let H=A.runKernel(Js,D,O);return U([G,j,H]),{value:L(H,b),gradFunc:$}})(w,_):Qr((G,j,U,H)=>{let q=A.runKernel(Js,D,O);return H([G,j,q,U]),{value:L(q,b),gradFunc:$}})(w,_,I)}var a1=S({fusedMatMul_:ZH});function JH(r){return vg(r,.54,.46)}var l1=S({hammingWindow_:JH});function QH(r){return vg(r,.5,.5)}var Ng=S({hannWindow_:QH});function eq(r,e,t,n=!1,o=0){let s=0,a=[];for(;s+e<=r.size;)a.push(Fe(r,s,e)),s+=t;if(n)for(;s<r.size;){let i=s+e-r.size,l=Qe([Fe(r,s,e-i),xa([i],o)]);a.push(l),s+=t}return a.length===0?si([],[0,e]):L(Qe(a),[a.length,e])}var Sg=S({frame_:eq});function tq(r,e,t,n,o=Ng){n==null&&(n=o1(e));let s=Sg(r,e,t),a=P(s,o(e));return Ia(a,n)}var u1=S({stft_:tq});function rq(r,e,t,n,o="bilinear",s=0){let a=k(r,"image","cropAndResize"),i=k(e,"boxes","cropAndResize","float32"),l=k(t,"boxInd","cropAndResize","int32"),u=i.shape[0];T(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),T(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),T(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),T(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),T(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),T(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:a,boxes:i,boxInd:l},p={method:o,extrapolationValue:s,cropSize:n};return A.runKernel(Di,c,p)}var c1=S({cropAndResize_:rq});function nq(r){let e=k(r,"image","flipLeftRight","float32");T(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return A.runKernel(Mi,t,{})}var p1=S({flipLeftRight_:nq});function oq(r,e,t=0,n=.5){let o=k(r,"image","rotateWithOffset","float32");T(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},a={radians:e,fillValue:t,center:n};return A.runKernel(aa,s,a)}var m1=S({rotateWithOffset_:oq});function oo(r,e,t,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let a=r.shape[0];return t=Math.min(t,a),T(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),T(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),T(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),T(e.rank===1,()=>"scores must be a 1D tensor"),T(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),T(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function sq(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=k(r,"boxes","nonMaxSuppression"),a=k(e,"scores","nonMaxSuppression"),i=oo(s,a,t,n,o);t=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let l={maxOutputSize:t,iouThreshold:n,scoreThreshold:o};return A.runKernel(Xi,{boxes:s,scores:a},l)}var f1=S({nonMaxSuppression_:sq});function d1(r,e,t){let n=iq(r,e,t),o=n<0?-(n+1):n;r.splice(o,0,e)}function iq(r,e,t){return lq(r,e,t||aq)}function aq(r,e){return r>e?1:r<e?-1:0}function lq(r,e,t){let n=0,o=r.length,s=0,a=!1;for(;n<o;){s=n+(o-n>>>1);let i=t(e,r[s]);i>0?n=s+1:(o=s,a=!i)}return a?n:-n-1}function Tg(r,e,t,n,o){return k_(r,e,t,n,o,0)}function Ag(r,e,t,n,o,s){return k_(r,e,t,n,o,0,!1,s,!0)}function Eg(r,e,t,n,o,s){return k_(r,e,t,n,o,s,!0)}function k_(r,e,t,n,o,s,a=!1,i=!1,l=!1){let u=[];for(let g=0;g<e.length;g++)e[g]>o&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(h1);let c=s>0?-.5/s:0,p=[],m=[];for(;p.length<t&&u.length>0;){let g=u.pop(),{score:x,boxIndex:b,suppressBeginIndex:w}=g;if(x<o)break;let _=!1;for(let I=p.length-1;I>=w;--I){let E=uq(r,b,p[I]);if(E>=n){_=!0;break}if(g.score=g.score*cq(n,c,E),g.score<=o)break}g.suppressBeginIndex=p.length,_||(g.score===x?(p.push(b),m.push(g.score)):g.score>o&&d1(u,g,h1))}let f=p.length,d=t-f;i&&d>0&&(p.push(...new Array(d).fill(0)),m.push(...new Array(d).fill(0)));let h={selectedIndices:p};return a&&(h.selectedScores=m),l&&(h.validOutputs=f),h}function uq(r,e,t){let n=r.subarray(e*4,e*4+4),o=r.subarray(t*4,t*4+4),s=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),i=Math.max(n[0],n[2]),l=Math.max(n[1],n[3]),u=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),m=Math.max(o[1],o[3]),f=(i-s)*(l-a),d=(p-u)*(m-c);if(f<=0||d<=0)return 0;let h=Math.max(s,u),g=Math.max(a,c),x=Math.min(i,p),b=Math.min(l,m),w=Math.max(x-h,0)*Math.max(b-g,0);return w/(f+d-w)}function cq(r,e,t){let n=Math.exp(e*t*t);return t<=r?n:0}function h1(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}async function pq(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=k(r,"boxes","nonMaxSuppressionAsync"),a=k(e,"scores","nonMaxSuppressionAsync"),i=oo(s,a,t,n,o);t=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let l=await Promise.all([s.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:p}=Tg(u,c,t,n,o);return s!==r&&s.dispose(),a!==e&&a.dispose(),Vt(p,"int32")}var g1=pq;function mq(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=k(r,"boxes","nonMaxSuppression"),i=k(e,"scores","nonMaxSuppression"),l=oo(a,i,t,n,o,s);t=l.maxOutputSize,n=l.iouThreshold,o=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:a,scores:i},c={maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},p=A.runKernel(Zi,u,c);return{selectedIndices:p[0],selectedScores:p[1]}}var x1=S({nonMaxSuppressionWithScore_:mq});async function fq(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=k(r,"boxes","nonMaxSuppressionAsync"),i=k(e,"scores","nonMaxSuppressionAsync"),l=oo(a,i,t,n,o,s);t=l.maxOutputSize,n=l.iouThreshold,o=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([a.data(),i.data()]),c=u[0],p=u[1],{selectedIndices:m,selectedScores:f}=Eg(c,p,t,n,o,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Vt(m,"int32"),selectedScores:Vt(f)}}var y1=fq;function dq(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=k(r,"boxes","nonMaxSuppression"),i=k(e,"scores","nonMaxSuppression"),l=oo(a,i,t,n,o,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,m={boxes:a,scores:i},f={maxOutputSize:u,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},d=A.runKernel(Yi,m,f);return{selectedIndices:d[0],validOutputs:d[1]}}var b1=S({nonMaxSuppressionPadded_:dq});async function hq(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=k(r,"boxes","nonMaxSuppressionAsync"),i=k(e,"scores","nonMaxSuppressionAsync"),l=oo(a,i,t,n,o,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,[m,f]=await Promise.all([a.data(),i.data()]),{selectedIndices:d,validOutputs:h}=Ag(m,f,u,c,p,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Vt(d,"int32"),validOutputs:le(h,"int32")}}var w1=hq;function gq(r,e,t=!1,n=!1){let o=k(r,"images","resizeBilinear");T(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),T(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),T(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,i={images:s},l={alignCorners:t,halfPixelCenters:n,size:e},u=A.runKernel(Jo,i,l);return a?L(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Dg=S({resizeBilinear_:gq});function xq(r,e,t=!1,n=!1){let o=k(r,"images","resizeNearestNeighbor");T(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),T(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),T(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),T(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,i={images:s},l={alignCorners:t,halfPixelCenters:n,size:e},u=A.runKernel(ol,i,l);return a?L(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var $g=S({resizeNearestNeighbor_:xq});function yq(r,e,t="nearest",n="constant",o=0,s){let a=k(r,"image","transform","float32"),i=k(e,"transforms","transform","float32");T(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),T(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),T(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:a,transforms:i},u={interpolation:t,fillMode:n,fillValue:o,outputShape:s};return A.runKernel(Wc,l,u)}var _1=S({transform_:yq});function bq(r,e,t){T(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),T(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);let n=k(r,"a","bandPart");T(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,a]=n.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=a))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`);e<0&&(e=s),t<0&&(t=a);let i=L(sp(0,s,1,"int32"),[-1,1]),l=sp(0,a,1,"int32"),u=pe(i,l),c=yr(Bn(u,le(+e,"int32")),hn(u,le(-t,"int32"))),p=ht([s,a],n.dtype);return L(Bt(fr(L(n,[-1,s,a])).map(m=>Dt(c,m,p))),o)}var k1=S({bandPart_:bq});function wq(r){let e;if(Array.isArray(r)){e=!1,T(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)T(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else e=!0,r=mr(r,r.shape[0],0).map(o=>Sn(o,[0]));T(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let t=[],n=r;for(let o=0;o<r.length;++o)t.push(A.tidy(()=>{let s=n[o];if(o>0)for(let a=0;a<o;++a){let i=P(ge(P(t[a],s)),t[a]);s=pe(s,i)}return me(s,lp(s,"euclidean"))}));return e?Bt(t,0):t}var v1=S({gramSchmidt_:wq});function _q(r,e=!1){if(T(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return C1(r,e);{let t=r.shape.slice(0,r.shape.length-2).reduce((l,u)=>l*u),n=fr(L(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(l=>{let[u,c]=C1(l,e);o.push(u),s.push(c)});let a=L(Bt(o,0),r.shape),i=L(Bt(s,0),r.shape);return[a,i]}}function C1(r,e=!1){return A.tidy(()=>{T(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let t=r.shape[0],n=r.shape[1],o=rp(t),s=Mn(r),a=si([[1]],[1,1]),i=Mn(a),l=t>=n?n:t;for(let u=0;u<l;++u){let c=s,p=i,m=o;[i,s,o]=A.tidy(()=>{let f=Fe(s,[u,u],[t-u,1]),d=lp(f),h=Fe(s,[u,u],[1,1]),g=Dt(nr(h,0),si([[-1]]),si([[1]])),x=pe(h,P(g,d)),b=me(f,x);b.shape[0]===1?i=Mn(a):i=Qe([a,Fe(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let w=qe(me(ze(g,x),d)),_=Fe(s,[u,0],[t-u,n]),I=P(w,i),E=Ue(i);if(u===0)s=pe(_,ze(I,ze(E,_)));else{let O=pe(_,ze(I,ze(E,_)));s=Qe([Fe(s,[0,0],[u,n]),O],0)}let $=Ue(I),D=Fe(o,[0,u],[t,o.shape[1]-u]);if(u===0)o=pe(D,ze(ze(D,i),$));else{let O=pe(D,ze(ze(D,i),$));o=Qe([Fe(o,[0,0],[t,u]),O],1)}return[i,s,o]}),Ee([c,p,m])}return!e&&t>n&&(o=Fe(o,[0,0],[t,n]),s=Fe(s,[0,0],[n,n])),[o,s]})}var I1=S({qr_:_q});var Gt;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Gt||(Gt={}));function kq(r,e,t=Gt.SUM_BY_NONZERO_WEIGHTS){let n=k(r,"losses","computeWeightedLoss"),o=null;e!=null&&(o=k(e,"weights","computeWeightedLoss"));let s=o==null?n:P(n,o);if(t===Gt.NONE)return s;if(t===Gt.SUM)return ge(s);if(t===Gt.MEAN){if(o==null)return dt(s);{let a=n.size/o.size,i=me(ge(s),ge(o));return a>1?me(i,le(a)):i}}if(t===Gt.SUM_BY_NONZERO_WEIGHTS){if(o==null)return me(ge(s),le(n.size));{let a=P(o,Qt(n.shape)),i=oe(ge(ro(a,le(0))),"float32");return me(ge(s),i)}}throw Error(`Unknown reduction: ${t}`)}var $r=S({computeWeightedLoss_:kq});function vq(r,e,t,n=Gt.SUM_BY_NONZERO_WEIGHTS){let o=k(r,"labels","absoluteDifference"),s=k(e,"predictions","absoluteDifference"),a=null;t!=null&&(a=k(t,"weights","absoluteDifference")),At(o.shape,s.shape,"Error in absoluteDifference: ");let i=Nt(pe(o,s));return $r(i,a,n)}var N1=S({absoluteDifference_:vq});function Cq(r,e,t,n,o=Gt.SUM_BY_NONZERO_WEIGHTS){let s=k(r,"labels","cosineDistance"),a=k(e,"predictions","cosineDistance"),i=null;n!=null&&(i=k(n,"weights","cosineDistance")),At(s.shape,a.shape,"Error in cosineDistance: ");let l=le(1),u=pe(l,ge(P(s,a),t,!0));return $r(u,i,o)}var S1=S({cosineDistance_:Cq});function Iq(r,e,t,n=Gt.SUM_BY_NONZERO_WEIGHTS){let o=k(r,"labels","hingeLoss"),s=k(e,"predictions","hingeLoss"),a=null;t!=null&&(a=k(t,"weights","hingeLoss")),At(o.shape,s.shape,"Error in hingeLoss: ");let i=le(1);o=pe(P(le(2),o),i);let l=Dr(pe(i,P(o,s)));return $r(l,a,n)}var T1=S({hingeLoss_:Iq});function Nq(r,e,t,n=1,o=Gt.SUM_BY_NONZERO_WEIGHTS){let s=k(r,"labels","huberLoss"),a=k(e,"predictions","huberLoss"),i=null;t!=null&&(i=k(t,"weights","huberLoss")),At(s.shape,a.shape,"Error in huberLoss: ");let l=le(n),u=Nt(pe(a,s)),c=ws(u,l),p=pe(u,c),m=ee(P(le(.5),Me(c)),P(l,p));return $r(m,i,o)}var A1=S({huberLoss_:Nq});function Sq(r,e,t,n=1e-7,o=Gt.SUM_BY_NONZERO_WEIGHTS){let s=k(r,"labels","logLoss"),a=k(e,"predictions","logLoss"),i=null;t!=null&&(i=k(t,"weights","logLoss")),At(s.shape,a.shape,"Error in logLoss: ");let l=le(1),u=le(n),c=qe(P(s,cr(ee(a,u)))),p=P(pe(l,s),cr(ee(pe(l,a),u))),m=pe(c,p);return $r(m,i,o)}var E1=S({logLoss_:Sq});function Tq(r,e,t,n=Gt.SUM_BY_NONZERO_WEIGHTS){let o=k(r,"labels","meanSquaredError"),s=k(e,"predictions","meanSquaredError"),a=null;t!=null&&(a=k(t,"weights","meanSquaredError")),At(o.shape,s.shape,"Error in meanSquaredError: ");let i=bu(o,s);return $r(i,a,n)}var D1=S({meanSquaredError_:Tq});function Aq(r,e){let t=k(r,"labels","sigmoidCrossEntropyWithLogits"),n=k(e,"logits","sigmoidCrossEntropyWithLogits");At(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Dr(n),s=P(n,t),a=lu(Jt(qe(Nt(n))));return ee(pe(o,s),a)}function Eq(r,e,t,n=0,o=Gt.SUM_BY_NONZERO_WEIGHTS){let s=k(r,"multiClassLabels","sigmoidCrossEntropy"),a=k(e,"logits","sigmoidCrossEntropy"),i=null;if(t!=null&&(i=k(t,"weights","sigmoidCrossEntropy")),At(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),n>0){let u=le(n),c=le(1),p=le(.5);s=ee(P(s,pe(c,u)),P(p,u))}let l=Aq(s,a);return $r(l,i,o)}var $1=S({sigmoidCrossEntropy_:Eq});function Dq(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Qr((o,s,a)=>{let l=of(s,[t],!0),u=pe(oe(s,"float32"),l);a([o,u]);let c=qe(P(u,o));return{value:ge(c,[t]),gradFunc:(f,d)=>{let[h,g]=d,x=to(f.shape,[t]);return[P(L(f,x),pe(oe(h,"float32"),Jt(g))),P(L(f,x),pe(Jt(g),oe(h,"float32")))]}}})(r,e)}function $q(r,e,t,n=0,o=Gt.SUM_BY_NONZERO_WEIGHTS){let s=k(r,"onehotLabels","softmaxCrossEntropy"),a=k(e,"logits","softmaxCrossEntropy"),i=null;if(t!=null&&(i=k(t,"weights","softmaxCrossEntropy")),At(s.shape,a.shape,"Error in softmaxCrossEntropy: "),n>0){let u=le(n),c=le(1),p=le(s.shape[1]);s=ee(P(s,pe(c,u)),me(u,p))}let l=Dq(s,a);return $r(l,i,o)}var R1=S({softmaxCrossEntropy_:$q});function Rq(r,e,t){let n=k(r,"inputIndices","sparseReshape"),o=k(e,"inputShape","sparseReshape"),s=k(t,"newShape","sparseReshape");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let a={inputIndices:n,inputShape:o,newShape:s},i=A.runKernel(Vc,a);return{outputIndices:i[0],outputShape:i[1]}}var F1=S({sparseReshape_:Rq});var zFe={fft:Ca,ifft:oi,rfft:Ia,irfft:yu},BFe={hammingWindow:l1,hannWindow:Ng,frame:Sg,stft:u1},ii={flipLeftRight:p1,resizeNearestNeighbor:$g,resizeBilinear:Dg,rotateWithOffset:m1,cropAndResize:c1,nonMaxSuppression:f1,nonMaxSuppressionAsync:g1,nonMaxSuppressionWithScore:x1,nonMaxSuppressionWithScoreAsync:y1,nonMaxSuppressionPadded:b1,nonMaxSuppressionPaddedAsync:w1,transform:_1},O1={bandPart:k1,gramSchmidt:v1,qr:I1},VFe={absoluteDifference:N1,computeWeightedLoss:$r,cosineDistance:S1,hingeLoss:T1,huberLoss:A1,logLoss:E1,meanSquaredError:D1,sigmoidCrossEntropy:$1,softmaxCrossEntropy:R1},P1={sparseReshape:F1};var Br=class extends mg{minimize(e,t=!1,n){let{value:o,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return Ee(s),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return gg(e,t)}dispose(){this.iterations_!=null&&Ee(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:le(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Br,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var cp=class extends Br{constructor(e,t,n=null){super();this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=A.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=A.registeredVariables[n],a=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:V(()=>Ie(s).variable(a))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:V(()=>Ie(s).variable(a))});let i=Array.isArray(e)?e[o].tensor:e[n];if(i==null)return;let l=this.accumulatedGrads[o].variable,u=this.accumulatedUpdates[o].variable;V(()=>{let c=ee(P(l,this.rho),P(Me(i),1-this.rho)),p=P(me(gt(ee(u,this.epsilon)),gt(ee(l,this.epsilon))),i),m=ee(P(u,this.rho),P(Me(p),1-this.rho));l.assign(c),u.assign(m);let f=ee(P(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ee(this.accumulatedGrads.map(e=>e.variable)),Ee(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};cp.className="Adadelta";dn(cp);var pp=class extends Br{constructor(e,t=.1){super();this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=A.registeredVariables[n];if(this.accumulatedGrads[o]==null){let l=!1;this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:V(()=>xa(s.shape,this.initialAccumulatorValue).variable(l))}}let a=Array.isArray(e)?e[o].tensor:e[n];if(a==null)return;let i=this.accumulatedGrads[o].variable;V(()=>{let l=ee(i,Me(a));i.assign(l);let u=ee(P(me(a,gt(ee(l,A.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ee(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};pp.className="Adagrad";dn(pp);var mp=class extends Br{constructor(e,t,n,o=null){super();this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],V(()=>{this.accBeta1=le(t).variable(),this.accBeta2=le(n).variable()}),o==null&&(this.epsilon=A.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);V(()=>{let n=pe(1,this.accBeta1),o=pe(1,this.accBeta2);t.forEach((s,a)=>{let i=A.registeredVariables[s],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:V(()=>Ie(i).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:V(()=>Ie(i).variable(l))});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,p=this.accumulatedSecondMoment[a].variable,m=ee(P(c,this.beta1),P(u,1-this.beta1)),f=ee(P(p,this.beta2),P(Me(u),1-this.beta2)),d=me(m,n),h=me(f,o);c.assign(m),p.assign(f);let g=ee(P(me(d,ee(gt(h),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(P(this.accBeta1,this.beta1)),this.accBeta2.assign(P(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ee(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),V(()=>{this.accBeta1.assign(zr(this.beta1,this.iterations_+1)),this.accBeta2.assign(zr(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};mp.className="Adam";dn(mp);var fp=class extends Br{constructor(e,t,n,o=null,s=0){super();this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],V(()=>{this.iteration=le(0).variable(),this.accBeta1=le(t).variable()}),o==null&&(this.epsilon=A.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);V(()=>{let n=pe(1,this.accBeta1),o=me(-this.learningRate,ee(P(this.iteration,this.decay),1));t.forEach((s,a)=>{let i=A.registeredVariables[s],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:Ie(i).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:Ie(i).variable(l)});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,p=this.accumulatedWeightedInfNorm[a].variable,m=ee(P(c,this.beta1),P(u,1-this.beta1)),f=P(p,this.beta2),d=Nt(u),h=en(f,d);c.assign(m),p.assign(h);let g=ee(P(me(o,n),me(m,ee(h,this.epsilon))),i);i.assign(g)}),this.iteration.assign(ee(this.iteration,1)),this.accBeta1.assign(P(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ee(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};fp.className="Adamax";dn(fp);var hl=class extends Br{constructor(e){super();this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=Array.isArray(e)?e[o].tensor:e[n];if(s==null)return;let a=A.registeredVariables[n];V(()=>{let i=ee(P(this.c,s),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Et(le(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};hl.className="SGD";dn(hl);var dp=class extends hl{constructor(e,t,n=!1){super(e);this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=le(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=A.registeredVariables[n];if(this.accumulations[o]==null){let l=!1;this.accumulations[o]={originalName:`${n}/momentum`,variable:V(()=>Ie(s).variable(l))}}let a=this.accumulations[o].variable,i=Array.isArray(e)?e[o].tensor:e[n];i!=null&&V(()=>{let l,u=ee(P(this.m,a),i);this.useNesterov?l=ee(P(this.c,ee(i,P(u,this.m))),s):l=ee(P(this.c,u),s),a.assign(u),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ee(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};dp.className="Momentum";dn(dp);var hp=class extends Br{constructor(e,t=.9,n=0,o=null,s=!1){super();if(this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=A.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=A.registeredVariables[n],a=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:V(()=>Ie(s).variable(a))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:V(()=>Ie(s).variable(a))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:V(()=>Ie(s).variable(a))});let i=Array.isArray(e)?e[o].tensor:e[n];if(i==null)return;let l=this.accumulatedMeanSquares[o].variable,u=this.accumulatedMoments[o].variable;V(()=>{let c=ee(P(l,this.decay),P(Me(i),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,m=ee(P(p,this.decay),P(i,1-this.decay)),f=me(P(i,this.learningRate),gt(pe(c,ee(Me(m),this.epsilon)))),d=ee(P(u,this.momentum),f);l.assign(c),p.assign(m),u.assign(d);let h=pe(s,d);s.assign(h)}else{let p=ee(P(l,this.decay),P(Me(i),1-this.decay)),m=ee(P(u,this.momentum),me(P(i,this.learningRate),gt(ee(p,this.epsilon))));l.assign(p),u.assign(m);let f=pe(s,m);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ee(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ee(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ee(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};hp.className="RMSProp";dn(hp);var Na=class{static sgd(e){return new hl(e)}static momentum(e,t,n=!1){return new dp(e,t,n)}static rmsprop(e,t=.9,n=0,o=null,s=!1){return new hp(e,t,n,o,s)}static adam(e=.001,t=.9,n=.999,o=null){return new mp(e,t,n,o)}static adadelta(e=.001,t=.95,n=null){return new cp(e,t,n)}static adamax(e=.002,t=.9,n=.999,o=null,s=0){return new fp(e,t,n,o,s)}static adagrad(e,t=.1){return new pp(e,t)}};var Iu={sgd:Na.sgd,momentum:Na.momentum,adadelta:Na.adadelta,adagrad:Na.adagrad,rmsprop:Na.rmsprop,adamax:Na.adamax,adam:Na.adam};var Fq=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function wf(){return new Promise(r=>Fq(()=>r()))}var C={};We(C,{ERF_A1:()=>Uq,ERF_A2:()=>Hq,ERF_A3:()=>qq,ERF_A4:()=>Kq,ERF_A5:()=>Xq,ERF_P:()=>jq,PARALLELIZE_THRESHOLD:()=>Rg,SELU_SCALE:()=>C_,SELU_SCALEALPHA:()=>v_,applyActivation:()=>vu,assertAndGetBroadcastShape:()=>Be,assertAxesAreInnerMostDims:()=>U4,assertParamsConsistent:()=>Oq,assignToTypedArray:()=>nK,axesAreInnerMostDims:()=>n_,calculateShapes:()=>bT,checkEinsumDimSizes:()=>uK,combineLocations:()=>MT,complexWithEvenIndex:()=>eK,complexWithOddIndex:()=>tK,computeConv2DInfo:()=>eu,computeConv3DInfo:()=>OT,computeDefaultPad:()=>Bw,computeDilation2DInfo:()=>gj,computeOptimalWindowSize:()=>Mq,computeOutAndReduceShapes:()=>o_,computeOutShape:()=>Pq,computePool2DInfo:()=>Lw,computePool3DInfo:()=>xj,convertConv2DDataFormat:()=>FT,decodeEinsumEquation:()=>aK,eitherStridesOrDilationsAreOne:()=>vr,expandShapeToKeepDim:()=>to,exponent:()=>sK,exponents:()=>oK,fromStringArrayToUint8:()=>yK,fromUint8ToStringArray:()=>xK,getAxesPermutation:()=>s_,getBroadcastDims:()=>i4,getComplexWithIndex:()=>rK,getEinsumComputePath:()=>pK,getEinsumPermutation:()=>lK,getFusedBiasGradient:()=>ku,getFusedDyActivation:()=>_u,getImageCenter:()=>Lq,getInnerMostAxes:()=>H4,getPermuted:()=>Bq,getReductionAxes:()=>kt,getReshaped:()=>zq,getReshapedPermuted:()=>Vq,getSliceBeginCoords:()=>Gq,getSliceSize:()=>Wq,getUndoAxesPermutation:()=>nf,isIdentityPermutation:()=>mK,log:()=>Zq,mergeRealAndImagArrays:()=>Jq,prepareAndValidate:()=>yT,prepareSplitSize:()=>fK,segment_util:()=>N_,shouldFuse:()=>Cu,slice_util:()=>rr,splitRealAndImagArrays:()=>Qq,tupleValuesAreOne:()=>Ln,upcastType:()=>ar,validateInput:()=>cg,validateUpdateShape:()=>Dw,warn:()=>Yq});function Oq(r,e){let t=r[0].length;r.forEach((o,s)=>{T(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),T(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let n=r[0];r.forEach((o,s)=>{for(let a=0;a<t;a++)T(a===e||o[a]===n[a],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function Pq(r,e){let t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}var Rg=30;function Mq(r){return r<=Rg?r:dc(r,Math.floor(Math.sqrt(r)))}function Lq(r,e,t){let n=t*(typeof r=="number"?r:r[0]),o=e*(typeof r=="number"?r:r[1]);return[n,o]}function zq(r,e,t,n=!0){let o=[];if(n)o=o.concat(e.slice(0)),o.push(r[0]/t),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=e.length;for(let a=0;a<s;++a)o=o.concat([r[a+1]/e[a],e[a]]);o=o.concat(r.slice(s+1))}return o}function Bq(r,e,t=!0){let n=[];if(t){n.push(e);for(let o=e+1;o<r;++o)o<=2*e?(n.push(o),n.push(o-(e+1))):n.push(o)}else{let o=[],s=[];for(let a=1;a<r;++a)a>=e*2+1||a%2==1?s.push(a):o.push(a);n.push(...o),n.push(0),n.push(...s)}return n}function Vq(r,e,t,n=!0){let o=[];n?o.push(r[0]/t):o.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?n?o.push(e[s-1]*r[s]):o.push(r[s]/e[s-1]):o.push(r[s]);return o}function Gq(r,e){let t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function Wq(r,e,t){let n=r.slice(0,1);for(let o=0;o<t;++o)n.push(r[o+1]-e[o][0]-e[o][1]);return n}var v_=1.7580993408473768,C_=1.0507009873554805;var jq=.3275911,Uq=.254829592,Hq=-.284496736,qq=1.421413741,Kq=-1.453152027,Xq=1.061405429;function Yq(...r){W().getBool("IS_TEST")||console.warn(...r)}function Zq(...r){W().getBool("IS_TEST")||console.log(...r)}function Jq(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);let t=new Float32Array(r.length*2);for(let n=0;n<t.length;n+=2)t[n]=r[n/2],t[n+1]=e[n/2];return t}function Qq(r){let e=new Float32Array(r.length/2),t=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)e[n/2]=r[n],t[n/2]=r[n+1];return{real:e,imag:t}}function eK(r){let e=Math.ceil(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=0;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function tK(r){let e=Math.floor(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=2;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function rK(r,e){let t=r[e*2],n=r[e*2+1];return{real:t,imag:n}}function nK(r,e,t,n){r[n*2]=e,r[n*2+1]=t}function oK(r,e){let t=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(e?2:-2)*Math.PI*(o/r);t[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:t,imag:n}}function sK(r,e,t){let n=(t?2:-2)*Math.PI*(r/e),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var I_="->",iK=/->/g,M1=",",L1="...";function aK(r,e){r=r.replace(/\s/g,"");let t=(r.length-r.replace(iK,"").length)/I_.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${I_}").`);let[n,o]=r.split(I_);T(n.indexOf(L1)===-1,()=>`The ellipsis notation ("${L1}") is not supported yet.`);let s=n.split(M1),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let m=0;m<o.length;++m){let f=o[m];if(!s.some(d=>d.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);i.indexOf(f)===-1&&i.push(f)}for(let m=0;m<n.length;++m){let f=n[m];i.indexOf(f)===-1&&f!==M1&&i.push(f)}let l=new Array(s.length);for(let m=0;m<a;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);l[m]=[];for(let f=0;f<s[m].length;++f)l[m].push(i.indexOf(s[m][f]))}let u=i.length,c=o.length,p=[];for(let m=c;m<u;++m)p.push(m);return{allDims:i,summedDims:p,idDims:l}}function lK(r,e){let t=new Array(r);t.fill(-1);for(let o=0;o<e.length;++o)t[e[o]]=o;let n=[];for(let o=0;o<r;++o)t[o]===-1&&n.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:n}}function uK(r,e,t){let n=new Array(r);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let a=0;a<e[o].length;++a)n[e[o][a]]===void 0?n[e[o][a]]=s[a]:T(n[e[o][a]]===s[a],()=>`Expected dimension ${n[e[o][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function pK(r,e){let t=r,n=[],o=0;r.length===0&&t.push(-1),o=r.length+1;for(let a=0;a<o;++a)n.push([]);let s=[];for(let a=0;a<t.length;++a){let i=t[a],l=cK(e,i);for(let u of l)s.indexOf(u)===-1&&(n[a].push(u),s.push(u))}return{path:t,steps:n}}function mK(r){return r.every((e,t)=>e===t)}function cK(r,e){let t=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function fK(r,e,t=0){let n=[];if(typeof e=="number")T(r.shape[t]%e==0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{let o=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);T(o<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let a=e.reduce((i,l)=>l>0?i+l:i);e[s]=r.shape[t]-a}T(r.shape[t]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}var N_={};We(N_,{collectGatherOpShapeInfo:()=>gK,computeOutShape:()=>hK,segOpComputeOptimalWindowSize:()=>dK});function dK(r,e){let t=!1,n;for(r<=Rg?(n=r,t=!0):n=dc(r,Math.floor(Math.sqrt(r)));!t;)n>e||n===r?t=!0:n=dc(r,n+1);return n}function hK(r,e,t){let n=[],o=r.length;for(let s=0;s<o;s++)s!==e?n.push(r[s]):n.push(t);return n}function gK(r,e,t,n){let o=e.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let p=0;p<n;++p)if(r.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${r.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);let a=r.shape[t],i=[],l=1,u=1,c=1;for(let p=0;p<n;++p)i.push(r.shape[p]),l*=r.shape[p];for(let p=n;p<t;p++)i.push(r.shape[p]),u*=r.shape[p];for(let p=n;p<o;p++)i.push(e.shape[p]);for(let p=t+1;p<s;p++)i.push(r.shape[p]),c*=r.shape[p];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:i}}function xK(r){try{return r.map(e=>qc(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function yK(r){return r.map(e=>ll(e))}var Rr={};We(Rr,{nonMaxSuppressionV3Impl:()=>Tg,nonMaxSuppressionV4Impl:()=>Ag,nonMaxSuppressionV5Impl:()=>Eg,whereImpl:()=>_g});function te(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var bK=Rr.whereImpl,Nu=class extends Ps{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new qa(this,hs())}nextDataId(){return Nu.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,W().get("IS_NODE")&&C.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:n,refCount:1}),o}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&y.isString(n[0])){let s=n.map(a=>y.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,o,s){this.data.set(e,{values:t,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return C.mergeRealAndImagArrays(o,s)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>y.decodeString(o))}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(e.shape,e.dtype,n)}makeOutput(e,t,n){let o=this.write(e,t,n);return hs().makeTensorFromDataId(o,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=y.now();return e(),{kernelMs:y.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){te([e],"where");let t=this.readSync(e.dataId);return bK(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};Nu.nextDataId=0;var Wg={};We(Wg,{addImpl:()=>T_,bincountImpl:()=>yp,bincountReduceImpl:()=>Fg,ceilImpl:()=>A_,concatImpl:()=>Su,expImpl:()=>E_,expm1Impl:()=>$_,floorImpl:()=>R_,gatherV2Impl:()=>Og,greaterImpl:()=>F_,lessImpl:()=>O_,linSpaceImpl:()=>Pg,logImpl:()=>P_,maxImpl:()=>Mg,maximumImpl:()=>M_,minimumImpl:()=>L_,multiplyImpl:()=>_f,negImpl:()=>z_,notEqualImpl:()=>B_,prodImpl:()=>V_,rangeImpl:()=>Au,rsqrtImpl:()=>G_,simpleAbsImpl:()=>S_,sliceImpl:()=>Eu,sparseReshapeImpl:()=>Lg,squaredDifferenceImpl:()=>W_,stridedSliceImpl:()=>zg,subImpl:()=>j_,tileImpl:()=>Bg,topKImpl:()=>Vg,transposeImpl:()=>bp,uniqueImpl:()=>Gg});function S_(r){let e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e}var wK=r=>{let{x:e}=r.inputs,t=r.backend;te(e,"abs");let n=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId).values;return n=S_(o),t.makeOutput(n,e.shape,"float32")},z1={kernelName:zs,backendName:"cpu",kernelFunc:wK};function Ye(r){return(e,t,n,o,s)=>{let a=C.assertAndGetBroadcastShape(e,t),i=a.length,l=y.computeStrides(a),u=y.sizeFromShape(a),c=y.getTypedArrayFromDType(s,u),p=e.length,m=t.length,f=y.computeStrides(e),d=y.computeStrides(t),h=C.getBroadcastDims(e,a),g=C.getBroadcastDims(t,a);if(h.length+g.length===0)for(let x=0;x<c.length;++x)c[x]=r(n[x%n.length],o[x%o.length]);else for(let x=0;x<c.length;++x){let b=y.indexToLoc(x,i,l),w=b.slice(-p);h.forEach($=>w[$]=0);let _=y.locToIndex(w,p,f),I=b.slice(-m);g.forEach($=>I[$]=0);let E=y.locToIndex(I,m,d);c[x]=r(n[_],o[E])}return[c,a]}}function dr(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,i=t.makeTensorInfo(n.shape,"complex64"),l=t.data.get(i.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",a)},i}var B1={kernelName:bc,backendName:"cpu",kernelFunc:dr};function gp(r,e,t="float32"){if(t==="complex64"){let o=gp(r,e,"float32"),s=gp(r,e,"float32");return dr({inputs:{real:o,imag:s},backend:r})}let n=y.makeZerosTypedArray(y.sizeFromShape(e),t);return r.makeTensorInfo(e,t,n)}function Fr(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var V1={kernelName:Xn,backendName:"cpu",kernelFunc:Fr};function so(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var G1={kernelName:Lc,backendName:"cpu",kernelFunc:so};function io(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Fr({inputs:{x:o},backend:t});let a=gp(t,o.shape,o.dtype),i=io({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),l=dr({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}if(o.dtype==="complex64"){let a=so({inputs:{input:o},backend:t}),i=io({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(a),i}if(!y.hasEncodingLoss(o.dtype,s)){let a=Fr({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(s==="int32"){let a=t.data.get(o.dataId).values,i=Int32Array.from(a);return t.makeTensorInfo(o.shape,"int32",i)}if(s==="bool"){let a=t.data.get(o.dataId).values,i=y.toTypedArray([0],o.dtype),[l,u]=Ye((c,p)=>c!==p?1:0)(o.shape,[],a,i,"bool");return t.makeTensorInfo(u,"bool",l)}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var W1={kernelName:qn,backendName:"cpu",kernelFunc:io};function et(r,e,t,n){return t==null?({inputs:o,backend:s})=>{let{a,b:i}=o,l=s;te([a,i],r);let u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,p=n||a.dtype,[m,f]=e(a.shape,i.shape,u,c,p);return l.makeTensorInfo(f,p,m)}:({inputs:o,backend:s})=>{let{a,b:i}=o,l=s;if(a.dtype==="complex64"||i.dtype==="complex64"){let u=io({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),p=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=l.data.get(p.dataId).values,d=l.data.get(m.dataId).values,h=io({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(h.dataId),x=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,w=l.data.get(x.dataId).values,_=l.data.get(b.dataId).values,[I,E,$]=t(a.shape,i.shape,f,d,w,_),D=l.makeTensorInfo($,"float32",I),O=l.makeTensorInfo($,"float32",E),M=dr({inputs:{real:D,imag:O},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(h),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(O),M}else{let u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,p=n||a.dtype,[m,f]=e(a.shape,i.shape,u,c,p);return l.makeTensorInfo(f,p,m)}}}function xp(r){return(e,t,n,o,s,a)=>{let i=C.assertAndGetBroadcastShape(e,t),l=y.sizeFromShape(i),u=i.length,c=y.computeStrides(i),p=y.getTypedArrayFromDType("float32",l),m=y.getTypedArrayFromDType("float32",l),f=C.getBroadcastDims(e,i),d=C.getBroadcastDims(t,i),h=C.mergeRealAndImagArrays(n,o),g=C.mergeRealAndImagArrays(s,a),x=e.length,b=y.computeStrides(e),w=t.length,_=y.computeStrides(t);if(f.length+d.length===0)for(let I=0;I<p.length;I++){let E=I%h.length,$=I%g.length,D=r(h[E*2],h[E*2+1],g[$*2],g[$*2+1]);p[I]=D.real,m[I]=D.imag}else for(let I=0;I<p.length;I++){let E=y.indexToLoc(I,u,c),$=E.slice(-x);f.forEach(j=>$[j]=0);let D=y.locToIndex($,x,b),O=E.slice(-w);d.forEach(j=>O[j]=0);let M=y.locToIndex(O,w,_),G=r(h[D*2],h[D*2+1],g[M*2],g[M*2+1]);p[I]=G.real,m[I]=G.imag}return[p,m,i]}}var T_=Ye((r,e)=>r+e),_K=xp((r,e,t,n)=>({real:r+t,imag:e+n})),Sa=et(On,T_,_K),j1={kernelName:On,backendName:"cpu",kernelFunc:Sa};function yp(r,e,t,n,o){let s=y.sizeFromShape(n),a=y.makeZerosTypedArray(o,t);for(let i=0;i<r.length;i++){let l=r[i];if(l<0)throw new Error("Input x must be non-negative!");l>=o||(s>0?a[l]+=e[i]:a[l]+=1)}return a}function Fg(r,e,t,n=!1){let o=r.shape[0],s=r.shape[1],a=Ce([o,t],e.dtype);for(let i=0;i<o;i++)for(let l=0;l<s;l++){let u=r.get(i,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(n?a.set(1,i,u):e.size>0?a.set(a.get(i,u)+e.get(i,l),i,u):a.set(a.get(i,u)+1,i,u))}return a}function ao(r){return(e,t,n)=>{let o=y.getTypedArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)o[s]=r(e[s],n);return o}}function $e(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(te(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,l=i.data.get(a.dataId).values,u=y.sizeFromShape(a.shape),c=t||a.dtype,p=y.getArrayFromDType(c,u);for(let m=0;m<u;++m)p[m]=e(l[m],o);return i.makeTensorInfo(a.shape,c,p)}}function lo(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(te(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,l=i.data.get(a.dataId).values,u=t||a.dtype,c=e(l,u,o);return i.makeTensorInfo(a.shape,u,c)}}var A_=ao(r=>Math.ceil(r)),kK=lo(Io,A_),U1={kernelName:Io,backendName:"cpu",kernelFunc:kK};function Su(r,e,t,n){let o=y.getArrayFromDType(t,y.sizeFromShape(e));if(n&&t!=="string"){let s=0;r.forEach(a=>{let i=y.sizeFromShape(a.shape);o.set(a.vals,s),s+=i})}else{let s=0;r.forEach(a=>{let i=t==="string"?C.fromUint8ToStringArray(a.vals):a.vals,l=0;for(let u=0;u<a.shape[0];++u){let c=u*e[1]+s;for(let p=0;p<a.shape[1];++p)o[c+p]=i[l++]}s+=a.shape[1]})}return o}var E_=ao(r=>Math.exp(r)),D_=lo($o,E_),H1={kernelName:$o,backendName:"cpu",kernelFunc:D_};var $_=ao(r=>Math.expm1(r)),vK=lo(Pi,$_),q1={kernelName:Pi,backendName:"cpu",kernelFunc:vK};var R_=ao(r=>Math.floor(r)),CK=lo(Ro,R_),K1={kernelName:Ro,backendName:"cpu",kernelFunc:CK};function Og(r,e,t){let n=Ce(t,r.dtype);for(let o=0;o<n.size;++o){let a=n.indexToLoc(o).slice(),i=a[0],l=a[2],u=e.locToIndex([i,l]);a[2]=e.values[u];let c=r.locToIndex(a);n.values[o]=r.values[c]}return n}var F_=Ye((r,e)=>r>e?1:0),IK=et(zi,F_,null,"bool"),X1={kernelName:zi,backendName:"cpu",kernelFunc:IK};var O_=Ye((r,e)=>r<e?1:0),NK=et(Wi,O_,null,"bool"),Y1={kernelName:Wi,backendName:"cpu",kernelFunc:NK};function Pg(r,e,t){let n=(e-r)/(t-1),o=y.makeZerosTypedArray(t,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var P_=ao(r=>Math.log(r)),SK=lo(Lo,P_),Z1={kernelName:Lo,backendName:"cpu",kernelFunc:SK};function Mg(r,e,t,n){let o=y.getTypedArrayFromDType(n,y.sizeFromShape(t));for(let s=0;s<o.length;++s){let a=s*e,i=r[a];for(let l=0;l<e;++l){let u=r[a+l];u>i&&(i=u)}o[s]=i}return o}var M_=Ye((r,e)=>Math.max(r,e)),TK=et(Bo,M_),J1={kernelName:Bo,backendName:"cpu",kernelFunc:TK};var L_=Ye((r,e)=>Math.min(r,e)),AK=et(jo,L_),Q1={kernelName:jo,backendName:"cpu",kernelFunc:AK};var _f=Ye((r,e)=>r*e),EK=xp((r,e,t,n)=>({real:r*t-e*n,imag:r*n+e*t})),Tu=et(Ho,_f,EK),eA={kernelName:Ho,backendName:"cpu",kernelFunc:Tu};function z_(r,e,t){let n=y.createScalarValue(-1,t);return _f([],e,n,r,t)}function DK(r){let{inputs:e,backend:t}=r,{x:n}=e;te(n,"neg");let o=t.data.get(n.dataId).values,[s,a]=z_(o,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,s)}var tA={kernelName:Ws,backendName:"cpu",kernelFunc:DK};var B_=Ye((r,e)=>r!==e?1:0),$K=et(Ki,B_,null,"bool"),rA={kernelName:Ki,backendName:"cpu",kernelFunc:$K};function bp(r,e,t,n,o){let s=e.length,a=y.sizeFromShape(e),i=y.computeStrides(e),l=y.computeStrides(o),u=y.getTypedArrayFromDType(t,y.sizeFromShape(o));for(let c=0;c<a;++c){let p=y.indexToLoc(c,s,i),m=new Array(p.length);for(let d=0;d<m.length;d++)m[d]=p[n[d]];let f=y.locToIndex(m,s,l);u[f]=r[c]}return u}function Kt(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{perm:s}=t;te(o,"transpose");let a=o.shape.length,i=new Array(a);for(let p=0;p<i.length;p++)i[p]=o.shape[s[p]];let l=n.data.get(o.dataId).values,u=bp(l,o.shape,o.dtype,s,i);return{dataId:n.write(u,i,o.dtype),shape:i,dtype:o.dtype}}var nA={kernelName:ms,backendName:"cpu",kernelFunc:Kt};function V_(r,e,t,n){let[o,s]=C.computeOutAndReduceShapes(r,n),a=ar(e,"int32"),i=y.makeZerosTypedArray(y.sizeFromShape(o),a),l=y.sizeFromShape(s);for(let u=0;u<i.length;++u){let c=u*l,p=1;for(let m=0;m<l;++m)p*=t[c+m];i[u]=p}return{outVals:i,outShape:o,outDtype:a}}function RK(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;te(o,"prod");let i=o.shape.length,l=y.parseAxisParam(s,o.shape),u=C.getAxesPermutation(l,i),c=l,p=o,m=[];u!=null&&(p=Kt({inputs:{x:o},backend:t,attrs:{perm:u}}),m.push(p),c=C.getInnerMostAxes(c.length,i));let f=t.data.get(p.dataId).values,{outVals:d,outShape:h,outDtype:g}=V_(p.shape,p.dtype,f,c),x=h;return a&&(x=C.expandShapeToKeepDim(h,l)),m.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(x,g,d)}var oA={kernelName:Ji,backendName:"cpu",kernelFunc:RK};function Au(r,e,t,n){let o=r===e,s=r<e&&t<0,a=e<r&&t>1;if(o||s||a)return y.makeZerosTypedArray(0,n);let i=Math.abs(Math.ceil((e-r)/t)),l=y.makeZerosTypedArray(i,n);e<r&&t===1&&(t=-1),l[0]=r;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}var G_=ao(r=>1/Math.sqrt(r)),FK=lo(rs,G_),sA={kernelName:rs,backendName:"cpu",kernelFunc:FK};function Eu(r,e,t,n,o){let s=rr.isSliceContinous(n,e,t),a=y.sizeFromShape(t),i=y.computeStrides(n);if(s){let p=rr.computeFlatOffset(e,i);return o==="string"?r.slice(p,p+a):r.subarray(p,p+a)}let l=o==="string"?C.fromUint8ToStringArray(r):r,u=Ce(n,o,l),c=Ce(t,o);for(let p=0;p<c.size;++p){let m=c.indexToLoc(p),f=m.map((d,h)=>d+e[h]);c.set(u.get(...f),...m)}return o==="string"?C.fromStringArrayToUint8(c.values):c.values}function uo(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n;te(o,"slice");let[i,l]=rr.parseSliceParams(o,s,a);rr.assertParamsValid(o,i,l);let u=t.data.get(o.dataId).values,c=Eu(u,i,l,o.shape,o.dtype);return t.makeTensorInfo(l,o.dtype,c)}var iA={kernelName:Ks,backendName:"cpu",kernelFunc:uo};function Lg(r,e,t,n,o){let s=y.sizeFromShape(n),a=e[0],i=o.length,l=[],u=1,c=-1;for(let g=0;g<i;++g){let x=o[g];if(x===-1){if(c!==-1)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,l.push(1)}else{if(x<0)throw new Error(`size ${g} must be non-negative, not ${x}`);u*=x,l.push(x)}}if(c!==-1){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");let g=Math.trunc(s/u);if(u*g!==s)throw new Error(`Input to reshape is a SparseTensor with ${s}
          dense values, but the requested shape requires a multiple of ${u}. inputShape=${n} outputShape= ${l}`);l[c]=g}let p=y.sizeFromShape(l);if(p!==s)throw new Error(`Input to reshape is a tensor with ${s} dense values, but the requested shape has ${p}. inputShape=${n} outputShape=${l}`);let m=n.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*n[g+1]}let d=[];if(i>0){d[i-1]=1;for(let g=i-2;g>=0;--g)d[g]=d[g+1]*l[g+1]}let h=y.getArrayFromDType(t,a*i);for(let g=0;g<a;++g){let x=0;for(let b=0;b<m;++b)x+=r[g*m+b]*f[b];for(let b=0;b<i;++b)h[g*i+b]=Math.trunc(x/d[b]),x%=d[b]}return[h,[a,i],l]}var W_=Ye((r,e)=>{let t=r-e;return t*t}),OK=et(ls,W_),aA={kernelName:ls,backendName:"cpu",kernelFunc:OK};function zg(r,e,t,n){let o=Ce(r,e.dtype);for(let s=0;s<o.size;s++){let a=o.indexToLoc(s),i=new Array(a.length);for(let l=0;l<i.length;l++)i[l]=a[l]*t[l]+n[l];o.set(e.get(...i),...a)}return o}var j_=Ye((r,e)=>r-e),PK=xp((r,e,t,n)=>({real:r-t,imag:e-n})),kf=et(us,j_,PK),lA={kernelName:us,backendName:"cpu",kernelFunc:kf};function Bg(r,e){let t=new Array(r.rank);for(let o=0;o<t.length;o++)t[o]=r.shape[o]*e[o];let n=Ce(t,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),a=new Array(r.rank);for(let l=0;l<a.length;l++)a[l]=s[l]%r.shape[l];let i=r.locToIndex(a);n.values[o]=r.values[i]}return n}function Vg(r,e,t,n,o){let s=e[e.length-1],[a,i]=[r.length/s,s],l=y.getTypedArrayFromDType(t,a*n),u=y.getTypedArrayFromDType("int32",a*n);for(let p=0;p<a;p++){let m=p*i,f=r.subarray(m,m+i),d=[];for(let b=0;b<f.length;b++)d.push({value:f[b],index:b});d.sort((b,w)=>w.value-b.value);let h=p*n,g=l.subarray(h,h+n),x=u.subarray(h,h+n);for(let b=0;b<n;b++)g[b]=d[b].value,x[b]=d[b].index}let c=e.slice();return c[c.length-1]=n,[Ce(c,t,l),Ce(c,"int32",u)]}function Gg(r,e,t,n){let o=y.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let d=0;d<o;d++)s[0]*=t[d];s[1]=t[o];for(let d=o+1;d<t.length;d++)s[2]*=t[d];let a={},i=new Int32Array(t[o]),l=new ut(s,n,r),u=[],c=s[0]===1&&s[2]===1;for(let d=0;d<t[o];d++){let h;if(c)h=r[d].toString();else{let g=[];for(let x=0;x<s[0];x++)for(let b=0;b<s[2];b++)g.push(l.get(x,d,b));h=g.join(",")}if(a[h]!==void 0)i[d]=a[h];else{let g=Object.keys(a).length;a[h]=g,i[d]=g,u.push(d)}}let p=s.slice();p[1]=Object.keys(a).length;let m=new ut(p,n);u.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let x=0;x<s[2];x++)m.set(l.get(g,d,x),g,h,x)});let f=t.slice();return f[o]=p[1],{outputValues:m.values,outputShape:f,indices:i}}var U_="3.5.0";Qc("cpu",()=>new Nu,1);var H_=$e(Ri,r=>r>=0?r:Math.exp(r)-1),uA={kernelName:Ri,backendName:"cpu",kernelFunc:H_};function q_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n;te([o],"leakyRelu");let a=y.sizeFromShape(o.shape),i=t.data.get(o.dataId).values,l=y.getTypedArrayFromDType("float32",a);for(let u=0;u<i.length;u++)l[u]=i[u]<0?s*i[u]:i[u];return t.makeTensorInfo(o.shape,"float32",l)}var cA={kernelName:Mo,backendName:"cpu",kernelFunc:q_};var MK=Ye((r,e)=>r<0?e*r:r);function K_(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e;te([n,o],"prelu");let s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,[i,l]=MK(n.shape,o.shape,s,a,n.dtype);return t.makeTensorInfo(l,n.dtype,i)}var pA={kernelName:Yo,backendName:"cpu",kernelFunc:K_};var X_=$e(Zo,r=>Math.max(0,r)),mA={kernelName:Zo,backendName:"cpu",kernelFunc:X_};var Y_=$e(Qo,r=>Math.min(Math.max(0,r),6)),fA={kernelName:Qo,backendName:"cpu",kernelFunc:Y_};var Z_=$e(os,r=>1/(1+Math.exp(-r))),dA={kernelName:os,backendName:"cpu",kernelFunc:Z_};function wp(r,e,t,n,o){if(t==="linear")return Fr({inputs:{x:e},backend:r});if(t==="relu")return X_({inputs:{x:e},backend:r});if(t==="elu")return H_({inputs:{x:e},backend:r});if(t==="relu6")return Y_({inputs:{x:e},backend:r});if(t==="prelu")return K_({inputs:{x:e,alpha:n},backend:r});if(t==="leakyrelu")return q_({inputs:{x:e},backend:r,attrs:{alpha:o}});if(t==="sigmoid")return Z_({inputs:{x:e},backend:r});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function Ze(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,a=y.sizeFromShape(o.shape),i=y.inferFromImplicitShape(s,a),l=y.sizeFromShape(i);y.assert(a===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(o.dataId);let u=t.data.get(o.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,p=u.complexTensorInfos.imag;c.shape=i,p.shape=i}return{dataId:o.dataId,shape:i,dtype:o.dtype}}var hA={kernelName:Hs,backendName:"cpu",kernelFunc:Ze};function J_(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;te([o,s],"matMul");let l=o.shape.length,u=s.shape.length,c=a?o.shape[l-2]:o.shape[l-1],p=i?s.shape[u-1]:s.shape[u-2],m=a?o.shape[l-1]:o.shape[l-2],f=i?s.shape[u-2]:s.shape[u-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(d),x=y.sizeFromShape(h),b=g===x||g===1||x===1;y.assert(l>=2&&u>=2&&b,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${d}) and (${h}).`);let _=(g>x?o.shape.slice(0,-2):s.shape.slice(0,-2)).concat([m,f]);y.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let I=a?[g,c,m]:[g,m,c],E=i?[x,f,p]:[x,p,f],$=Ze({inputs:{x:o},backend:t,attrs:{shape:I}}),D=Ze({inputs:{x:s},backend:t,attrs:{shape:E}}),O=a?$.shape[1]:$.shape[2],M=a?$.shape[2]:$.shape[1],G=i?D.shape[1]:D.shape[2],j=Math.max(g,x),U=t.data.get($.dataId).values,H=t.data.get(D.dataId).values,q=y.computeStrides($.shape),X=y.computeStrides(D.shape),[ne,Y,re]=a?[q[0],1,q[1]]:[q[0],q[1],1],[Q,ie,ce]=i?[1,X[1],X[0]]:[X[1],1,X[0]],ae=M*G,fe=Ce([j,M,G],$.dtype),de=fe.values,xe=t.blockSize;for(let we=0;we<j;we++)for(let De=0;De<M;De+=xe)for(let ve=0;ve<G;ve+=xe)for(let Ge=0;Ge<O;Ge+=xe){let Ke=Math.min(De+xe,M),at=Math.min(ve+xe,G),St=Math.min(Ge+xe,O);for(let Tt=De;Tt<Ke;Tt++)for(let He=ve;He<at;He++){let ct=0;for(let mt=Ge;mt<St;mt++){let Lt=Math.min(we,g-1)*ne,kn=Math.min(we,x-1)*ce,Yt=U[Lt+Tt*Y+mt*re],cn=H[mt*Q+He*ie+kn];ct+=Yt*cn}de[we*ae+(Tt*G+He)]+=ct}}return t.disposeIntermediateTensorInfo($),t.disposeIntermediateTensorInfo(D),t.makeTensorInfo(_,fe.dtype,fe.values)}var gA={kernelName:Co,backendName:"cpu",kernelFunc:J_};function LK(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=n,m,f,d,h=[];m=J_({inputs:{a:o,b:s},attrs:{transposeA:l,transposeB:u},backend:t}),a&&(f=Sa({inputs:{a:m,b:a},backend:t}),h.push(m),m=f),c&&(d=wp(t,m,c,i,p),h.push(m),m=d);for(let x of h)t.disposeIntermediateTensorInfo(x);return m}var xA={kernelName:Js,backendName:"cpu",kernelFunc:LK};var zK=$e(_i,r=>Math.acos(r)),yA={kernelName:_i,backendName:"cpu",kernelFunc:zK};var BK=$e(ki,r=>Math.acosh(r)),bA={kernelName:ki,backendName:"cpu",kernelFunc:BK};function VK(r){let{inputs:e,backend:t}=r,n=e;te(e,"addN");let o=n.map(i=>t.data.get(i.dataId).values),s=Ce(n[0].shape,n[0].dtype),a=s.values;for(let i=0;i<n.length;i++){let l=o[i];for(let u=0;u<a.length;u++)a[u]+=l[u]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var wA={kernelName:_o,backendName:"cpu",kernelFunc:VK};function GK(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;te(o,"all");let i=y.parseAxisParam(s,o.shape),l=i,u=C.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Kt({inputs:{x:o},backend:t,attrs:{perm:u}}),l=C.getInnerMostAxes(l.length,o.shape.length)),C.assertAxesAreInnerMostDims("all",l,c.shape.length);let[p,m]=C.computeOutAndReduceShapes(c.shape,l),f=y.sizeFromShape(m),d=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),h=t.data.get(c.dataId).values;for(let x=0;x<d.length;++x){let b=x*f,w=h[b];for(let _=0;_<f;++_){let I=h[b+_];w=w&&I}d[x]=w}u!=null&&t.disposeIntermediateTensorInfo(c);let g=t.makeTensorInfo(p,c.dtype,d);if(a){let x=C.expandShapeToKeepDim(p,i),b=Ze({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),b}return g}var _A={kernelName:vi,backendName:"cpu",kernelFunc:GK};function WK(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;te(o,"any");let i=y.parseAxisParam(s,o.shape),l=i,u=C.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Kt({inputs:{x:o},backend:t,attrs:{perm:u}}),l=C.getInnerMostAxes(l.length,o.shape.length)),C.assertAxesAreInnerMostDims("any",l,c.shape.length);let[p,m]=C.computeOutAndReduceShapes(c.shape,l),f=y.sizeFromShape(m),d=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),h=t.data.get(c.dataId).values;for(let x=0;x<d.length;++x){let b=x*f,w=h[b];for(let _=0;_<f;++_){let I=h[b+_];w=w||I}d[x]=w}u!=null&&t.disposeIntermediateTensorInfo(c);let g=t.makeTensorInfo(p,c.dtype,d);if(a){let x=C.expandShapeToKeepDim(p,i),b=Ze({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),b}return g}var kA={kernelName:Ci,backendName:"cpu",kernelFunc:WK};function jK(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;te(o,"argMax");let a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),l=o,u=[];i!=null&&(l=Kt({inputs:{x:o},backend:t,attrs:{perm:i}}),u.push(l),a=C.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],C.assertAxesAreInnerMostDims("argMax",a,l.shape.length);let[c,p]=C.computeOutAndReduceShapes(l.shape,a),m=y.sizeFromShape(c),f=y.makeZerosTypedArray(m,"int32"),d=y.sizeFromShape(p),h=t.data.get(l.dataId).values;for(let g=0;g<f.length;++g){let x=g*d,b=h[x],w=0;for(let _=0;_<d;++_){let I=h[x+_];I>b&&(b=I,w=_)}f[g]=w}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",f)}var vA={kernelName:ko,backendName:"cpu",kernelFunc:jK};function UK(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;te(o,"argMin");let a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),l=o,u=[];i!=null&&(l=Kt({inputs:{x:o},backend:t,attrs:{perm:i}}),u.push(l),a=C.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],C.assertAxesAreInnerMostDims("argMin",a,l.shape.length);let[c,p]=C.computeOutAndReduceShapes(l.shape,a),m=y.sizeFromShape(c),f=y.makeZerosTypedArray(m,"int32"),d=y.sizeFromShape(p),h=t.data.get(l.dataId).values;for(let g=0;g<f.length;++g){let x=g*d,b=h[x],w=0;for(let _=0;_<d;++_){let I=h[x+_];I<b&&(b=I,w=_)}f[g]=w}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",f)}var CA={kernelName:Ka,backendName:"cpu",kernelFunc:UK};var HK=$e(Ii,r=>Math.asin(r)),IA={kernelName:Ii,backendName:"cpu",kernelFunc:HK};var qK=$e(Ni,r=>Math.asinh(r)),NA={kernelName:Ni,backendName:"cpu",kernelFunc:qK};var KK=$e(Si,r=>Math.atan(r)),SA={kernelName:Si,backendName:"cpu",kernelFunc:KK};var XK=Ye((r,e)=>Math.atan2(r,e)),YK=et(Ai,XK),TA={kernelName:Ai,backendName:"cpu",kernelFunc:YK};var ZK=$e(Ti,r=>Math.atanh(r)),AA={kernelName:Ti,backendName:"cpu",kernelFunc:ZK};function _p(r,e,t,n,o,s){let a=o.strideHeight,i=o.strideWidth,l=o.dilationHeight,u=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,m=o.padInfo.top,f=o.padInfo.left,d=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=Ce(o.outShape,t),g=h.values,x=o.outShape[1]*o.outShape[2]*o.outShape[3],b=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let _=0;_<o.batchSize;++_){let I=_*x,E=_*n[0];for(let $=0;$<o.inChannels;++$)for(let D=0;D<o.outHeight;++D){let O=D*a-m,M=Math.max(0,O),G=Math.min(o.inHeight,c+O),j=I+D*b;for(let U=0;U<o.outWidth;++U){let H=U*i-f,q=Math.max(0,H),X=Math.min(o.inWidth,p+H),ne=d,Y=0,re=0;for(let ie=M;ie<G;ie+=l){let ce=E+ie*n[1];for(let ae=q;ae<X;ae+=u){let fe=ce+ae*n[2],de=r[fe+$];s==="max"&&de>ne?ne=de:s==="avg"&&(Y+=de,re++)}if(isNaN(ne))break}let Q=j+U*w+$;g[Q]=s==="avg"?Y/re:ne}}}return h}function jg(r,e,t,n,o=!1,s=!1){let a=Ce(n.outShape,"int32"),i=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterHeight,m=n.effectiveFilterWidth,f=n.padInfo.top,d=n.padInfo.left,h=Ce(e,t,r);for(let g=0;g<n.batchSize;++g)for(let x=0;x<n.inChannels;++x)for(let b=0;b<n.outHeight;++b){let w=b*i-f,_=w;for(;_<0;)_+=u;let I=Math.min(n.inHeight,p+w);for(let E=0;E<n.outWidth;++E){let $=E*l-d,D=$;for(;D<0;)D+=c;let O=Math.min(n.inWidth,m+$),M=Number.NEGATIVE_INFINITY,G=-1;for(let j=_;j<I;j+=u){let U=j-w;for(let H=D;H<O;H+=c){let q=H-$,X=h.get(g,j,H,x);X>M&&(M=X,o?G=s?((g*n.inHeight+j)*n.inWidth+H)*n.inChannels+x:(j*n.inWidth+H)*n.inChannels+x:G=U*m+q)}}a.set(G,g,b,E,x)}}return a}function Ug(r,e,t,n,o,s){let a=o.strideDepth,i=o.strideHeight,l=o.strideWidth,u=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,m=o.effectiveFilterDepth,f=o.effectiveFilterHeight,d=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,x=o.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Ce(o.outShape,t),_=w.values,I=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],E=o.outShape[2]*o.outShape[3]*o.outShape[4],$=o.outShape[3]*o.outShape[4],D=o.outShape[4];for(let O=0;O<o.batchSize;++O){let M=O*I,G=O*n[0];for(let j=0;j<o.inChannels;++j)for(let U=0;U<o.outDepth;++U){let H=U*a-h,q=H;for(;q<0;)q+=u;let X=Math.min(o.inDepth,m+H),ne=M+U*E;for(let Y=0;Y<o.outHeight;++Y){let re=Y*i-g,Q=re;for(;Q<0;)Q+=c;let ie=Math.min(o.inHeight,f+re),ce=ne+Y*$;for(let ae=0;ae<o.outWidth;++ae){let fe=ae*l-x,de=fe;for(;de<0;)de+=p;let xe=Math.min(o.inWidth,d+fe),we=ce+ae*D,De=b,ve=0,Ge=0;for(let at=q;at<X;at+=u){let St=G+at*n[1];for(let Tt=Q;Tt<ie;Tt+=c){let He=St+Tt*n[2];for(let ct=de;ct<xe;ct+=p){let mt=He+ct*n[3],Lt=r[mt+j];if(s==="max"&&Lt>De?De=Lt:s==="avg"&&(ve+=Lt,Ge++),isNaN(De))break}if(isNaN(De))break}if(isNaN(De))break}let Ke=we+j;_[Ke]=s==="avg"?ve/Ge:De}}}}return w}function EA(r,e){let t=Ce(e.outShape,"int32"),n=e.strideDepth,o=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.front,f=e.padInfo.top,d=e.padInfo.left;for(let h=0;h<e.batchSize;++h)for(let g=0;g<e.inChannels;++g)for(let x=0;x<e.outDepth;++x){let b=x*n-m,w=b;for(;w<0;)w+=a;let _=Math.min(e.inDepth,u+b);for(let I=0;I<e.outHeight;++I){let E=I*o-f,$=E;for(;$<0;)$+=i;let D=Math.min(e.inHeight,c+E);for(let O=0;O<e.outWidth;++O){let M=O*s-d,G=M;for(;G<0;)G+=l;let j=Math.min(e.inWidth,p+M),U=Number.NEGATIVE_INFINITY,H=-1;for(let q=w;q<_;q+=a){let X=q-b;for(let ne=$;ne<D;ne+=i){let Y=ne-E;for(let re=G;re<j;re+=l){let Q=re-M,ie=r.get(h,q,ne,re,g);ie>=U&&(U=ie,H=X*c*p+Y*c+Q)}}}t.set(H,h,x,I,O,g)}}}return t}function JK(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;te(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:l}=n,u=1;y.assert(C.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=C.computePool2DInfo(o.shape,s,a,u,i,l),p;if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))p=Fr({inputs:{x:o},backend:t});else{let m=t.data.get(o.dataId).values,f=y.computeStrides(o.shape),d=_p(m,o.shape,o.dtype,f,c,"avg");p=t.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var DA={kernelName:vo,backendName:"cpu",kernelFunc:JK};function QK(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=n;te(o,"avgPool3d");let c=C.computePool3DInfo(o.shape,s,a,1,i,l,u),p=t.data.get(o.dataId).values,m=Ug(p,o.shape,o.dtype,y.computeStrides(o.shape),c,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}var $A={kernelName:Xa,backendName:"cpu",kernelFunc:QK};function e6(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=n;te([o,s],"avgPool3DGrad");let c=C.computePool3DInfo(s.shape,a,i,1,l,u),p=c.strideDepth,m=c.strideHeight,f=c.strideWidth,d=c.filterDepth,h=c.filterHeight,g=c.filterWidth,x=c.dilationDepth,b=c.dilationHeight,w=c.dilationWidth,_=c.effectiveFilterDepth,I=c.effectiveFilterHeight,E=c.effectiveFilterWidth,$=_-1-c.padInfo.front,D=E-1-c.padInfo.left,O=I-1-c.padInfo.top,M=Ce(s.shape,"float32"),G=1/(d*h*g),j=t.bufferSync(o);for(let U=0;U<c.batchSize;++U)for(let H=0;H<c.inChannels;++H)for(let q=0;q<c.inDepth;++q)for(let X=0;X<c.inHeight;++X)for(let ne=0;ne<c.inWidth;++ne){let Y=q-$,re=X-O,Q=ne-D,ie=0;for(let ce=0;ce<_;ce+=x){let ae=(Y+ce)/p;if(!(ae<0||ae>=c.outDepth||Math.floor(ae)!==ae))for(let fe=0;fe<I;fe+=b){let de=(re+fe)/m;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let xe=0;xe<E;xe+=w){let we=(Q+xe)/f;if(we<0||we>=c.outWidth||Math.floor(we)!==we)continue;ie+=j.get(U,ae,de,we,H)}}}M.set(ie*G,U,q,X,ne,H)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}var RA={kernelName:xc,backendName:"cpu",kernelFunc:e6};function t6(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s;te([o,s],"avgPoolGrad");let{filterSize:i,strides:l,pad:u}=n,c=C.computePool2DInfo(a.shape,i,l,1,u),p=c.strideHeight,m=c.strideWidth,f=c.filterHeight,d=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,x=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=b-1-c.padInfo.left,_=x-1-c.padInfo.top,I=Ce(a.shape,"float32"),E=1/(f*d),$=t.data.get(o.dataId).values,D=Ce(o.shape,"float32",$);for(let O=0;O<c.batchSize;++O)for(let M=0;M<c.inChannels;++M)for(let G=0;G<c.inHeight;++G)for(let j=0;j<c.inWidth;++j){let U=G-_,H=j-w,q=0;for(let X=0;X<x;X+=h){let ne=(U+X)/p;if(!(ne<0||ne>=c.outHeight||Math.floor(ne)!==ne))for(let Y=0;Y<b;Y+=g){let re=(H+Y)/m;if(re<0||re>=c.outWidth||Math.floor(re)!==re)continue;q+=D.get(O,ne,re,M)}}I.set(q*E,O,G,j,M)}return t.makeTensorInfo(I.shape,I.dtype,I.values)}var FA={kernelName:gc,backendName:"cpu",kernelFunc:t6};function r6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,scale:s,offset:a,mean:i,variance:l}=e;y.assert(i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),te([o,i,l,s,a],"batchNorm");let{varianceEpsilon:u}=n;u==null&&(u=.001);let c=t.data.get(o.dataId).values,p=t.data.get(i.dataId).values,m=t.data.get(l.dataId).values,f=s?t.data.get(s.dataId).values:new Float32Array([1]),d=a?t.data.get(a.dataId).values:new Float32Array([0]),h=new Float32Array(c.length),g=d.length,x=f.length,b=m.length,w=p.length,_=0,I=0,E=0,$=0;for(let D=0;D<c.length;++D)h[D]=d[_++]+(c[D]-p[I++])*f[E++]/Math.sqrt(m[$++]+u),_>=g&&(_=0),I>=w&&(I=0),E>=x&&(E=0),$>=b&&($=0);return t.makeTensorInfo(o.shape,o.dtype,h)}var OA={kernelName:Oo,backendName:"cpu",kernelFunc:r6};function n6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;te([o],"batchToSpaceND");let i=s.reduce((x,b)=>x*b),l=C.getReshaped(o.shape,s,i),u=C.getPermuted(l.length,s.length),c=C.getReshapedPermuted(o.shape,s,i),p=C.getSliceBeginCoords(a,s.length),m=C.getSliceSize(c,a,s.length),f=Ze({inputs:{x:o},backend:t,attrs:{shape:l}}),d=Kt({inputs:{x:f},backend:t,attrs:{perm:u}}),h=Ze({inputs:{x:d},backend:t,attrs:{shape:c}}),g=uo({inputs:{x:h},backend:t,attrs:{begin:p,size:m}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var PA={kernelName:Ya,backendName:"cpu",kernelFunc:n6};function o6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,u=yp(i,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,u)}var MA={kernelName:yc,backendName:"cpu",kernelFunc:o6};var s6=$e(Kn,(r,e)=>{let t=e;return r>t.clipValueMax?t.clipValueMax:r<t.clipValueMin?t.clipValueMin:r}),LA={kernelName:Kn,backendName:"cpu",kernelFunc:s6};var i6=r=>{let{x:e}=r.inputs,t=r.backend,n=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId),s=o.complexTensorInfos.real,a=o.complexTensorInfos.imag,i=t.data.get(s.dataId).values,l=t.data.get(a.dataId).values;for(let u=0;u<i.length;u++){let c=i[u],p=l[u];n[u]=Math.hypot(c,p)}return t.makeOutput(n,e.shape,"float32")},zA={kernelName:Za,backendName:"cpu",kernelFunc:i6};function ai(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.imag,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var BA={kernelName:Dc,backendName:"cpu",kernelFunc:ai};function gl(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,e[0].shape)[0],a=C.computeOutShape(e.map(h=>h.shape),s);if(y.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let i=e.filter(h=>y.sizeFromShape(h.shape)>0);if(i.length===1)return Fr({inputs:{x:i[0]},backend:t});let l=i.map(h=>h.shape);if(C.assertParamsConsistent(l,s),i[0].dtype==="complex64"){let h=i.map(_=>so({inputs:{input:_},backend:t})),g=i.map(_=>ai({inputs:{input:_},backend:t})),x=gl({inputs:h,backend:t,attrs:{axis:s}}),b=gl({inputs:g,backend:t,attrs:{axis:s}}),w=dr({inputs:{real:x,imag:b},backend:t});return h.forEach(_=>t.disposeIntermediateTensorInfo(_)),g.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),w}let u=i.map(h=>{let g=y.sizeFromShape(h.shape.slice(s));return Ze({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}})}),c=u.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));a=C.computeOutShape(u.map(h=>h.shape),1);let p=u[0].shape[0]===1,m=Su(c,a,e[0].dtype,p),f=C.computeOutShape(i.map(h=>h.shape),s),d=t.makeTensorInfo(f,e[0].dtype,m);return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}var VA={kernelName:Bs,backendName:"cpu",kernelFunc:gl};function Q_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=n;te([o,s],"conv2d");let p=C.convertConv2DDataFormat(l),m=C.computeConv2DInfo(o.shape,s.shape,a,u,i,c,!1,p),f=m.filterHeight,d=m.filterWidth,h=m.dilationHeight,g=m.dilationWidth,x=m.padInfo.left,b=m.padInfo.top,w=m.dataFormat==="channelsLast",_=new ut(m.outShape,o.dtype),I=y.computeStrides(o.shape),E=y.computeStrides(s.shape),$=I[0],D=w?I[1]:I[2],O=w?I[2]:1,M=w?1:I[1],G=_.strides[0],j=w?_.strides[1]:_.strides[2],U=w?_.strides[2]:1,H=w?1:_.strides[1],q=t.data.get(o.dataId).values,X=t.data.get(s.dataId).values,ne=_.values;for(let Y=0;Y<m.batchSize;++Y){let re=Y*$,Q=Y*G;for(let ie=0;ie<m.outHeight;++ie){let ce=Q+ie*j,ae=ie*m.strideHeight-b;for(let fe=0;fe<f;++fe){let de=ae+fe*h;if(de<0||de>=m.inHeight)continue;let xe=fe*E[0],we=re+de*D;for(let De=0;De<m.outWidth;++De){let ve=ce+De*U,Ge=De*m.strideWidth-x;for(let Ke=0;Ke<d;++Ke){let at=Ge+Ke*g;if(at<0||at>=m.inWidth)continue;let St=xe+Ke*E[1],Tt=we+at*O,He=St;for(let ct=0;ct<m.inChannels;++ct){let mt=q[Tt+ct*M];for(let Lt=0;Lt<m.outChannels;++Lt)ne[ve+Lt*H]+=mt*X[He+Lt];He+=m.outChannels}}}}}}return t.makeTensorInfo(_.shape,_.dtype,ne)}var GA={kernelName:No,backendName:"cpu",kernelFunc:Q_};function a6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=n;te([o,s],"conv2dBackpropFilter");let p=C.convertConv2DDataFormat(l),m=C.computeConv2DInfo(o.shape,c,a,1,i,u,!1,p),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=m,x=m.dataFormat==="channelsLast",b=new ut(m.filterShape,"float32"),w=m.padInfo.left,_=m.padInfo.top,I=t.data.get(o.dataId).values,E=t.data.get(s.dataId).values,$=new ut(o.shape,o.dtype,I),D=new ut(s.shape,s.dtype,E);for(let O=0;O<h;++O){let M=Math.max(0,Math.ceil((_-O)/f)),G=Math.min(m.outHeight,(m.inHeight+_-O)/f);for(let j=0;j<g;++j){let U=Math.max(0,Math.ceil((w-j)/d)),H=Math.min(m.outWidth,(m.inWidth+w-j)/d);for(let q=0;q<m.inChannels;++q)for(let X=0;X<m.outChannels;++X){let ne=0;for(let Y=0;Y<m.batchSize;++Y)for(let re=M;re<G;++re){let Q=O+re*f-_;for(let ie=U;ie<H;++ie){let ce=j+ie*d-w;x?ne+=$.get(Y,Q,ce,q)*D.get(Y,re,ie,X):ne+=$.get(Y,q,Q,ce)*D.get(Y,X,re,ie)}}b.set(ne,O,j,q,X)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}var WA={kernelName:wc,backendName:"cpu",kernelFunc:a6};function l6(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=n;te([o,s],"conv2dBackpropInput");let p=y.computeStrides(s.shape),m=y.computeStrides(o.shape),f=C.convertConv2DDataFormat(u),d=C.computeConv2DInfo(a,s.shape,i,1,l,c,!1,f),h=new ut(d.inShape,"float32"),g=h.values,x=t.data.get(o.dataId).values,b=t.data.get(s.dataId).values,[w,_,I]=p,{batchSize:E,filterHeight:$,filterWidth:D,inChannels:O,inHeight:M,inWidth:G,outChannels:j,outHeight:U,outWidth:H,strideHeight:q,strideWidth:X}=d;f=d.dataFormat;let ne=$-1-d.padInfo.top,Y=D-1-d.padInfo.left,re=f==="channelsLast",Q=h.strides[0],ie=re?h.strides[1]:h.strides[2],ce=re?h.strides[2]:1,ae=re?1:h.strides[1],fe=m[0],de=re?m[1]:m[2],xe=re?m[2]:1,we=re?1:m[1];for(let De=0;De<E;++De)for(let ve=0;ve<O;++ve)for(let Ge=0;Ge<M;++Ge){let Ke=Ge-ne,at=Math.max(0,Math.ceil(Ke/q)),St=Math.min(U,($+Ke)/q);for(let Tt=0;Tt<G;++Tt){let He=Tt-Y,ct=Math.max(0,Math.ceil(He/X)),mt=Math.min(H,(D+He)/X),Lt=0;for(let Yt=at;Yt<St;++Yt){let cn=Yt*q-Ke;for(let Pr=ct;Pr<mt;++Pr){let Un=Pr*X-He,sr=fe*De+de*Yt+xe*Pr,vn=w*($-1-cn)+_*(D-1-Un)+I*ve;for(let Ur=0;Ur<j;++Ur){let _r=x[sr+we*Ur],pn=b[vn+Ur];Lt+=_r*pn}}}let kn=Q*De+ie*Ge+ce*Tt+ae*ve;g[kn]=Lt}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var jA={kernelName:So,backendName:"cpu",kernelFunc:l6};function u6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:l}=n;te([o,s],"conv3d");let u=C.computeConv3DInfo(o.shape,s.shape,a,l,i),{filterDepth:c,filterHeight:p,filterWidth:m,dilationDepth:f,dilationHeight:d,dilationWidth:h,padInfo:g}=u,x=g.front,b=g.left,w=g.top,_=new ut(u.outShape,o.dtype),I=t.data.get(o.dataId).values,E=t.data.get(s.dataId).values,$=_.values,D=y.computeStrides(o.shape),O=y.computeStrides(s.shape);for(let M=0;M<u.batchSize;++M){let G=M*D[0],j=M*_.strides[0];for(let U=0;U<u.outDepth;++U){let H=j+U*_.strides[1],q=U*u.strideDepth-x;for(let X=0;X<c;++X){let ne=q+X*f;if(ne<0||ne>=u.inDepth)continue;let Y=X*O[0],re=G+ne*D[1];for(let Q=0;Q<u.outHeight;++Q){let ie=H+Q*_.strides[2],ce=Q*u.strideHeight-w;for(let ae=0;ae<p;++ae){let fe=ce+ae*d;if(fe<0||fe>=u.inHeight)continue;let de=Y+ae*O[1],xe=re+fe*D[2];for(let we=0;we<u.outWidth;++we){let De=ie+we*u.outChannels,ve=we*u.strideWidth-b;for(let Ge=0;Ge<m;++Ge){let Ke=ve+Ge*h;if(Ke<0||Ke>=u.inWidth)continue;let at=de+Ge*O[2],St=xe+Ke*u.inChannels,Tt=at;for(let He=0;He<u.inChannels;++He){let ct=I[St+He];for(let mt=0;mt<u.outChannels;++mt)$[De+mt]+=ct*E[Tt+mt];Tt+=u.outChannels}}}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}var UA={kernelName:Ja,backendName:"cpu",kernelFunc:u6};function c6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,filterShape:l}=n;te([o,s],"conv3dBackpropFilterV2");let u=y.computeStrides(o.shape),c=y.computeStrides(s.shape),p=C.computeConv3DInfo(o.shape,l,a,1,i),m=p.strideDepth,f=p.strideHeight,d=p.strideWidth,h=p.filterDepth,g=p.filterHeight,x=p.filterWidth,b=new ut(p.filterShape,"float32"),w=b.values,[_,I,E,$]=b.strides,D=t.data.get(s.dataId).values,[O,M,G,j]=c,U=t.data.get(o.dataId).values,[H,q,X,ne]=u,Y=p.padInfo.front,re=p.padInfo.left,Q=p.padInfo.top;for(let ie=0;ie<h;++ie){let ce=Math.max(0,Math.ceil((Y-ie)/m)),ae=Math.min(p.outDepth,(p.inDepth+Y-ie)/m),fe=ie*_;for(let de=0;de<g;++de){let xe=Math.max(0,Math.ceil((Q-de)/f)),we=Math.min(p.outHeight,(p.inHeight+Q-de)/f),De=de*I+fe;for(let ve=0;ve<x;++ve){let Ge=Math.max(0,Math.ceil((re-ve)/d)),Ke=Math.min(p.outWidth,(p.inWidth+re-ve)/d),at=ve*E+De;for(let St=0;St<p.inChannels;++St){let Tt=St*$+at;for(let He=0;He<p.outChannels;++He){let ct=0;for(let mt=0;mt<p.batchSize;++mt){let Lt=mt*H,kn=mt*O;for(let Yt=ce;Yt<ae;++Yt){let Pr=(ie+Yt*m-Y)*q+Lt,Un=Yt*M+kn;for(let sr=xe;sr<we;++sr){let Ur=(de+sr*f-Q)*X+Pr,_r=sr*G+Un;for(let pn=Ge;pn<Ke;++pn){let Ml=(ve+pn*d-re)*ne+Ur,Va=pn*j+_r;ct+=U[Ml+St]*D[Va+He]}}}}w[Tt+He]=ct}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}var HA={kernelName:_c,backendName:"cpu",kernelFunc:c6};function p6(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:a,strides:i,inputShape:l}=n;te([o],"conv3dBackpropInputV2");let u=y.computeStrides(o.shape),c=y.computeStrides(s.shape),p=C.computeConv3DInfo(l,s.shape,i,1,a),m=new ut(p.inShape,"float32"),f=m.values,[d,h,g,x]=m.strides,b=t.data.get(o.dataId).values,[w,_,I,E]=u,$=t.data.get(s.dataId).values,[D,O,M,G]=c,{batchSize:j,filterDepth:U,filterHeight:H,filterWidth:q,inChannels:X,inDepth:ne,inHeight:Y,inWidth:re,outChannels:Q,outDepth:ie,outHeight:ce,outWidth:ae,strideDepth:fe,strideHeight:de,strideWidth:xe}=p,we=U-1-p.padInfo.front,De=H-1-p.padInfo.top,ve=q-1-p.padInfo.left;for(let Ge=0;Ge<j;++Ge)for(let Ke=0;Ke<X;++Ke)for(let at=0;at<ne;++at){let St=at-we,Tt=Math.max(0,Math.ceil(St/fe)),He=Math.min(ie,(U+St)/fe);for(let ct=0;ct<Y;++ct){let mt=ct-De,Lt=Math.max(0,Math.ceil(mt/de)),kn=Math.min(ce,(H+mt)/de);for(let Yt=0;Yt<re;++Yt){let cn=Yt-ve,Pr=Math.max(0,Math.ceil(cn/xe)),Un=Math.min(ae,(q+cn)/xe),sr=0;for(let vn=Tt;vn<He;++vn){let Ur=vn*fe-St;for(let _r=Lt;_r<kn;++_r){let pn=_r*de-mt;for(let Rn=Pr;Rn<Un;++Rn){let Ml=Rn*xe-cn,Va=w*Ge+_*vn+I*_r+E*Rn,Os=D*(U-1-Ur)+O*(H-1-pn)+M*(q-1-Ml)+G*Ke;for(let gi=0;gi<Q;++gi){let lm=b[Va+gi],Ll=$[Os+gi];sr+=lm*Ll}}}}f[d*Ge+h*at+g*ct+x*Yt+Ke]=sr}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}var qA={kernelName:kc,backendName:"cpu",kernelFunc:p6};var m6=$e(To,r=>Math.cos(r)),KA={kernelName:To,backendName:"cpu",kernelFunc:m6};var f6=$e(Ei,r=>Math.cosh(r)),XA={kernelName:Ei,backendName:"cpu",kernelFunc:f6};function d6(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:l,extrapolationValue:u}=n,[c,p,m,f]=o.shape,d=s.shape[0],[h,g]=i,x=Ce([d,h,g,f],"float32"),b=t.data.get(s.dataId).values,w=t.data.get(a.dataId).values,_=t.data.get(o.dataId).values,I=y.computeStrides(o.shape),E=y.computeStrides(x.shape);for(let $=0;$<d;$++){let D=$*4,O=b[D],M=b[D+1],G=b[D+2],j=b[D+3],U=w[$];if(U>=c)continue;let H=h>1?(G-O)*(p-1)/(h-1):0,q=g>1?(j-M)*(m-1)/(g-1):0;for(let X=0;X<h;X++){let ne=h>1?O*(p-1)+X*H:.5*(O+G)*(p-1);if(ne<0||ne>p-1){for(let Y=0;Y<g;Y++)for(let re=0;re<f;re++){let Q=re+Y*E[2]+X*E[1]+$*E[0];x.values[Q]=u}continue}if(l==="bilinear"){let Y=Math.floor(ne),re=Math.ceil(ne),Q=ne-Y;for(let ie=0;ie<g;ie++){let ce=g>1?M*(m-1)+ie*q:.5*(M+j)*(m-1);if(ce<0||ce>m-1){for(let xe=0;xe<f;xe++){let we=xe+ie*E[2]+X*E[1]+$*E[0];x.values[we]=u}continue}let ae=Math.floor(ce),fe=Math.ceil(ce),de=ce-ae;for(let xe=0;xe<f;xe++){let we=xe+ae*I[2]+Y*I[1]+U*I[0],De=_[we];we=xe+fe*I[2]+Y*I[1]+U*I[0];let ve=_[we];we=xe+ae*I[2]+re*I[1]+U*I[0];let Ge=_[we];we=xe+fe*I[2]+re*I[1]+U*I[0];let Ke=_[we],at=De+(ve-De)*de,St=Ge+(Ke-Ge)*de;we=xe+ie*E[2]+X*E[1]+$*E[0],x.values[we]=at+(St-at)*Q}}}else for(let Y=0;Y<g;++Y){let re=g>1?M*(m-1)+Y*q:.5*(M+j)*(m-1);if(re<0||re>m-1){for(let ce=0;ce<f;ce++){let ae=ce+Y*E[2]+X*E[1]+$*E[0];x.values[ae]=u}continue}let Q=Math.round(re),ie=Math.round(ne);for(let ce=0;ce<f;ce++){let ae=ce+Q*I[2]+ie*I[1]+U*I[0],fe=ce+Y*E[2]+X*E[1]+$*E[0];x.values[fe]=_[ae]}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}var YA={kernelName:Di,backendName:"cpu",kernelFunc:d6};function h6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;te(o,"cumsum");let l=C.getAxesPermutation([s],o.shape.length),u=o;l!=null&&(u=Kt({inputs:{x:o},backend:t,attrs:{perm:l}}));let c=C.getInnerMostAxes(1,o.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=ar(u.dtype,"int32"),m=y.makeZerosTypedArray(y.sizeFromShape(u.shape),p),f=t.data.get(u.dataId).values,d=u.shape[u.shape.length-1],h=i?(x,b)=>x+d-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=d)for(let b=0;b<d;b++){let w=h(x,b);if(b===0)m[w]=a?0:f[w];else{let _=h(x,b-1);m[w]=a?f[_]+m[_]:f[w]+m[_]}}let g=t.makeTensorInfo(u.shape,p,m);if(l!=null){let x=C.getUndoAxesPermutation(l),b=Kt({inputs:{x:g},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),b}return g}var ZA={kernelName:Ao,backendName:"cpu",kernelFunc:h6};function g6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let l=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,c=yp(l,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,c)}else if(o.shape.length===2){let l=t.bufferSync(o),u=t.bufferSync(s),c=Fg(l,u,a,i);return t.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var JA={kernelName:vc,backendName:"cpu",kernelFunc:g6};function x6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n;y.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`),y.assert(s>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`);let i=o.shape[0],l=o.shape[1],u=o.shape[2],c=o.shape[3],p=l*s,m=u*s,f=c/(s*s),d=t.data.get(o.dataId).values,h=new Float32Array(i*p*m*f),g=0;for(let x=0;x<i;++x)for(let b=0;b<p;++b){let w=Math.floor(b/s),_=b%s;for(let I=0;I<m;++I){let E=Math.floor(I/s),$=I%s,D=(_*s+$)*f;for(let O=0;O<f;++O){let G=O+D+c*(E+u*(w+l*x));h[g++]=d[G]}}}return t.makeTensorInfo([i,p,m,f],o.dtype,h)}var QA={kernelName:$i,backendName:"cpu",kernelFunc:x6};function ek(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=n;te([o,s],"depthwiseConv2DNative");let c=y.computeStrides(o.shape),p=y.computeStrides(s.shape),m=l;m==null&&(m=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(a,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${m}'`);let f=C.computeConv2DInfo(o.shape,s.shape,a,m,i,u,!0),{filterHeight:d,filterWidth:h,dilationHeight:g,dilationWidth:x,padInfo:b}=f,w=b.left,_=b.top,I=f.outChannels/f.inChannels,E=new ut(f.outShape,o.dtype),$=t.data.get(o.dataId).values,D=t.data.get(s.dataId).values,O=E.values;for(let M=0;M<f.batchSize;++M){let G=M*c[0],j=M*E.strides[0];for(let U=0;U<f.outHeight;++U){let H=j+U*E.strides[1],q=U*f.strideHeight-_;for(let X=0;X<d;++X){let ne=q+X*g;if(ne<0||ne>=f.inHeight)continue;let Y=X*p[0],re=G+ne*c[1];for(let Q=0;Q<f.outWidth;++Q){let ie=H+Q*E.strides[2],ce=Q*f.strideWidth-w;for(let ae=0;ae<h;++ae){let fe=ce+ae*x;if(fe<0||fe>=f.inWidth)continue;let de=Y+ae*p[1],xe=re+fe*f.inChannels,we=ie,De=de;for(let ve=0;ve<f.inChannels;++ve){let Ge=$[xe+ve];for(let Ke=0;Ke<I;++Ke)O[we+Ke]+=Ge*D[De+Ke];we+=I,De+=I}}}}}}return t.makeTensorInfo(E.shape,E.dtype,E.values)}var eE={kernelName:Eo,backendName:"cpu",kernelFunc:ek};function y6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=n;te([o,s],"depthwiseConv2dNativeBackpropFilter");let p=C.computeConv2DInfo(o.shape,c,a,i,l,u,!0),{strideHeight:m,strideWidth:f,filterHeight:d,filterWidth:h}=p,g=new ut(p.filterShape,"float32"),x=p.padInfo.left,b=p.padInfo.top,w=p.outChannels/p.inChannels,_=t.data.get(o.dataId).values,I=new ut(o.shape,o.dtype,_),E=t.data.get(s.dataId).values,$=new ut(s.shape,s.dtype,E);for(let D=0;D<d;++D){let O=Math.max(0,Math.ceil((b-D)/m)),M=Math.min(p.outHeight,(p.inHeight+b-D)/m);for(let G=0;G<h;++G){let j=Math.max(0,Math.ceil((x-G)/f)),U=Math.min(p.outWidth,(p.inWidth+x-G)/f);for(let H=0;H<p.outChannels;++H){let q=Math.trunc(H/w),X=H%w,ne=0;for(let Y=0;Y<p.batchSize;++Y)for(let re=O;re<M;++re){let Q=D+re*m-b;for(let ie=j;ie<U;++ie){let ce=G+ie*f-x;ne+=I.get(Y,Q,ce,q)*$.get(Y,re,ie,H)}}g.set(ne,D,G,q,X)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var tE={kernelName:Cc,backendName:"cpu",kernelFunc:y6};function b6(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=n;te([o,s],"depthwiseConv2DNativeBackpropInput");let p=y.computeStrides(o.shape),m=y.computeStrides(s.shape),f=C.computeConv2DInfo(c,s.shape,a,i,l,u,!0),d=new ut(f.inShape,"float32"),h=d.values,[g,x,b]=d.strides,w=t.data.get(o.dataId).values,[_,I,E]=p,$=t.data.get(s.dataId).values,[D,O,M]=m,{batchSize:G,filterHeight:j,filterWidth:U,inChannels:H,inHeight:q,inWidth:X,outChannels:ne,outHeight:Y,outWidth:re,strideHeight:Q,strideWidth:ie}=f,ce=j-1-f.padInfo.top,ae=U-1-f.padInfo.left,fe=ne/H;for(let de=0;de<G;++de)for(let xe=0;xe<H;++xe)for(let we=0;we<q;++we){let De=we-ce,ve=Math.max(0,Math.ceil(De/Q)),Ge=Math.min(Y,(j+De)/Q);for(let Ke=0;Ke<X;++Ke){let at=Ke-ae,St=Math.max(0,Math.ceil(at/ie)),Tt=Math.min(re,(U+at)/ie),He=0;for(let ct=ve;ct<Ge;++ct){let mt=ct*Q-De;for(let Lt=St;Lt<Tt;++Lt){let kn=Lt*ie-at,Yt=_*de+I*ct+E*Lt,cn=D*(j-1-mt)+O*(U-1-kn)+M*xe;for(let Pr=0;Pr<fe;++Pr){let Un=xe*fe+Pr,sr=w[Yt+Un],vn=$[cn+Pr];He+=sr*vn}}}h[g*de+x*we+b*Ke+xe]=He}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}var rE={kernelName:Ic,backendName:"cpu",kernelFunc:b6};function w6(r){let{inputs:e,backend:t}=r,{x:n}=e,o=y.sizeFromShape(n.shape),s=t.data.get(n.dataId).values,a=Ce([o,o],n.dtype),i=a.values;for(let u=0;u<s.length;u++)i[u*o+u]=s[u];let l=[...n.shape,...n.shape];return t.makeTensorInfo(l,a.dtype,a.values)}var nE={kernelName:Nc,backendName:"cpu",kernelFunc:w6};var oE={kernelName:Qa,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o}=r,{strides:s,pad:a,dilations:i}=t,l=e,u=l.data.get(n.dataId).values,c=n.shape.length,p=l.data.get(o.dataId).values,m=o.shape.length,{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:x,outWidth:b,padInfo:w,strideHeight:_,strideWidth:I,filterHeight:E,filterWidth:$,dilationHeight:D,dilationWidth:O,outShape:M}=C.computeDilation2DInfo(n.shape,o.shape,s,a,"NHWC",i),G=y.sizeFromShape(M),j=M.length,U=y.getArrayFromDType(n.dtype,G);for(let q=0;q<f;++q)for(let X=0;X<x;++X){let ne=X*_-w.top;for(let Y=0;Y<b;++Y){let re=Y*I-w.left;for(let Q=0;Q<g;++Q){let ie=Number.MIN_SAFE_INTEGER;for(let ae=0;ae<E;++ae){let fe=ne+ae*D;if(fe>=0&&fe<d)for(let de=0;de<$;++de){let xe=re+de*O;if(xe>=0&&xe<h){let we=y.locToIndex([q,fe,xe,Q],c,y.computeStrides(n.shape)),De=y.locToIndex([ae,de,Q],m,y.computeStrides(o.shape)),ve=u[we]+p[De];ve>ie&&(ie=ve)}}}let ce=y.locToIndex([q,X,Y,Q],j,y.computeStrides(M));U[ce]=ie}}}return{dataId:l.write(y.toTypedArray(U,n.dtype),M,n.dtype),shape:M,dtype:n.dtype}}};var sE={kernelName:Am,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:l}=t,u=e,c=y.toNestedArray(n.shape,u.data.get(n.dataId).values),p=y.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:x,padInfo:b,strideHeight:w,strideWidth:_,filterHeight:I,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:O}=C.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",l);y.assert(s.rank===O.length,()=>`Error in ${Am}, dy must have the same rank as output ${O.length}, but got ${s.rank}`);let M=y.toNestedArray(O,u.data.get(s.dataId).values),G=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let U=0;U<m;++U)for(let H=0;H<g;++H){let q=H*w-b.top;for(let X=0;X<x;++X){let ne=X*_-b.left;for(let Y=0;Y<h;++Y){let re=Number.MIN_SAFE_INTEGER,Q=0,ie=0;for(let ce=0;ce<I;++ce){let ae=q+ce*$;if(ae>=0&&ae<f)for(let fe=0;fe<E;++fe){let de=ne+fe*D;if(de>=0&&de<d){let xe=c[U][ae][de][Y]+p[ce][fe][Y];xe>re&&(re=xe,Q=ce,ie=fe)}}}G[Q][ie][Y]+=M[U][H][X][Y]}}}return{dataId:u.write(y.toTypedArray(G,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var iE={kernelName:Tm,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:l}=t,u=e,c=y.toNestedArray(n.shape,u.data.get(n.dataId).values),p=y.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:x,padInfo:b,strideHeight:w,strideWidth:_,filterHeight:I,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:O}=C.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",l);y.assert(s.rank===O.length,()=>`Error in ${Tm}, dy must have the same rank as output ${O.length}, but got ${s.rank}`);let M=y.toNestedArray(O,u.data.get(s.dataId).values),G=y.makeZerosNestedTypedArray(n.shape,n.dtype);for(let U=0;U<m;++U)for(let H=0;H<g;++H){let q=H*w-b.top;for(let X=0;X<x;++X){let ne=X*_-b.left;for(let Y=0;Y<h;++Y){let re=Number.MIN_SAFE_INTEGER,Q=q<0?0:q,ie=ne<0?0:ne;for(let ce=0;ce<I;++ce){let ae=q+ce*$;if(ae>=0&&ae<f)for(let fe=0;fe<E;++fe){let de=ne+fe*D;if(de>=0&&de<d){let xe=c[U][ae][de][Y]+p[ce][fe][Y];xe>re&&(re=xe,Q=ae,ie=de)}}}G[U][Q][ie][Y]+=M[U][H][X][Y]}}}return{dataId:u.write(y.toTypedArray(G,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function Ta(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;te(o,"sum");let i;o.dtype==="bool"?i=io({inputs:{x:o},backend:t,attrs:{dtype:"int32"}}):i=Fr({inputs:{x:o},backend:t});let l=i.shape.length,u=y.parseAxisParam(s,i.shape),c=C.getAxesPermutation(u,l),p=u,m=i;c!=null&&(m=Kt({inputs:{x:i},backend:t,attrs:{perm:c}}),p=C.getInnerMostAxes(p.length,l)),C.assertAxesAreInnerMostDims("sum",p,m.shape.length);let[f,d]=C.computeOutAndReduceShapes(m.shape,p),h=C.upcastType(m.dtype,"int32"),g=gp(t,f,h),x=y.sizeFromShape(d),b=t.data.get(g.dataId).values,w=t.data.get(m.dataId).values;for(let _=0;_<b.length;++_){let I=_*x,E=0;for(let $=0;$<x;++$)E+=w[I+$];b[_]=E}if(a){let _=C.expandShapeToKeepDim(g.shape,u),I=g;g=Ze({inputs:{x:g},backend:t,attrs:{shape:_}}),t.disposeIntermediateTensorInfo(I)}return t.disposeIntermediateTensorInfo(i),c!=null&&t.disposeIntermediateTensorInfo(m),g}var aE={kernelName:is,backendName:"cpu",kernelFunc:Ta};function _6(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:l}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,l,s);let{path:u,steps:c}=C.getEinsumComputePath(i,l),p=c.length,m=null,f=a.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:x,expandDims:b}=C.getEinsumPermutation(f,l[g]),w;C.isIdentityPermutation(x)?w=s[g]:(w=Kt({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),d.push(w));let _=w.shape.slice();for(let I=0;I<b.length;++I)_.splice(b[I],0,1);y.arraysEqual(w.shape,_)||(w=Ze({inputs:{x:w},backend:t,attrs:{shape:_}}),d.push(w)),m===null?m=w:(m=Tu({inputs:{a:w,b:m},backend:t}),d.push(m))}h<p-1&&(u[h]>=0&&(m=Ta({inputs:{x:m},backend:t,attrs:{axis:u[h]-(a.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var lE={kernelName:Sc,backendName:"cpu",kernelFunc:_6};function k6(r){let{inputs:e,backend:t}=r,{dy:n,y:o}=e;te([n,o],"eluGrad");let s=new Float32Array(y.sizeFromShape(o.shape)),a=t.data.get(o.dataId).values,i=t.data.get(n.dataId).values;for(let l=0;l<a.length;++l){let u=a[l];u>=1?s[l]=i[l]:s[l]=i[l]*(u+1)}return t.makeTensorInfo(o.shape,"float32",s)}var uE={kernelName:Tc,backendName:"cpu",kernelFunc:k6};var v6=Ye((r,e)=>r===e?1:0),tk=et(Oi,v6,null,"bool"),cE={kernelName:Oi,backendName:"cpu",kernelFunc:tk};var C6=C.ERF_P,I6=C.ERF_A1,N6=C.ERF_A2,S6=C.ERF_A3,T6=C.ERF_A4,A6=C.ERF_A5,E6=$e(Fi,r=>{let e=Math.sign(r),t=Math.abs(r),n=1/(1+C6*t);return e*(1-((((A6*n+T6)*n+S6)*n+N6)*n+I6)*n*Math.exp(-t*t))}),pE={kernelName:Fi,backendName:"cpu",kernelFunc:E6};function kp(r){let{inputs:e,backend:t,attrs:n}=r,{input:o}=e,{dim:s}=n,a=o.shape.length,i=o.shape.slice(),l=s;return s<0&&(y.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),i.splice(l,0,1),Ze({inputs:{x:o},backend:t,attrs:{shape:i}})}var mE={kernelName:Vs,backendName:"cpu",kernelFunc:kp};var D6=Ye((r,e)=>r/e),vf=et(Do,D6),Cf={kernelName:Do,backendName:"cpu",kernelFunc:vf};function Hg(r,e,t){let n=r.shape,o=n[0],s=n[1],a=t.data.get(r.dataId),i=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[o,s],c=y.sizeFromShape(u),p=y.getTypedArrayFromDType("float32",c),m=y.getTypedArrayFromDType("float32",c);for(let g=0;g<o;g++){let x=uo({inputs:{x:i},backend:t,attrs:{begin:[g,0],size:[1,s]}}),b=uo({inputs:{x:l},backend:t,attrs:{begin:[g,0],size:[1,s]}}),w=dr({inputs:{real:x,imag:b},backend:t}),{real:_,imag:I}=$6(w,e,t),E=C.mergeRealAndImagArrays(_,I);for(let $=0;$<s;$++){let D=C.getComplexWithIndex(E,$);p[g*s+$]=D.real,m[g*s+$]=D.imag}t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(w)}let f=t.makeTensorInfo(u,"float32",p),d=t.makeTensorInfo(u,"float32",m),h=dr({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),h}function $6(r,e,t){let n=y.sizeFromShape(r.shape),o=t.data.get(r.dataId),s=t.data.get(o.complexTensorInfos.real.dataId).values,a=t.data.get(o.complexTensorInfos.imag.dataId).values;if(R6(n)){let i=rk(s,a,n,e,t),l=[r.shape[0],r.shape[1]];if(e){let u=t.makeTensorInfo(l,"float32",i.real),c=t.makeTensorInfo(l,"float32",i.imag),p=t.makeTensorInfo([],"float32",y.createScalarValue(n,"float32")),m=Fr({inputs:{x:p},backend:t}),f=Cf.kernelFunc({inputs:{a:u,b:p},backend:t}),d=Cf.kernelFunc({inputs:{a:c,b:m},backend:t}),h=t.data.get(f.dataId).values,g=t.data.get(d.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),{real:h,imag:g}}return i}else{let i=C.mergeRealAndImagArrays(s,a),l=F6(i,n,e);return C.splitRealAndImagArrays(l)}}function R6(r){return(r&r-1)==0}function rk(r,e,t,n,o){if(t===1)return{real:r,imag:e};let s=C.mergeRealAndImagArrays(r,e),a=t/2,i=C.complexWithEvenIndex(s),l=i.real,u=i.imag,c=[l.length],p=o.makeTensorInfo(c,"float32",l),m=o.makeTensorInfo(c,"float32",u),f=dr({inputs:{real:p,imag:m},backend:o}),d=C.complexWithOddIndex(s),h=d.real,g=d.imag,x=[h.length],b=o.makeTensorInfo(x,"float32",h),w=o.makeTensorInfo(x,"float32",g),_=dr({inputs:{real:b,imag:w},backend:o}),I=rk(l,u,a,n,o),E=I.real,$=I.imag,D=[E.length],O=o.makeTensorInfo(D,"float32",E),M=o.makeTensorInfo(D,"float32",$),G=dr({inputs:{real:O,imag:M},backend:o}),j=rk(h,g,a,n,o),U=j.real,H=j.imag,q=[U.length],X=o.makeTensorInfo(q,"float32",U),ne=o.makeTensorInfo(q,"float32",H),Y=dr({inputs:{real:X,imag:ne},backend:o}),re=C.exponents(t,n),Q=[re.real.length],ie=o.makeTensorInfo(Q,"float32",re.real),ce=o.makeTensorInfo(Q,"float32",re.imag),ae=dr({inputs:{real:ie,imag:ce},backend:o}),fe=Tu({inputs:{a:ae,b:Y},backend:o}),de=Sa({inputs:{a:G,b:fe},backend:o}),xe=kf({inputs:{a:G,b:fe},backend:o}),we=so({inputs:{input:de},backend:o}),De=so({inputs:{input:xe},backend:o}),ve=ai({inputs:{input:de},backend:o}),Ge=ai({inputs:{input:xe},backend:o}),Ke=gl({inputs:[we,De],backend:o,attrs:{axis:0}}),at=gl({inputs:[ve,Ge],backend:o,attrs:{axis:0}}),St=o.data.get(Ke.dataId).values,Tt=o.data.get(at.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(_),o.disposeIntermediateTensorInfo(O),o.disposeIntermediateTensorInfo(M),o.disposeIntermediateTensorInfo(G),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(ne),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(ie),o.disposeIntermediateTensorInfo(ce),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(de),o.disposeIntermediateTensorInfo(xe),o.disposeIntermediateTensorInfo(we),o.disposeIntermediateTensorInfo(ve),o.disposeIntermediateTensorInfo(De),o.disposeIntermediateTensorInfo(Ge),o.disposeIntermediateTensorInfo(Ke),o.disposeIntermediateTensorInfo(at),{real:St,imag:Tt}}function F6(r,e,t){let n=new Float32Array(e*2);for(let o=0;o<e;o++){let s=0,a=0;for(let i=0;i<e;i++){let l=C.exponent(o*i,e,t),u=C.getComplexWithIndex(r,i);s+=u.real*l.real-u.imag*l.imag,a+=u.real*l.imag+u.imag*l.real}t&&(s/=e,a/=e),C.assignToTypedArray(n,s,a,o)}return n}function O6(r){let{inputs:e,backend:t}=r,{input:n}=e,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=Ze({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),l=Hg(i,!1,t),u=Ze({inputs:{x:l},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),u}var fE={kernelName:Ac,backendName:"cpu",kernelFunc:O6};function If(r){let{backend:e,attrs:t}=r,{shape:n,value:o,dtype:s}=t,a=s||y.inferDtype(o),i=y.getArrayFromDType(a,y.sizeFromShape(n));return P6(i,o,a),e.makeTensorInfo(n,a,i)}var dE={kernelName:el,backendName:"cpu",kernelFunc:If};function P6(r,e,t){r.fill(e)}var hE={kernelName:Mi,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,o=t,s=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[a,i,l,u]=n.shape,c=o.data.get(n.dataId).values;for(let m=0;m<a;m++){let f=m*l*i*u;for(let d=0;d<i;d++){let h=d*(l*u);for(let g=0;g<l;g++){let x=g*u;for(let b=0;b<u;b++){let _=[a,d,g,b][2],I=Math.round(l-_),E=f+h+x+b,$=c[E];if(I>=0&&I<l){let D=I*u,O=f+h+D+b;$=c[O]}s[E]=$}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var M6=Ye((r,e)=>Math.floor(r/e)),L6=et(Fo,M6,null,"int32"),gE={kernelName:Fo,backendName:"cpu",kernelFunc:L6};function z6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=Q_({inputs:{x:o,filter:s},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m}});if(a){let g=h;h=Sa({inputs:{a:h,b:a},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=wp(t,h,f,i,d),t.disposeIntermediateTensorInfo(g)}return h}var xE={kernelName:Qs,backendName:"cpu",kernelFunc:z6};function B6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=ek({inputs:{x:o,filter:s},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m}});if(a){let g=h;h=Sa({inputs:{a:h,b:a},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=wp(t,h,f,i,d),t.disposeIntermediateTensorInfo(g)}return h}var yE={kernelName:ei,backendName:"cpu",kernelFunc:B6};function V6(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=y.sizeFromShape(n.shape),a=o.shape,i=a[a.length-1],[l,u,c,p]=C.prepareAndValidate(n,o);if(u===0)return t.makeTensorInfo(l,n.dtype,[]);let m=Ce([u,c],n.dtype),f=t.data.get(o.dataId).values,d=t.data.get(n.dataId).values;for(let h=0;h<u;h++){let g=[],x=0;for(let b=0;b<i;b++){let w=f[h*i+b];x+=w*p[b],g.push(w)}if(x<0||x>=s/c)throw new Error(`Invalid indices: ${g} does not index into ${n.shape}`);for(let b=0;b<c;b++)m.values[h*c+b]=d[x*c+b]}return t.makeTensorInfo(l,m.dtype,m.values)}var bE={kernelName:Li,backendName:"cpu",kernelFunc:V6};function G6(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n;te([o,s],"gatherV2");let l=i;i==null&&(l=0);let u=y.sizeFromShape(s.shape),c=y.parseAxisParam(a,o.shape)[0],p=C.segment_util.collectGatherOpShapeInfo(o,s,c,l),m=Ze({inputs:{x:o},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),f=Ze({inputs:{x:s},backend:t,attrs:{shape:[p.batchSize,u/p.batchSize]}}),d=[p.batchSize,p.outerSize,u/p.batchSize,p.sliceSize],h=t.bufferSync(f),g=t.bufferSync(m),x=Og(g,h,d);return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.makeTensorInfo(p.outputShape,x.dtype,x.values)}var wE={kernelName:Gs,backendName:"cpu",kernelFunc:G6};var W6=Ye((r,e)=>r>=e?1:0),j6=et(Po,W6,null,"bool"),_E={kernelName:Po,backendName:"cpu",kernelFunc:j6};function U6(r){let{inputs:e,backend:t}=r,{input:n}=e,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=Ze({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),l=Hg(i,!0,t),u=Ze({inputs:{x:l},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),u}var kE={kernelName:Ec,backendName:"cpu",kernelFunc:U6};var H6=$e(Bi,r=>Number.isFinite(r)?1:0,"bool"),vE={kernelName:Bi,backendName:"cpu",kernelFunc:H6};var q6=$e(Vi,r=>Math.abs(r)===Infinity?1:0,"bool"),CE={kernelName:Vi,backendName:"cpu",kernelFunc:q6};var K6=$e(Gi,r=>Number.isNaN(r)?1:0,"bool"),IE={kernelName:Gi,backendName:"cpu",kernelFunc:K6};var X6=Ye((r,e)=>r<=e?1:0),Y6=et(ji,X6,null,"bool"),NE={kernelName:ji,backendName:"cpu",kernelFunc:Y6};function Z6(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,a=Pg(n,o,s);return e.makeTensorInfo([a.length],"float32",a)}var SE={kernelName:$c,backendName:"cpu",kernelFunc:Z6};var J6=$e(Ui,r=>Math.log1p(r)),TE={kernelName:Ui,backendName:"cpu",kernelFunc:J6};var Q6=Ye((r,e)=>r&&e),e5=et(Hi,Q6,null,"bool"),AE={kernelName:Hi,backendName:"cpu",kernelFunc:e5};var t5=$e(jl,r=>r?0:1,"bool"),EE={kernelName:jl,backendName:"cpu",kernelFunc:t5};var r5=Ye((r,e)=>r||e),n5=et(Ul,r5,null,"bool"),DE={kernelName:Ul,backendName:"cpu",kernelFunc:n5};function o5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:a,alpha:i,beta:l}=n;te(o,"LRN");let u=o.shape[3],c=u-1,p=t.data.get(o.dataId).values,m=y.sizeFromShape(o.shape),f=new Float32Array(m);function d(h){let g=h%u,x=h-g+Math.max(0,g-s),b=h-g+Math.min(g+s,c),w=0;for(;x<=b;x++){let _=p[x];w+=_*_}return w}for(let h=0;h<m;h++){let g=d(h),x=p[h]*Math.pow(a+i*g,-l);f[h]=x}return t.makeTensorInfo(o.shape,o.dtype,f)}var $E={kernelName:tl,backendName:"cpu",kernelFunc:o5};function s5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:a}=e,{depthRadius:i,bias:l,alpha:u,beta:c}=n;te(a,"LRNGrad");let p=y.sizeFromShape(a.shape),m=a.shape[3],f=t.data.get(a.dataId).values,d=t.data.get(o.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(p),x=p;for(let b=0;b<x;b++){let w=b%m,_=b-w+Math.max(0,w-i),I=b-w+Math.min(m,w+i+1),E=0;for(let $=_;$<I;$++)E+=Math.pow(d[$],2);E=u*E+l;for(let $=_;$<I;$++){let D=-2*u*c*d[$]*h[b]/E;b===$&&(D+=Math.pow(E,-c)),D*=f[b],g[$]+=D}}return t.makeTensorInfo(a.shape,o.dtype,g)}var RE={kernelName:Rc,backendName:"cpu",kernelFunc:s5};function nk(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n,i=t,l=o.shape,u=l.length,c=y.parseAxisParam(s,l),p=c,m=C.getAxesPermutation(p,u),f=i.data.get(o.dataId).values;if(m!=null){let _=new Array(u);for(let I=0;I<_.length;I++)_[I]=l[m[I]];f=bp(f,l,o.dtype,m,_),p=C.getInnerMostAxes(p.length,u),l=_}te(o,"max"),C.assertAxesAreInnerMostDims("max",p,u);let[d,h]=C.computeOutAndReduceShapes(l,p),g=y.sizeFromShape(h),x=Mg(f,g,d,o.dtype),b=i.write(x,d,o.dtype),w=d;return a&&(w=C.expandShapeToKeepDim(d,c)),{dataId:b,shape:w,dtype:o.dtype}}var FE={kernelName:zo,backendName:"cpu",kernelFunc:nk};function i5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;te(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:l}=n,u=1;y.assert(C.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=C.computePool2DInfo(o.shape,s,a,u,i,l),p;if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))p=Fr({inputs:{x:o},backend:t});else{let m=t.data.get(o.dataId).values,f=y.computeStrides(o.shape),d=_p(m,o.shape,o.dtype,f,c,"max");p=t.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var OE={kernelName:Vo,backendName:"cpu",kernelFunc:i5};function a5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=n;te(o,"maxPool3d");let c=C.computePool3DInfo(o.shape,s,a,1,i,l,u),p=t.data.get(o.dataId).values,m=Ug(p,o.shape,o.dtype,y.computeStrides(o.shape),c,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}var PE={kernelName:rl,backendName:"cpu",kernelFunc:a5};function l5(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=n;te([o,s],"maxPool3DGrad");let c=C.computePool3DInfo(s.shape,a,i,1,l,u),p=t.bufferSync(s),m=EA(p,c),f=c.strideDepth,d=c.strideHeight,h=c.strideWidth,g=c.dilationDepth,x=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,_=c.effectiveFilterHeight,I=c.effectiveFilterWidth,E=w-1-c.padInfo.front,$=I-1-c.padInfo.left,D=_-1-c.padInfo.top,O=Ce(s.shape,"float32"),M=t.bufferSync(o);for(let G=0;G<c.batchSize;++G)for(let j=0;j<c.inChannels;++j)for(let U=0;U<c.inDepth;++U)for(let H=0;H<c.inHeight;++H)for(let q=0;q<c.inWidth;++q){let X=U-E,ne=H-D,Y=q-$,re=0;for(let Q=0;Q<w;Q+=g){let ie=(X+Q)/f;if(!(ie<0||ie>=c.outDepth||Math.floor(ie)!==ie))for(let ce=0;ce<_;ce+=x){let ae=(ne+ce)/d;if(!(ae<0||ae>=c.outHeight||Math.floor(ae)!==ae))for(let fe=0;fe<I;fe+=b){let de=(Y+fe)/h;if(de<0||de>=c.outWidth||Math.floor(de)!==de)continue;let xe=w*_*I-1-m.get(G,ie,ae,de,j),we=Q*_*I+ce*I+fe,De=xe===we?1:0;if(De===0)continue;re+=M.get(G,ie,ae,de,j)*De}}}O.set(re,G,U,H,q,j)}return t.makeTensorInfo(O.shape,O.dtype,O.values)}var ME={kernelName:Oc,backendName:"cpu",kernelFunc:l5};function u5(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:a}=e,i=s;te([s,a],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=n,m=C.computePool2DInfo(i.shape,l,u,1,c,p),f=t.data.get(i.dataId).values,d=Ce(m.outShape,i.dtype,jg(f,i.shape,i.dtype,m).values),h=m.strideHeight,g=m.strideWidth,x=m.dilationHeight,b=m.dilationWidth,w=m.effectiveFilterHeight,_=m.effectiveFilterWidth,I=_-1-m.padInfo.left,E=w-1-m.padInfo.top,$=Ce(i.shape,"float32"),D=t.data.get(o.dataId).values,O=Ce(o.shape,"float32",D);for(let M=0;M<m.batchSize;++M)for(let G=0;G<m.inChannels;++G)for(let j=0;j<m.inHeight;++j)for(let U=0;U<m.inWidth;++U){let H=j-E,q=U-I,X=0;for(let ne=0;ne<w;ne+=x){let Y=(H+ne)/h;if(!(Y<0||Y>=m.outHeight||Math.floor(Y)!==Y))for(let re=0;re<_;re+=b){let Q=(q+re)/g;if(Q<0||Q>=m.outWidth||Math.floor(Q)!==Q)continue;let ie=w*_-1-d.get(M,Y,Q,G),ce=ne*_+re,ae=ie===ce?1:0;if(ae===0)continue;X+=O.get(M,Y,Q,G)*ae}}$.set(X,M,j,U,G)}return t.makeTensorInfo($.shape,$.dtype,$.values)}var LE={kernelName:Fc,backendName:"cpu",kernelFunc:u5};function zE(r,e,t,n,o){let s=y.computeStrides(e),a=_p(r,e,t,s,o,"max"),i=jg(r,e,t,o,!0,n);return[a.values,i.values]}var BE={kernelName:Pc,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=e,l=t;te(n,"MaxPoolWithArgmax");let u=l.data.get(n.dataId).values,c=C.computePool2DInfo(n.shape,o,s,[1,1],a),[p,m]=zE(u,n.shape,n.dtype,i,c),f=l.write(p,c.outShape,n.dtype),d=l.write(m,c.outShape,n.dtype);return[{dataId:f,shape:c.outShape,dtype:n.dtype},{dataId:d,shape:c.outShape,dtype:"int32"}]}};function c5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=y.parseAxisParam(s,o.shape),u=C.computeOutAndReduceShapes(o.shape,i)[1],c=y.sizeFromShape(u),p=[],m=t.makeTensorInfo([],"float32",new Float32Array([c]));p.push(m);let f=io({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});p.push(f);let d=vf({inputs:{a:f,b:m},backend:t});p.push(d);let h=Ta({inputs:{x:d},backend:t,attrs:{axis:s,keepDims:a}});return p.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var VE={kernelName:Go,backendName:"cpu",kernelFunc:c5};function p5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;te(o,"min");let i=y.parseAxisParam(s,o.shape),l=i,u=C.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Kt({inputs:{x:o},backend:t,attrs:{perm:u}}),l=C.getInnerMostAxes(l.length,o.shape.length)),C.assertAxesAreInnerMostDims("min",l,c.shape.length);let[p,m]=C.computeOutAndReduceShapes(c.shape,l),f=y.sizeFromShape(m),d=y.makeZerosTypedArray(y.sizeFromShape(p),c.dtype),h=t.data.get(c.dataId).values;for(let x=0;x<d.length;++x){let b=x*f,w=h[b];for(let _=0;_<f;++_){let I=h[b+_];I<w&&(w=I)}d[x]=w}u!=null&&t.disposeIntermediateTensorInfo(c);let g=t.makeTensorInfo(p,c.dtype,d);if(a){let x=C.expandShapeToKeepDim(p,i),b=Ze({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),b}return g}var GE={kernelName:Wo,backendName:"cpu",kernelFunc:p5};function m5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,mode:a}=n;te(o,"mirrorPad");let i=s.map((w,_)=>w[0]+o.shape[_]+w[1]),l=s.map(w=>w[0]),u=s.map((w,_)=>w[0]+o.shape[_]),c=a==="reflect"?0:1,p=t.data.get(o.dataId).values,m=o.shape.length,f=y.computeStrides(o.shape),d=y.sizeFromShape(i),h=i.length,g=y.computeStrides(i),x=y.getTypedArrayFromDType(o.dtype,d);for(let w=0;w<d;w++){let _=y.indexToLoc(w,h,g);for(let E=0;E<h;E++)_[E]<l[E]?_[E]=l[E]*2-_[E]-c:_[E]>=u[E]&&(_[E]=(u[E]-1)*2-_[E]+c);_=_.map((E,$)=>E-l[$]);let I=y.locToIndex(_,m,f);x[w]=p[I]}return{dataId:t.write(x,i,o.dtype),shape:i,dtype:o.dtype}}var WE={kernelName:Uo,backendName:"cpu",kernelFunc:m5};var f5=Ye((r,e)=>{let t=r%e;return r<0&&e<0||r>=0&&e>=0?t:(t+e)%e}),d5=et(qi,f5),jE={kernelName:qi,backendName:"cpu",kernelFunc:d5};var HE=pc(x_());function ok(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=o.shape.length,i=s;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let l=y.parseAxisParam([i],o.shape),u=nk({inputs:{x:o},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=C.expandShapeToKeepDim(u.shape,l),p=Ze({inputs:{x:u},backend:t,attrs:{shape:c}}),m=kf({inputs:{a:o,b:p},backend:t}),f=D_({inputs:{x:m},backend:t}),d=Ta({inputs:{x:f},backend:t,attrs:{axis:l,keepDims:!1}}),h=Ze({inputs:{x:d},backend:t,attrs:{shape:c}}),g=vf({inputs:{a:f,b:h},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var UE={kernelName:as,backendName:"cpu",kernelFunc:ok};function h5(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:a,normalized:i}=n;te(o,"multinomial");let l=i?o:ok({inputs:{logits:o},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],p=t.data.get(l.dataId).values,m=[u,s],f=y.makeZerosTypedArray(y.sizeFromShape(m),"int32");for(let d=0;d<u;++d){let h=d*c,g=new Float32Array(c-1);g[0]=p[h];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[h+w];let x=HE.alea(a.toString()),b=d*s;for(let w=0;w<s;++w){let _=x();f[b+w]=g.length;for(let I=0;I<g.length;I++)if(_<g[I]){f[b+w]=I;break}}}return i||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(m,"int32",f)}var qE={kernelName:Mc,backendName:"cpu",kernelFunc:h5};var g5=Rr.nonMaxSuppressionV3Impl;function x5(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=n;te(o,"NonMaxSuppression");let u=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,{selectedIndices:p}=g5(u,c,a,i,l);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var KE={kernelName:Xi,backendName:"cpu",kernelFunc:x5};var y5=Rr.nonMaxSuppressionV4Impl;function b5(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=n;te(o,"NonMaxSuppressionPadded");let c=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,{selectedIndices:m,validOutputs:f}=y5(c,p,a,i,l,u);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var XE={kernelName:Yi,backendName:"cpu",kernelFunc:b5};var w5=Rr.nonMaxSuppressionV5Impl;function _5(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=n;te(o,"NonMaxSuppressionWithScore");let c=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,m=a,f=i,d=l,h=u,{selectedIndices:g,selectedScores:x}=w5(c,p,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var YE={kernelName:Zi,backendName:"cpu",kernelFunc:_5};function k5(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:a,offValue:i}=n;te(o,"oneHot");let l=y.sizeFromShape(o.shape),u=new Float32Array(l*s);u.fill(i);let c=t.data.get(o.dataId).values;for(let p=0;p<l;++p)c[p]>=0&&c[p]<s&&(u[p*s+c[p]]=a);return t.makeTensorInfo([...o.shape,s],"int32",u)}var ZE={kernelName:qo,backendName:"cpu",kernelFunc:k5};function Nf(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=so({inputs:{input:n},backend:t}),s=Nf({inputs:{x:o},backend:t}),a=ai({inputs:{input:n},backend:t}),i=Nf({inputs:{x:a},backend:t}),l=dr({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}else return If({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var JE={kernelName:Zs,backendName:"cpu",kernelFunc:Nf};function QE(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=so({inputs:{input:n},backend:t}),s=QE({inputs:{x:o},backend:t}),a=ai({inputs:{input:n},backend:t}),i=Nf({inputs:{x:a},backend:t}),l=dr({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}else return If({backend:t,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var e2={kernelName:js,backendName:"cpu",kernelFunc:QE};function sk(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return kp({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{y.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=e.map(c=>{let p=kp({inputs:{input:c},backend:t,attrs:{dim:o}});return i.push(p),p}),u=gl({inputs:l,backend:t,attrs:{axis:o}});return i.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}var t2={kernelName:Us,backendName:"cpu",kernelFunc:sk};function v5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;te(o,"pad");let i=s.map((b,w)=>b[0]+o.shape[w]+b[1]),l=s.map(b=>b[0]),u=t.data.get(o.dataId).values,c=y.sizeFromShape(o.shape),p=o.shape.length,m=y.computeStrides(o.shape),f=y.sizeFromShape(i),d=i.length,h=y.computeStrides(i),g=y.getTypedArrayFromDType(o.dtype,f);a!==0&&g.fill(a);for(let b=0;b<c;b++){let _=y.indexToLoc(b,p,m).map((E,$)=>E+l[$]),I=y.locToIndex(_,d,h);g[I]=u[b]}return{dataId:t.write(g,i,o.dtype),shape:i,dtype:o.dtype}}var qg={kernelName:Ko,backendName:"cpu",kernelFunc:v5};var C5=Ye((r,e)=>Math.pow(r,e)),I5=et(Xo,C5),r2={kernelName:Xo,backendName:"cpu",kernelFunc:I5};function N5(r){let{backend:e,attrs:t}=r,{start:n,stop:o,dtype:s,step:a}=t,i=Au(n,o,a,s);return e.makeTensorInfo([i.length],s,i)}var n2={kernelName:nl,backendName:"cpu",kernelFunc:N5};var S5=$e(Qi,r=>1/r),o2={kernelName:Qi,backendName:"cpu",kernelFunc:S5};function T5(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n;te(o,"resizeBilinear");let l=y.computeStrides(o.shape),[u,c]=i,[p,m,f,d]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(y.sizeFromShape([p,u,c,d])),x=[s&&u>1?m-1:m,s&&c>1?f-1:f],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],w=0,_=x[0]/b[0],I=x[1]/b[1];for(let E=0;E<p;E++)for(let $=0;$<u;$++){let D;a?D=_*($+.5)-.5:D=_*$;let O=Math.max(0,Math.floor(D)),M=D-O,G=Math.min(m-1,Math.ceil(D)),j=E*l[0]+O*l[1],U=E*l[0]+G*l[1];for(let H=0;H<c;H++){let q;a?q=I*(H+.5)-.5:q=I*H;let X=Math.max(0,Math.floor(q)),ne=q-X,Y=Math.min(f-1,Math.ceil(q)),re=j+X*l[2],Q=U+X*l[2],ie=j+Y*l[2],ce=U+Y*l[2];for(let ae=0;ae<d;ae++){let fe=h[re+ae],de=h[Q+ae],xe=h[ie+ae],we=h[ce+ae],De=fe+(xe-fe)*ne,ve=de+(we-de)*ne,Ge=De+(ve-De)*M;g[w++]=Ge}}}return t.makeTensorInfo([p,u,c,d],"float32",g)}var s2={kernelName:Jo,backendName:"cpu",kernelFunc:T5};function A5(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n;te([s,o],"resizeBilinearGrad");let i=y.computeStrides(o.shape),[l,u,c,p]=o.shape,[,m,f]=s.shape,d=new Float32Array(l*u*c*p),h=[a&&m>1?u-1:u,a&&f>1?c-1:c],g=[a&&m>1?m-1:m,a&&f>1?f-1:f],x=h[0]/g[0],b=h[1]/g[1],w=t.data.get(s.dataId).values,_=0;for(let I=0;I<l;I++){let E=I*i[0];for(let $=0;$<m;$++){let D=$*x,O=Math.floor(D),M=Math.min(Math.ceil(D),u-1),G=E+O*i[1],j=E+M*i[1],U=D-O,H=1-U;for(let q=0;q<f;q++){let X=q*b,ne=Math.floor(X),Y=Math.min(Math.ceil(X),c-1),re=X-ne,Q=1-re,ie=G+ne*i[2],ce=G+Y*i[2],ae=j+ne*i[2],fe=j+Y*i[2],de=H*Q,xe=H*re,we=U*Q,De=U*re;for(let ve=0;ve<p;ve++){let Ge=w[_++];d[ie+ve]+=Ge*de,d[ce+ve]+=Ge*xe,d[ae+ve]+=Ge*we,d[fe+ve]+=Ge*De}}}}return t.makeTensorInfo([l,c,u,p],"float32",d)}var i2={kernelName:Bc,backendName:"cpu",kernelFunc:A5};function E5(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n;te(o,"resizeNearestNeighbor");let l=y.computeStrides(o.shape),[u,c]=i,[p,m,f,d]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(p*u*c*d),x=[s&&u>1?m-1:m,s&&c>1?f-1:f],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],w=x[0]/b[0],_=x[1]/b[1],I=0;for(let E=0;E<p;E++){let $=E*l[0];for(let D=0;D<u;D++){let O=a?w*(D+.5):w*D,M=Math.min(m-1,s?Math.round(O):Math.floor(O));a&&(M=Math.max(0,M));let G=$+M*l[1];for(let j=0;j<c;j++){let U=a?_*(j+.5):_*j,H=Math.min(f-1,s?Math.round(U):Math.floor(U));a&&(H=Math.max(0,H));let q=G+H*l[2];for(let X=0;X<d;X++){let ne=h[q+X];g[I++]=ne}}}}return t.makeTensorInfo([p,u,c,d],o.dtype,g)}var a2={kernelName:ol,backendName:"cpu",kernelFunc:E5};function D5(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n;te([s,o],"resizeNearestNeighborGrad");let i=y.computeStrides(o.shape),l=y.computeStrides(s.shape),[u,c,p,m]=o.shape,[,f,d]=s.shape,h=new Float32Array(u*c*p*m),g=t.data.get(s.dataId).values,x=[a&&f>1?c-1:c,a&&d>1?p-1:p],b=[a&&f>1?f-1:f,a&&d>1?d-1:d],w=x[0]/b[0],_=x[1]/b[1],I=1/w,E=1/_,$=Math.ceil(I)*2+2,D=Math.ceil(E)*2+2;for(let O=0;O<u;O++){let M=O*i[0];for(let G=0;G<c;G++){let j=M+G*i[1],U=Math.floor(G*I),H=Math.floor(U-$/2);for(let q=0;q<p;q++){let X=j+q*i[2],ne=Math.floor(q*E),Y=Math.floor(ne-D/2);for(let re=0;re<m;re++){let Q=0;for(let ie=0;ie<$;ie++){let ce=ie+H;if(ce<0||ce>=f)continue;let ae=M+ce*l[1],fe=ce*w,de=Math.min(c-1,a?Math.round(fe):Math.floor(fe));if(G===de)for(let xe=0;xe<D;xe++){let we=xe+Y;if(we<0||we>=d)continue;let De=ae+we*l[2],ve=we*_,Ge=Math.min(p-1,a?Math.round(ve):Math.floor(ve));q===Ge&&(Q+=g[De+re])}}h[X+re]=Q}}}}return t.makeTensorInfo(o.shape,o.dtype,h)}var l2={kernelName:zc,backendName:"cpu",kernelFunc:D5};function $5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n;te(o,"reverse");let a=o.shape.length,i=y.parseAxisParam(s,o.shape);if(a===0)return Fr({inputs:{x:o},backend:t});let l=new ut(o.shape,o.dtype),u=t.bufferSync(o);for(let c=0;c<l.size;c++){let p=l.indexToLoc(c),m=p.slice();i.forEach(f=>m[f]=o.shape[f]-1-m[f]),l.set(u.get(...m),...p)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}var u2={kernelName:es,backendName:"cpu",kernelFunc:$5};var c2={kernelName:aa,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,l=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[u,c,p,m]=n.shape,[f,d]=C.getImageCenter(a,c,p),h=255,g=Math.sin(o),x=Math.cos(o),b=i.data.get(n.dataId).values;for(let _=0;_<u;_++){let I=_*p*c*m;for(let E=0;E<c;E++){let $=E*(p*m);for(let D=0;D<p;D++){let O=D*m;for(let M=0;M<m;M++){let G=[u,E,D,M],j=G[2],U=G[1],H=(j-f)*x-(U-d)*g,q=(j-f)*g+(U-d)*x;H=Math.round(H+f),q=Math.round(q+d);let X=s;if(typeof s!="number"&&(M===3?X=h:X=s[M]),H>=0&&H<p&&q>=0&&q<c){let Y=q*(p*m),re=H*m,Q=I+Y+re+M;X=b[Q]}let ne=I+$+O+M;l[ne]=X}}}}return{dataId:i.write(l,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var R5=$e(ts,r=>{let e=Math.floor(r);return r-e<.5?Math.floor(r):r-e>.5?Math.ceil(r):e%2==0?e:e+1}),p2={kernelName:ts,backendName:"cpu",kernelFunc:R5};function Kg(r,e,t,n,o,s,a,i,l,u){let c=[n/o,o],p=r.values,m=e.values;if(n===0)return Ce(t,e.dtype);let f=Ce(c,e.dtype);f.values.fill(l);for(let d=0;d<s;d++){let h=[],g=0;for(let x=0;x<a;x++){let b=p[d*a+x];h.push(b),g+=b*i[x]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let x=0;x<o;x++)u?f.values[g*o+x]+=m[d*o+x]:f.values[g*o+x]=e.rank===0?m[0]:m[d*o+x]}return f}function F5(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=C.calculateShapes(s,o,a),m=!0,f=t.bufferSync(o),d=t.bufferSync(s),h=Kg(f,d,a,p,u,l,i,c,0,m);return t.makeTensorInfo(a,h.dtype,h.values)}var m2={kernelName:ea,backendName:"cpu",kernelFunc:F5};function O5(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e;te([n,o,s],"select");let a=n.shape.length,i=t.data.get(n.dataId).values,l=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,c=ar(o.dtype,s.dtype),p=y.makeZerosTypedArray(y.sizeFromShape(o.shape),c),m=0,f=a===0||a>1||o.shape.length===1?1:y.sizeFromShape(o.shape.slice(1));for(let d=0;d<i.length;d++)for(let h=0;h<f;h++)i[d]===1?p[m++]=l[d]:p[m++]=u[d];return t.makeTensorInfo(o.shape,c,p)}var f2={kernelName:qs,backendName:"cpu",kernelFunc:O5};var P5=C.SELU_SCALEALPHA,M5=C.SELU_SCALE,L5=$e(ta,r=>r>=0?M5*r:P5*(Math.exp(r)-1)),d2={kernelName:ta,backendName:"cpu",kernelFunc:L5};var z5=$e(na,r=>r<0?-1:r>0?1:0),h2={kernelName:na,backendName:"cpu",kernelFunc:z5};var B5=$e(ns,r=>Math.sin(r)),g2={kernelName:ns,backendName:"cpu",kernelFunc:B5};var V5=$e(ra,r=>Math.sinh(r)),x2={kernelName:ra,backendName:"cpu",kernelFunc:V5};var G5=11920928955078125e-23,y2=Math.log(G5)+2,W5=$e(oa,r=>{let e=r>-y2,t=r<y2,n=Math.exp(r),o;return t?o=n:e?o=r:o=Math.log(1+n),o}),b2={kernelName:oa,backendName:"cpu",kernelFunc:W5};function j5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;te([o],"spaceToBatchND");let i=y.sizeFromShape(s),l=[[0,0]];l.push(...a);for(let E=1+s.length;E<o.shape.length;++E)l.push([0,0]);let u=qg.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:l,constantValue:0}}),c=C.getReshaped(u.shape,s,i,!1),p=C.getPermuted(c.length,s.length,!1),m=C.getReshapedPermuted(u.shape,s,i,!1),h=Ze({inputs:{x:u},backend:t,attrs:{shape:c}}),b=Kt({inputs:{x:h},backend:t,attrs:{perm:p}}),I=Ze({inputs:{x:b},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(b),I}var w2={kernelName:sl,backendName:"cpu",kernelFunc:j5};function U5(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.data.get(o.dataId).values),i=t.data.get(n.dataId).values,l=Array.from(t.data.get(s.dataId).values),[u,c,p]=Lg(i,n.shape,n.dtype,a,l);return[t.makeTensorInfo(c,n.dtype,u),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var _2={kernelName:Vc,backendName:"cpu",kernelFunc:U5};function H5(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:m}=C.calculateShapes(s,o,i),f=!1,d=t.bufferSync(o),h=t.bufferSync(s),g=t.data.get(a.dataId).values[0],x=Kg(d,h,i,m,c,u,l,p,g,f);return t.makeTensorInfo(i,x.dtype,x.values)}var k2={kernelName:Gc,backendName:"cpu",kernelFunc:H5};function q5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],l=C.prepareSplitSize(o,s,i),u=new Array(o.shape.length).fill(0),c=o.shape.slice();return l.map(p=>{let m=[...c];m[i]=p;let f=uo({inputs:{x:o},backend:t,attrs:{begin:u,size:m}});return u[i]+=p,f})}var v2={kernelName:Xs,backendName:"cpu",kernelFunc:q5};var K5=$e(ss,r=>Math.sqrt(r)),C2={kernelName:ss,backendName:"cpu",kernelFunc:K5};var I2={kernelName:il,backendName:"cpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e;te(t,"square");let o=n.data.get(t.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){let l=o[i];s[i]=l*l}return{dataId:n.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};var X5=$e(Yn,(r,e)=>{let t=e;return isNaN(r)?NaN:r>0?1:t.alpha}),N2={kernelName:Yn,backendName:"cpu",kernelFunc:X5};function Y5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n;te(o,"stridedSlice");let{nonStrided:f,$begin:d,$strides:h,size:g,newShape:x,outShape:b}=rr.sliceInfo(o.shape,s,a,i,l,u,c,p,m),w=Ze({inputs:{x:o},backend:t,attrs:{shape:x}}),_;if(f){let E=uo({inputs:{x:w},backend:t,attrs:{begin:d,size:g}});_=Ze({inputs:{x:E},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(E)}else if(b.some(E=>E===0))_=t.makeTensorInfo(b,o.dtype,[]);else{let E=t.bufferSync(w),$=zg(b,E,h,d);_=t.makeTensorInfo($.shape,$.dtype,$.values)}let I=Ze({inputs:{x:_},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(_),I}var S2={kernelName:sa,backendName:"cpu",kernelFunc:Y5};var Z5=$e(cs,r=>Math.tan(r)),T2={kernelName:cs,backendName:"cpu",kernelFunc:Z5};var J5=$e(ps,r=>Math.tanh(r)),A2={kernelName:ps,backendName:"cpu",kernelFunc:J5};function Q5(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;te(o,"tile");let a=Bg(t.bufferSync(o),s);return t.makeTensorInfo(a.shape,a.dtype,a.values)}var E2={kernelName:Pn,backendName:"cpu",kernelFunc:Q5};function e8(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n;te(o,"topk");let i=t.data.get(o.dataId).values,[l,u]=Vg(i,o.shape,o.dtype,s,a);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}var D2={kernelName:ia,backendName:"cpu",kernelFunc:e8};function n8(r){let{inputs:e,attrs:t,backend:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=t,[c,p,m,f]=o.shape,[d,h]=u!=null?u:[p,m],g=[c,d,h,f],x=y.computeStrides(o.shape),b=x[0],w=x[1],_=x[2],I=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(g));I.fill(l);let E=n.data.get(o.dataId).values,$=n.data.get(s.dataId).values;for(let O=0;O<c;++O){let M=s.shape[0]===1?$:$.subarray(O*8,O*8+8);for(let G=0;G<d;++G)for(let j=0;j<h;++j)for(let U=0;U<f;++U){let H,q=M[6]*j+M[7]*G+1;if(q===0)continue;let X=(M[0]*j+M[1]*G+M[2])/q,ne=(M[3]*j+M[4]*G+M[5])/q,Y=$2(X,m,i),re=$2(ne,p,i);switch(a){case"nearest":H=t8(E,p,m,b,w,_,O,re,Y,U,l);break;case"bilinear":H=r8(E,p,m,b,w,_,O,re,Y,U,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let Q=O*b+G*w+j*_+U;I[Q]=H}return n.makeTensorInfo(g,o.dtype,I)}return{dataId:n.write(I,g,o.dtype),shape:o.shape,dtype:o.dtype}}var R2={kernelName:Wc,backendName:"cpu",kernelFunc:n8};function $2(r,e,t){switch(t){case"reflect":return o8(r,e);case"wrap":return s8(r,e);case"nearest":return a8(r,e);case"constant":default:return i8(r,e)}}function o8(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=2*e;t<n&&(t=n*Math.trunc(-t/n)+t),t=t<-e?t+n:-t-1}else if(t>e-1)if(e<=1)t=0;else{let n=2*e;t-=n*Math.trunc(t/n),t>=e&&(t=n-t-1)}return y.clamp(0,t,e-1)}function s8(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=e-1;t+=e*(Math.trunc(-t/n)+1)}else if(t>e-1)if(e<=1)t=0;else{let n=e-1;t-=e*Math.trunc(t/n)}return y.clamp(0,t,e-1)}function i8(r,e){return r}function a8(r,e){return y.clamp(0,r,e-1)}function Sf(r,e,t,n,o,s,a,i,l,u,c){let p=a*n+i*o+l*s+u;return 0<=i&&i<e&&0<=l&&l<t?r[p]:c}function t8(r,e,t,n,o,s,a,i,l,u,c){let p=Math.round(i),m=Math.round(l);return Sf(r,e,t,n,o,s,a,p,m,u,c)}function r8(r,e,t,n,o,s,a,i,l,u,c){let p=Math.floor(i),m=Math.floor(l),f=p+1,d=m+1,h=(d-l)*Sf(r,e,t,n,o,s,a,p,m,u,c)+(l-m)*Sf(r,e,t,n,o,s,a,p,d,u,c),g=(d-l)*Sf(r,e,t,n,o,s,a,f,m,u,c)+(l-m)*Sf(r,e,t,n,o,s,a,f,d,u,c);return(f-i)*h+(i-p)*g}function l8(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;te(s,"unique");let a=n.data.get(s.dataId).values,{outputValues:i,outputShape:l,indices:u}=Gg(a,o,s.shape,s.dtype);return[n.makeTensorInfo(l,s.dtype,i),n.makeTensorInfo([u.length],"int32",u)]}var F2={kernelName:jc,backendName:"cpu",kernelFunc:l8};function u8(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape.length,i=o.shape[s],l=new Array(a-1),u=0;for(let f=0;f<a;f++)f!==s&&(l[u++]=o.shape[f]);let c=new Array(a).fill(0),p=o.shape.slice();p[s]=1;let m=new Array(i);for(let f=0;f<m.length;f++){c[s]=f;let d=uo({inputs:{x:o},backend:t,attrs:{begin:c,size:p}});m[f]=Ze({inputs:{x:d},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(d)}return m}var O2={kernelName:Ys,backendName:"cpu",kernelFunc:u8};function c8(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:a}=n;te(o,"unsortedSegmentSum");let i=o.shape.length,l=s.shape.length,u=[],c=[],p=i-l,m=s;for(let d=0;d<p;++d){let h=kp({inputs:{input:m},backend:t,attrs:{dim:d+1}});m=h,c.push(h)}for(let d=0;d<a;++d){let h=y.createScalarValue(d,"int32"),g=t.makeTensorInfo([],"int32",h),x=tk({inputs:{a:g,b:m},backend:t}),b=io({inputs:{x},backend:t,attrs:{dtype:"float32"}}),w=Tu({inputs:{a:b,b:o},backend:t}),_=Ta({inputs:{x:w},backend:t,attrs:{axis:0,keepDims:!1}});u.push(_),c.push(g),c.push(x),c.push(b),c.push(w),c.push(_)}let f=sk({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),f}var P2={kernelName:al,backendName:"cpu",kernelFunc:c8};var p8=[xA,z1,yA,bA,j1,wA,_A,kA,vA,CA,IA,NA,SA,TA,AA,DA,$A,RA,FA,gA,OA,PA,MA,W1,U1,LA,B1,zA,VA,WA,jA,GA,HA,qA,UA,KA,XA,YA,ZA,JA,QA,eE,tE,rE,nE,oE,iE,sE,Cf,lE,uA,uE,cE,pE,H1,mE,q1,fE,dE,hE,K1,gE,xE,yE,bE,wE,X1,_E,V1,kE,BA,vE,CE,IE,cA,Y1,NE,SE,Z1,TE,AE,EE,DE,$E,RE,J1,OE,PE,ME,LE,BE,FE,VE,GE,Q1,WE,jE,qE,eA,tA,KE,XE,YE,rA,ZE,e2,t2,qg,r2,pA,oA,n2,G1,o2,mA,fA,hA,s2,i2,a2,l2,u2,c2,p2,sA,m2,f2,d2,dA,h2,g2,x2,iA,UE,b2,w2,_2,k2,v2,C2,I2,aA,N2,S2,lA,aE,T2,A2,E2,D2,nA,R2,F2,O2,P2,JE];for(let r of p8)Hl(r);var z2={};We(z2,{assertNotComplex:()=>vs,bindCanvasToFramebuffer:()=>_8,bindColorTextureToFramebuffer:()=>Ef,bindTextureToProgramUniformSampler:()=>wk,bindTextureUnit:()=>G2,bindVertexBufferToProgramAttribute:()=>Xg,callAndCheck:()=>Ne,canBeRepresented:()=>lk,createFragmentShader:()=>ck,createFramebuffer:()=>xk,createProgram:()=>pk,createStaticIndexBuffer:()=>dk,createStaticVertexBuffer:()=>fk,createTexture:()=>hk,createVertexShader:()=>uk,getBatchDim:()=>Ea,getExtensionOrThrow:()=>vp,getFramebufferErrorMessage:()=>W2,getMaxTexturesInShader:()=>vk,getNumChannels:()=>b8,getProgramUniformLocation:()=>bk,getProgramUniformLocationOrThrow:()=>yk,getRowsCols:()=>Da,getShapeAs3D:()=>Df,getTextureShapeFromLogicalShape:()=>_k,getWebGLDisjointQueryTimerVersion:()=>Ck,getWebGLErrorMessage:()=>B2,getWebGLMaxTextureSize:()=>kk,hasExtension:()=>Tn,isCapableOfRenderingToFloatTexture:()=>Nk,isDownloadFloatTextureEnabled:()=>Sk,isReshapeFree:()=>bl,isWebGLFenceEnabled:()=>Tk,isWebGLVersionEnabled:()=>ex,linkProgram:()=>mk,resetMaxTextureSize:()=>k8,resetMaxTexturesInShader:()=>v8,unbindColorTextureFromFramebuffer:()=>Yg,unbindTextureUnit:()=>w8,validateFramebuffer:()=>Cp,validateProgram:()=>Af,validateTextureSize:()=>gk});var Du={},ik={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ak(r,e){Du[r]=e}function Vn(r){if(!(r in Du)){let t=m8(r);if(t!==null)Du[r]=t;else return console.log("Could not get context for WebGL version",r),null}let e=Du[r];return e.isContextLost()?(delete Du[r],Vn(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Du[r])}function f8(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function m8(r){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=f8(r);return e.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete Du[r]},!1),r===1?e.getContext("webgl",ik)||e.getContext("experimental-webgl",ik):e.getContext("webgl2",ik)}var xl;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(xl||(xl={}));var Or;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(Or||(Or={}));var Cr;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Cr||(Cr={}));function $u(r,e){return[e,r]}function M2(r,e){return r*e}function yl(r){let e=y.sizeFromShape(r),t=Math.ceil(e/4);return y.sizeToSquarishShape(t)}function li(r,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(r/2))]}function L2(r,e){let[t,n]=li(r,e);return t*n*4}function Tf(r,e){let t=r,n,o,s,a,i,l,u,c,p,m;return W().getNumber("WEBGL_VERSION")===2?(n=t.R32F,o=t.R16F,s=t.RGBA16F,a=t.RGBA32F,i=t.RED,u=4,c=1,p=t.HALF_FLOAT,m=t.FLOAT):(n=r.RGBA,o=r.RGBA,s=r.RGBA,a=t.RGBA,i=r.RGBA,u=4,c=4,p=e!=null?e.HALF_FLOAT_OES:null,m=r.FLOAT),l=r.RGBA,{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function Ne(r,e){let t=e();return W().getBool("DEBUG")&&d8(r),t}function d8(r){let e=r.getError();if(e!==r.NO_ERROR)throw new Error("WebGL Error: "+B2(r,e))}var h8=596e-10,g8=65504;function lk(r){return!!(W().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||h8<Math.abs(r)&&Math.abs(r)<g8)}function B2(r,e){switch(e){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function vp(r,e){return Aa(r,()=>r.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function uk(r,e){let t=Aa(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ne(r,()=>r.shaderSource(t,e)),Ne(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function ck(r,e){let t=Aa(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ne(r,()=>r.shaderSource(t,e)),Ne(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw x8(e,r.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var y8=/ERROR: [0-9]+:([0-9]+):/g;function x8(r,e){let t=y8.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(r);return}let n=+t[1],o=r.split(`
`),s=o.length.toString().length+2,a=o.map((p,m)=>y.rightPad((m+1).toString(),s)+p),i=0;for(let p=0;p<a.length;p++)i=Math.max(a[p].length,i);let l=a.slice(0,n-1),u=a.slice(n-1,n),c=a.slice(n);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${y.rightPad(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function pk(r){return Aa(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function mk(r,e){if(Ne(r,()=>r.linkProgram(e)),r.getProgramParameter(e,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Af(r,e){if(Ne(r,()=>r.validateProgram(e)),r.getProgramParameter(e,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function fk(r,e){let t=Aa(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Ne(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Ne(r,()=>r.bufferData(r.ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function dk(r,e){let t=Aa(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Ne(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t)),Ne(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function b8(){return W().getNumber("WEBGL_VERSION")===2?1:4}function hk(r){return Aa(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function gk(r,e){let t=W().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||e<=0){let n=`[${r}x${e}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>t||e>t){let n=`[${r}x${e}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function xk(r){return Aa(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Xg(r,e,t,n,o,s,a){let i=r.getAttribLocation(e,t);return i===-1?!1:(Ne(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),Ne(r,()=>r.vertexAttribPointer(i,o,r.FLOAT,!1,s,a)),Ne(r,()=>r.enableVertexAttribArray(i)),!0)}function G2(r,e,t){V2(r,t),Ne(r,()=>r.activeTexture(r.TEXTURE0+t)),Ne(r,()=>r.bindTexture(r.TEXTURE_2D,e))}function w8(r,e){V2(r,e),Ne(r,()=>r.activeTexture(r.TEXTURE0+e)),Ne(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function yk(r,e,t){return Aa(r,()=>r.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function bk(r,e,t){return r.getUniformLocation(e,t)}function wk(r,e,t,n){Ne(r,()=>G2(r,e,n)),Ne(r,()=>r.uniform1i(t,n))}function _8(r){Ne(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),Ne(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),Ne(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function Ef(r,e,t){Ne(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Ne(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0))}function Yg(r,e){Ne(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),Ne(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function Cp(r){let e=r.checkFramebufferStatus(r.FRAMEBUFFER);if(e!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+W2(r,e))}function W2(r,e){switch(e){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Aa(r,e,t){let n=Ne(r,()=>e());if(n==null)throw new Error(t);return n}function V2(r,e){let t=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+r.TEXTURE0;if(n<r.TEXTURE0||n>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function Ea(r,e=2){return y.sizeFromShape(r.slice(0,r.length-e))}function Da(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function Df(r){let e=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(e=[Ea(r),...Da(r)]),e}function _k(r,e=!1){let t=W().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,r=r.map((o,s)=>s>=r.length-2?y.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=y.squeezeShape(r).newShape);let n=y.sizeFromShape(r);if(r.length<=1&&n<=t)return[1,n];if(r.length===2&&r[0]<=t&&r[1]<=t)return r;if(r.length===3&&r[0]*r[1]<=t&&r[2]<=t)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=t&&r[1]*r[2]<=t)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t)return[r[0],r[1]*r[2]*r[3]];if(e){let o=Ea(r),s=2,a=2;return r.length&&([s,a]=Da(r)),n=o*(s/2)*(a/2),y.sizeToSquarishShape(n).map(i=>i*2)}return y.sizeToSquarishShape(n)}function Zg(r){return r%2==0}function bl(r,e){if(r=r.slice(-2),e=e.slice(-2),y.arraysEqual(r,e)||!r.length||!e.length||r[0]===0||r[1]===0||e[0]===0||e[1]===0)return!0;if(r.length!==e.length){let t=r.slice(-1)[0],n=e.slice(-1)[0];if(t===n||Zg(t)&&Zg(n)&&(r[0]===1||e[0]===1))return!0}return r[1]===e[1]&&Zg(r[0])&&Zg(e[0])}var Jg,Qg;function kk(r){if(Jg==null){let e=Vn(r);Jg=e.getParameter(e.MAX_TEXTURE_SIZE)}return Jg}function k8(){Jg=null}function v8(){Qg=null}function vk(r){if(Qg==null){let e=Vn(r);Qg=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Qg)}function Ck(r){if(r===0)return 0;let e,t=Vn(r);return Tn(t,"EXT_disjoint_timer_query_webgl2")&&r===2?e=2:Tn(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Tn(r,e){return r.getExtension(e)!=null}function ex(r){try{if(Vn(r)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Nk(r){if(r===0)return!1;let e=Vn(r);if(r===1){if(!Tn(e,"OES_texture_float"))return!1}else if(!Tn(e,"EXT_color_buffer_float"))return!1;return Ik(e)}function Sk(r){if(r===0)return!1;let e=Vn(r);if(r===1){if(!Tn(e,"OES_texture_float")||!Tn(e,"WEBGL_color_buffer_float"))return!1}else{if(Tn(e,"EXT_color_buffer_float"))return Ik(e);let n="EXT_color_buffer_half_float";if(Tn(e,n)){let o=e.getExtension(n);return C8(e,o)}return!1}return Ik(e)}function Ik(r){let e=Tf(r),t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatFloat,n,o,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(t),r.deleteFramebuffer(s),a}function C8(r,e){let t=Tf(r,e),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatHalfFloat,o,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let a=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,a),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(a),i}function Tk(r){return r!==2?!1:Vn(r).fenceSync!=null}function vs(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var Oe=W();Oe.registerFlag("HAS_WEBGL",()=>Oe.getNumber("WEBGL_VERSION")>0);Oe.registerFlag("WEBGL_VERSION",()=>ex(2)?2:ex(1)?1:0);Oe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Oe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Oe.get("WEBGL_VERSION")===2);Oe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Oe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Oe.registerFlag("WEBGL_PACK",()=>Oe.getBool("HAS_WEBGL"));Oe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_CLIP",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_PACK_REDUCE",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_CONV_IM2COL",()=>Oe.getBool("WEBGL_PACK"));Oe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>kk(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>vk(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Oe.getNumber("WEBGL_VERSION");return r===0?0:Ck(r)});Oe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Oe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Yl.isMobile());Oe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Nk(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Oe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Oe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Oe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Sk(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Tk(Oe.getNumber("WEBGL_VERSION")));Oe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Oe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Oe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Oe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Yl.isMobile()&&Oe.getBool("IS_CHROME")?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});function Ot(){let r,e,t,n,o,s,a,i,l,u;return W().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",e="in",t="out",n="in",o="texture",s="outputColor",a="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",e="attribute",t="varying",n="varying",o="texture2D",s="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:e,varyingVs:t,varyingFs:n,texture2D:o,output:s,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function Cs(r,e,t="index"){let n=y.computeStrides(e);return n.map((o,s)=>{let a=`int ${r[s]} = ${t} / ${o}`,i=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${a}; ${i};`}).join("")}function Ip(r){let e=y.computeStrides(r).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}var tx=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var Ak=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=xl.DENSE;let t=yl(e),n=Ot();this.outputShape=e,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${Cs(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${t[0]}, ${t[1]}));
        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}};var Ek=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=xl.DENSE;let t=yl(e),n=Ot();this.outputShape=e,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${Cs(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${t[0]}, ${t[1]}));
        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}};var Dk=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Or.DOWNLOAD;let t=Ot();this.outputShape=e,this.userCode=`
      ${tx}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var $k=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Or.DOWNLOAD;let t=Ot();this.outputShape=e,this.userCode=`
      ${tx}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var Rk=class{constructor(e,t,n=!1){this.variableNames=["A"];let o=Ot(),[s,a]=t;this.outputShape=e;let i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode=`
      ${Ip(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / ${a};
        int c = imod(flatIndex, ${a});
        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);
        vec4 values = ${o.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${o.output} = vec4(${i}, 0., 0., 0.);
      }
    `}};var Fk=class{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let o=Ot(),[s,a]=t;this.outputShape=e;let i="",l="result";n&&(l="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let c=0;c<=1;c++){let p=u*2+c;i+=`
          localCoords = coords;
          if(localCoords[2] + ${c} < ${e[2]}) {
            localCoords[2] += ${c};
            if(localCoords[1] + ${u} < ${e[1]}) {
              localCoords[1] += ${u};

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ${a};
              c = imod(flatIndex, ${a});
              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);
              values = ${o.texture2D}(A, uv);

              if(offset == 0) {
                result[${p}] = values[0];
              } else if(offset == 1) {
                result[${p}] = values[1];
              } else if(offset == 2) {
                result[${p}] = values[2];
              } else {
                result[${p}] = values[3];
              }
            }
          }
        `}this.userCode=`
      ${Ip(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ${i}

        ${o.output} = ${l};
      }
    `}};var j2={};We(j2,{bindVertexProgramAttributeStreams:()=>Wk,createBufferFromOutputTexture:()=>Hk,createFloat16MatrixTexture:()=>zk,createFloat16PackedMatrixTexture:()=>Gk,createFloat32MatrixTexture:()=>Lk,createIndexBuffer:()=>Mk,createPackedMatrixTexture:()=>Vk,createUnsignedBytesMatrixTexture:()=>Bk,createVertexBuffer:()=>Pk,createVertexShader:()=>Ok,downloadByteEncodedFloatMatrixFromOutputTexture:()=>Kk,downloadFloat32MatrixFromBuffer:()=>qk,downloadMatrixFromPackedOutputTexture:()=>Yk,downloadPackedMatrixFromBuffer:()=>Xk,getInternalFormatForFloat16MatrixTexture:()=>nx,getInternalFormatForFloat16PackedMatrixTexture:()=>ix,getInternalFormatForFloat32MatrixTexture:()=>rx,getInternalFormatForPackedMatrixTexture:()=>sx,getInternalFormatForUnsignedBytesMatrixTexture:()=>ox,uploadDenseMatrixToTexture:()=>jk,uploadPixelDataToTexture:()=>Uk});function Ok(r){let e=Ot(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return uk(r,t)}function Pk(r){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return fk(r,e)}function Mk(r){let e=new Uint16Array([0,1,2,2,1,3]);return dk(r,e)}function $f(r,e,t,n,o,s){gk(e,t);let a=hk(r),i=r.TEXTURE_2D;return Ne(r,()=>r.bindTexture(i,a)),Ne(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Ne(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Ne(r,()=>r.texParameteri(i,r.TEXTURE_MIN_FILTER,r.NEAREST)),Ne(r,()=>r.texParameteri(i,r.TEXTURE_MAG_FILTER,r.NEAREST)),Ne(r,()=>r.texImage2D(i,0,n,e,t,0,o,s,null)),Ne(r,()=>r.bindTexture(r.TEXTURE_2D,null)),a}function rx(r){return r.internalFormatFloat}function Lk(r,e,t,n){let[o,s]=$u(e,t);return $f(r,o,s,rx(n),n.textureFormatFloat,r.FLOAT)}function nx(r){return r.internalFormatHalfFloat}function zk(r,e,t,n){let[o,s]=$u(e,t);return $f(r,o,s,nx(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function ox(r){return r.downloadTextureFormat}function Bk(r,e,t,n){let[o,s]=$u(e,t);return $f(r,o,s,ox(n),r.RGBA,r.UNSIGNED_BYTE)}function sx(r){return r.internalFormatPackedFloat}function Vk(r,e,t,n){let[o,s]=li(e,t);return $f(r,o,s,sx(n),r.RGBA,r.FLOAT)}function ix(r){return r.internalFormatPackedHalfFloat}function Gk(r,e,t,n){let[o,s]=li(e,t);return $f(r,o,s,ix(n),r.RGBA,n.textureTypeHalfFloat)}function Wk(r,e,t){let n=0,o=3*4,s=3*4+2*4;return Ne(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Xg(r,e,"clipSpacePos",t,3,s,n)&&Xg(r,e,"uv",t,2,s,o)}function jk(r,e,t,n,o,s){Ne(r,()=>r.bindTexture(r.TEXTURE_2D,e));let a,i,l;o instanceof Uint8Array?(a=new Uint8Array(t*n*4),i=r.UNSIGNED_BYTE,l=r.RGBA):(a=new Float32Array(t*n*4),i=r.FLOAT,l=s.internalFormatPackedFloat),a.set(o),Ne(r,()=>r.texImage2D(r.TEXTURE_2D,0,l,t,n,0,r.RGBA,i,a)),Ne(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function Uk(r,e,t){Ne(r,()=>r.bindTexture(r.TEXTURE_2D,e)),t.data instanceof Uint8Array?Ne(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t.width,t.height,0,r.RGBA,r.UNSIGNED_BYTE,t.data)):Ne(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,t)),Ne(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function Hk(r,e,t,n){let o=r.createBuffer();Ne(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let i=4*4*e*t;return Ne(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,i,r.STREAM_READ)),Ne(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,0)),Ne(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function qk(r,e,t){let n=r,o=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function Kk(r,e,t,n){let[o,s]=$u(e,t),a=4,i=new Uint8Array(M2(e*t,a));return Ne(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function Xk(r,e,t,n,o,s,a,i){let l=r,u=new Float32Array(L2(s,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function Yk(r,e,t){let n=new Float32Array(e*t*4);return Ne(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,n)),n}var ax=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let t=W().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,ak(t,e)):this.gl=Vn(t);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(W().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=vp(this.gl,s),Tn(this.gl,a))this.textureHalfFloatExtension=vp(this.gl,a);else if(W().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Tn(this.gl,o))this.colorBufferHalfFloatExtension=vp(this.gl,o);else if(W().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Tn(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Tn(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Pk(this.gl),this.indexBuffer=Mk(this.gl),this.framebuffer=xk(this.gl),this.textureConfig=Tf(this.gl,this.textureHalfFloatExtension)}get debug(){return W().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Ne(e,()=>e.finish()),Ne(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ne(e,()=>e.deleteFramebuffer(this.framebuffer)),Ne(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ne(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ne(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Lk(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),zk(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Bk(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Uk(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,o){this.throwIfDisposed(),jk(this.gl,e,t,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Gk(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Vk(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Yg(this.gl,this.framebuffer),this.outputTexture=null),Ne(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Kk(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,o,s,a){return Xk(this.gl,e,t,n,o,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return qk(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let o=Hk(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(W().getBool("WEBGL_FENCE_API_ENABLED")){let o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=o.clientWaitSync(s,0,0);return a===o.ALREADY_SIGNALED||a===o.CONDITION_SATISFIED},t=s}else W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Yk(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl,n=ck(t,e),o=Ok(t),s=pk(t);return Ne(t,()=>t.attachShader(s,o)),Ne(t,()=>t.attachShader(s,n)),mk(t,s),this.debug&&Af(t,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=Wk(t,this.program,this.vertexBuffer)),s}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&Ne(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Af(this.gl,this.program),Ne(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?yk(this.gl,e,t):bk(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ne(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),wk(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[o,s]=li(t,n);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,n,o){this.setOutputMatrixWriteRegionDriver(n,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Af(this.gl,this.program),Cp(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),Ne(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ne(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=vp(this.gl,W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await y.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=I8(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ef(this.gl,e,this.framebuffer),this.debug&&Cp(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ef(this.gl,this.outputTexture,this.framebuffer),this.debug&&Cp(this.gl)):Yg(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let o=this.gl;Ef(o,e,this.framebuffer),this.debug&&Cp(o),this.outputTexture=e,Ne(o,()=>o.viewport(0,0,t,n)),Ne(o,()=>o.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,o){this.throwIfDisposed(),Ne(this.gl,()=>this.gl.scissor(e,t,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function I8(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var{getBroadcastDims:U2}=C;function H2(r,e,t,n){let o=[];r.forEach(d=>{let h=y.sizeFromShape(d.shapeInfo.logicalShape);d.shapeInfo.isUniform?o.push(`uniform float ${d.name}${h>1?`[${h}]`:""};`):(o.push(`uniform sampler2D ${d.name};`),o.push(`uniform int offset${d.name};`))});let s=o.join(`
`),a=r.map(d=>N8(d,e,n)).join(`
`),i=e.texShape,l=Ot(),u=A8(l),c,p,m=$8(l);return e.isPacked?(c=S8(e.logicalShape,i),p=D8(l)):(c=T8(e.logicalShape,i),p=E8(l)),n&&(m+=R8),[m,u,p,s,c,a,t].join(`
`)}function Np(r){let e=r.shapeInfo.logicalShape;switch(e.length){case 0:return F8(r);case 1:return O8(r);case 2:return P8(r);case 3:return M8(r);case 4:return L8(r);case 5:return z8(r);case 6:return B8(r);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function q2(r){switch(r.shapeInfo.logicalShape.length){case 0:return V8(r);case 1:return G8(r);case 2:return W8(r);case 3:return j8(r);default:return U8(r)}}function N8(r,e,t=!1){let n="";t?n+=q2(r):n+=Np(r);let o=r.shapeInfo.logicalShape,s=e.logicalShape;return o.length<=s.length&&(t?n+=H8(r,e):n+=q8(r,e)),n}function S8(r,e){switch(r.length){case 0:return K2();case 1:return K8(r,e);case 2:return Z8(r,e);case 3:return X8(r,e);default:return Y8(r,e)}}function T8(r,e){switch(r.length){case 0:return K2();case 1:return J8(r,e);case 2:return nX(r,e);case 3:return Q8(r,e);case 4:return eX(r,e);case 5:return tX(r,e);case 6:return rX(r,e);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function A8(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function E8(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function D8(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function $8(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${oX}
    ${sX}
    ${iX}
  `}var oX=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,sX=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,iX=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,R8=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function K2(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function K8(r,e){let t=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return t[0]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${t[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return 2 * (resTexRC.x * ${t[1]} + resTexRC.y);
    }
  `}function J8(r,e){return e[0]===1?`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function X8(r,e){let t=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],n=Math.ceil(r[2]/2),o=n*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec3(b, r, c);
    }
  `}function Q8(r,e){let t=Cs(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${t}
      return ivec3(r, c, d);
    }
  `}function Y8(r,e){let t=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],n=Math.ceil(r[r.length-1]/2),o=n*Math.ceil(r[r.length-2]/2),s=o,a="",i="b, r, c";for(let l=2;l<r.length-1;l++)s*=r[r.length-l-1],a=`
      int b${l} = index / ${s};
      index -= b${l} * ${s};
    `+a,i=`b${l}, `+i;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec${r.length}(${i});
    }
  `}function eX(r,e){let t=Cs(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${t}
      return ivec4(r, c, d, d2);
    }
  `}function tX(r,e){let t=Cs(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function rX(r,e){let t=Cs(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Z8(r,e){let t=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(y.arraysEqual(r,e))return`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `;let n=Math.ceil(r[1]/2);return`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec2(r, c);
    }
  `}function nX(r,e){return y.arraysEqual(r,e)?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:r[1]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Ru(r){return`offset${r}`}function V8(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=Ot();return`
    vec4 ${t}() {
      return ${n.texture2D}(${e}, halfCR);
    }
  `}function F8(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`float ${t}() {return ${e};}`;let[n,o]=r.shapeInfo.texShape;if(n===1&&o===1)return`
      float ${t}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let[s,a]=r.shapeInfo.texShape,i=Ru(e);return`
    float ${t}() {
      vec2 uv = uvFromFlat(${s}, ${a}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function G8(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=r.shapeInfo.texShape,o=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Ot();return`
    vec4 ${t}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function O8(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`
      float ${t}(int index) {
        ${Sp(r)}
      }
    `;let n=r.shapeInfo.texShape,o=n[0],s=n[1];if(s===1&&o===1)return`
      float ${t}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Ru(e);return s===1?`
      float ${t}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${e}, uv);
      }
    `:o===1?`
      float ${t}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${s}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
    float ${t}(int index) {
      vec2 uv = uvFromFlat(${o}, ${s}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function W8(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=r.shapeInfo.texShape,s=o[0],a=o[1],i=Ot();if(o!=null&&y.arraysEqual(e,o))return`
      vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${s}.0);

        return ${i.texture2D}(${t}, uv);
      }
    `;let l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(e[1]/2);return`
    vec4 ${n}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);
      return ${i.texture2D}(${t}, uv);
    }
  `}function P8(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=r.shapeInfo.texShape;if(o!=null&&y.arraysEqual(e,o)){let p=o[0],m=o[1];return`
    float ${n}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${t}, uv);
    }
  `}let{newShape:s,keptDims:a}=y.squeezeShape(e),i=s;if(i.length<e.length){let p=Tp(r,i),m=["row","col"];return`
      ${Np(p)}
      float ${n}(int row, int col) {
        return ${n}(${Ap(m,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Sp(r)}
      }
    `;let l=o[0],u=o[1],c=Ru(t);return u===1?`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${t}, uv);
    }
  `:l===1?`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${t}, uv);
    }
  `:`
  float ${n}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${c};
    vec2 uv = uvFromFlat(${l}, ${u}, index);
    return sampleTexture(${t}, uv);
  }
`}function j8(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=r.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(e[0]===1){let p=e.slice(1),m=[1,2],f=Tp(r,p),d=["b","row","col"];return`
        ${q2(f)}
        vec4 ${n}(int b, int row, int col) {
          return ${n}(${Ap(d,m)});
        }
      `}let a=s[0],i=s[1],l=Math.ceil(e[2]/2),u=l*Math.ceil(e[1]/2),c=Ot();return`
    vec4 ${n}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${a}, ${i}, ${u}, ${l}, b, row, col);
      return ${c.texture2D}(${t}, uv);
    }
  `}function M8(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[1]*e[2],s=e[2],{newShape:a,keptDims:i}=y.squeezeShape(e),l=a;if(l.length<e.length){let d=Tp(r,l),h=["row","col","depth"];return`
        ${Np(d)}
        float ${n}(int row, int col, int depth) {
          return ${n}(${Ap(h,i)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${s}, 1)));
        ${Sp(r)}
      }
    `;let u=r.shapeInfo.texShape,c=u[0],p=u[1],m=r.shapeInfo.flatOffset;if(p===o&&m==null)return`
        float ${n}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${s}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${c}.0);
          return sampleTexture(${t}, uv);
        }
      `;if(p===s&&m==null)return`
    float ${n}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${c}.0);
      return sampleTexture(${t}, uv);
    }
  `;let f=Ru(t);return`
      float ${n}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${s} + depth + ${f};
        vec2 uv = uvFromFlat(${c}, ${p}, index);
        return sampleTexture(${t}, uv);
      }
  `}function U8(r){let e=r.shapeInfo.logicalShape,t=e.length,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],i=a[0],l=a[1],u=Math.ceil(e[t-1]/2),c=u*Math.ceil(e[t-2]/2),p="int b, int row, int col",m=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let d=2;d<t-1;d++)p=`int b${d}, `+p,c*=e[t-d-1],m=`b${d} * ${c} + `+m;let f=Ot();return`
    vec4 ${o}(${p}) {
      int index = ${m};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${i});
      return ${f.texture2D}(${n}, uv);
    }
  `}function L8(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[3],s=e[2]*o,a=e[1]*s,{newShape:i,keptDims:l}=y.squeezeShape(e);if(i.length<e.length){let d=Tp(r,i),h=["row","col","depth","depth2"];return`
      ${Np(d)}
      float ${n}(int row, int col, int depth, int depth2) {
        return ${n}(${Ap(h,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${s}, ${o}, 1)));
        ${Sp(r)}
      }
    `;let u=r.shapeInfo.flatOffset,c=r.shapeInfo.texShape,p=c[0],m=c[1];if(m===a&&u==null)return`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(m===o&&u==null)return`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;let f=Ru(t);return`
    float ${n}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${s} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${m}, index + ${f});
      return sampleTexture(${t}, uv);
    }
  `}function z8(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[4],s=e[3]*o,a=e[2]*s,i=e[1]*a,{newShape:l,keptDims:u}=y.squeezeShape(e);if(l.length<e.length){let h=Tp(r,l),g=["row","col","depth","depth2","depth3"];return`
      ${Np(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Ap(g,u)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${s}, ${o})) +
          depth3;
        ${Sp(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1];if(f===i&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;let d=Ru(t);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${s} +
          depth2 * ${o} + depth3 + ${d};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function B8(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=y.squeezeShape(e);if(o.length<e.length){let g=Tp(r,o),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${Np(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Ap(x,s)});
      }
    `}let a=e[5],i=e[4]*a,l=e[3]*i,u=e[2]*l,c=e[1]*u;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Sp(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],d=m[1];if(d===c&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===a&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Ru(t);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Sp(r){let e=r.name,t=y.sizeFromShape(r.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function H8(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=U2(r.shapeInfo.logicalShape,e.logicalShape),l=Ve(a),u=a-s,c,p=["x","y","z","w","u","v"];s===0?c="":a<2&&i.length>=1?c="coords = 0;":c=i.map(b=>`coords.${p[b+u]} = 0;`).join(`
`);let m="";a<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((b,w)=>`coords.${p[w+u]}`).join(", ");let f="return outputValue;",h=y.sizeFromShape(r.shapeInfo.logicalShape)===1,x=y.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!x)a===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(i.length){let b=s-2,w=s-1;i.indexOf(b)>-1&&i.indexOf(w)>-1?f="return vec4(outputValue.x);":i.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${m});
      ${f}
    }
  `}function q8(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=e.texShape,a=r.shapeInfo.texShape,i=r.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!r.shapeInfo.isUniform&&i===l&&r.shapeInfo.flatOffset==null&&y.arraysEqual(a,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let u=Ve(l),c=U2(r.shapeInfo.logicalShape,e.logicalShape),p=l-i,m,f=["x","y","z","w","u","v"];i===0?m="":l<2&&c.length>=1?m="coords = 0;":m=c.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let d="";return l<2&&i>0?d="coords":d=r.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${u} coords = getOutputCoords();
      ${m}
      return get${n}(${d});
    }
  `}function Ve(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function Tp(r,e){let t=JSON.parse(JSON.stringify(r));return t.shapeInfo.logicalShape=e,t}function Ap(r,e){return e.map(t=>r[t]).join(", ")}function X2(r,e,t,n){let o=e.userCode,s=t.map((f,d)=>{let h={logicalShape:f.shape,texShape:f.isUniform?null:f.texData.texShape,isUniform:f.isUniform,isPacked:f.isUniform?!1:f.texData.isPacked,flatOffset:null};return f.texData!=null&&f.texData.slice!=null&&f.texData.slice.flatOffset>0&&(h.flatOffset=f.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:h}}),a=s.map(f=>f.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},l=H2(s,i,o,e.packedInputs),u=r.createProgram(l),c=null,p=r.getUniformLocation(u,"NAN",!1);W().getNumber("WEBGL_VERSION")===1&&(c=r.getUniformLocation(u,"INFINITY",!1));let m={};for(let f=0;f<e.variableNames.length;f++){let d=e.variableNames[f],h=!1;m[d]=r.getUniformLocation(u,d,h),m[`offset${d}`]=r.getUniformLocation(u,`offset${d}`,h)}return{program:e,source:l,webGLProgram:u,uniformLocations:m,inShapeInfos:a,outShapeInfo:i,infLoc:c,nanLoc:p}}function Y2(r,e){if(r.length!==e.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${e.length} inputs`);r.forEach((t,n)=>{let o=t.logicalShape,s=e[n],a=s.shape;if(!y.arraysEqual(o,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${a} must match`);if(t.isUniform&&s.isUniform)return;let i=t.texShape,l=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(i,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${l} must match`)})}function Z2(r,e,t,n,o){Y2(e.inShapeInfos,t),Y2([e.outShapeInfo],[n]);let s=n.texData.texture,a=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s,a[0],a[1]):r.setOutputMatrixTexture(s,a[0],a[1]),r.setProgram(e.webGLProgram),W().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&r.gl.uniform1f(e.infLoc,Infinity),e.nanLoc!==null&&r.gl.uniform1f(e.nanLoc,NaN),t.forEach((i,l)=>{let u=e.program.variableNames[l],c=e.uniformLocations[u],p=e.uniformLocations[`offset${u}`];if(c!=null){if(i.isUniform){if(y.sizeFromShape(i.shape)<2)r.gl.uniform1f(c,i.uniformValues[0]);else{let m=i.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),r.gl.uniform1fv(c,m)}return}i.texData.slice!=null&&p!=null&&r.gl.uniform1i(p,i.texData.slice.flatOffset),r.setInputMatrixTexture(i.texData.texture,c,l)}}),o!=null&&o(r,e.webGLProgram),r.executeProgram()}function J2(r,e,t){let n="";e.concat(t).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0,l=a.isUniform?"uniform":a.texData.texShape;n+=`${a.shape}_${l}_${i}`});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o,s}var{addImpl:Q2,bincountImpl:lx,bincountReduceImpl:eD,ceilImpl:tD,concatImpl:rD,expImpl:nD,expm1Impl:oD,floorImpl:sD,gatherV2Impl:iD,greaterImpl:aD,lessImpl:lD,linSpaceImpl:uD,logImpl:cD,maxImpl:pD,maximumImpl:mD,minimumImpl:fD,multiplyImpl:dD,negImpl:hD,prodImpl:gD,rangeImpl:xD,rsqrtImpl:yD,simpleAbsImpl:ux,sliceImpl:bD,sparseReshapeImpl:wD,stridedSliceImpl:_D,subImpl:kD,tileImpl:vD,topKImpl:CD,transposeImpl:Fu,uniqueImpl:ID}=Wg;function Zk(r,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${r}.${t}`)}function Wt(r,e){return e===1?[r]:Zk(r,e)}function ND(r,e){if(r===1)return"rc";let t="";for(let n=0;n<r;n++)t+=e[n],n<r-1&&(t+=",");return t}var Jk=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;let t=e.length;if(t===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let n=Wt("rc",t),o=Ve(t),s=aX(t,e,n),a=lX(t,e[e.length-1],e[e.length-2],n),i=uX(e,n);this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}};function cX(r,e){let t=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let a=2;a<r;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}function aX(r,e,t){if(r===1)return`rc > ${e[0]}`;let n="";for(let o=r-2;o<r;o++)n+=`${t[o]} >= ${e[o]}`,o<r-1&&(n+="||");return n}function lX(r,e,t,n){if(r===1)return"";let o=n.slice(-2);return`
    int r = ${o[0]};
    int c = ${o[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${e};
    bool rEdge = rp1 >= ${t};
  `}function uX(r,e){let t=r.length,n=cX(t,e);return t===1?`getA(rc),
            rc + 1 >= ${r[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${n[0]}),
          cEdge ? 0. : getA(${n[1]}),
          rEdge ? 0. : getA(${n[2]}),
          rEdge || cEdge ? 0. : getA(${n[3]})`}var Rf=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2==1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${pX(t)}
      ${Ip(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${e[1]};
        int cols = ${e[2]};

        ${n}

        setOutput(result);
      }
    `}};function pX(r){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${Cs(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var Qk=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){let o=TD(t,n),s=AD(e,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=SD(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let l=this.freeTextures[s].shift();return this.usedTextures[s].push(l),l}let i;return o===Cr.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===Cr.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===Cr.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===Cr.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===Cr.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,o){if(this.freeTextures==null)return;let s=TD(n,o),a=AD(t,s,o);a in this.freeTextures||(this.freeTextures[a]=[]);let i=SD(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),l=W().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let u=this.usedTextures[a],c=u.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function mX(r,e){let t=r;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===r.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}function SD(r,e,t,n,o){let s=fX(e,n),a;if(o){let[l,u]=li(r[0],r[1]);a=l*u}else{let[l,u]=$u(r[0],r[1]);a=l*u}let i=mX(t,s);return a*i}function fX(r,e){switch(r){case Cr.PACKED_2X2_FLOAT32:return sx(e);case Cr.PACKED_2X2_FLOAT16:return ix(e);case Cr.UNPACKED_FLOAT32:return rx(e);case Cr.UNPACKED_FLOAT16:return nx(e);case Cr.PACKED_4X1_UNSIGNED_BYTE:return ox(e);default:throw new Error(`Unknown physical texture type ${r}`)}}function dX(r){return W().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Cr.PACKED_2X2_FLOAT32:Cr.UNPACKED_FLOAT32:r?Cr.PACKED_2X2_FLOAT16:Cr.UNPACKED_FLOAT16}function TD(r,e){if(r===Or.UPLOAD)return Cr.PACKED_2X2_FLOAT32;if(r===Or.RENDER||r==null)return dX(e);if(r===Or.DOWNLOAD||r===Or.PIXELS)return Cr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function AD(r,e,t){return`${r[0]}_${r[1]}_${e}_${t}`}var gn=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},br="if (isnan(x)) return x;",ED="return x;",ev="return abs(x);";var DD="return (x >= 0.0) ? x : (exp(x) - 1.0);",$D=br+`
  return (x < 0.0) ? 0.0 : x;
`,RD=br+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ff="return x;",FD="return 1.0 / (1.0 + exp(-1.0 * x));";var OD="return x;",PD=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,MD=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,LD=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zD="return 1.0 / (1.0 + exp(-1.0 * x));",Is=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var tv=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;let t=e.length,n=Wt("rc",t),o=Ve(t),s=ND(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}};var hX=Rr.whereImpl,gX=1e-7,xX=1e-4,cx={};function yX(r){return r in cx||(cx[r]={}),cx[r]}var bX=128,wX=600;function _X(){return W().global.screen==null?1024:W().global.screen.height*W().global.screen.width*window.devicePixelRatio*wX/1024/1024}var Ou=class extends Ps{constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!W().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){let t=Vn(W().getNumber("WEBGL_VERSION"));this.binaryCache=yX(W().getNumber("WEBGL_VERSION")),this.gpgpu=new ax(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new Qk(this.gpgpu),this.numMBBeforeWarning=_X(),this.texData=new qa(this,hs())}nextDataId(){return Ou.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((W().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||W().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:t,dtype:n,values:e,usage:Or.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,o,s){if(W().getBool("DEBUG")&&this.checkNumericalProblems(t),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:o,values:t,usage:Or.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:o,complexTensorInfos:s,slice:a,shape:i,isPacked:l}=t;if(a!=null){let m;l?m=new Is(i,Ff):m=new gn(i,Ff);let f=this.runWebGLProgram(m,[{dataId:e,shape:i,dtype:o}],o),d=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),d}if(n!=null)return this.convertAndCacheOnCPU(e);if(o==="string")return n;let u=this.activeTimers!=null,c;u&&(c=y.now());let p;if(o==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);p=C.mergeRealAndImagArrays(m,f)}else p=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=y.now()-c),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){let d=this.pendingRead.get(e);return new Promise(h=>d.push(h))}let t=this.texData.get(e),{values:n,shape:o,slice:s,dtype:a,complexTensorInfos:i,isPacked:l}=t;if(s!=null){let d;l?d=new Is(o,Ff):d=new gn(o,Ff);let h=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:a}],a),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(e);if(!W().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&W().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(a!=="complex64"&&W().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);let d=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(d.texture,...yl(o))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(a==="complex64"){let d=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),h=d[0],g=d[1];p=C.mergeRealAndImagArrays(h,g)}else if(u==null)p=this.getValuesFromTexture(e);else{let d=y.sizeFromShape(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(u,d)}c!=null&&this.disposeIntermediateTensorInfo(c);let m=this.convertAndCacheOnCPU(e,p),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(d=>d(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&hs().removeDataId(e,this),this.pendingDeletes--),m}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>y.decodeString(o))}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!lk(n))throw W().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:o}=this.texData.get(e),s=y.sizeFromShape(t);if(W().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(e),f=this.texData.get(m.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(f.texture,...yl(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),d}let a=W().getBool("WEBGL_PACK")&&o===!0,i=a?Df(t):t,l=a?new $k(i):new Dk(i),u=this.runWebGLProgram(l,[{shape:i,dtype:n,dataId:e}],"float32"),c=this.texData.get(u.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),p}timerAvailable(){return W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=y.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=y.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(s);i.kernelMs=y.sum(l),i.getExtraProfileInfo=()=>l.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(e){return W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=y.now(),e)}async getQueryTime(e){if(W().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:o,usage:s,isPacked:a,slice:i}=this.texData.get(e),l=i&&i.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(t,o,s,a)));let c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=bX){return W().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&y.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){C.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return hX(e.shape,t)}packedUnaryOp(e,t,n){let o=new Is(e.shape,t),s=this.compileAndRun(o,[e],n);return hs().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let o=ux(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(W().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ev,e.dtype);let t=new gn(e.shape,ev),n=this.compileAndRun(t,[e]);return hs().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&y.isString(n[0])){let s=n.map(a=>y.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:t}}makeOutput(e,t,n){let{dataId:o}=this.makeTensorInfo(e,t,n);return hs().makeTensorFromDataId(o,e,t,this)}unpackTensor(e){let t=new tv(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new Jk(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[Ea(e.shape),...Da(e.shape)],o={dtype:e.dtype,shape:n,dataId:e.dataId},s=[Ea(t),...Da(t)],a=new Rf(s,n),i=!0,l=this.runWebGLProgram(a,[o],e.dtype,null,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e){let t=this.texData.get(e),{isPacked:n,shape:o,dtype:s}=t,a=Df(o),i;n?i=new Ek(a):i=new Ak(a);let l=!0,u=this.runWebGLProgram(i,[{shape:a,dtype:s,dataId:e}],s,null,l);return{dtype:s,shape:o,dataId:u.dataId}}runWebGLProgram(e,t,n,o,s=!1){let a=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(a.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===xl.DENSE){let g=yl(e.outputShape);i.texShape=g.map(x=>x*2)}if(e.outTexUsage!=null&&(i.usage=e.outTexUsage),y.sizeFromShape(a.shape)===0)return i.values=y.getTypedArrayFromDType(a.dtype,0),a;let l=[],u=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(g.dataId);if(x.texture==null){if(!e.packedInputs&&y.sizeFromShape(g.shape)<=W().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=g.shape)}else if(!!x.isPacked!=!!e.packedInputs)g=x.isPacked?this.unpackTensor(g):this.packTensor(g),l.push(g),x=this.texData.get(g.dataId);else if(x.isPacked&&!bl(x.shape,g.shape)){let b=g,w=g.shape;g.shape=x.shape,g=this.packedReshape(g,w),l.push(g),x=this.texData.get(g.dataId),b.shape=w}return this.uploadToGPU(g.dataId),{shape:g.shape,texData:x,isUniform:!1}});this.uploadToGPU(a.dataId);let c={shape:a.shape,texData:i,isUniform:!1},p=J2(e,u,c),m=this.getAndSaveBinary(p,()=>X2(this.gpgpu,e,u,c)),f=this.activeTimers!=null,d;f&&(d=this.startTimer()),Z2(this.gpgpu,m,u,c,o),l.forEach(g=>this.disposeIntermediateTensorInfo(g)),f&&(d=this.endTimer(d),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(d)}));let h=W().get("WEBGL_FLUSH_THRESHOLD");if(h>0){let g=y.now();g-this.lastGlFlushTime>h&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!W().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&s===!1){let g=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),g}return a}compileAndRun(e,t,n,o,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,o,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(W().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=V(()=>{if(!W().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=W().getBool("DEBUG");W().set("DEBUG",!1);let t=this.abs(le(1e-8)).dataSync()[0];if(W().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?gX:xX}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:o,values:s,texture:a,usage:i,isPacked:l}=t;if(a!=null)return;let u=this.activeTimers!=null,c;u&&(c=y.now());let p=t.texShape;if(p==null&&(p=_k(n,l),t.texShape=p),s!=null){let m=Df(n),f,d=p[1],h=p[0],g=s instanceof Uint8Array;l?([d,h]=li(p[0],p[1]),f=new Fk(m,[h,d],g)):f=new Rk(m,[h,d],g);let x=this.makeTensorInfo([h,d],o);g?this.texData.get(x.dataId).usage=Or.PIXELS:this.texData.get(x.dataId).usage=Or.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),d,h,s);let b=!0,w=this.runWebGLProgram(f,[x],o,null,b),_=this.texData.get(w.dataId);t.texture=_.texture,t.texShape=_.texShape,t.isPacked=_.isPacked,t.usage=_.usage,this.disposeIntermediateTensorInfo(x),this.texData.delete(w.dataId),t.values=null,u&&(this.uploadWaitMs+=y.now()-c)}else{let m=this.acquireTexture(p,i,o,l);t.texture=m}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:o}=n;return this.releaseGPUData(e),t!=null&&(n.values=kX(t,o)),n.values}acquireTexture(e,t,n,o){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,o)}computeBytes(e,t){return e[0]*e[1]*y.bytesPerElement(t)}};Ou.nextDataId=0;function kX(r,e){if(e==="float32"||e==="complex64")return r;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<t.length;++n)t[n]=Math.round(r[n]);return t}else throw new Error(`Unknown dtype ${e}`)}var rv="3.5.0";function BD(){W().set("WEBGL_FORCE_F16_TEXTURES",!0)}Yl.isBrowser()&&Qc("webgl",()=>new Ou,2);var r7e={forceHalfFloat:BD};var px=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var co=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=C.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var wl=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Ns=class{constructor(e,t,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=C.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length,a="";if(o)if(s===0||y.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ve(s)} coords = getOutputCoords();
        `,s===1)a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let l=Wt("coords",s);a+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function jt(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var VD={kernelName:Xn,backendName:"webgl",kernelFunc:jt};function xn(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),a=t.texData.get(s.dataId),i=jt({inputs:{x:n},backend:t}),l=jt({inputs:{x:o},backend:t});return a.complexTensorInfos={real:i,imag:l},s}var GD={kernelName:bc,backendName:"webgl",kernelFunc:xn};var nv="return (a < 0.) ? b * a : a;",ov=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function vX(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,a=t.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),i=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ns(ov,o.shape,a.shape):new co(nv,o.shape,a.shape),l=t.runWebGLProgram(i,[o,a],o.dtype);return t.disposeIntermediateTensorInfo(a),l}var WD={kernelName:Mo,backendName:"webgl",kernelFunc:vX};var sv="return (a < 0.) ? b * a : a;",iv=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function CX(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ns(iv,n.shape,o.shape):new co(sv,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],n.dtype)}var jD={kernelName:Yo,backendName:"webgl",kernelFunc:CX};var mx="if (isnan(x)) return x;",UD=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,HD=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function _e({opSnippet:r,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:o,backend:s})=>{let{x:a}=o,i=s,l=n||a.dtype;if(i.shouldExecuteOnCPU([a])&&t!=null){let p=i.texData.get(a.dataId),m=t(p.values,l);return i.makeTensorInfo(a.shape,l,m)}let u=W().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,c;return u?c=new Is(a.shape,e):c=new gn(a.shape,r),i.runWebGLProgram(c,[a],l)}}function st({opSnippet:r,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:a,backend:i})=>{let{a:l,b:u}=a,c=i;if(n&&l.dtype==="complex64"){let d=c.texData.get(l.dataId),h=c.texData.get(u.dataId),[g,x]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(w=>{let[_,I]=w,E={dataId:_.dataId,dtype:_.dtype,shape:l.shape},$={dataId:I.dataId,dtype:I.dtype,shape:u.shape},D=new co(r,l.shape,u.shape);return c.runWebGLProgram(D,[E,$],ar(_.dtype,I.dtype))}),b=xn({inputs:{real:g,imag:x},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(x),b}let p=s||ar(l.dtype,u.dtype);if(c.shouldExecuteOnCPU([l,u])&&o!=null){let d=c.texData.get(l.dataId),h=c.texData.get(u.dataId),[g,x]=o(l.shape,u.shape,d.values,h.values,p),b=c.makeTensorInfo(x,p),w=c.texData.get(b.dataId);return w.values=g,b}let m=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,f;return m?f=new Ns(e,l.shape,u.shape,t):f=new co(r,l.shape,u.shape),c.runWebGLProgram(f,[l,u],p)}}function _l(r,e=!1){if(r==="linear")return e?OD:ED;if(r==="relu")return e?MD:$D;if(r==="elu")return e?PD:DD;if(r==="relu6")return e?LD:RD;if(r==="prelu")return e?iv:sv;if(r==="leakyrelu")return e?ov:nv;if(r==="sigmoid")return e?zD:FD;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var Of=class{constructor(e,t,n,o=!1,s=!1,a=!1,i=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;let c=o?e[1]:e[2],p=Math.ceil(c/2),m=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",d=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",x="";i&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,x="result = activation(result);");let b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let w="rc.x",_="rc.x";e[0]<t[0]?w=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(_=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}

      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${w};
          int batchB = ${_};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${x}

        setOutput(result);
      }
    `}};var av={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},fx=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=C.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var qD="return a * b;";function Pf(r){let{inputs:e,backend:t}=r,{a:n,b:o}=e,s=C.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let i=t.texData.get(n.dataId),l=t.texData.get(o.dataId),u=new fx(av.REAL,n.shape,o.shape),c=new fx(av.IMAG,n.shape,o.shape),p=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:n.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:o.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:o.shape}],m=t.runWebGLProgram(u,p,"float32"),f=t.runWebGLProgram(c,p,"float32"),d=xn({inputs:{real:m,imag:f},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}if(t.shouldExecuteOnCPU([n,o])){let i=t.texData.get(n.dataId),l=t.texData.get(o.dataId),[u,c]=dD(n.shape,o.shape,i.values,l.values,s),p=t.makeTensorInfo(c,s),m=t.texData.get(p.dataId);return m.values=u,p}let a;return W().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ns(qD,n.shape,o.shape):a=new co(qD,n.shape,o.shape),t.runWebGLProgram(a,[n,o],s)}var KD={kernelName:Ho,backendName:"webgl",kernelFunc:Pf};function XD(r,e,t){let n=[Ea(r.shape),...Da(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[Ea(e),...Da(e)],a=new Rf(s,n),i=!0,l=t.runWebGLProgram(a,[o],r.dtype,null,i);return{dataId:l.dataId,shape:e,dtype:l.dtype}}function ue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,a=t,i=y.sizeFromShape(o.shape),l=y.inferFromImplicitShape(s,i),u=y.sizeFromShape(l);y.assert(i===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let c=a.texData.get(o.dataId);return c.isPacked&&!bl(o.shape,l)&&!(c.texture!==null&&bl(c.shape,l))?XD(o,l,a):(a.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype})}var YD={kernelName:Hs,backendName:"webgl",kernelFunc:ue};var dx=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:a}=e;this.outputShape=[o,a];let i=Math.floor(n/4)*4,l=n%4,u="sumValue += dot(values, ones);";if(t!=null){let p=1/t;u=`sumValue += dot(values * ${y.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};var lv=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:a}=e;this.outputShape=[o,a];let i="0.0",l="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",l="min"):t==="max"&&(i="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let c=Math.floor(n/4)*4,p=n%4,m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
      }
    `,f="vec4";t==="all"?(i="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(i="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${u});
      }
    `}};function IX(r){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:r[1],n=C.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function An(r,e,t,n){let o=IX(r.shape),s=r;for(let a=0;a<o.length;a++){let{inSize:i,windowSize:l,outSize:u}=o[a],c,p;t==="mean"?c=a===0?new dx({windowSize:l,inSize:i,batchSize:r.shape[0],outSize:u},i):new dx({windowSize:l,inSize:i,batchSize:r.shape[0],outSize:u}):c=new lv({windowSize:l,inSize:i,batchSize:r.shape[0],outSize:u},t),p=s,s=n.runWebGLProgram(c,[s],e),p.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(p)}return s}var uv=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let o=Ve(this.rank),s=NX(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function NX(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let o=0;o<r.length;o++)n[r[o]]=t[o];return n.join()}var cv=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=Ve(this.rank),s=Zk("rc",this.rank),a=new Array(this.rank);for(let c=0;c<t.length;c++)a[t[c]]=s[c];let i=`vec2(${a.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function kl(r,e,t){let n=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cv(r.shape,e):new uv(r.shape,e);return t.runWebGLProgram(n,[r],r.dtype)}function ZD(r,e,t,n){let o=e,s=r.shape.length,a=y.parseAxisParam(o,r.shape),i=a,l=C.getAxesPermutation(i,s),u=l!=null,c=r;u&&(c=kl(r,l,n),i=C.getInnerMostAxes(i.length,s)),C.assertAxesAreInnerMostDims("sum",i,s);let[p,m]=C.computeOutAndReduceShapes(c.shape,i),f=p;t&&(f=C.expandShapeToKeepDim(p,a));let d=y.sizeFromShape(m),g=y.sizeFromShape(r.shape)/d,x=ue({inputs:{x:c},attrs:{shape:[g,d]},backend:n}),b=Kl(r.dtype),w=An(x,b,"sum",n),_=ue({inputs:{x:w},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),u&&n.disposeIntermediateTensorInfo(c),_}function Pu(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return ZD(o,s,a,t)}var JD={kernelName:is,backendName:"webgl",kernelFunc:Pu};function $t(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,a=t,i=o.shape.length,l=new Array(i);for(let c=0;c<l.length;c++)l[c]=o.shape[s[c]];let u;if(a.shouldExecuteOnCPU([o])){let p=a.texData.get(o.dataId).values,m=Fu(p,o.shape,o.dtype,s,l);u=a.makeTensorInfo(l,o.dtype);let f=a.texData.get(u.dataId);f.values=m}else u=kl(o,s,a);return u}var QD={kernelName:ms,backendName:"webgl",kernelFunc:$t};var pv=1e3;function Mu({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:l=null}){let u=r.shape.length,c=e.shape.length,p=t?r.shape[u-2]:r.shape[u-1],m=n?e.shape[c-1]:e.shape[c-2],f=t?r.shape[u-1]:r.shape[u-2],d=n?e.shape[c-2]:e.shape[c-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),x=y.sizeFromShape(h),b=y.sizeFromShape(g),w=x===b||x===1||b===1;y.assert(u>=2&&c>=2&&w,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${g}).`);let I=(x>b?r.shape.slice(0,-2):e.shape.slice(0,-2)).concat([f,d]);y.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let E=t?[x,p,f]:[x,f,p],$=n?[b,d,m]:[b,m,d],D=ue({inputs:{x:r},backend:o,attrs:{shape:E}}),O=ue({inputs:{x:e},backend:o,attrs:{shape:$}}),M=[D,O],G=Math.max(x,b),j=t?D.shape[1]:D.shape[2],U=s!=null,H=a!=null,q=l==="leakyrelu",X=l!=null?_l(l,!0):null,ne=U||H||q||X!=null,Y;if((f===1||d===1)&&j>pv&&ne===!1){let Q=D,ie=O;t&&(Q=$t({inputs:{x:D},backend:o,attrs:{perm:[0,2,1]}}),M.push(Q)),n&&(ie=$t({inputs:{x:O},backend:o,attrs:{perm:[0,2,1]}}),M.push(ie));let ce=d!==1,ae=d===1,fe=Q;ce&&(fe=ue({inputs:{x:Q},backend:o,attrs:{shape:[G,j,1]}}),M.push(fe));let de=d===1?2:1,xe=ie;ae&&(xe=ue({inputs:{x:ie},backend:o,attrs:{shape:[G,1,j]}}),M.push(xe));let we=Pf({inputs:{a:fe,b:xe},backend:o});Y=Pu({inputs:{x:we},backend:o,attrs:{axis:de,keepDims:!0}}),M.push(we)}else{let Q=ar(r.dtype,e.dtype),ie=new Of(E,$,[G,f,d],t,n,U,X,H,q),ce=[D,O];if(s!=null&&ce.push(s),H&&ce.push(a),q){let ae=o.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));ce.push(ae),M.push(ae)}Y=o.runWebGLProgram(ie,ce,Q)}let re=ue({inputs:{x:Y},backend:o,attrs:{shape:I}});M.push(Y);for(let Q of M)o.disposeIntermediateTensorInfo(Q);return re}function SX(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=n;return Mu({a:o,b:s,transposeA:l,transposeB:u,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:p,activation:c})}var e$={kernelName:Js,backendName:"webgl",kernelFunc:SX};var t$="return abs(x);";function TX(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=t.texData.get(n.dataId),a=ux(s.values);return t.makeTensorInfo(n.shape,n.dtype,a)}let o;return W().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Is(n.shape,t$):o=new gn(n.shape,t$),t.runWebGLProgram(o,[n],n.dtype)}var r$={kernelName:zs,backendName:"webgl",kernelFunc:TX};var AX=br+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,EX=_e({opSnippet:AX}),n$={kernelName:_i,backendName:"webgl",kernelFunc:EX};var DX=br+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,$X=_e({opSnippet:DX}),o$={kernelName:ki,backendName:"webgl",kernelFunc:$X};var s$="return a + b;",RX=st({opSnippet:s$,packedOpSnippet:s$,supportsComplex:!0,cpuKernelImpl:Q2}),i$={kernelName:On,backendName:"webgl",kernelFunc:RX};var mv=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var fv=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function hx(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return jt({inputs:{x:n[0]},backend:t});if(n.length>W().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(n.length/2),u=hx({inputs:n.slice(0,l),backend:t}),c=hx({inputs:n.slice(l),backend:t});return hx({inputs:[u,c],backend:t})}let o=n.map(l=>l.dtype).reduce((l,u)=>ar(l,u)),s=n.map(l=>l.shape),i=W().getBool("WEBGL_PACK")?new fv(n[0].shape,s):new mv(n[0].shape,s);return t.runWebGLProgram(i,n,o)}var a$={kernelName:_o,backendName:"webgl",kernelFunc:hx};function FX(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,l=y.parseAxisParam(s,o.shape),u=l,c=C.getAxesPermutation(u,i),p=o;c!=null&&(p=$t({inputs:{x:o},backend:t,attrs:{perm:c}}),u=C.getInnerMostAxes(u.length,i)),C.assertAxesAreInnerMostDims("all",u,i);let[m,f]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(f),h=ue({inputs:{x:p},backend:t,attrs:{shape:[-1,d]}}),g=An(h,h.dtype,"all",t),x;if(a){let b=C.expandShapeToKeepDim(m,l);x=ue({inputs:{x:g},backend:t,attrs:{shape:b}})}else x=ue({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),x}var l$={kernelName:vi,backendName:"webgl",kernelFunc:FX};function OX(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,l=y.parseAxisParam(s,o.shape),u=l,c=C.getAxesPermutation(u,i),p=o;c!=null&&(p=$t({inputs:{x:o},backend:t,attrs:{perm:c}}),u=C.getInnerMostAxes(u.length,i)),C.assertAxesAreInnerMostDims("any",u,i);let[m,f]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(f),h=ue({inputs:{x:p},backend:t,attrs:{shape:[-1,d]}}),g=An(h,h.dtype,"any",t),x;if(a){let b=C.expandShapeToKeepDim(m,l);x=ue({inputs:{x:g},backend:t,attrs:{shape:b}})}else x=ue({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),x}var u$={kernelName:Ci,backendName:"webgl",kernelFunc:OX};var dv=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",l=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var hv=class{constructor(e,t,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,y.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),o||this.variableNames.push("bestIndicesA");let i=this.outputShape,l=i.length,u=Ve(l),c=Wt("coords",l),p,m;if(a===1){m=l+1;let D=Ve(m);p=`
        ${D} sourceLocR = ${D}(${c.join()}, 0);
        ++${c[l-1]};
        ${D} sourceLocG = ${D}(${c.join()}, 0);
        ++${c[l-2]};
        ${D} sourceLocA = ${D}(${c.join()}, 0);
        --${c[l-1]};
        ${D} sourceLocB = ${D}(${c.join()}, 0);
        --${c[l-2]};`}else m=l,p=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),d="."+f[m-1],h=f.map(D=>"int "+D),g=Wt("sourceLocR",m-1).concat("inIdx.r"),x=Wt("sourceLocG",m-1).concat("inIdx.g"),b=Wt("sourceLocB",m-1).concat("inIdx.b"),w=Wt("sourceLocA",m-1).concat("inIdx.a"),_=n==="max"?"greaterThan":"lessThan",I=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()})));`,E=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,$=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${$}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${i[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${i[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${_}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function c$(r,e,t,n=null){let o=e.shape[0],s=e.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let a=C.computeOptimalWindowSize(s),i={windowSize:a,inSize:s,batchSize:o,outSize:Math.ceil(s/a)},l=new dv(i,t,n==null),u=[e];n!=null&&u.push(n);let c=r.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let p=c$(r,e,t,c);return r.disposeIntermediateTensorInfo(c),p}function p$(r,e,t,n=null){let o=n!=null?n.shape:e.shape,s=o[o.length-1],a=C.computeOptimalWindowSize(s),i=new hv(o,a,t,n==null),l=n==null?[e]:[e,n],u=r.runWebGLProgram(i,l,"int32");if(u.shape.length===e.shape.length){let c=p$(r,e,t,u);return r.disposeIntermediateTensorInfo(u),c}return u}function gx(r,e,t,n){let o=[t];if(C.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,e.shape.length),!W().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],[a,i]=C.computeOutAndReduceShapes(e.shape,o),l=y.sizeFromShape(i),u=ue({inputs:{x:e},backend:r,attrs:{shape:[-1,l]}});s.push(u);let c=c$(r,u,n);s.push(c);let p=ue({inputs:{x:c},backend:r,attrs:{shape:a}});return s.forEach(m=>r.disposeIntermediateTensorInfo(m)),p}return p$(r,e,n)}function PX(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),l=o,u=[];i!=null&&(l=$t({inputs:{x:o},backend:t,attrs:{perm:i}}),u.push(l),a=C.getInnerMostAxes(a.length,l.shape.length)),C.assertAxesAreInnerMostDims("argMax",[a[0]],l.shape.length);let c=gx(t,l,a[0],"max");return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),c}var m$={kernelName:ko,backendName:"webgl",kernelFunc:PX};function MX(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),l=o,u=[];i!=null&&(l=$t({inputs:{x:o},backend:t,attrs:{perm:i}}),u.push(l),a=C.getInnerMostAxes(a.length,l.shape.length)),C.assertAxesAreInnerMostDims("argMin",[a[0]],l.shape.length);let c=gx(t,l,a[0],"min");return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),c}var f$={kernelName:Ka,backendName:"webgl",kernelFunc:MX};var LX=br+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,zX=_e({opSnippet:LX}),d$={kernelName:Ii,backendName:"webgl",kernelFunc:zX};var BX=br+"return log(x + sqrt(x * x + 1.0));",VX=_e({opSnippet:BX}),h$={kernelName:Ni,backendName:"webgl",kernelFunc:VX};var GX=br+`
  return atan(x);
`,WX=_e({opSnippet:GX}),g$={kernelName:Si,backendName:"webgl",kernelFunc:WX};var jX=UD+`
  return atan(a, b);
`,UX=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+HD+`
  return result;
`,HX=st({opSnippet:jX,packedOpSnippet:UX}),x$={kernelName:Ai,backendName:"webgl",kernelFunc:HX};var qX=br+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,KX=_e({opSnippet:qX}),y$={kernelName:Ti,backendName:"webgl",kernelFunc:KX};var ui=class{constructor(e,t,n,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,f=e.padInfo.top,d=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b="0.0";if(h||(b="-1.0 / 1e-20"),n){let D=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${l});
        const ivec2 pads = ivec2(${f}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:x:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",_=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / count");let I=Math.floor(a/4)*4,E=a%4,$=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${f}, ${d});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${$}
          }

          int xC = xCCorner + ${I};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${$}
          }
        }
        setOutput(${_});
      }
    `}},Lu=class{constructor(e,t,n,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,p=e.dilationHeight,m=e.dilationWidth,f=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,x=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let w=t==="avg",_="0.0";if(w||(_="-1.0 / 1e-20"),n){let M=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${l}, ${u});
        const ivec3 pads = ivec3(${g}, ${x}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${M} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let I="max",E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(E="avgValue / count");let $=Math.floor(a/4)*4,D=a%4,O=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${l}, ${u});
      const ivec3 pads = ivec3(${g}, ${x}, ${b});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${$}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${O}
            }

            int xC = xCCorner + ${$};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${O}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${O}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${O}
            }
          }
          setOutput(${E});
        }
      }
    `}};function XX(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;vs(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:l}=n,u=1;y.assert(C.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=C.computePool2DInfo(o.shape,s,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))return jt({inputs:{x:o},backend:t});let p=new ui(c,"avg",!1);return t.runWebGLProgram(p,[o],"float32")}var b$={kernelName:vo,backendName:"webgl",kernelFunc:XX};function YX(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=n,c=[1,1,1],p=C.computePool3DInfo(o.shape,s,a,c,i,l,u),m=new Lu(p,"avg",!1);return t.runWebGLProgram(m,[o],"float32")}var w$={kernelName:Xa,backendName:"webgl",kernelFunc:YX};var gv=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,p=u-1-e.padInfo.left,m=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},xv=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterDepth,m=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=p-1-e.padInfo.front,h=m-1-e.padInfo.top,g=f-1-e.padInfo.left,x=1/(t*n*o);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ZX(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=n,p=[1,1,1],m=C.computePool3DInfo(a.shape,i,l,p,u,c),f=new xv(m);return t.runWebGLProgram(f,[o],a.dtype)}var _$={kernelName:xc,backendName:"webgl",kernelFunc:ZX};function JX(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s;vs([o,s],"avgPoolGrad");let{filterSize:i,strides:l,pad:u}=n,c=C.computePool2DInfo(a.shape,i,l,1,u),p=new gv(c);return t.runWebGLProgram(p,[o],a.dtype)}var k$={kernelName:gc,backendName:"webgl",kernelFunc:JX};function QX(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;return Mu({a:o,b:s,transposeA:a,transposeB:i,backend:t})}var v$={kernelName:Co,backendName:"webgl",kernelFunc:QX};var yv=class{constructor(e,t,n,o,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(e,t),C.assertAndGetBroadcastShape(e,n);let i="0.0";o!=null&&(C.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="1.0";s!=null&&(C.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var bv=class{constructor(e,t,n,o,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(e,t),C.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";o!=null&&(C.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(C.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var e7=({inputs:r,backend:e,attrs:t})=>{let{x:n,mean:o,variance:s,offset:a,scale:i}=r;y.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);let u=[n,o,s],c=null;a!=null&&(c=a.shape,u.push(a));let p=null;i!=null&&(p=i.shape,u.push(i));let m=W().getBool("WEBGL_PACK_NORMALIZATION")?new bv(n.shape,o.shape,s.shape,c,p,l):new yv(n.shape,o.shape,s.shape,c,p,l);return e.runWebGLProgram(m,u,u[0].dtype)},C$={kernelName:Oo,backendName:"webgl",kernelFunc:e7};var wv=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Ve(this.rank),n=`uniform int start[${this.rank}];`,o=t7(this.rank),s,a=e.map((i,l)=>`sourceLoc.${_v[l]} = start[${l}] + coords.${_v[l]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      ${n}
      void main() {
        ${s}
        setOutput(getSource(${o}));
      }
    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{this.startLoc==null&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),this.startLoc==null)||t.gl.uniform1iv(this.startLoc,e)}}},_v=["x","y","z","w","u","v"];function t7(r){if(r===1)return"sourceLoc";if(r<=6)return _v.slice(0,r).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var kv=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;let t=Ve(this.rank),n=Wt("coords",this.rank),o=Wt("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,a=`getChannel(getSource(${o.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${a};
        --${o[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,p)=>`start[${p}]`).join()});`:e.map((c,p)=>`${o[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      uniform int start[${this.rank}];
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i}
        ${l}
        setOutput(result);
      }
    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{this.startLoc==null&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),this.startLoc==null)||t.gl.uniform1iv(this.startLoc,e)}}};function r7(r,e,t,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(t,r.dtype),a=n.texData.get(s.dataId);Object.assign(a,o),a.refCount=1,a.shape=t,a.dtype=r.dtype;let i=rr.computeFlatOffset(e,y.computeStrides(r.shape));o.slice&&(i+=o.slice.flatOffset),a.slice={flatOffset:i,origDataId:o.slice&&o.slice.origDataId||r.dataId};let l=n.dataRefCount.get(a.slice.origDataId)||1;return n.dataRefCount.set(a.slice.origDataId,l+1),s}function $a(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n,[i,l]=rr.parseSliceParams(o,s,a);if(rr.assertParamsValid(o,i,l),y.sizeFromShape(l)===0)return t.makeTensorInfo(l,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=t.texData.get(o.dataId),m=bD(p.values,i,l,o.shape,o.dtype);return t.makeTensorInfo(l,o.dtype,m)}let{isPacked:u}=t.texData.get(o.dataId),c=rr.isSliceContinous(o.shape,i,l);if(u||!c){let p=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kv(l):new wv(l),m=p.getCustomSetupFunc(i);return t.runWebGLProgram(p,[o],o.dtype,m)}return t.uploadToGPU(o.dataId),r7(o,i,l,t)}var I$={kernelName:Ks,backendName:"webgl",kernelFunc:$a};var n7=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((b,w)=>b*w),l=C.getReshaped(o.shape,s,i),u=C.getPermuted(l.length,s.length),c=C.getReshapedPermuted(o.shape,s,i),p=C.getSliceBeginCoords(a,s.length),m=C.getSliceSize(c,a,s.length),f=[],d=ue({inputs:{x:o},backend:t,attrs:{shape:l}}),h=$t({inputs:{x:d},backend:t,attrs:{perm:u}}),g=ue({inputs:{x:h},backend:t,attrs:{shape:c}}),x=$a({inputs:{x:g},backend:t,attrs:{begin:p,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),x},N$={kernelName:Ya,backendName:"webgl",kernelFunc:n7};function o7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=t.readSync(o.dataId),l=t.readSync(s.dataId),u=lx(i,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,u)}var S$={kernelName:yc,backendName:"webgl",kernelFunc:o7};var s7="return float(a != b);",vv=st({opSnippet:s7,dtype:"bool"}),T$={kernelName:Ki,backendName:"webgl",kernelFunc:vv};function Ra(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return jt({inputs:{x:o.complexTensorInfos.real},backend:t})}var A$={kernelName:Lc,backendName:"webgl",kernelFunc:Ra};var i7="return float(int(x));";function E$(r,e){let t=new gn(r.shape,i7),n=e.runWebGLProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function Cv(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return jt({inputs:{x:o},backend:t});let a=ht(o.shape),i=Cv({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),l=xn({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(i),l}if(o.dtype==="complex64"){let a=Ra({inputs:{input:o},backend:t}),i=Cv({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(a),i}if(!y.hasEncodingLoss(o.dtype,s)){let a=jt({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(s==="int32")return E$(o,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),l=vv({inputs:{a:o,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var D$={kernelName:qn,backendName:"webgl",kernelFunc:Cv};var $$="return ceil(x);",a7=_e({opSnippet:$$,packedOpSnippet:$$,cpuKernelImpl:tD}),R$={kernelName:Io,backendName:"webgl",kernelFunc:a7};var Iv=class{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}getCustomSetupFunc(e,t){return(n,o)=>{this.minLoc==null&&(this.minLoc=n.getUniformLocationNoThrow(o,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(o,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}};var Nv=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}getCustomSetupFunc(e,t){return(n,o)=>{this.minLoc==null&&(this.minLoc=n.getUniformLocationNoThrow(o,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(o,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}};function l7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i;W().getBool("WEBGL_PACK_CLIP")?i=new Nv(o.shape):i=new Iv(o.shape);let l=i.getCustomSetupFunc(s,a);return t.runWebGLProgram(i,[o],o.dtype,l)}var F$={kernelName:Kn,backendName:"webgl",kernelFunc:l7};var Sv=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function O$(r,e){return{dataId:e.dataId,dtype:e.dtype,shape:r.shape}}function u7(r){let{inputs:e,backend:t}=r,{x:n}=e,o=t.texData.get(n.dataId),s=new Sv(n.shape),a=[O$(n,o.complexTensorInfos.real),O$(n,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,a,a[0].dtype)}var P$={kernelName:Za,backendName:"webgl",kernelFunc:u7};var Tv=class{constructor(e){this.outputShape=[],this.outputShape=C.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let o=t.length,s=t[t.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var Av=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=C.computeOutShape(e,t);let n=this.outputShape,o=n.length,s=Ve(o),a=Wt("coords",o),i=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((h,g)=>`T${g}`);let l=new Array(e.length-1);l[0]=e[0][t];for(let h=1;h<l.length;h++)l[h]=l[h-1]+e[h][t];let u=i[t],c=i.slice(-2),p=i.join(),m=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let h=1;h<l.length;h++){let g=l[h-1];m+=`
        if (${u} < ${l[h]}  && ${u} >= ${l[h-1]}) {
          return getChannel(
            getT${h}(${xx(i,u,g)}),
            vec2(${xx(c,u,g)}));
        }`}let f=l.length,d=l[l.length-1];m+=`
        return getChannel(
          getT${f}(${xx(i,u,d)}),
          vec2(${xx(c,u,d)}));`,this.userCode=`
      float getValue(${i.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[o-1]} = ${a[o-1]} + 1;
        if (${a[o-1]} < ${n[o-1]}) {
          result.g = getValue(${a});
        }

        ${a[o-2]} = ${a[o-2]} + 1;
        if (${a[o-2]} < ${n[o-2]}) {
          result.a = getValue(${a});
        }

        ${a[o-1]} = ${a[o-1]} - 1;
        if (${a[o-2]} < ${n[o-2]} &&
            ${a[o-1]} < ${n[o-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function xx(r,e,t){let n=r.indexOf(e);return r.map((s,a)=>a===n?`${s} - ${t}`:s).join()}function zu(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return jt({inputs:{x:o.complexTensorInfos.imag},backend:t})}var M$={kernelName:Dc,backendName:"webgl",kernelFunc:zu};function Bu(r,e,t){let n=r[0].dtype;if(n==="complex64"){let c=r.map(h=>Ra({inputs:{input:h},backend:t})),p=r.map(h=>zu({inputs:{input:h},backend:t})),m=Bu(c,e,t),f=Bu(p,e,t),d=xn({inputs:{real:m,imag:f},backend:t});return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),p.forEach(h=>t.disposeIntermediateTensorInfo(h)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let c=r.map(x=>{let b=y.sizeFromShape(x.shape.slice(e));return ue({inputs:{x},backend:t,attrs:{shape:[-1,b]}})}),p=c.map(x=>({vals:t.readSync(x.dataId),shape:x.shape})),m=C.computeOutShape(c.map(x=>x.shape),1),f=c[0].shape[0]===1,d=rD(p,m,n,f),h=C.computeOutShape(r.map(x=>x.shape),e),g=t.makeTensorInfo(h,n,d);return c.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}if(r.length>W().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(r.length/2),p=Bu(r.slice(0,c),e,t),m=Bu(r.slice(c),e,t),f=Bu([p,m],e,t);return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),f}if(W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let c=new Av(r.map(p=>p.shape),e);return t.runWebGLProgram(c,r,n)}let{tensors2D:s,outShape:a}=c7(r,e,t),i=new Tv(s.map(c=>c.shape)),l=t.runWebGLProgram(i,s,n);s.forEach(c=>t.disposeIntermediateTensorInfo(c));let u=ue({inputs:{x:l},attrs:{shape:a},backend:t});return t.disposeIntermediateTensorInfo(l),u}function c7(r,e,t){let n=C.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>ue({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:n}}function Ev(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,e[0].shape)[0],a=C.computeOutShape(e.map(u=>u.shape),s);if(y.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let i=e.filter(u=>y.sizeFromShape(u.shape)>0);if(i.length===1)return jt({inputs:{x:i[0]},backend:t});let l=i.map(u=>u.shape);return C.assertParamsConsistent(l,s),Bu(i,s,t)}var L$={kernelName:Bs,backendName:"webgl",kernelFunc:Ev};var Mf=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,p=e.dilationWidth,m=e.filterHeight,f=e.filterWidth,d=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",x=g?1:2,b=g?2:3,w=g?3:1,_="",I="";n&&(o?_=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?_=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:_=`
          float activation(float x) {
            ${n}
          }
        `,I="result = activation(result);");let E=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${_}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${I}
        setOutput(result);
      }
    `}},Dv=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,o=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,p=e.filterDepth,m=e.filterHeight,f=e.filterWidth,d=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var $v=class{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let{filterWidth:o,inChannels:s,strideWidth:a,strideHeight:i,padInfo:l,outWidth:u,dilationWidth:c,dilationHeight:p,dataFormat:m}=n,{left:f,top:d}=l,h=s*o,g=Ot(),x=m==="channelsLast",b=x?0:1,w=x?1:2,_="";for(let I=0;I<=1;I++)for(let E=0;E<=1;E++)_+=`
          blockIndex = rc.y + ${E};
          pos = rc.x + ${I};

          if(blockIndex < ${e[1]} && pos < ${e[0]}) {
            offsetY = int(blockIndex / (${u})) * ${i} - ${d};
            d0 = offsetY + ${p} * (pos / ${h});

            if(d0 < ${t[b]} && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ${u}.) * ${a}. - ${f}.);
              d1 = offsetX + ${c} * (int(mod(float(pos), ${h}.) / ${s}.));

              if(d1 < ${t[w]} && d1 >= 0) {

                ch = int(mod(float(pos), ${s}.));

                if (${x}) {
                  innerDims = vec2(d1, ch);
                  result[${I*2+E}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${I*2+E}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${_}

        ${g.output} = result;
      }
    `}};function yx({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let l=r.shape,u=n.texData.get(r.dataId),c=t.inChannels,p=l[0]*l[1]*l[2],m=t.outChannels,f=t.dataFormat==="channelsLast",d=!1,h=!1,g,x=[],b=(p===1||m===1)&&c>pv,w=l[2]%2!=0&&!!u.isPacked;if(b||!W().getBool("WEBGL_LAZILY_UNPACK")||!W().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!w){let _=f?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],I=ue({inputs:{x:r},backend:n,attrs:{shape:[1,_,t.inChannels]}}),E=ue({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),$=Mu({a:I,b:E,transposeA:d,transposeB:h,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a});g=ue({inputs:{x:$},backend:n,attrs:{shape:t.outShape}}),x.push(I),x.push(E),x.push($)}else{let _=f?l[0]*l[1]*(l[2]+1):l[0]*l[2]*(l[3]+1),I={dataId:r.dataId,shape:[1,_,t.inChannels],dtype:r.dtype},E=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,y.assert(bl(u.shape,I.shape),()=>`packed reshape ${u.shape} to ${I.shape} isn't free`);let $=ue({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});x.push($);let D=Mu({a:I,b:$,backend:n,transposeA:d,transposeB:h,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),O=n.texData.get(D.dataId);y.assert(O.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=E,O.shape=t.outShape,g=jt({inputs:{x:D},backend:n}),g.shape=t.outShape,x.push(D)}for(let _ of x)n.disposeIntermediateTensorInfo(_);return g}function bx({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:p,outHeight:m,dataFormat:f}=t,d=f==="channelsLast",h=l*u*c,g=m*p,x=[h,g],b=!0,w=!1,_=[],I=ue({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),E=ue({inputs:{x:e},backend:n,attrs:{shape:[1,h,y.sizeFromShape(e.shape)/h]}});_.push(I),_.push(E);let $=new $v(x,I.shape,t),D=n.runWebGLProgram($,[I],"float32"),O=ue({inputs:{x:D},backend:n,attrs:{shape:[1,x[0],x[1]]}});_.push(D),_.push(O);let M=o!=null,G=s!=null,j=i==="leakyrelu",U=i?_l(i,!0):null,H=new Of(O.shape,E.shape,[1,g,t.outChannels],b,w,M,U,G,j),q=[O,E];if(o&&q.push(o),G&&q.push(s),j){let re=n.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));q.push(re),_.push(re)}let X=n.runWebGLProgram(H,q,"float32"),ne=d?[1,m,p,t.outChannels]:[1,t.outChannels,m,p],Y=ue({inputs:{x:X},backend:n,attrs:{shape:ne}});_.push(X);for(let re of _)n.disposeIntermediateTensorInfo(re);return Y}function p7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=n,p=C.convertConv2DDataFormat(l),m=C.computeConv2DInfo(o.shape,s.shape,a,u,i,c,!1,p),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=yx({x:o,filter:s,convInfo:m,backend:t});else if(W().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)f=bx({x:o,filter:s,convInfo:m,backend:t});else{let h=new Mf(m);f=t.runWebGLProgram(h,[o,s],"float32")}let d=ue({inputs:{x:f},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(f),d}var z$={kernelName:No,backendName:"webgl",kernelFunc:p7};var Rv=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Fv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,l=n-1-e.padInfo.left,u=a?1:2,c=a?2:3,p=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ov=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Pv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=t-1-e.padInfo.front,u=n-1-e.padInfo.top,c=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function m7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=n,p=C.convertConv2DDataFormat(l),m=C.computeConv2DInfo(o.shape,c,a,1,i,u,!1,p),f=new Rv(m);return t.runWebGLProgram(f,[o,s],"float32")}var B$={kernelName:wc,backendName:"webgl",kernelFunc:m7};function f7(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=n,p=C.convertConv2DDataFormat(u),m=C.computeConv2DInfo(a,s.shape,i,1,l,c,!1,p),f=new Fv(m);return t.runWebGLProgram(f,[o,s],"float32")}var V$={kernelName:So,backendName:"webgl",kernelFunc:f7};function d7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:l}=n,u=C.computeConv3DInfo(o.shape,s.shape,a,l,i),c=new Dv(u);return t.runWebGLProgram(c,[o,s],"float32")}var G$={kernelName:Ja,backendName:"webgl",kernelFunc:d7};function h7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,filterShape:l}=n,u=C.computeConv3DInfo(o.shape,l,a,1,i),c=new Ov(u);return t.runWebGLProgram(c,[o,s],"float32")}var W$={kernelName:_c,backendName:"webgl",kernelFunc:h7};function g7(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:a,strides:i,inputShape:l}=n,u=C.computeConv3DInfo(l,s.shape,i,1,a),c=new Pv(u);return t.runWebGLProgram(c,[o,s],"float32")}var j$={kernelName:kc,backendName:"webgl",kernelFunc:g7};var x7=mx+`
  return cos(x);
`,y7=_e({opSnippet:x7}),U$={kernelName:To,backendName:"webgl",kernelFunc:y7};var b7=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,w7=_e({opSnippet:b7}),H$={kernelName:Ei,backendName:"webgl",kernelFunc:w7};var Mv=class{constructor(e,t,n,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,i,l,u]=e,[c]=t,[p,m]=n;this.outputShape=[c,p,m,u];let f=o==="bilinear"?1:0,[d,h]=[`${i-1}.0`,`${l-1}.0`],[g,x,b]=p>1?[`${(i-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[w,_,I]=m>1?[`${(l-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${_};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var _7=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:l,extrapolationValue:u}=n,c=new Mv(o.shape,s.shape,i,l,u);return t.runWebGLProgram(c,[o,s,a],"float32")},q$={kernelName:Di,backendName:"webgl",kernelFunc:_7};var wx=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;let o=e.length,s=t?"0.0":`getX(${K$(o,"coords")})`,a=e[e.length-1],i="",l="";t?(i=n?`end != ${a-1}`:"end != 0",l=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${a}`:"end >= pow2",l=n?"end + pow2":"end - pow2"),this.userCode=`
      uniform float index;
      void main() {
        ${Ve(o)} coords = getOutputCoords();
        int end = ${X$(o,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${i}) {
          int idx = ${l};
          ${X$(o,"coords")} = idx;
          val += getX(${K$(o,"coords")});
        }
        setOutput(val);
      }
    `}getCustomSetupFunc(e){return(t,n)=>{this.index==null&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}};function K$(r,e){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function X$(r,e){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function k7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n,l=o.shape.length,u=C.getAxesPermutation([s],l),c=o;u!=null&&(c=$t({inputs:{x:o},backend:t,attrs:{perm:u}}));let p=C.getInnerMostAxes(1,l)[0];if(p!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);let m=c.shape[p],f=jt({inputs:{x:c},backend:t});for(let d=0;d<=Math.ceil(Math.log2(m))-1;d++){let h=new wx(c.shape,!1,i),g=h.getCustomSetupFunc(d),x=f;f=t.runWebGLProgram(h,[f],f.dtype,g),t.disposeIntermediateTensorInfo(x)}if(a){let d=new wx(c.shape,a,i),h=f;f=t.runWebGLProgram(d,[f],f.dtype),t.disposeIntermediateTensorInfo(h)}if(u!=null){let d=C.getUndoAxesPermutation(u),h=$t({inputs:{x:f},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(c),h}return f}var Y$={kernelName:Ao,backendName:"webgl",kernelFunc:k7};function v7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let l=t.readSync(o.dataId),u=t.readSync(s.dataId),c=lx(l,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,c)}else if(o.shape.length===2){let l=t.bufferSync(o),u=t.bufferSync(s),c=eD(l,u,a,i);return t.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var Z$={kernelName:vc,backendName:"webgl",kernelFunc:v7};var Lv=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function C7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n;y.assert(s>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`);let i=o.shape[0],l=a==="NHWC"?o.shape[1]:o.shape[2],u=a==="NHWC"?o.shape[2]:o.shape[3],c=a==="NHWC"?o.shape[3]:o.shape[1],p=l*s,m=u*s,f=c/(s*s),d=a==="NHWC"?[i,p,m,f]:[i,f,p,m],h=new Lv(d,s,a);return t.runWebGLProgram(h,[o],o.dtype)}var J$={kernelName:$i,backendName:"webgl",kernelFunc:C7};var Lf=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.inHeight,i=e.inWidth,l=e.padInfo.top,u=e.padInfo.left,c=e.strideHeight,p=e.strideWidth,m=e.dilationHeight,f=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,g=e.outChannels/e.inChannels,x="",b="";n&&(o?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,b="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${c}, ${p});
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${g};
        int q = d2 - d1 * ${g};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${m};

          if (xR < 0 || xR >= ${a}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${i}) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${w}
        ${b}
        setOutput(result);
      }
    `}};var zf=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;let a=e.outChannels/e.inChannels,i=e.inHeight,l=e.inWidth,u=e.padInfo.top,c=e.padInfo.left,p=e.strideHeight,m=e.strideWidth,f=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,g=e.filterWidth,x=g,b=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let E=0;E<g;E++)b+=`
          vec4 xTexelC${E*2};
          vec4 xC${E};`;for(let E=0;E<h;E++){for(let $=0;$<g;$++)b+=`
          xTexelC${$*2} = vec4(0.0);
          xC${$} = vec4(0.0);`;b+=`
        xR = xRCorner + ${E*f};
        if (xR >=0 && xR < ${i}) {
      `;for(let $=0;$<x/2+1;$++){let D=$*2;if(b+=`
          xC = xCCorner + ${D*d};
          `,m===1){if(D<g&&(c%2==1?(b+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelC${D} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= ${l}) {
                    xTexelC${D}.zw = vec2(0.0);
                  }
                }
              `,d===1&&D>0?b+=`
                xC${D} = vec4(xTexelC${D-2}.zw, xTexelC${D}.xy);
                `:b+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < ${l}) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= ${l}) {
                      previous.zw = vec2(0.0);
                    }

                    xC${D} = vec4(previous.zw, xTexelC${D}.xy);
                  } else {
                    xC${D} = vec4(0.0, 0.0, xTexelC${D}.xy);
                  }
                  `):b+=`
                if (xC >= 0 && xC < ${l}) {
                  xTexelC${D} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= ${l}) {
                    xTexelC${D}.zw = vec2(0.0);
                  }
                }

                xC${D} = xTexelC${D};
                `,D+1<g)){let O=c%2==0?y.nearestLargerEven(d):d;d%2==0&&c%2==1||d%2!=0&&c%2!=1?(b+=`
                  xCOffset = xC + ${c%2} + ${O};

                  if (xCOffset >= 0 && xCOffset < ${l}) {
                    xTexelC${D+2} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= ${l}) {
                      xTexelC${D+2}.zw = vec2(0.0);
                    }
                  }
                  `,d>1&&(b+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < ${l}) {
                      xTexelC${D} = getX(batch, xR, xCOffset, d1);
                    }
                    `),b+=`
                  xC${D+1} = vec4(xTexelC${D}.zw, xTexelC${D+2}.xy);
                  `):O===1?b+=`
                    xC${D+1} = xTexelC${D};
                    `:b+=`
                    xCOffset = xC + ${O};

                    if (xCOffset >= 0 && xCOffset < ${l}) {
                      xTexelC${D+2} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= ${l}) {
                        xTexelC${D+2}.zw = vec2(0.0);
                      }
                    }

                    xC${D+1} = xTexelC${D+2};
                    `}}else D<g&&(c%2==1?(b+=`
                xCOffset = xC + 1 - ${m};
                if(xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelC${D} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= ${l}) {
                    xTexelC${D}.zw = vec2(0.0);
                  }
                }

                if(xC + 1 >= 0 && xC + 1 < ${l}) {
                  xTexelC${D+2} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= ${l}) {
                    xTexelC${D+2}.zw = vec2(0.0);
                  }
                }

                xC${D} = vec4(xTexelC${D}.zw, xTexelC${D+2}.zw);
              `,D+1<g&&(b+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + ${m};
                  if(xCOffset >= 0 && xCOffset < ${l}) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${D+1} = vec4(xTexelC${D+2}.xy, final.xy);
                `)):(b+=`
                if(xC >= 0 && xC < ${l}) {
                  xTexelC${D} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= ${l}) {
                    xTexelC${D}.zw = vec2(0.0);
                  }
                }

                xCOffset = xC + ${m};
                if(xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelC${D+2} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= ${l}) {
                    xTexelC${D+2}.zw = vec2(0.);
                  }
                }

                xC${D} = vec4(
                  xTexelC${D}.xy, xTexelC${D+2}.xy);
              `,D+1<g&&(b+=`
                  xC${D+1} = vec4(xTexelC${D}.zw, xTexelC${D+2}.zw);
                `)));D<g&&(b+=`
            wTexel = getW(${E}, ${D}, d1, q);
            dotProd += xC${D} * vec4(wTexel.xz, wTexel.xz);
          `,D+1<g&&(b+=`
              wTexel = getW(${E}, ${D+1}, d1, q);
              dotProd += xC${D+1} * vec4(wTexel.xz, wTexel.xz);
            `))}b+=`
        }
      `}let w="",_="";n&&(o?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:w=`vec4 activation(vec4 x) {
          ${n}
        }`,_="result = activation(result);");let I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${p}, ${m});
      const ivec2 pads = ivec2(${u}, ${c});

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${b}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${I}
        ${_}
        setOutput(result);
      }
    `}};function I7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=n,c=l;c==null&&(c=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let p=C.computeConv2DInfo(o.shape,s.shape,a,c,i,u,!0),m;return W().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?m=new zf(p):m=new Lf(p),t.runWebGLProgram(m,[o,s],"float32")}var Q$={kernelName:Eo,backendName:"webgl",kernelFunc:I7};var zv=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Bv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function N7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=n,p=C.computeConv2DInfo(o.shape,c,a,i,l,u,!0),m=new zv(p);return t.runWebGLProgram(m,[o,s],"float32")}var eR={kernelName:Cc,backendName:"webgl",kernelFunc:N7};function S7(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=n,p=C.computeConv2DInfo(c,s.shape,a,i,l,u,!0),m=new Bv(p);return t.runWebGLProgram(m,[o,s],"float32")}var tR={kernelName:Ic,backendName:"webgl",kernelFunc:S7};var Vv=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function T7(r){let{inputs:e,backend:t}=r,{x:n}=e,o=[...n.shape,...n.shape],s=y.sizeFromShape(n.shape),a=ue({inputs:{x:n},backend:t,attrs:{shape:[s]}}),i=new Vv(s),l=t.runWebGLProgram(i,[a],a.dtype),u=ue({inputs:{x:l},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}var rR={kernelName:Nc,backendName:"webgl",kernelFunc:T7};var Gv=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:o,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:p,left:m}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function A7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:l}=n,u=C.computeDilation2DInfo(o.shape,s.shape,a,i,"NHWC",l),c,p=new Gv(u);c=t.runWebGLProgram(p,[o,s],"float32");let m=ue({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),m}var nR={kernelName:Qa,backendName:"webgl",kernelFunc:A7};function E7(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:l}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,l,s);let{path:u,steps:c}=C.getEinsumComputePath(i,l),p=c.length,m=null,f=a.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:x,expandDims:b}=C.getEinsumPermutation(f,l[g]),w;C.isIdentityPermutation(x)?w=s[g]:(w=$t({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),d.push(w));let _=w.shape.slice();for(let I=0;I<b.length;++I)_.splice(b[I],0,1);y.arraysEqual(w.shape,_)||(w=ue({inputs:{x:w},backend:t,attrs:{shape:_}}),d.push(w)),m===null?m=w:(m=Pf({inputs:{a:w,b:m},backend:t}),d.push(m))}h<p-1&&(u[h]>=0&&(m=Pu({inputs:{x:m},backend:t,attrs:{axis:u[h]-(a.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var oR={kernelName:Sc,backendName:"webgl",kernelFunc:E7};var D7="return (x >= 0.0) ? x : (exp(x) - 1.0);",$7=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,R7=_e({opSnippet:D7,packedOpSnippet:$7}),sR={kernelName:Ri,backendName:"webgl",kernelFunc:R7};var F7="return (b >= 1.0) ? a : a * (b + 1.0);",O7=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,P7=r=>{let{inputs:e,backend:t}=r,{dy:n,y:o}=e,s=W().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ns(O7,n.shape,o.shape):new co(F7,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],n.dtype)},iR={kernelName:Tc,backendName:"webgl",kernelFunc:P7};var M7=`
  return vec4(equal(a, b));
`,L7="return float(a == b);",z7=st({opSnippet:L7,packedOpSnippet:M7,dtype:"bool"}),aR={kernelName:Oi,backendName:"webgl",kernelFunc:z7};var B7=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${C.ERF_P};
  float a1 = ${C.ERF_A1};
  float a2 = ${C.ERF_A2};
  float a3 = ${C.ERF_A3};
  float a4 = ${C.ERF_A4};
  float a5 = ${C.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,V7=_e({opSnippet:B7}),lR={kernelName:Fi,backendName:"webgl",kernelFunc:V7};var uR="return exp(x);",Wv=_e({opSnippet:uR,packedOpSnippet:uR,cpuKernelImpl:nD}),cR={kernelName:$o,backendName:"webgl",kernelFunc:Wv};function _x(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),l=o;return o<0&&(y.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),i.splice(l,0,1),ue({inputs:{x:s},backend:n,attrs:{shape:i}})}var pR={kernelName:Vs,backendName:"webgl",kernelFunc:_x};var mR="return exp(x) - 1.0;",G7=_e({opSnippet:mR,packedOpSnippet:mR,cpuKernelImpl:oD}),fR={kernelName:Pi,backendName:"webgl",kernelFunc:G7};var kx=class{constructor(e,t,n){this.variableNames=["real","imag"];let o=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${o}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function vx(r,e,t){let n=t.texData.get(r.dataId),o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=o/s,i=ue({inputs:{x:r},backend:t,attrs:{shape:[a,s]}}),l=i.shape,u=new kx("real",l,e),c=new kx("imag",l,e),p=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],m=t.runWebGLProgram(u,p,"float32"),f=t.runWebGLProgram(c,p,"float32"),d=xn({inputs:{real:m,imag:f},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f);let h=ue({inputs:{x:d},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(d),h}function W7(r){let{inputs:e,backend:t}=r,{input:n}=e;return vx(n,!1,t)}var dR={kernelName:Ac,backendName:"webgl",kernelFunc:W7};var jv=class{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}getCustomSetupFunc(e){return(t,n)=>{this.valueLoc==null&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}};function Bf(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||y.inferDtype(o),s==="string"){let a=y.getArrayFromDType(s,y.sizeFromShape(n));return a.fill(o),e.makeTensorInfo(n,s,a)}else{let a=new jv(n,o),i=a.getCustomSetupFunc(o);return e.runWebGLProgram(a,[],s,i)}}var hR={kernelName:el,backendName:"webgl",kernelFunc:Bf};var Uv=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var gR={kernelName:Mi,backendName:"webgl",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new Uv(t.shape);return n.runWebGLProgram(o,[t],t.dtype)}};var xR="return floor(x);",j7=_e({opSnippet:xR,packedOpSnippet:xR,cpuKernelImpl:sD}),yR={kernelName:Ro,backendName:"webgl",kernelFunc:j7};var U7=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,H7=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,q7=st({opSnippet:U7,packedOpSnippet:H7,dtype:"int32"}),bR={kernelName:Fo,backendName:"webgl",kernelFunc:q7};var Hv=class{constructor(e){this.variableNames=["A"];let t=Ot(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var qv=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Ot(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var wR={kernelName:Em,backendName:"webgl",kernelFunc:K7},Ep;function K7(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n,a=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[l,u]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[u,l],p=[u,l,s];(i||a)&&(Ep==null&&(Ep=document.createElement("canvas").getContext("2d")),Ep.canvas.width=l,Ep.canvas.height=u,Ep.drawImage(o,0,0,l,u),o=Ep.canvas);let m=t.makeTensorInfo(c,"int32");t.texData.get(m.dataId).usage=Or.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),o);let f=W().getBool("WEBGL_PACK")?new qv(p):new Hv(p),d=t.runWebGLProgram(f,[m],"int32");return t.disposeData(m.dataId),d}function X7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=C.convertConv2DDataFormat(c),g=C.computeConv2DInfo(o.shape,s.shape,l,p,u,m,!1,h),x,b=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=yx({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:d});else if(W().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)x=bx({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:d});else{let _=a!=null,I=i!=null,E=f==="leakyrelu",$=f?_l(f,!1):null,D=new Mf(g,_,$,I,E),O=[o,s];if(a&&O.push(a),i&&O.push(i),E){let M=t.makeTensorInfo([],"float32",y.createScalarValue(d,"float32"));O.push(M),b.push(M)}x=t.runWebGLProgram(D,O,"float32")}let w=ue({inputs:{x},backend:t,attrs:{shape:g.outShape}});return b.push(x),b.forEach(_=>t.disposeIntermediateTensorInfo(_)),w}var _R={kernelName:Qs,backendName:"webgl",kernelFunc:X7};function Y7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=n,d=[],h=c;h==null&&(h=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(l,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${h}'`);let g=C.computeConv2DInfo(o.shape,s.shape,l,h,u,p,!0),x=W().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=m?_l(m,x):null,w=[o,s],_=a!=null,I=i!=null,E=m==="leakyrelu";if(_&&w.push(a),I&&w.push(i),E){let O=t.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));w.push(O),d.push(O)}let $;x?$=new zf(g,_,b,I,E):$=new Lf(g,_,b,I,E);let D=t.runWebGLProgram($,w,"float32");return d.forEach(O=>t.disposeIntermediateTensorInfo(O)),D}var kR={kernelName:ei,backendName:"webgl",kernelFunc:Y7};var Kv=class{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;let o=Ve(t.length),s=Ve(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function Z7(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,a=s[s.length-1],[i,l,u,c]=C.prepareAndValidate(n,o),p=ue({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),m=ue({inputs:{x:n},backend:t,attrs:{shape:[y.sizeFromShape(n.shape)/u,u]}}),f=new Kv(a,c,[l,u]),d=t.runWebGLProgram(f,[m,p],m.dtype),h=ue({inputs:{x:d},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(d),h}var vR={kernelName:Li,backendName:"webgl",kernelFunc:Z7};var Xv=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Ve(this.rank),o=J7(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function J7(r,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("int(getIndices(resRC.x, resRC.z))"):n.push(`${t[o]}`);return n.join()}function Q7(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n,l=y.parseAxisParam(a,o.shape)[0],u=C.segment_util.collectGatherOpShapeInfo(o,s,l,i),c=y.sizeFromShape(s.shape),p=[],m=ue({inputs:{x:o},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=ue({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});p.push(m),p.push(f);let d=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let b=t.bufferSync(f),w=t.bufferSync(m),_=iD(w,b,d);return p.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.makeTensorInfo(u.outputShape,_.dtype,_.values)}let h=new Xv(m.shape,d),g=t.runWebGLProgram(h,[m,f],m.dtype);p.push(g);let x=ue({inputs:{x:g},backend:t,attrs:{shape:u.outputShape}});return p.forEach(b=>t.disposeIntermediateTensorInfo(b)),x}var CR={kernelName:Gs,backendName:"webgl",kernelFunc:Q7};var eY="return float(a > b);",tY=`
  return vec4(greaterThan(a, b));
`,rY=st({opSnippet:eY,packedOpSnippet:tY,cpuKernelImpl:aD,dtype:"bool"}),IR={kernelName:zi,backendName:"webgl",kernelFunc:rY};var nY="return float(a >= b);",oY=`
  return vec4(greaterThanEqual(a, b));
`,sY=st({opSnippet:nY,packedOpSnippet:oY,dtype:"bool"}),NR={kernelName:Po,backendName:"webgl",kernelFunc:sY};function iY(r){let{inputs:e,backend:t}=r,{input:n}=e;return vx(n,!0,t)}var SR={kernelName:Ec,backendName:"webgl",kernelFunc:iY};var aY="return float(!isnan(x) && !isinf(x));",lY=_e({opSnippet:aY,dtype:"bool"}),TR={kernelName:Bi,backendName:"webgl",kernelFunc:lY};var uY="return float(isinf(x));",cY=_e({opSnippet:uY,dtype:"bool"}),AR={kernelName:Vi,backendName:"webgl",kernelFunc:cY};var pY="return float(isnan(x));",mY=_e({opSnippet:pY,dtype:"bool"}),ER={kernelName:Gi,backendName:"webgl",kernelFunc:mY};var fY="return float(a < b);",dY=`
  return vec4(lessThan(a, b));
`,hY=st({opSnippet:fY,packedOpSnippet:dY,cpuKernelImpl:lD,dtype:"bool"}),DR={kernelName:Wi,backendName:"webgl",kernelFunc:hY};var gY="return float(a <= b);",xY=`
  return vec4(lessThanEqual(a, b));
`,yY=st({opSnippet:gY,packedOpSnippet:xY,dtype:"bool"}),$R={kernelName:ji,backendName:"webgl",kernelFunc:yY};function bY(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,a=uD(n,o,s);return e.makeTensorInfo([a.length],"float32",a)}var RR={kernelName:$c,backendName:"webgl",kernelFunc:bY};var wY=`if (x < 0.0) return NAN;
  return log(x);`,_Y=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,kY=_e({opSnippet:wY,packedOpSnippet:_Y,cpuKernelImpl:cD}),FR={kernelName:Lo,backendName:"webgl",kernelFunc:kY};var vY="return log(1.0 + x);",CY=_e({opSnippet:vY}),OR={kernelName:Ui,backendName:"webgl",kernelFunc:CY};var IY="return float(a >= 1.0 && b >= 1.0);",NY=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,SY=st({opSnippet:IY,packedOpSnippet:NY,dtype:"bool"}),PR={kernelName:Hi,backendName:"webgl",kernelFunc:SY};var TY="return float(!(x >= 1.0));",AY=_e({opSnippet:TY}),MR={kernelName:jl,backendName:"webgl",kernelFunc:AY};var EY="return float(a >= 1.0 || b >= 1.0);",DY=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,$Y=st({opSnippet:EY,packedOpSnippet:DY,dtype:"bool"}),LR={kernelName:Ul,backendName:"webgl",kernelFunc:$Y};var Yv=class{constructor(e,t,n,o,s){this.variableNames=["x"],this.outputShape=[];let a=t,i=e[3]-1;this.outputShape=e;let l,u=`float(${n}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};var Zv=class{constructor(e,t,n,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,i=e[3]-1;this.outputShape=e;let l,u=`float(${n}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}};var RY=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:a,alpha:i,beta:l}=n,u=W().getBool("WEBGL_PACK_NORMALIZATION")?new Zv(o.shape,s,a,i,l):new Yv(o.shape,s,a,i,l);return t.runWebGLProgram(u,[o],o.dtype)},zR={kernelName:tl,backendName:"webgl",kernelFunc:RY};var Jv=class{constructor(e,t,n,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var FY=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:a}=e,{depthRadius:i,bias:l,alpha:u,beta:c}=n,p=new Jv(o.shape,i,l,u,c);return t.runWebGLProgram(p,[o,s,a],o.dtype)},BR={kernelName:Rc,backendName:"webgl",kernelFunc:FY};function VR(r,e,t,n){let o=y.sizeFromShape(e),a=y.sizeFromShape(r.shape)/o,i=ue({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),l=An(i,r.dtype,"max",n),u=ue({inputs:{x:l},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}function Qv(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n,i=o.shape.length,l=y.parseAxisParam(s,o.shape),u=l,c=C.getAxesPermutation(u,i),p=c!=null,m=t.shouldExecuteOnCPU([o]),f=o;if(p){if(m){let w=t.texData.get(f.dataId).values,_=new Array(i);for(let $=0;$<_.length;$++)_[$]=o.shape[c[$]];let I=Fu(w,o.shape,o.dtype,c,_);f=t.makeTensorInfo(_,o.dtype);let E=t.texData.get(f.dataId);E.values=I}else f=kl(o,c,t);u=C.getInnerMostAxes(u.length,i)}C.assertAxesAreInnerMostDims("max",u,i);let[d,h]=C.computeOutAndReduceShapes(f.shape,u),g=d;a&&(g=C.expandShapeToKeepDim(d,l));let x;if(m){let w=t.texData.get(f.dataId).values,_=pD(w,y.sizeFromShape(h),g,o.dtype);x=t.makeTensorInfo(g,o.dtype);let I=t.texData.get(x.dataId);I.values=_}else x=VR(f,h,g,t);return p&&t.disposeIntermediateTensorInfo(f),x}var GR={kernelName:zo,backendName:"webgl",kernelFunc:Qv};var OY=px+`
  return max(a, b);
`,PY=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+wl+`
  return result;
`,MY=st({opSnippet:OY,packedOpSnippet:PY,cpuKernelImpl:mD}),WR={kernelName:Bo,backendName:"webgl",kernelFunc:MY};function LY(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;vs(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:l}=n,u=1;y.assert(C.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=C.computePool2DInfo(o.shape,s,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&y.arraysEqual(c.inShape,c.outShape))return jt({inputs:{x:o},backend:t});let p=new ui(c,"max",!1);return t.runWebGLProgram(p,[o],o.dtype)}var jR={kernelName:Vo,backendName:"webgl",kernelFunc:LY};function zY(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dataFormat:l,dimRoundingMode:u}=n,c=[1,1,1],p=C.computePool3DInfo(o.shape,s,a,c,i,u,l),m=new Lu(p,"max",!1);return t.runWebGLProgram(m,[o],o.dtype)}var UR={kernelName:rl,backendName:"webgl",kernelFunc:zY};var eC=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,l=a-1-e.padInfo.left,u=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},tC=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,p=l-1-e.padInfo.front,m=u-1-e.padInfo.top,f=c-1-e.padInfo.left,d=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function BY(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=n,p=[1,1,1],m=C.computePool3DInfo(a.shape,i,l,p,u,c),f=new Lu(m,"max",!0),d=t.runWebGLProgram(f,[a],a.dtype),h=new tC(m),g=t.runWebGLProgram(h,[o,d],a.dtype);return t.disposeIntermediateTensorInfo(d),g}var HR={kernelName:Oc,backendName:"webgl",kernelFunc:BY};function VY(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:a}=e,i=s;vs([s,a],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=n,m=C.computePool2DInfo(i.shape,l,u,1,c,p),f=!0,d=new ui(m,"max",f),h=t.runWebGLProgram(d,[i],i.dtype),g=new eC(m),x=t.runWebGLProgram(g,[o,h],i.dtype);return t.disposeIntermediateTensorInfo(h),x}var qR={kernelName:Fc,backendName:"webgl",kernelFunc:VY};function KR(r,e,t,n){let o=new ui(t,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new ui(t,"max",!0,!0,e);let a=n.runWebGLProgram(o,[r],"float32");return[s,a]}var XR={kernelName:Pc,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=e,l=t;y.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let u=[1,1];y.assert(C.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=C.computePool2DInfo(n.shape,o,s,u,a),[p,m]=KR(n,i,c,l);return[p,m]}};function YR(r,e,t,n){let o=y.sizeFromShape(e),a=y.sizeFromShape(r.shape)/o,i=ue({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),l=An(i,"float32","mean",n),u=ue({inputs:{x:l},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var ZR={kernelName:Go,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{keepDims:o,axis:s}=e,a=t,i=n.shape.length,l=y.parseAxisParam(s,n.shape),u=l,c=C.getAxesPermutation(u,i),p=c!=null,m=a.shouldExecuteOnCPU([n]),f=[],d=n;if(p){if(m){let _=a.texData.get(d.dataId).values,I=new Array(i);for(let D=0;D<I.length;D++)I[D]=n.shape[c[D]];let E=Fu(_,n.shape,n.dtype,c,I);d=a.makeTensorInfo(I,n.dtype);let $=a.texData.get(d.dataId);$.values=E}else d=kl(n,c,a);f.push(d),u=C.getInnerMostAxes(u.length,i)}C.assertAxesAreInnerMostDims("sum",u,i);let[h,g]=C.computeOutAndReduceShapes(d.shape,u),x=h;o&&(x=C.expandShapeToKeepDim(h,l));let b=YR(d,g,x,a);for(let w of f)a.disposeIntermediateTensorInfo(w);return b}};function GY(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,l=y.parseAxisParam(s,o.shape),u=l,c=C.getAxesPermutation(u,i),p=o;c!=null&&(p=$t({inputs:{x:o},backend:t,attrs:{perm:c}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("min",u,i);let[m,f]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(f),h=ue({inputs:{x:p},backend:t,attrs:{shape:[-1,d]}}),g=An(h,h.dtype,"min",t),x;if(a){let b=C.expandShapeToKeepDim(m,l);x=ue({inputs:{x:g},backend:t,attrs:{shape:b}})}else x=ue({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),x}var JR={kernelName:Wo,backendName:"webgl",kernelFunc:GY};var WY=px+`
  return min(a, b);
`,jY=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+wl+`
  return result;
`,UY=st({opSnippet:WY,packedOpSnippet:jY,cpuKernelImpl:fD}),QR={kernelName:jo,backendName:"webgl",kernelFunc:UY};var rC=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((c,p)=>c[0]+e[p]+c[1]);let o=e.length,s=Ve(o),a=t.map(c=>c[0]).join(","),i=t.map((c,p)=>c[0]+e[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),u=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};var nC=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((d,h)=>d[0]+e[h]+d[1]);let o=e.length,s=Ve(o),a=t.map(d=>d[0]).join(","),i=t.map((d,h)=>d[0]+e[h]).join(","),l=Wt("rc",o),u=Wt("source",o),c=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,m=n==="reflect"?0:1,f="";if(o===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
        rc = outputLoc;
        ${l[o-2]} += 1;
        if(${l[o-2]} < ${this.outputShape[o-2]}) {
          ${d}
          result[2] = getChannel(getX(${u.join()}), ${p});
          ${l[o-1]} += 1;
          if(${c}) {
            ${d}
            result[3] = getChannel(getX(${u.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var HY=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{paddings:o,mode:s}=t,a=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nC(n.shape,o,s):new rC(n.shape,o,s);return e.runWebGLProgram(a,[n],n.dtype)},eF={kernelName:Uo,backendName:"webgl",kernelFunc:HY};var qY=`if (b == 0.0) return NAN;
  return mod(a, b);`,KY=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+wl+`
  return result;
`,XY=st({opSnippet:qY,packedOpSnippet:KY}),tF={kernelName:qi,backendName:"webgl",kernelFunc:XY};var oC=class{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}getCustomSetupFunc(e){return(t,n)=>{this.seedLoc==null&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}};var YY=`
if (a == b) {
  return 1.0;
};
return a / b;`,ZY=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,sC=st({opSnippet:YY,packedOpSnippet:ZY,checkOutOfBounds:!0}),rF={kernelName:Do,backendName:"webgl",kernelFunc:sC};var nF="return a - b;",iC=st({opSnippet:nF,packedOpSnippet:nF,supportsComplex:!0,cpuKernelImpl:kD}),oF={kernelName:us,backendName:"webgl",kernelFunc:iC};function aC(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=y.parseAxisParam([s],o.shape),i=Qv({inputs:{x:o},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),l=C.expandShapeToKeepDim(i.shape,a),u=ue({inputs:{x:i},backend:t,attrs:{shape:l}}),c=iC({inputs:{a:o,b:u},backend:t}),p=Wv({inputs:{x:c},backend:t}),m=Pu({inputs:{x:p},backend:t,attrs:{axis:a,keepDims:!1}}),f=ue({inputs:{x:m},backend:t,attrs:{shape:l}}),d=sC({inputs:{a:p,b:f},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}var sF={kernelName:as,backendName:"webgl",kernelFunc:aC};function JY(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:a,normalized:i}=n,l=i?o:aC({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),u=l.shape[0],c=l.shape[1],p=new oC(u,c,s),m=p.getCustomSetupFunc(a),f=t.runWebGLProgram(p,[l],"int32",m);return i||t.disposeIntermediateTensorInfo(l),f}var iF={kernelName:Mc,backendName:"webgl",kernelFunc:JY};var aF="return -x;";function QY(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.texData.get(n.dataId),[a,i]=hD(s.values,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,a)}let o;return W().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Is(n.shape,aF):o=new gn(n.shape,aF),t.runWebGLProgram(o,[n],n.dtype)}var lF={kernelName:Ws,backendName:"webgl",kernelFunc:QY};var e9=Rr.nonMaxSuppressionV3Impl;function t9(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=n,u=t.readSync(o.dataId),c=t.readSync(s.dataId),{selectedIndices:p}=e9(u,c,a,i,l);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var uF={kernelName:Xi,backendName:"webgl",kernelFunc:t9};var r9=Rr.nonMaxSuppressionV4Impl;function n9(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=n,c=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=r9(c,p,a,i,l,u);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var cF={kernelName:Yi,backendName:"webgl",kernelFunc:n9};var o9=Rr.nonMaxSuppressionV5Impl;function s9(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=n,c=t.readSync(o.dataId),p=t.readSync(s.dataId),m=a,f=i,d=l,h=u,{selectedIndices:g,selectedScores:x}=o9(c,p,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var pF={kernelName:Zi,backendName:"webgl",kernelFunc:s9};var lC=class{constructor(e,t,n,o){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var i9=r=>{let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:a,offValue:i}=n,l=y.sizeFromShape(o.shape),u=new lC(l,s,a,i),c=ue({inputs:{x:o},backend:t,attrs:{shape:[l]}}),p=t.runWebGLProgram(u,[c],o.dtype);t.disposeIntermediateTensorInfo(c);let m=[...o.shape,s],f=ue({inputs:{x:p},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(p),f},mF={kernelName:qo,backendName:"webgl",kernelFunc:i9};function Vf(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=Ra({inputs:{input:n},backend:t}),s=Vf({inputs:{x:o},backend:t}),a=zu({inputs:{input:n},backend:t}),i=Vf({inputs:{x:a},backend:t}),l=xn({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}else return Bf({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var fF={kernelName:Zs,backendName:"webgl",kernelFunc:Vf};function dF(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Ra({inputs:{input:n},backend:t}),s=dF({inputs:{x:o},backend:t}),a=zu({inputs:{input:n},backend:t}),i=Vf({inputs:{x:a},backend:t}),l=xn({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}else return Bf({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var hF={kernelName:js,backendName:"webgl",kernelFunc:dF};function a9(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return _x({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{y.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=e.map(c=>{let p=_x({inputs:{input:c},backend:t,attrs:{dim:o}});return i.push(p),p}),u=Ev({inputs:l,backend:t,attrs:{axis:o}});return i.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}var gF={kernelName:Us,backendName:"webgl",kernelFunc:a9};var uC=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let o=e.length,s=Ve(o),a=t.map(u=>u[0]).join(","),i=t.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};
        uniform float value;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});
      uniform float value;

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}getCustomSetupFunc(e){return(t,n)=>{this.valueLoc==null&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}};var cC=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let o=e.length,s=Ve(o),a=t.map(h=>h[0]).join(","),i=t.map((h,g)=>h[0]+e[g]).join(","),l=Wt("rc",o),u=Wt("source",o),c=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${l[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${l[o-2]} += 1;
       if(${l[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${l[o-1]} += 1;
         if(${c}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,g=o===1?2:4;h<g;h++)d+=`
        ${m[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${u.join()}), ${p});
        }
      `;d+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});
      uniform float value;

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}getCustomSetupFunc(e){return(t,n)=>{this.valueLoc==null&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}};var pC=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n,i=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cC(o.shape,s,a):new uC(o.shape,s,a),l=i.getCustomSetupFunc(a);return t.runWebGLProgram(i,[o],o.dtype,l)},xF={kernelName:Ko,backendName:"webgl",kernelFunc:pC};var l9=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,u9=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+wl+`
  return result;
`,c9=st({opSnippet:l9,packedOpSnippet:u9}),yF={kernelName:Xo,backendName:"webgl",kernelFunc:c9};function p9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,l=[],u=y.parseAxisParam(s,o.shape),c=u,p=C.getAxesPermutation(c,i),m=o;p!=null&&(m=$t({inputs:{x:o},backend:t,attrs:{perm:p}}),c=C.getInnerMostAxes(c.length,i),l.push(m)),C.assertAxesAreInnerMostDims("prod",c,i);let f;if(t.shouldExecuteOnCPU([m])){let d=t.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:x}=gD(m.shape,m.dtype,d,c);f=t.makeTensorInfo(g,x,h)}else{let[d,h]=C.computeOutAndReduceShapes(m.shape,c),g=y.sizeFromShape(h),x=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,g]}}),b=Kl(o.dtype),w=An(x,b,"prod",t);f=ue({inputs:{x:w},backend:t,attrs:{shape:d}}),l.push(x),l.push(w)}if(a){l.push(f);let d=C.expandShapeToKeepDim(f.shape,u);f=ue({inputs:{x:f},backend:t,attrs:{shape:d}})}return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),f}var bF={kernelName:Ji,backendName:"webgl",kernelFunc:p9};var mC=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=xD(n,o,s,a);return e.makeTensorInfo([i.length],a,i)},wF={kernelName:nl,backendName:"webgl",kernelFunc:mC};var m9="return 1.0 / x;",f9=_e({opSnippet:m9}),_F={kernelName:Qi,backendName:"webgl",kernelFunc:f9};var d9=br+`
  return (x < 0.0) ? 0.0 : x;
`,h9=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,g9=_e({opSnippet:d9,packedOpSnippet:h9}),kF={kernelName:Zo,backendName:"webgl",kernelFunc:g9};var x9=br+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,y9=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,b9=_e({opSnippet:x9,packedOpSnippet:y9}),vF={kernelName:Qo,backendName:"webgl",kernelFunc:b9};var fC=class{constructor(e,t,n,o,s){this.variableNames=["A"],this.outputShape=[];let[a,i,l,u]=e;this.outputShape=[a,t,n,u];let c=[o&&t>1?i-1:i,o&&n>1?l-1:l],p=[o&&t>1?t-1:t,o&&n>1?n-1:n],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var dC=class{constructor(e,t,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,l,u]=e;this.outputShape=[a,t,n,u];let c=[o&&t>1?i-1:i,o&&n>1?l-1:l],p=[o&&t>1?t-1:t,o&&n>1?n-1:n],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function w9(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[l,u]=i,c=W().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dC(o.shape,l,u,s,a):new fC(o.shape,l,u,s,a);return t.runWebGLProgram(c,[o],"float32")}var CF={kernelName:Jo,backendName:"webgl",kernelFunc:w9};var hC=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,a,i]=e,l=[n&&a>1?o-1:o,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],c=l[0]/u[0],p=l[1]/u[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function _9(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n,i=new hC(s.shape,o.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var IF={kernelName:Bc,backendName:"webgl",kernelFunc:_9};var gC=class{constructor(e,t,n,o,s){this.variableNames=["A"],this.outputShape=[];let[a,i,l,u]=e;this.outputShape=[a,t,n,u];let c=[o&&t>1?i-1:i,o&&n>1?l-1:l],p=[o&&t>1?t-1:t,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};function k9(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[l,u]=i,c=new gC(o.shape,l,u,s,a);return t.runWebGLProgram(c,[o],o.dtype)}var NF={kernelName:ol,backendName:"webgl",kernelFunc:k9};var xC=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,a,i]=e,l=[n&&a>1?o-1:o,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],c=l[0]/u[0],p=l[1]/u[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function v9(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n,i=new xC(s.shape,o.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var SF={kernelName:zc,backendName:"webgl",kernelFunc:v9};var yC=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let o=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,l)=>o(l)).join(","),a=Ve(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var bC=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let o=Wt("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Ve(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(o.slice())};
          if(${s}){
            result.g = ${u(o.slice())};
          }
          if(${a}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(d){return m(d)}function u(d){return d[n-1]="("+d[n-1]+" + 1)",m(d)}function c(d){return d[n-2]="("+d[n-2]+" + 1)",m(d)}function p(d){return d[n-1]="("+d[n-1]+" + 1)",d[n-2]="("+d[n-2]+" + 1)",m(d)}function m(d){let h=e.map((b,w)=>f(w,d)),g=h.join(","),x=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${x}))`}function f(d,h){return t.indexOf(d)!==-1&&e[d]!==1?`${e[d]} - ${h[d]} - 1`:`${h[d]}`}}};function C9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=o.shape.length,i=y.parseAxisParam(s,o.shape);if(a===0)return jt({inputs:{x:o},backend:t});let l=W().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bC(o.shape,i):new yC(o.shape,i);return t.runWebGLProgram(l,[o],o.dtype)}var TF={kernelName:es,backendName:"webgl",kernelFunc:C9};var wC=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[];let n=e[1],o=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        uniform vec4 params;
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}getCustomSetupFunc(e,t,n,o){return(s,a)=>{this.paramsLoc==null&&(this.paramsLoc=s.getUniformLocationNoThrow(a,"params")),s.gl.uniform4f(this.paramsLoc,e,t,n,o)}}};var AF={kernelName:aa,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,l=new wC(n.shape,s),[u,c]=C.getImageCenter(a,n.shape[1],n.shape[2]),p=l.getCustomSetupFunc(u,c,Math.sin(o),Math.cos(o));return i.runWebGLProgram(l,[n],n.dtype,p)}};var I9=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,N9=_e({opSnippet:I9}),EF={kernelName:ts,backendName:"webgl",kernelFunc:N9};var S9="return inversesqrt(x);",T9=_e({opSnippet:S9,cpuKernelImpl:yD}),DF={kernelName:rs,backendName:"webgl",kernelFunc:T9};var Gf=class{constructor(e,t,n,o,s,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let l=Ve(s.length),u=Ve(a.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,m="";o===1?m="i":o===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,d=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function A9(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=C.calculateShapes(s,o,a),m=[p/u,u];if(p===0)return t.makeTensorInfo(a,o.dtype);let f=ue({inputs:{x:o},backend:t,attrs:{shape:[l,i]}}),d=ue({inputs:{x:s},backend:t,attrs:{shape:[l,u]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new Gf(l,i,f.shape.length,d.shape.length,c,m),x=t.runWebGLProgram(g,[d,f,h],d.dtype),b=ue({inputs:{x},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(h),b}var $F={kernelName:ea,backendName:"webgl",kernelFunc:A9};var _C=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${i[c]}`),c<e&&l.push(`${i[c]}`);o=l.join(),s=u.join()}let a=Ve(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function E9(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=new _C(n.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(a,[n,o,s],ar(o.dtype,s.dtype))}var RF={kernelName:qs,backendName:"webgl",kernelFunc:E9};var D9=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${C.SELU_SCALEALPHA};
  float scale = ${C.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,$9=_e({opSnippet:D9}),FF={kernelName:ta,backendName:"webgl",kernelFunc:$9};var R9="return 1.0 / (1.0 + exp(-1.0 * x));",F9=_e({opSnippet:R9}),OF={kernelName:os,backendName:"webgl",kernelFunc:F9};var O9=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,P9=_e({opSnippet:O9}),PF={kernelName:na,backendName:"webgl",kernelFunc:P9};var M9=mx+`
  return sin(x);
`,L9=_e({opSnippet:M9}),MF={kernelName:ns,backendName:"webgl",kernelFunc:L9};var z9=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,B9=_e({opSnippet:z9}),LF={kernelName:ra,backendName:"webgl",kernelFunc:B9};var V9=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,G9=_e({opSnippet:V9}),zF={kernelName:oa,backendName:"webgl",kernelFunc:G9};var W9=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((x,b)=>x*b),l=[[0,0]];l.push(...a);for(let x=1+s.length;x<o.shape.length;++x)l.push([0,0]);let u=[],c=pC({inputs:{x:o},backend:t,attrs:{paddings:l,constantValue:0}}),p=C.getReshaped(c.shape,s,i,!1),m=C.getPermuted(p.length,s.length,!1),f=C.getReshapedPermuted(c.shape,s,i,!1),d=ue({inputs:{x:c},backend:t,attrs:{shape:p}}),h=$t({inputs:{x:d},backend:t,attrs:{perm:m}}),g=ue({inputs:{x:h},backend:t,attrs:{shape:f}});return u.push(c),u.push(d),u.push(h),u.forEach(x=>t.disposeIntermediateTensorInfo(x)),g},BF={kernelName:sl,backendName:"webgl",kernelFunc:W9};function j9(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.readSync(o.dataId)),i=t.readSync(n.dataId),l=Array.from(t.readSync(s.dataId)),[u,c,p]=wD(i,n.shape,n.dtype,a,l);return[t.makeTensorInfo(c,n.dtype,u),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var VF={kernelName:Vc,backendName:"webgl",kernelFunc:j9};function U9(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:l,numUpdates:u,strides:c,outputSize:p}=C.calculateShapes(s,o,i),m=!1,f=new Gf(u,l,o.shape.length,s.shape.length,c,[p,1],m),d=t.runWebGLProgram(f,[s,o,a],s.dtype),h=ue({inputs:{x:d},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(d),h}var GF={kernelName:Gc,backendName:"webgl",kernelFunc:U9};function H9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],l=C.prepareSplitSize(o,s,i),u=o.shape.length,c=new Array(u).fill(0),p=o.shape.slice();return l.map(m=>{let f=[...p];f[i]=m;let d=$a({inputs:{x:o},backend:t,attrs:{begin:c,size:f}});return c[i]+=m,d})}var WF={kernelName:Xs,backendName:"webgl",kernelFunc:H9};var q9="return sqrt(x);",K9=_e({opSnippet:q9}),jF={kernelName:ss,backendName:"webgl",kernelFunc:K9};var X9="return x * x;",Y9=_e({opSnippet:X9}),UF={kernelName:il,backendName:"webgl",kernelFunc:Y9};var HF="return (a - b) * (a - b);",Z9=st({opSnippet:HF,packedOpSnippet:HF}),qF={kernelName:ls,backendName:"webgl",kernelFunc:Z9};function J9({inputs:r,attrs:e,backend:t}){let{x:n}=r,o=br+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new gn(n.shape,o);return t.runWebGLProgram(s,[n],n.dtype)}var KF={kernelName:Yn,backendName:"webgl",kernelFunc:J9};var kC=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let o=n.length,s=Ve(n.length),a=Ve(n.length),i="";if(o===1)i="coords * strides + begin";else{let l=0;i=n.map((u,c)=>(l++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function Q9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{nonStrided:f,$begin:d,$strides:h,size:g,newShape:x,outShape:b}=rr.sliceInfo(o.shape,s,a,i,l,u,c,p,m),w=ue({inputs:{x:o},backend:t,attrs:{shape:x}}),_;if(f){let E=$a({inputs:{x:w},backend:t,attrs:{begin:d,size:g}});_=ue({inputs:{x:E},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(E)}else if(b.some(E=>E===0))_=t.makeTensorInfo(b,o.dtype,[]);else if(t.shouldExecuteOnCPU([w])){let D=t.texData.get(w.dataId).values,O=Ce(w.shape,w.dtype,D),M=_D(b,O,h,d);_=t.makeTensorInfo(b,w.dtype,M.values)}else{let $=new kC(d,h,b);_=t.runWebGLProgram($,[w],w.dtype)}let I=ue({inputs:{x:_},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(_),I}var XF={kernelName:sa,backendName:"webgl",kernelFunc:Q9};var eZ="return tan(x);",tZ=_e({opSnippet:eZ}),YF={kernelName:cs,backendName:"webgl",kernelFunc:tZ};var rZ=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,nZ=_e({opSnippet:rZ}),ZF={kernelName:ps,backendName:"webgl",kernelFunc:nZ};var vC=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let o=Ve(this.rank),s=oZ(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function oZ(r){let e=r.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${r[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${t[o]}, ${r[o]})`);return n.join()}function CC(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=t.readSync(o.dataId).map(m=>y.decodeString(m)),c=Ce(o.shape,o.dtype,u),p=vD(c,s);return t.makeTensorInfo(p.shape,p.dtype,p.values)}let a=new vC(o.shape,s);return t.runWebGLProgram(a,[o],o.dtype)}var JF={kernelName:Pn,backendName:"webgl",kernelFunc:CC};function sZ(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n,i=t.readSync(o.dataId),[l,u]=CD(i,o.shape,o.dtype,s,a);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}var QF={kernelName:ia,backendName:"webgl",kernelFunc:sZ};var IC=class{constructor(e,t,n,o,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let i=n==="nearest"?1:2,l;switch(o){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function iZ(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=n,[c,p,m,f]=o.shape,[d,h]=u!=null?u:[p,m],g=[c,d,h,f],x=new IC(p,m,a,i,l,g);return t.runWebGLProgram(x,[o,s],"float32")}var eO={kernelName:Wc,backendName:"webgl",kernelFunc:iZ};function aZ(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;vs(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=n.readSync(s.dataId),{outputValues:i,outputShape:l,indices:u}=ID(a,o,s.shape,s.dtype);return[n.makeTensorInfo(l,s.dtype,i),n.makeTensorInfo([u.length],"int32",u)]}var tO={kernelName:jc,backendName:"webgl",kernelFunc:aZ};function lZ(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,l=o.shape[s],u=new Array(i-1),c=0;for(let h=0;h<i;h++)h!==s&&(u[c++]=a.shape[h]);let p=[],m=new Array(i).fill(0),f=a.shape.slice();f[s]=1;let d=new Array(l);for(let h=0;h<d.length;h++){m[s]=h;let g=$a({inputs:{x:a},backend:t,attrs:{begin:m,size:f}}),x=ue({inputs:{x:g},backend:t,attrs:{shape:u}});d[h]=x,p.push(g)}return p.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}var rO={kernelName:Ys,backendName:"webgl",kernelFunc:lZ};var NC=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,o=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[o,i];let l="0.0",u="sumValue",c=Math.floor(n/4)*4,p=n%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${u});
      }
    `}};function uZ(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:a}=n,i=o.shape.length,l=[],u=0,c=C.getAxesPermutation([u],i),p=o;c!=null&&(p=$t({inputs:{x:o},backend:t,attrs:{perm:c}}),l.push(p),u=C.getInnerMostAxes(1,i)[0]);let m=C.segment_util.computeOutShape(p.shape,u,a),f=y.sizeFromShape([p.shape[u]]),d=ue({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}});l.push(d);let h=Kl(o.dtype),g=(_,I,E,$,D)=>{let O=_.shape[0],M=_.shape[1],G=C.segment_util.segOpComputeOptimalWindowSize(M,D),j={windowSize:G,inSize:M,batchSize:O,numSegments:D},U=new NC(j,I),H=t.compileAndRun(U,[_,E],$);if(l.push(H),H.shape[1]===D)return H;let q=mC({backend:t,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),X=CC({inputs:{x:q},backend:t,attrs:{reps:[M/G]}});return l.push(q),l.push(X),g(H,I,X,$,D)},x=g(d,"unsortedSegmentSum",s,h,a),b=ue({inputs:{x},backend:t,attrs:{shape:m}}),w=b;if(c!=null){l.push(b);let _=C.getUndoAxesPermutation(c);w=$t({inputs:{x:w},backend:t,attrs:{perm:_}})}return l.forEach(_=>t.disposeIntermediateTensorInfo(_)),w}var nO={kernelName:al,backendName:"webgl",kernelFunc:uZ};var cZ=[zR,BR,e$,r$,n$,o$,i$,a$,l$,u$,m$,f$,d$,h$,x$,g$,y$,w$,b$,_$,k$,v$,C$,N$,S$,D$,R$,F$,P$,GD,L$,B$,V$,z$,W$,j$,G$,U$,H$,q$,Y$,Z$,J$,eR,tR,Q$,rR,nR,oR,sR,iR,aR,lR,cR,pR,fR,dR,hR,gR,yR,bR,wR,_R,kR,vR,CR,IR,NR,VD,SR,M$,TR,AR,ER,WD,DR,$R,RR,OR,FR,PR,MR,LR,GR,UR,jR,HR,qR,XR,WR,ZR,JR,QR,eF,tF,iF,KD,lF,uF,cF,pF,T$,mF,hF,gF,xF,yF,jD,bF,wF,A$,rF,_F,vF,kF,YD,CF,IF,NF,SF,TF,AF,EF,DF,$F,RF,FF,OF,PF,MF,LF,I$,sF,zF,BF,VF,GF,WF,jF,UF,qF,KF,XF,oF,JD,YF,ZF,JF,QF,eO,QD,tO,rO,nO,fF];for(let r of cZ)Hl(r);var Rt;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(Rt||(Rt={}));var vl;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid"})(vl||(vl={}));var oO;function pZ(r){oO=r.wasm.cwrap(Js,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function mZ(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=n,m=t.dataIdMap.get(o.dataId).id,f=t.dataIdMap.get(s.dataId).id,d=0;if(a!=null){let D=t.dataIdMap.get(a.dataId);if(D.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${D.shape.length}.`);d=D.id}let h=i==null?0:t.dataIdMap.get(i.dataId).id,g=vl[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let x=l?o.shape[2]:o.shape[1],b=u?s.shape[1]:s.shape[2],w=o.shape[0],_=t.makeOutput([w,x,b],o.dtype),I=t.dataIdMap.get(_.dataId).id,E=new Uint8Array(new Int32Array(o.shape).buffer),$=new Uint8Array(new Int32Array(s.shape).buffer);return oO(m,E,o.shape.length,f,$,s.shape.length,l,u,g,d,h,p||0,I),_}var sO={kernelName:Js,backendName:"wasm",setupFunc:pZ,kernelFunc:mZ};function xt(r){let e;function t(o){e=o.wasm.cwrap(r,null,["number","number"])}function n(o){let{backend:s,inputs:{x:a}}=o,i=s.dataIdMap.get(a.dataId).id,l=s.makeOutput(a.shape,a.dtype),u=s.dataIdMap.get(l.dataId).id;return y.sizeFromShape(l.shape)===0||e(i,u),l}return{kernelName:r,backendName:"wasm",setupFunc:t,kernelFunc:n}}var iO=xt(zs);function yt(r,e,t){let n;function o(a){n=a.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(a){let{backend:i,inputs:l}=a,{a:u,b:c}=l,p=i.dataIdMap.get(u.dataId).id,m=i.dataIdMap.get(c.dataId).id,f=t!=null?t:u.dtype,d=C.assertAndGetBroadcastShape(u.shape,c.shape),h=i.makeOutput(d,f);if(y.sizeFromShape(d)===0)return h;let g=new Uint8Array(new Int32Array(u.shape).buffer),x=new Uint8Array(new Int32Array(c.shape).buffer),b=i.dataIdMap.get(h.dataId).id,w=()=>n(p,g,u.shape.length,m,x,c.shape.length,Rt[u.dtype],b);if(e&&u.dtype==="float32")return w(),h;let _=C.getBroadcastDims(u.shape,d),I=C.getBroadcastDims(c.shape,d),E=_.every((D,O)=>D===O),$=I.every((D,O)=>D===O);if(E&&$)return w(),h;throw new Error(`Broadcasting along outer dims is not yet supported for ${u.dtype} ${r}.`)}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var fZ=!0,aO=yt(On,fZ);var lO;function dZ(r){lO=r.wasm.cwrap(_o,null,["array","number","number","number"])}function hZ(r){let{inputs:e,backend:t}=r,n=t.makeOutput(e[0].shape,e[0].dtype);if(y.sizeFromShape(n.shape)===0)return n;let o=e.map(i=>t.dataIdMap.get(i.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),a=t.dataIdMap.get(n.dataId).id;return lO(s,o.length,Rt[n.dtype],a),n}var uO={kernelName:_o,backendName:"wasm",setupFunc:dZ,kernelFunc:hZ};function Vu(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype),o=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(n).set(o),n}var cO={kernelName:Xn,backendName:"wasm",kernelFunc:Vu};var pO;function gZ(r){pO=r.wasm.cwrap(ms,null,["number","array","number","number","number","array","number"])}function Dp(r){let{inputs:e,backend:t,attrs:n}=r,[o,s]=yZ(e.x.shape,n.perm),a=!0;for(let d=0;d<s.length;d++)s[d]!==d&&(a=!1);let i=xZ(e.x.shape,n.perm),l={dataId:e.x.dataId,shape:o,dtype:e.x.dtype};if(a){let d=Vu({inputs:e,backend:t});return d.shape=i,d}let u=t.makeOutput(i,l.dtype),c=t.dataIdMap.get(l.dataId).id,p=t.dataIdMap.get(u.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),f=new Uint8Array(new Int32Array(l.shape).buffer);return pO(c,f,l.shape.length,Rt[l.dtype],p,m,s.length),u}function xZ(r,e){let t=new Array(r.length);for(let n=0;n<t.length;n++)t[n]=r[e[n]];return t}function yZ(r,e){let t=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&t.push(r[o]),r[e[o]]!==1&&n.push(e[o]);for(let o=0;o<n.length;++o){let s=-1;for(let a=0;a<n.length;++a)n[a]>=o&&(s===-1||n[s]>n[a])&&(s=a);n[s]=o}return[t,n]}var mO={kernelName:ms,backendName:"wasm",kernelFunc:Dp,setupFunc:gZ};function tn(r,e,t){let n=r.shape,o=r.shape.length,s=y.parseAxisParam(e,n),a=s,i=C.getAxesPermutation(a,o),l=null,u=!1;if(i!=null){let c=new Array(o);for(let f=0;f<c.length;f++)c[f]=n[i[f]];a=C.getInnerMostAxes(a.length,o),l=Dp({inputs:{x:r},attrs:{perm:i},backend:t});let p=t.dataIdMap.get(r.dataId).id;t.dataIdMap.get(l.dataId).id!==p&&(u=!0)}return{transposed:l,originalAxes:s,axes:a,inputWasTransposed:u}}var fO;function bZ(r){fO=r.wasm.cwrap(vi,null,["number, number, number"])}function wZ(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,l=e.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=tn(a,o,e);if(f){let w=e.dataIdMap.get(c.dataId).id;u=c,l=w}let d=u.shape.length;C.assertAxesAreInnerMostDims("all",p,d);let[h,g]=C.computeOutAndReduceShapes(u.shape,p),x=y.sizeFromShape(g),b=e.makeOutput(h,a.dtype);if(y.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;fO(l,x,w)}if(f&&e.disposeData(c.dataId),s){let w=C.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var dO={kernelName:vi,backendName:"wasm",setupFunc:bZ,kernelFunc:wZ};var hO;function _Z(r){hO=r.wasm.cwrap(Ci,null,["number, number, number"])}function kZ(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,l=e.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=tn(a,o,e);if(f){let w=e.dataIdMap.get(c.dataId).id;u=c,l=w}let d=u.shape.length;C.assertAxesAreInnerMostDims("any",p,d);let[h,g]=C.computeOutAndReduceShapes(u.shape,p),x=y.sizeFromShape(g),b=e.makeOutput(h,a.dtype);if(y.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;hO(l,x,w)}if(f&&e.disposeData(c.dataId),s){let w=C.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var gO={kernelName:Ci,backendName:"wasm",setupFunc:_Z,kernelFunc:kZ};var xO;function vZ(r){xO=r.wasm.cwrap(ko,null,["number","number","number","number","number"])}function CZ(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o}=n,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=a,l=s,{transposed:u,axes:c,inputWasTransposed:p}=tn(s,o,e);if(p){let x=e.dataIdMap.get(u.dataId).id;x!==a&&(l=u,i=x)}let m=l.shape.slice(0,-1),f=e.makeOutput(m,"int32"),d=e.dataIdMap.get(f.dataId).id,h=y.sizeFromShape(f.shape),g=l.shape[c[0]];return xO(i,Rt[l.dtype],h,g,d),p&&e.disposeData(u.dataId),f}var yO={kernelName:ko,backendName:"wasm",kernelFunc:CZ,setupFunc:vZ};var bO;function IZ(r){bO=r.wasm.cwrap(vo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function NZ(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=t,c=C.computePool2DInfo(o.shape,a,i,1,l,u),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,x=c.strideHeight,b=c.strideWidth,w=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let _=n.makeOutput(c.outShape,"float32"),I=n.dataIdMap.get(_.dataId).id;return bO(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,x,b,w,I),_}var wO={kernelName:vo,backendName:"wasm",setupFunc:IZ,kernelFunc:NZ};function Vr(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=y.sizeFromShape(n.shape),a=y.inferFromImplicitShape(o,s);return y.assert(s===y.sizeFromShape(a),()=>`new shape: ${a}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var _O={kernelName:Hs,backendName:"wasm",kernelFunc:Vr};var kO;function SZ(r){kO=r.wasm.cwrap(Co,null,["number","array","number","number","array","number","number","number","number"])}function TZ(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=o.shape.length,u=s.shape.length,c=a?o.shape[l-2]:o.shape[l-1],p=i?s.shape[u-1]:s.shape[u-2],m=a?o.shape[l-1]:o.shape[l-2],f=i?s.shape[u-2]:s.shape[u-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(d),x=y.sizeFromShape(h),b=g===x||g===1||x===1;y.assert(l>=2&&u>=2&&b,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${d}) and (${h}).`);let _=(g>x?o.shape.slice(0,-2):s.shape.slice(0,-2)).concat([m,f]);y.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let I=a?[g,c,m]:[g,m,c],E=i?[x,f,p]:[x,p,f],$=Vr({inputs:{x:o},backend:t,attrs:{shape:I}}),D=Vr({inputs:{x:s},backend:t,attrs:{shape:E}}),O=t.dataIdMap.get($.dataId).id,M=t.dataIdMap.get(D.dataId).id,G=a?$.shape[2]:$.shape[1],j=i?D.shape[1]:D.shape[2],U=Math.max(g,x),H=t.makeOutput([U,G,j],$.dtype),q=t.dataIdMap.get(H.dataId).id,X=new Uint8Array(new Int32Array($.shape).buffer),ne=new Uint8Array(new Int32Array(D.shape).buffer);return kO(O,X,$.shape.length,M,ne,D.shape.length,a,i,q),t.disposeData($.dataId),t.disposeData(D.dataId),H.shape=_,H}var vO={kernelName:Co,backendName:"wasm",setupFunc:SZ,kernelFunc:TZ};function Gu(r){let{inputs:{x:e},attrs:{dtype:t},backend:n}=r,o=n.makeOutput(e.shape,t),s=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(o).set(s),o}var CO={kernelName:qn,backendName:"wasm",kernelFunc:Gu};var IO=xt(Io);var NO;function AZ(r){NO=r.wasm.cwrap(Kn,null,["number","number","number","number"])}function EZ(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i=t.dataIdMap.get(o.dataId).id,l=t.makeOutput(o.shape,o.dtype),u=t.dataIdMap.get(l.dataId).id;return NO(i,s,a,u),l}var SO={kernelName:Kn,backendName:"wasm",setupFunc:AZ,kernelFunc:EZ};function SC(r){let{inputs:e,backend:t}=r,n=y.parseAxisParam(r.attrs.axis,e[0].shape)[0],o=C.computeOutShape(e.map(f=>f.shape),n),s=e.filter(f=>y.sizeFromShape(f.shape)>0);if(s.length===1)return Vu({inputs:{x:s[0]},backend:t});let a=t.makeOutput(o,e[0].dtype);if(y.sizeFromShape(o)===0)return a;let i=s.map(f=>f.shape);if(C.assertParamsConsistent(i,n),s[0].dtype==="string"){let f=s.map(w=>{let _=y.sizeFromShape(w.shape.slice(n));return Vr({inputs:{x:w},backend:t,attrs:{shape:[-1,_]}})}),d=f.map(w=>({vals:t.readSync(w.dataId),shape:w.shape}));o=C.computeOutShape(f.map(w=>w.shape),1);let h=f[0].shape[0]===1,g=Su(d,o,e[0].dtype,h),x=C.computeOutShape(s.map(w=>w.shape),n);a.shape=x;let b=t.dataIdMap.get(a.dataId);return b.stringBytes=C.fromStringArrayToUint8(g),f.forEach(w=>t.disposeData(w.dataId)),a}let l=y.sizeFromShape(s[0].shape.slice(0,n)),u=0,c=s.map(f=>{let d=y.sizeFromShape(f.shape.slice(n));return u+=d,d}),p=s.map(f=>t.typedArrayFromHeap(f)),m=t.typedArrayFromHeap(a);for(let f=0;f<l;f++){let d=f*u;for(let h=0;h<p.length;h++){let g=c[h],x=f*g,b=p[h].subarray(x,x+g);m.set(b,d),d+=g}}return a}var TO={kernelName:Bs,backendName:"wasm",kernelFunc:SC};var AO;function DZ(r){AO=r.wasm.cwrap(No,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function $Z(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:p,dataFormat:m}=t,f=C.convertConv2DDataFormat(m),d=C.computeConv2DInfo(o.shape,s.shape,l,u,c,p,!1,f),h=d.filterHeight,g=d.filterWidth,x=d.padInfo.top,b=d.padInfo.right,w=d.padInfo.bottom,_=d.padInfo.left,I=d.dilationHeight,E=d.dilationWidth,$=d.strideHeight,D=d.strideWidth,O=d.inChannels,M=d.outChannels,G=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let j=n.makeOutput(d.outShape,"float32"),U=n.dataIdMap.get(j.dataId).id;return AO(a,o.shape[0],o.shape[1],o.shape[2],i,h,g,x,b,w,_,G,I,E,$,D,O,M,U),j}var EO={kernelName:No,backendName:"wasm",setupFunc:DZ,kernelFunc:$Z};var DO;function RZ(r){DO=r.wasm.cwrap(So,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function FZ(r){let{backend:e,inputs:t,attrs:n}=r,{dy:o,filter:s}=t,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,inputShape:c}=n,p=1,m=C.convertConv2DDataFormat(l),f=C.computeConv2DInfo(c,s.shape,a,p,i,u,!1,m),{batchSize:d,filterHeight:h,filterWidth:g,inChannels:x,inHeight:b,inWidth:w,outChannels:_,outHeight:I,outWidth:E,strideHeight:$,strideWidth:D}=f,O=h-1-f.padInfo.top,M=g-1-f.padInfo.left,G=f.dataFormat==="channelsLast",j=y.computeStrides(f.inShape),U=y.computeStrides(o.shape),[H,q,X]=y.computeStrides(s.shape),ne=j[0],Y=G?j[1]:j[2],re=G?j[2]:1,Q=G?1:j[1],ie=U[0],ce=G?U[1]:U[2],ae=G?U[2]:1,fe=G?1:U[1],de=e.makeOutput(f.inShape,"float32"),xe=e.dataIdMap.get(de.dataId).id,we=e.dataIdMap.get(o.dataId).id,De=e.dataIdMap.get(s.dataId).id;return DO(we,De,d,h,g,b,w,x,I,E,_,$,D,O,M,H,q,X,ne,Y,re,Q,ie,ce,ae,fe,xe),de}var $O={kernelName:So,backendName:"wasm",setupFunc:RZ,kernelFunc:FZ};var RO=xt(To);var TC;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(TC||(TC={}));var FO;function OZ(r){FO=r.wasm.cwrap(Di,null,["number","number","number","number","array","number","number","number","number","number"])}function PZ(r){let{backend:e,inputs:t,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:a}=n,{image:i,boxes:l,boxInd:u}=t,c=l.shape[0],[p,m]=a,f=[c,p,m,i.shape[3]],d=e.dataIdMap.get(i.dataId),h;i.dtype!=="float32"&&(h=Gu({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),d=e.dataIdMap.get(h.dataId));let g=d.id,x=e.dataIdMap.get(l.dataId).id,b=e.dataIdMap.get(u.dataId).id,w=e.makeOutput(f,"float32"),_=e.dataIdMap.get(w.dataId).id,I=new Uint8Array(new Int32Array(i.shape).buffer);return FO(g,x,b,c,I,p,m,TC[o],s,_),h!=null&&e.disposeData(h.dataId),w}var OO={kernelName:Di,backendName:"wasm",setupFunc:OZ,kernelFunc:PZ};var PO;function MZ(r){PO=r.wasm.cwrap(Ao,null,["number","number","number","number","number","number"])}function LZ(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n,l=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let u=C.getAxesPermutation([s],l),c=o;u!==null&&(c=Dp({inputs:{x:o},attrs:{perm:u},backend:t}));let p=C.getInnerMostAxes(1,l)[0];C.assertAxesAreInnerMostDims("cumsum",[p],l);let m=t.makeOutput(c.shape,c.dtype),f=c.shape[p],d=t.dataIdMap.get(c.dataId).id,h=t.dataIdMap.get(m.dataId).id;PO(d,a?1:0,i?1:0,f,h,Rt[o.dtype]);let g=m;if(u!==null){let x=C.getUndoAxesPermutation(u);g=Dp({inputs:{x:m},attrs:{perm:x},backend:t}),t.disposeData(c.dataId),t.disposeData(m.dataId)}return g}var MO={kernelName:Ao,backendName:"wasm",setupFunc:MZ,kernelFunc:LZ};var LO;function zZ(r){LO=r.wasm.cwrap($i,null,["number","number","number","array","number","array","array","number","number"])}function BZ(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:a}=n;y.assert(s>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${s}`);let i=o.shape[0],l=a==="NHWC"?o.shape[1]:o.shape[2],u=a==="NHWC"?o.shape[2]:o.shape[3],c=a==="NHWC"?o.shape[3]:o.shape[1],p=l*s,m=u*s,f=c/(s*s),d=a==="NHWC"?[i,p,m,f]:[i,f,p,m],h=e.makeOutput(d,"float32"),x=e.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),w=new Uint8Array(new Int32Array(d).buffer),_=new Uint8Array(new Int32Array(y.computeStrides(d)).buffer),I=e.dataIdMap.get(h.dataId).id;return LO(x,s,a==="NHWC"?1:0,b,o.shape.length-1,w,_,d.length,I),h}var zO={kernelName:$i,backendName:"wasm",setupFunc:zZ,kernelFunc:BZ};var BO;function VZ(r){BO=r.wasm.cwrap(Eo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function GZ(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:p}=t,m=u==null?[1,1]:u,f=C.computeConv2DInfo(o.shape,s.shape,l,m,c,p,!0),d=f.filterHeight,h=f.filterWidth,g=f.padInfo.top,x=f.padInfo.right,b=f.padInfo.bottom,w=f.padInfo.left,_=f.dilationHeight,I=f.dilationWidth,E=f.strideHeight,$=f.strideWidth,D=f.inChannels,O=f.outChannels,M=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let G=n.makeOutput(f.outShape,"float32"),j=n.dataIdMap.get(G.dataId).id;return BO(a,o.shape[0],o.shape[1],o.shape[2],i,d,h,g,x,b,w,M,_,I,E,$,D,O,j),G}var VO={kernelName:Eo,backendName:"wasm",setupFunc:VZ,kernelFunc:GZ};var WZ=!1,GO=yt(Oi,WZ,"bool");var WO=xt($o);function Cx(r){let{inputs:e,attrs:t,backend:n}=r,{input:o}=e,{dim:s}=t,a=o.shape.length,i=o.shape.slice(),l=s;return s<0&&(y.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+s+1),i.splice(l,0,1),Vr({inputs:{x:o},backend:n,attrs:{shape:i}})}var jO={kernelName:Vs,backendName:"wasm",kernelFunc:Cx};function jZ(r){let{attrs:{shape:e,value:t,dtype:n},backend:o}=r,s=o.makeOutput(e,n);return o.typedArrayFromHeap(s).fill(t),s}var UO={kernelName:el,backendName:"wasm",kernelFunc:jZ};var HO;function UZ(r){HO=r.wasm.cwrap(Mi,null,["number","number","number","number","number","number"])}function HZ(r){let{inputs:e,backend:t}=r,{image:n}=e,o=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,[i,l,u,c]=n.shape;return HO(s,i,l,u,c,a),o}var qO={kernelName:Mi,backendName:"wasm",kernelFunc:HZ,setupFunc:UZ};var KO=xt(Ro);var qZ=!1,XO=yt(Fo,qZ);var YO;function KZ(r){YO=r.wasm.cwrap(Oo,null,["number","number","number","number","number","number","number"])}function XZ(r){let{backend:e,inputs:t,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:a,variance:i,offset:l,scale:u}=t,c=e.dataIdMap.get(s.dataId).id,p=e.dataIdMap.get(a.dataId).id,m=e.dataIdMap.get(i.dataId).id,f=l!=null?e.dataIdMap.get(l.dataId).id:0,d=u!=null?e.dataIdMap.get(u.dataId).id:0,h=e.makeOutput(s.shape,s.dtype);if(y.sizeFromShape(s.shape)===0)return h;let g=e.dataIdMap.get(h.dataId).id;return YO(c,p,m,f,d,o,g),h}var ZO={kernelName:Oo,backendName:"wasm",setupFunc:KZ,kernelFunc:XZ};var JO;function YZ(r){JO=r.wasm.cwrap(Qs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ZZ(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=t,h=C.computeConv2DInfo(o.shape,s.shape,l,c,u,m),g=vl[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let x=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,_=0;if(a!=null){let ae=n.dataIdMap.get(a.dataId);if(ae.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ae.shape.length}.`);if(ae.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${ae.shape}) does not match the number of output channels (${w})`);_=ae.id}let I=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,O=h.padInfo.bottom,M=h.padInfo.left,G=h.dilationHeight,j=h.dilationWidth,U=h.strideHeight,H=h.strideWidth,q=h.inChannels,X=h.padInfo.type==="SAME"?1:0,ne=h.batchSize,Y=h.inHeight,re=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let Q=n.makeOutput(h.outShape,"float32"),ie=n.dataIdMap.get(Q.dataId).id,ce=i==null?0:n.dataIdMap.get(i.dataId).id;return JO(x,ne,Y,re,b,I,E,_,$,D,O,M,X,G,j,U,H,q,w,g,ce,d||0,ie),Q}var QO={kernelName:Qs,backendName:"wasm",setupFunc:YZ,kernelFunc:ZZ};var eP;function JZ(r){eP=r.wasm.cwrap(ei,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function QZ(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=t,h=C.computeConv2DInfo(o.shape,s.shape,l,c,u,m,!0),g=vl[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let x=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,_=0;if(a!=null){let ae=n.dataIdMap.get(a.dataId);if(ae.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ae.shape.length}.`);if(ae.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${ae.shape}) does not match the number of output channels (${w})`);_=ae.id}let I=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,O=h.padInfo.bottom,M=h.padInfo.left,G=h.dilationHeight,j=h.dilationWidth,U=h.strideHeight,H=h.strideWidth,q=h.inChannels,X=h.padInfo.type==="SAME"?1:0,ne=h.batchSize,Y=h.inHeight,re=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let Q=n.makeOutput(h.outShape,"float32"),ie=n.dataIdMap.get(Q.dataId).id,ce=i==null?0:n.dataIdMap.get(i.dataId).id;return eP(x,ne,Y,re,b,I,E,_,$,D,O,M,X,G,j,U,H,q,w,g,ce,d||0,ie),Q}var tP={kernelName:ei,backendName:"wasm",setupFunc:JZ,kernelFunc:QZ};var rP;function eJ(r){rP=r.wasm.cwrap(Li,null,["number","number","number","number","number","number","array","number"])}function tJ(r){let{backend:e,inputs:t}=r,{params:n,indices:o}=t,[s,a,i,l]=lg.prepareAndValidate(n,o),u=e.makeOutput(s,n.dtype);if(a===0)return u;let c=o.shape,p=c[c.length-1],f=e.dataIdMap.get(n.dataId).id,h=e.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(l).buffer),x=e.dataIdMap.get(u.dataId).id;return rP(f,Rt[n.dtype],h,a,p,i,g,x),u}var nP={kernelName:Li,backendName:"wasm",setupFunc:eJ,kernelFunc:tJ};var oP;function rJ(r){oP=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function nJ(r){let{backend:e,inputs:t,attrs:n}=r,{x:o,indices:s}=t,{axis:a,batchDims:i}=n,l=y.parseAxisParam(a,o.shape)[0],u=C.segment_util.collectGatherOpShapeInfo(o,s,l,i),c=Vr({inputs:{x:o},attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]},backend:e}),p=y.sizeFromShape(s.shape),m=Vr({inputs:{x:s},attrs:{shape:[u.batchSize,p/u.batchSize]},backend:e}),f=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize],d=e.makeOutput(f,o.dtype);if(y.sizeFromShape(o.shape)===0)return d;let h=c.shape.length-1,x=e.dataIdMap.get(c.dataId).id,w=e.dataIdMap.get(m.dataId).id,_=e.dataIdMap.get(d.dataId).id,I=new Uint8Array(new Int32Array(y.computeStrides(c.shape)).buffer),E=new Uint8Array(new Int32Array(y.computeStrides(f)).buffer);return oP(x,Rt[o.dtype],I,h,w,u.batchSize,E,_),e.disposeData(c.dataId),e.disposeData(m.dataId),d.shape=u.outputShape,d}var sP={kernelName:Gs,backendName:"wasm",setupFunc:rJ,kernelFunc:nJ};var oJ=!1,iP=yt(zi,oJ,"bool");var sJ=!1,aP=yt(Po,sJ,"bool");var lP;function iJ(r){lP=r.wasm.cwrap(Mo,null,["number","number","number"])}function aJ(r){let{inputs:{x:e},attrs:{alpha:t},backend:n}=r,o=n.dataIdMap.get(e.dataId).id,s=n.makeOutput(e.shape,e.dtype);if(y.sizeFromShape(e.shape)!==0){let a=n.dataIdMap.get(s.dataId).id;lP(o,t,a)}return s}var uP={kernelName:Mo,backendName:"wasm",setupFunc:iJ,kernelFunc:aJ};var lJ=!1,cP=yt(Wi,lJ,"bool");var uJ=!1,pP=yt(ji,uJ,"bool");var mP=xt(Lo);var cJ=!1,fP=yt(Hi,cJ,"bool");var dP;function pJ(r){dP=r.wasm.cwrap(zo,null,["number, number, number"])}function mJ(r){let{backend:e,inputs:t,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:a}=t,l=e.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=tn(a,o,e);if(f){let w=e.dataIdMap.get(c.dataId).id;u=c,l=w}let d=u.shape.length;C.assertAxesAreInnerMostDims("max",p,d);let[h,g]=C.computeOutAndReduceShapes(u.shape,p),x=y.sizeFromShape(g),b=e.makeOutput(h,a.dtype);if(y.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;dP(l,x,w)}if(f&&e.disposeData(c.dataId),s){let w=C.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var hP={kernelName:zo,backendName:"wasm",setupFunc:pJ,kernelFunc:mJ};var fJ=!1,gP=yt(Bo,fJ);var xP;function dJ(r){xP=r.wasm.cwrap(Vo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function hJ(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=t,c=C.computePool2DInfo(o.shape,a,i,1,l,u),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,x=c.dilationHeight,b=c.dilationWidth,w=c.strideHeight,_=c.strideWidth,I=c.inChannels,E=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let $=n.makeOutput(c.outShape,"float32"),D=n.dataIdMap.get($.dataId).id;return xP(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,x,b,w,_,I,E,D),$}var yP={kernelName:Vo,backendName:"wasm",setupFunc:dJ,kernelFunc:hJ};var bP;function gJ(r){bP=r.wasm.cwrap(Go,null,["number, number, number"])}function xJ(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,l=i,u=a,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=tn(a,o,e),d=p;if(f){let _=e.dataIdMap.get(c.dataId).id;_!==i&&(u=c,l=_,d=C.getInnerMostAxes(d.length,u.shape.length))}C.assertAxesAreInnerMostDims("mean",d,u.shape.length);let[h,g]=C.computeOutAndReduceShapes(u.shape,d),x=y.sizeFromShape(g),b=u;u.dtype!=="float32"&&(b=Gu({backend:e,inputs:{x:u},attrs:{dtype:"float32"}}),l=e.dataIdMap.get(b.dataId).id);let w=e.makeOutput(h,"float32");if(y.sizeFromShape(u.shape)!==0){let _=e.dataIdMap.get(w.dataId).id;bP(l,x,_)}if(f&&e.disposeData(c.dataId),s){let _=C.expandShapeToKeepDim(w.shape,m);w.shape=_}return u.dtype!=="float32"&&e.disposeData(b.dataId),w}var wP={kernelName:Go,backendName:"wasm",setupFunc:gJ,kernelFunc:xJ};var _P;function yJ(r){_P=r.wasm.cwrap(Wo,null,["number, number, number"])}function bJ(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,l=i,u=a,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=tn(a,o,e);if(f){let w=e.dataIdMap.get(c.dataId).id;w!==i&&(u=c,l=w)}let d=u.shape.length;C.assertAxesAreInnerMostDims("min",p,d);let[h,g]=C.computeOutAndReduceShapes(u.shape,p),x=y.sizeFromShape(g),b=e.makeOutput(h,u.dtype);if(y.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;_P(l,x,w)}if(f&&e.disposeData(c.dataId),s){let w=C.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var kP={kernelName:Wo,backendName:"wasm",setupFunc:yJ,kernelFunc:bJ};var wJ=!1,vP=yt(jo,wJ);var AC;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(AC||(AC={}));var CP;function _J(r){CP=r.wasm.cwrap(Uo,null,["number","array","number","number","array","array","number","number"])}function kJ(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,mode:o}}=r,s=n.map((d,h)=>d[0]+e.shape[h]+d[1]),a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),l=t.dataIdMap.get(i.dataId).id,u=new Uint8Array(new Int32Array(e.shape).buffer),c=n.map(d=>d[0]),p=n.map(d=>d[1]),m=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(p).buffer);return CP(a,u,e.shape.length,Rt[e.dtype],m,f,AC[o],l),i}var IP={kernelName:Uo,backendName:"wasm",kernelFunc:kJ,setupFunc:_J};var vJ=!0,NP=yt(Ho,vJ);var SP=xt(Ws);function $p(r,e){let t=new Int32Array(r.wasm.HEAPU8.buffer,e,4),n=t[0],o=t[1],s=t[2],a=t[3];return r.wasm._free(e),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:a}}var TP;function CJ(r){TP=r.wasm.cwrap(Xi,"number",["number","number","number","number","number"])}function IJ(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a}=n,{boxes:i,scores:l}=t,u=e.dataIdMap.get(i.dataId).id,c=e.dataIdMap.get(l.dataId).id,p=TP(u,c,s,o,a),{pSelectedIndices:m,selectedSize:f,pSelectedScores:d,pValidOutputs:h}=$p(e,p);return e.wasm._free(d),e.wasm._free(h),e.makeOutput([f],"int32",m)}var AP={kernelName:Xi,backendName:"wasm",setupFunc:CJ,kernelFunc:IJ};var EP;function NJ(r){EP=r.wasm.cwrap(Yi,"number",["number","number","number","number","number","bool"])}function SJ(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,padToMaxOutputSize:i}=n,{boxes:l,scores:u}=t,c=e.dataIdMap.get(l.dataId).id,p=e.dataIdMap.get(u.dataId).id,m=EP(c,p,s,o,a,i),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=$p(e,m);e.wasm._free(h);let x=e.makeOutput([d],"int32",f),b=e.makeOutput([],"int32",g);return[x,b]}var DP={kernelName:Yi,backendName:"wasm",setupFunc:NJ,kernelFunc:SJ};var $P;function TJ(r){$P=r.wasm.cwrap(Zi,"number",["number","number","number","number","number","number"])}function AJ(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,softNmsSigma:i}=n,{boxes:l,scores:u}=t,c=e.dataIdMap.get(l.dataId).id,p=e.dataIdMap.get(u.dataId).id,m=$P(c,p,s,o,a,i),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=$p(e,m);e.wasm._free(g);let x=e.makeOutput([d],"int32",f),b=e.makeOutput([d],"float32",h);return[x,b]}var RP={kernelName:Zi,backendName:"wasm",setupFunc:TJ,kernelFunc:AJ};var EJ=!1,FP=yt(Ki,EJ,"bool");var OP;function DJ(r){OP=r.wasm.cwrap(qo,null,["number","number","number","number","number"])}function $J(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:a,offValue:i}=n,l=t.makeOutput([...o.shape,s],"int32"),u=t.dataIdMap.get(l.dataId).id,p=t.dataIdMap.get(o.dataId).id;return OP(p,s,a,i,u),l}var PP={kernelName:qo,backendName:"wasm",setupFunc:DJ,kernelFunc:$J};function RJ(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(1),n}var MP={kernelName:js,backendName:"wasm",kernelFunc:RJ};function FJ(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return Cx({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{y.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],l=e.map(c=>{let p=Cx({inputs:{input:c},backend:t,attrs:{dim:o}});return i.push(p),p}),u=SC({inputs:l,backend:t,attrs:{axis:o}});return i.forEach(c=>t.disposeData(c.dataId)),u}var LP={kernelName:Us,backendName:"wasm",kernelFunc:FJ};var zP;function OJ(r){zP=r.wasm.cwrap(Ko,null,["number","array","number","number","array","array","number","number"])}function PJ(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,constantValue:o}}=r,s=n.map((d,h)=>d[0]+e.shape[h]+d[1]),a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),l=t.dataIdMap.get(i.dataId).id,u=new Uint8Array(new Int32Array(e.shape).buffer),c=n.map(d=>d[0]),p=n.map(d=>d[1]),m=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(p).buffer);return zP(a,u,e.shape.length,Rt[e.dtype],m,f,o,l),i}var BP={kernelName:Ko,backendName:"wasm",kernelFunc:PJ,setupFunc:OJ};var MJ=!1,VP=yt(Xo,MJ);var GP;function LJ(r){GP=r.wasm.cwrap(Yo,null,["number","number","number"])}function zJ(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,i=t.makeOutput(n.shape,"float32"),l=t.dataIdMap.get(i.dataId).id;return GP(s,a,l),i}var WP={kernelName:Yo,backendName:"wasm",setupFunc:LJ,kernelFunc:zJ};var jP;function BJ(r){jP=r.wasm.cwrap(Ji,null,["number","number","number","number"])}function VJ(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,l=i,u=a,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=tn(a,o,e),d=p;if(f){let w=e.dataIdMap.get(c.dataId).id;w!==i&&(u=c,l=w,d=C.getInnerMostAxes(d.length,u.shape.length))}C.assertAxesAreInnerMostDims("prod",d,u.shape.length);let[h,g]=C.computeOutAndReduceShapes(u.shape,d),x=y.sizeFromShape(g),b=e.makeOutput(h,u.dtype);if(y.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;jP(l,x,Rt[b.dtype],w)}if(f&&e.disposeData(c.dataId),s){let w=C.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var UP={kernelName:Ji,backendName:"wasm",setupFunc:BJ,kernelFunc:VJ};var GJ=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=Au(n,o,s,a),l=e.makeOutput([i.length],a);return e.typedArrayFromHeap(l).set(i),l},HP={kernelName:nl,backendName:"wasm",kernelFunc:GJ};var WJ=!0,qP=yt(Do,WJ);var KP=xt(Zo);var XP=xt(Qo);var YP;function jJ(r){YP=r.wasm.cwrap(Jo,null,["number","number","number","number","number","number","number","number","number","number"])}function UJ(r){let{backend:e,inputs:t,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[l,u]=i,[c,p,m,f]=o.shape,d=[c,l,u,f],h=e.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=Gu({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(g.dataId));let x=h.id,b=e.makeOutput(d,"float32");if(y.sizeFromShape(o.shape)===0)return b;let w=e.dataIdMap.get(b.dataId).id;return YP(x,c,p,m,f,l,u,s?1:0,a?1:0,w),g!=null&&e.disposeData(g.dataId),b}var ZP={kernelName:Jo,backendName:"wasm",setupFunc:jJ,kernelFunc:UJ};var JP;function HJ(r){JP=r.wasm.cwrap(es,null,["number","array","number","array","number","number"])}function qJ(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=y.parseAxisParam(s,o.shape);if(o.shape.length===0)return Vu({inputs:{x:o},backend:t});let i=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(a).buffer),p=new Uint8Array(new Int32Array(o.shape).buffer);JP(l,c,a.length,p,o.shape.length,u);let m=Vr({inputs:{x:i},attrs:{shape:o.shape},backend:t});return t.disposeData(i.dataId),m}var QP={kernelName:es,backendName:"wasm",kernelFunc:qJ,setupFunc:HJ};var eM;function KJ(r){eM=r.wasm.cwrap(aa,null,["number","number","number","number","number","number","number","number","array","number","number"])}function XJ(r){let{inputs:e,backend:t,attrs:n}=r,{image:o}=e,{radians:s,fillValue:a,center:i}=n,l=t.makeOutput(o.shape,o.dtype),u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,[p,m,f,d]=o.shape,[h,g]=C.getImageCenter(i,m,f),x=a===0,b=255,w=typeof a=="number"?[a,a,a,x?0:b]:[...a,b],_=new Uint8Array(new Int32Array(w).buffer);return eM(u,p,m,f,d,s,h,g,_,w.length,c),l}var tM={kernelName:aa,backendName:"wasm",kernelFunc:XJ,setupFunc:KJ};var rM=xt(ts);var nM=xt(rs);var oM;function YJ(r){oM=r.wasm.cwrap(ea,null,["number","number","number","number","number","number","array","number","number"])}function ZJ(r){let{backend:e,inputs:t,attrs:n}=r,{indices:o,updates:s}=t,{shape:a}=n,i=e.makeOutput(a,s.dtype);if(y.sizeFromShape(a)===0)return i;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:m}=ug.calculateShapes(s,o,a),d=e.dataIdMap.get(o.dataId).id,g=e.dataIdMap.get(s.dataId).id,x=new Uint8Array(new Int32Array(p).buffer),b=e.dataIdMap.get(i.dataId).id;return oM(d,g,Rt[s.dtype],l,u,c,x,m,b),i}var sM={kernelName:ea,backendName:"wasm",setupFunc:YJ,kernelFunc:ZJ};var iM;function JJ(r){iM=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function QJ(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=t.makeOutput(o.shape,o.dtype),c=t.dataIdMap.get(u.dataId).id,p=n.shape.length,m=o.shape.length,f=p===0||p>1||m===1?1:y.sizeFromShape(o.shape.slice(1));return iM(a,i,l,f,c),u}var aM={kernelName:qs,backendName:"wasm",kernelFunc:QJ,setupFunc:JJ};var lM;function eQ(r){lM=r.wasm.cwrap(os,null,["number","number"])}function tQ(r){let{backend:e,inputs:{x:t}}=r,n=e.dataIdMap.get(t.dataId).id,o=e.makeOutput(t.shape,t.dtype),s=e.dataIdMap.get(o.dataId).id;return y.sizeFromShape(o.shape)===0||lM(n,s),o}var uM={kernelName:"Sigmoid",backendName:"wasm",setupFunc:eQ,kernelFunc:tQ};var cM=xt(ns);function Wu(r){let{inputs:{x:e},attrs:{begin:t,size:n},backend:o}=r,[s,a]=rr.parseSliceParams(e,t,n),i=rr.isSliceContinous(e.shape,s,a),l=o.readSync(e.dataId),u=o.makeOutput(a,e.dtype),c=y.computeStrides(e.shape),p=o.dataIdMap.get(u.dataId);if(i){let d=rr.computeFlatOffset(s,c);return e.dtype==="string"?p.stringBytes=l.slice(d,d+y.sizeFromShape(a)):o.typedArrayFromHeap(u).set(l.subarray(d,d+y.sizeFromShape(a))),u}if(e.dtype==="string"){let d=Eu(l,s,a,e.shape,e.dtype);return p.stringBytes=d,u}let m=o.typedArrayFromHeap(u),f=e.shape.length;if(f===2)rQ(l,c[0],m,s,a);else if(f===3)nQ(l,c[0],c[1],m,s,a);else if(f===4)oQ(l,c[0],c[1],c[2],m,s,a);else{let d=Eu(l,s,a,e.shape,e.dtype);m.set(d)}return u}function rQ(r,e,t,n,o){let s=0,a=n[0],i=n[1],l=a+o[0];for(let u=a;u<l;u++){let c=u*e+i;t.set(r.subarray(c,c+o[1]),s),s+=o[1]}}function nQ(r,e,t,n,o,s){let a=0,i=o[0],l=o[1],u=o[2],c=i+s[0],p=l+s[1];for(let m=i;m<c;m++)for(let f=l;f<p;f++){let d=m*e+f*t+u;n.set(r.subarray(d,d+s[2]),a),a+=s[2]}}function oQ(r,e,t,n,o,s,a){let i=0,l=s[0],u=s[1],c=s[2],p=l+a[0],m=u+a[1],f=c+a[2],d=s[3];for(let h=l;h<p;h++)for(let g=u;g<m;g++)for(let x=c;x<f;x++){let b=h*e+g*t+x*n+d;o.set(r.subarray(b,b+a[3]),i),i+=a[3]}}var pM={kernelName:Ks,backendName:"wasm",kernelFunc:Wu};var mM;function sQ(r){mM=r.wasm.cwrap(as,null,["number","number","number","number"])}function iQ(r){let{backend:e,inputs:{logits:t},attrs:{dim:n}}=r,o=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),a=e.dataIdMap.get(s.dataId).id,i=t.shape[n],l=y.sizeFromShape(t.shape)/i;return y.sizeFromShape(s.shape)===0||mM(o,a,i,l),s}var fM={kernelName:as,backendName:"wasm",setupFunc:sQ,kernelFunc:iQ};function aQ(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=t,i=y.parseAxisParam(a,o.shape)[0],l=C.prepareSplitSize(o,s,i),u=new Array(o.shape.length).fill(0),c=o.shape.slice();return l.map(p=>{let m=[...c];m[i]=p;let f=Wu({inputs:{x:o},attrs:{begin:u,size:m},backend:n});return u[i]+=p,f})}var dM={kernelName:Xs,backendName:"wasm",kernelFunc:aQ};var hM=xt(ss);var gM=xt(il);var lQ=!0,xM=yt(ls,lQ);var yM;function uQ(r){yM=r.wasm.cwrap(Yn,null,["number","number","number"])}function cQ(r){let{backend:e,inputs:t,attrs:n}=r,{alpha:o}=n,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=e.makeOutput(s.shape,s.dtype),l=e.dataIdMap.get(i.dataId).id;return yM(a,o,l),i}var bM={kernelName:Yn,backendName:"wasm",setupFunc:uQ,kernelFunc:cQ};var wM;function pQ(r){wM=r.wasm.cwrap(sa,null,["number","array","number","array","array","array","array","array","number","number"])}function mQ(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{begin:s,end:a,strides:i}=n;i==null&&(i=new Array(s.length));let{beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,f=C.slice_util.maskToAxes(c);if(f.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(c!==0&&p!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(c!==0&&m!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let d=o.shape.length-s.length,h=C.slice_util.maskToAxes(p),g=o.shape.slice();h.forEach(G=>{s[G]=0,a[G]=1,g.splice(G,0,1)});let x=Vr({inputs:{x:o},attrs:{shape:g},backend:e}),{begin:b,end:w,strides:_}=C.slice_util.getNormalizedAxes(x.shape,f,d,s,a,i,l,u,c);s=b,a=w,i=_;let I=C.slice_util.maskToAxes(m);I.forEach(G=>{a[G]=s[G]+1,i[G]=1});let E=C.slice_util.computeOutShape(s,a,i),$=E.filter((G,j)=>I.indexOf(j)===-1);if(i.every(G=>G===1)){let G=Wu({inputs:{x},attrs:{begin:s,size:E},backend:e});e.disposeData(x.dataId);let j=Vr({inputs:{x:G},attrs:{shape:$},backend:e});return e.disposeData(G.dataId),j}let O=e.makeOutput($,"float32");if(!$.some(G=>G===0)){let G=e.dataIdMap.get(x.dataId).id,j=new Uint8Array(new Int32Array(y.computeStrides(x.shape)).buffer),U=new Uint8Array(new Int32Array(s).buffer),H=new Uint8Array(new Int32Array(a).buffer),q=new Uint8Array(new Int32Array(i).buffer),X=new Uint8Array(new Int32Array($).buffer),ne=new Uint8Array(new Int32Array(y.computeStrides($)).buffer),Y=e.dataIdMap.get(O.dataId).id;wM(G,j,x.shape.length,U,H,q,X,ne,$.length,Y)}e.disposeData(x.dataId);let M=Vr({inputs:{x:O},attrs:{shape:$},backend:e});return e.disposeData(O.dataId),M}var _M={kernelName:sa,backendName:"wasm",setupFunc:pQ,kernelFunc:mQ};var fQ=!0,kM=yt(us,fQ);var vM;function dQ(r){vM=r.wasm.cwrap(is,null,["number, number, number"])}function hQ(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,l=i,u=a,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=tn(a,o,e),d=p;if(f){let w=e.dataIdMap.get(c.dataId).id;w!==i&&(u=c,l=w,d=C.getInnerMostAxes(d.length,u.shape.length))}C.assertAxesAreInnerMostDims("sum",d,u.shape.length);let[h,g]=C.computeOutAndReduceShapes(u.shape,d),x=y.sizeFromShape(g),b=e.makeOutput(h,u.dtype);if(y.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(b.dataId).id;vM(l,x,w)}if(f&&e.disposeData(c.dataId),s){let w=C.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var CM={kernelName:is,backendName:"wasm",setupFunc:dQ,kernelFunc:hQ};var IM=xt(cs);var NM=xt(ps);var SM;function gQ(r){SM=r.wasm.cwrap(Pn,null,["number","array","number","array","number","number"])}function xQ(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,s=t.dataIdMap.get(o.dataId).id,{reps:a}=n,i=new Array(o.shape.length);for(let m=0;m<i.length;m++)i[m]=o.shape[m]*a[m];let l=new Uint8Array(new Int32Array(o.shape).buffer),u=new Uint8Array(new Int32Array(i).buffer),c=t.makeOutput(i,o.dtype),p=t.dataIdMap.get(c.dataId).id;return SM(s,l,o.shape.length,u,i.length,Rt[c.dtype],p),c}var TM={kernelName:Pn,backendName:"wasm",setupFunc:gQ,kernelFunc:xQ};var AM;function yQ(r){AM=r.wasm.cwrap(ia,null,["number","array","number","number","number","bool","number","number"])}var bQ=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{k:o,sorted:s}=t,a=e.dataIdMap.get(n.dataId).id,i=new Uint8Array(new Int32Array(n.shape).buffer),l=n.shape.slice();l[l.length-1]=o;let u=e.makeOutput(l,n.dtype),c=e.dataIdMap.get(u.dataId).id,p=e.makeOutput(l,"int32"),m=e.dataIdMap.get(p.dataId).id;return AM(a,i,n.shape.length,Rt[n.dtype],o,s,c,m),[u,p]},EM={kernelName:ia,backendName:"wasm",setupFunc:yQ,kernelFunc:bQ};function wQ(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape[s],i=o.shape.length,l=new Array(i-1),u=0;for(let f=0;f<i;f++)f!==s&&(l[u++]=o.shape[f]);let c=new Array(a),p=new Array(i).fill(0),m=o.shape.slice();m[s]=1;for(let f=0;f<c.length;f++)p[s]=f,c[f]=Wu({inputs:{x:o},attrs:{begin:p,size:m},backend:t});return c.map(({dataId:f,dtype:d})=>({dataId:f,dtype:d,shape:l}))}var DM={kernelName:Ys,backendName:"wasm",kernelFunc:wQ};function _Q(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(0),n}var $M={kernelName:Zs,backendName:"wasm",kernelFunc:_Q};var kQ=[iO,aO,uO,dO,gO,yO,wO,vO,CO,IO,SO,TO,EO,$O,RO,OO,MO,zO,VO,GO,WO,jO,UO,qO,KO,XO,sO,ZO,QO,tP,nP,sP,iP,aP,cO,uP,cP,pP,mP,fP,hP,gP,yP,wP,kP,vP,IP,NP,SP,AP,DP,RP,FP,PP,MP,LP,BP,VP,WP,UP,HP,qP,KP,XP,_O,ZP,QP,tM,nM,rM,sM,aM,uM,cM,pM,fM,dM,hM,gM,xM,bM,_M,kM,CM,IM,NM,TM,EM,mO,DM,$M];for(let r of kQ)Hl(r);var EC=W();EC.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));EC.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(EC.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(r){return!1}});var OC=pc(OM());var PM='var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}';var LM=pc(MM());var Sx=class extends Ps{constructor(e){super();this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.init(),this.dataIdMap=new qa(this,hs())}write(e,t,n){let o={id:this.dataIdNextNumber++};return this.move(o,e,t,n,1),o}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=y.now();return e(),{kernelMs:y.now()-t}}move(e,t,n,o,s){let a=this.dataIdNextNumber++;if(o==="string"){let c=t;this.dataIdMap.set(e,{id:a,stringBytes:c,shape:n,dtype:o,memoryOffset:null,refCount:s});return}let i=y.sizeFromShape(n),l=i*y.bytesPerElement(o),u=this.wasm._malloc(l);this.dataIdMap.set(e,{id:a,memoryOffset:u,shape:n,dtype:o,refCount:s}),this.wasm.tfjs.registerTensor(a,i,u),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,l),u)}async read(e){return this.readSync(e)}readSync(e){let{memoryOffset:t,dtype:n,shape:o,stringBytes:s}=this.dataIdMap.get(e);if(n==="string")return s;let a=this.wasm.HEAPU8.slice(t,t+y.sizeFromShape(o)*y.bytesPerElement(n));return vQ(a.buffer,n)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let o;if(n==null)o=this.write(null,e,t);else{let s=this.dataIdNextNumber++;o={id:s},this.dataIdMap.set(o,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let a=y.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,a,n)}return{dataId:o,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let o=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),a=y.sizeFromShape(e);switch(t){case"float32":return new Float32Array(o,s,a);case"int32":return new Int32Array(o,s,a);case"bool":return new Uint8Array(o,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function CQ(r){return(e,t)=>(y.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||e.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,e).then(s=>{t(s.instance,s.module)})})}),{})}function zM(r,e,t){if(Tx!=null)return Tx;let n="tfjs-backend-wasm.wasm";return r&&e?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),Wf!=null&&Wf[n]!=null?Wf[n]:t+n}async function BM(){let[r,e]=await Promise.all([W().getAsync("WASM_HAS_SIMD_SUPPORT"),W().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,n)=>{let o={};o.locateFile=(i,l)=>{if(i.endsWith(".worker.js")){let u=PM,c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return i.endsWith(".wasm")?zM(r,e,jf!=null?jf:l):l+i},PC&&(o.instantiateWasm=CQ(zM(r,e,jf!=null?jf:"")));let s=!1;o.onAbort=()=>{if(s||Uf)return;Uf=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let a;e&&r&&Tx==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+OC.default.toString()],{type:"text/javascript"}),a=(0,OC.default)(o)):a=(0,LM.default)(o),a.then(i=>{s=!0,Uf=!1;let l=null;i.tfjs={init:i.cwrap("init",null,[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",l,["number"]),dispose:i.cwrap("dispose",l,[])},t({wasm:i})})})}function vQ(r,e){switch(e){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${e}`)}}var IQ=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Tx=null,jf=null,Wf={},Uf=!1,PC=!1;function NQ(r,e=!1){if(Pw("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Uf)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Tx=r,PC=e}function SQ(r,e=!1){if(Uf)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")jf=r;else{Wf=r;let t=IQ.filter(n=>Wf[n]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}PC=e}var MC="3.5.0";var TQ=2;Qc("wasm",async()=>{let{wasm:r}=await BM();return new Sx(r)},TQ);F().prototype.abs=function(){return this.throwIfDisposed(),Nt(this)};F().prototype.acos=function(){return this.throwIfDisposed(),zm(this)};F().prototype.acosh=function(){return this.throwIfDisposed(),Bm(this)};F().prototype.add=function(r){return this.throwIfDisposed(),ee(this,r)};F().prototype.all=function(r,e){return this.throwIfDisposed(),Ql(this,r,e)};F().prototype.any=function(r,e){return this.throwIfDisposed(),ml(this,r,e)};F().prototype.argMax=function(r){return this.throwIfDisposed(),fl(this,r)};F().prototype.argMin=function(r){return this.throwIfDisposed(),Vm(this,r)};F().prototype.asScalar=function(){return this.throwIfDisposed(),T(this.size===1,()=>"The array must have only 1 element."),L(this,[])};F().prototype.asType=function(r){return this.throwIfDisposed(),oe(this,r)};F().prototype.as1D=function(){return this.throwIfDisposed(),L(this,[this.size])};F().prototype.as2D=function(r,e){return this.throwIfDisposed(),L(this,[r,e])};F().prototype.as3D=function(r,e,t){return this.throwIfDisposed(),L(this,[r,e,t])};F().prototype.as4D=function(r,e,t,n){return this.throwIfDisposed(),L(this,[r,e,t,n])};F().prototype.as5D=function(r,e,t,n,o){return this.throwIfDisposed(),L(this,[r,e,t,n,o])};F().prototype.asin=function(){return this.throwIfDisposed(),Gm(this)};F().prototype.asinh=function(){return this.throwIfDisposed(),Wm(this)};F().prototype.atan=function(){return this.throwIfDisposed(),jm(this)};F().prototype.atan2=function(r){return this.throwIfDisposed(),Um(this,r)};F().prototype.atanh=function(){return this.throwIfDisposed(),Hm(this)};F().prototype.avgPool=function(r,e,t,n){return this.throwIfDisposed(),fa(this,r,e,t,n)};F().prototype.batchToSpaceND=function(r,e){return this.throwIfDisposed(),da(this,r,e)};F().prototype.batchNorm=function(r,e,t,n,o){return this.throwIfDisposed(),Jn(this,r,e,t,n,o)};F().prototype.broadcastTo=function(r){return this.throwIfDisposed(),ha(this,r)};F().prototype.cast=function(r){return this.throwIfDisposed(),oe(this,r)};F().prototype.ceil=function(){return this.throwIfDisposed(),Km(this)};F().prototype.clipByValue=function(r,e){return this.throwIfDisposed(),lr(this,r,e)};F().prototype.concat=function(r,e){return this.throwIfDisposed(),r instanceof Pe&&(r=[r]),Qe([this,...r],e)};F().prototype.conv1d=function(r,e,t,n,o,s){return this.throwIfDisposed(),ru(this,r,e,t,n,o,s)};F().prototype.conv2dTranspose=function(r,e,t,n,o){return this.throwIfDisposed(),nu(this,r,e,t,n,o)};F().prototype.conv2d=function(r,e,t,n,o,s){return this.throwIfDisposed(),Jr(this,r,e,t,n,o,s)};F().prototype.cos=function(){return this.throwIfDisposed(),ga(this)};F().prototype.cosh=function(){return this.throwIfDisposed(),ou(this)};F().prototype.cumsum=function(r,e,t){return this.throwIfDisposed(),su(this,r,e,t)};F().prototype.depthToSpace=function(r,e){return this.throwIfDisposed(),Ym(this,r,e)};F().prototype.depthwiseConv2d=function(r,e,t,n,o,s){return this.throwIfDisposed(),xs(this,r,e,t,n,o,s)};F().prototype.dilation2d=function(r,e,t,n,o){return this.throwIfDisposed(),Zm(this,r,e,t,n,o)};F().prototype.divNoNan=function(r){return this.throwIfDisposed(),Jm(this,r)};F().prototype.div=function(r){return this.throwIfDisposed(),me(this,r)};F().prototype.dot=function(r){return this.throwIfDisposed(),Zw(this,r)};F().prototype.elu=function(){return this.throwIfDisposed(),ys(this)};F().prototype.equal=function(r){return this.throwIfDisposed(),Nn(this,r)};F().prototype.erf=function(){return this.throwIfDisposed(),Qm(this)};F().prototype.exp=function(){return this.throwIfDisposed(),Jt(this)};F().prototype.expandDims=function(r){return this.throwIfDisposed(),ur(this,r)};F().prototype.expm1=function(){return this.throwIfDisposed(),ef(this)};F().prototype.fft=function(){return this.throwIfDisposed(),Ca(this)};F().prototype.flatten=function(){return this.throwIfDisposed(),L(this,[this.size])};F().prototype.floor=function(){return this.throwIfDisposed(),bs(this)};F().prototype.floorDiv=function(r){return this.throwIfDisposed(),Jl(this,r)};F().prototype.gather=function(r,e){return this.throwIfDisposed(),Qn(this,r,e)};F().prototype.greaterEqual=function(r){return this.throwIfDisposed(),hn(this,r)};F().prototype.greater=function(r){return this.throwIfDisposed(),nr(this,r)};F().prototype.ifft=function(){return this.throwIfDisposed(),oi(this)};F().prototype.irfft=function(){return this.throwIfDisposed(),yu(this)};F().prototype.isFinite=function(){return this.throwIfDisposed(),Qw(this)};F().prototype.isInf=function(){return this.throwIfDisposed(),e_(this)};F().prototype.isNaN=function(){return this.throwIfDisposed(),tf(this)};F().prototype.leakyRelu=function(r){return this.throwIfDisposed(),ya(this,r)};F().prototype.lessEqual=function(r){return this.throwIfDisposed(),Bn(this,r)};F().prototype.less=function(r){return this.throwIfDisposed(),au(this,r)};F().prototype.localResponseNormalization=function(r,e,t,n){return this.throwIfDisposed(),rf(this,r,e,t,n)};F().prototype.logSigmoid=function(){return this.throwIfDisposed(),r_(this)};F().prototype.logSoftmax=function(r){return this.throwIfDisposed(),uu(this,r)};F().prototype.logSumExp=function(r,e){return this.throwIfDisposed(),of(this,r,e)};F().prototype.log=function(){return this.throwIfDisposed(),cr(this)};F().prototype.log1p=function(){return this.throwIfDisposed(),lu(this)};F().prototype.logicalAnd=function(r){return this.throwIfDisposed(),yr(this,r)};F().prototype.logicalNot=function(){return this.throwIfDisposed(),ba(this)};F().prototype.logicalOr=function(r){return this.throwIfDisposed(),cu(this,r)};F().prototype.logicalXor=function(r){return this.throwIfDisposed(),i_(this,r)};F().prototype.matMul=function(r,e,t){return this.throwIfDisposed(),ze(this,r,e,t)};F().prototype.maxPool=function(r,e,t,n){return this.throwIfDisposed(),wa(this,r,e,t,n)};F().prototype.max=function(r,e){return this.throwIfDisposed(),pr(this,r,e)};F().prototype.maximum=function(r){return this.throwIfDisposed(),en(this,r)};F().prototype.mean=function(r,e){return this.throwIfDisposed(),dt(this,r,e)};F().prototype.min=function(r,e){return this.throwIfDisposed(),ni(this,r,e)};F().prototype.minimum=function(r){return this.throwIfDisposed(),ws(this,r)};F().prototype.mirrorPad=function(r,e){return this.throwIfDisposed(),af(this,r,e)};F().prototype.mod=function(r){return this.throwIfDisposed(),lf(this,r)};F().prototype.mul=function(r){return this.throwIfDisposed(),P(this,r)};F().prototype.neg=function(){return this.throwIfDisposed(),qe(this)};F().prototype.norm=function(r,e,t){return this.throwIfDisposed(),lp(this,r,e,t)};F().prototype.notEqual=function(r){return this.throwIfDisposed(),ro(this,r)};F().prototype.oneHot=function(r,e=1,t=0){return this.throwIfDisposed(),ds(this,r,e,t)};F().prototype.onesLike=function(){return this.throwIfDisposed(),or(this)};F().prototype.pad=function(r,e){return this.throwIfDisposed(),Lr(this,r,e)};F().prototype.pool=function(r,e,t,n,o){return this.throwIfDisposed(),u_(this,r,e,t,n,o)};F().prototype.pow=function(r){return this.throwIfDisposed(),zr(this,r)};F().prototype.prelu=function(r){return this.throwIfDisposed(),ka(this,r)};F().prototype.prod=function(r,e){return this.throwIfDisposed(),pu(this,r,e)};F().prototype.reciprocal=function(){return this.throwIfDisposed(),uf(this)};F().prototype.relu=function(){return this.throwIfDisposed(),Dr(this)};F().prototype.relu6=function(){return this.throwIfDisposed(),fu(this)};F().prototype.reshapeAs=function(r){return this.throwIfDisposed(),L(this,r.shape)};F().prototype.reshape=function(r){return this.throwIfDisposed(),L(this,r)};F().prototype.resizeBilinear=function(r,e,t){return this.throwIfDisposed(),Dg(this,r,e,t)};F().prototype.resizeNearestNeighbor=function(r,e,t){return this.throwIfDisposed(),$g(this,r,e,t)};F().prototype.reverse=function(r){return this.throwIfDisposed(),qt(this,r)};F().prototype.rfft=function(){return this.throwIfDisposed(),Ia(this)};F().prototype.round=function(){return this.throwIfDisposed(),cf(this)};F().prototype.rsqrt=function(){return this.throwIfDisposed(),du(this)};F().prototype.selu=function(){return this.throwIfDisposed(),hu(this)};F().prototype.separableConv2d=function(r,e,t,n,o,s){return this.throwIfDisposed(),pf(this,r,e,t,n,o,s)};F().prototype.sigmoid=function(){return this.throwIfDisposed(),Er(this)};F().prototype.sign=function(){return this.throwIfDisposed(),mf(this)};F().prototype.sin=function(){return this.throwIfDisposed(),gu(this)};F().prototype.sinh=function(){return this.throwIfDisposed(),xu(this)};F().prototype.slice=function(r,e){return this.throwIfDisposed(),Fe(this,r,e)};F().prototype.softmax=function(r){return this.throwIfDisposed(),va(this,r)};F().prototype.softplus=function(){return this.throwIfDisposed(),eo(this)};F().prototype.spaceToBatchND=function(r,e){return this.throwIfDisposed(),_a(this,r,e)};F().prototype.split=function(r,e){return this.throwIfDisposed(),mr(this,r,e)};F().prototype.sqrt=function(){return this.throwIfDisposed(),gt(this)};F().prototype.square=function(){return this.throwIfDisposed(),Me(this)};F().prototype.squaredDifference=function(r){return this.throwIfDisposed(),bu(this,r)};F().prototype.squeeze=function(r){return this.throwIfDisposed(),Sn(this,r)};F().prototype.stack=function(r,e){this.throwIfDisposed();let t=r instanceof Pe?[this,r]:[this,...r];return Bt(t,e)};F().prototype.step=function(r){return this.throwIfDisposed(),ks(this,r)};F().prototype.stridedSlice=function(r,e,t,n,o,s,a,i){return this.throwIfDisposed(),hf(this,r,e,t,n,o,s,a,i)};F().prototype.sub=function(r){return this.throwIfDisposed(),pe(this,r)};F().prototype.sum=function(r,e){return this.throwIfDisposed(),ge(this,r,e)};F().prototype.tan=function(){return this.throwIfDisposed(),gf(this)};F().prototype.tanh=function(){return this.throwIfDisposed(),gs(this)};F().prototype.tile=function(r){return this.throwIfDisposed(),zn(this,r)};F().prototype.toBool=function(){return this.throwIfDisposed(),oe(this,"bool")};F().prototype.toFloat=function(){return this.throwIfDisposed(),oe(this,"float32")};F().prototype.toInt=function(){return this.throwIfDisposed(),oe(this,"int32")};F().prototype.topk=function(r,e){return this.throwIfDisposed(),xf(this,r,e)};F().prototype.transpose=function(r){return this.throwIfDisposed(),Ue(this,r)};F().prototype.unique=function(r){return this.throwIfDisposed(),ap(this,r)};F().prototype.unsortedSegmentSum=function(r,e){return this.throwIfDisposed(),yf(this,r,e)};F().prototype.unstack=function(r){return this.throwIfDisposed(),fr(this,r)};F().prototype.where=function(r,e){return this.throwIfDisposed(),Dt(r,this,e)};F().prototype.zerosLike=function(){return this.throwIfDisposed(),Ie(this)};var Ax={kernelName:zs,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,ks(oe(t,"float32"),-1))}}};var VM={kernelName:_i,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Me(oe(t,"float32")),o=gt(pe(le(1),n));return qe(me(r,o))}}}};var GM={kernelName:ki,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=gt(pe(Me(oe(t,"float32")),1));return me(r,n)}}}};var WM={kernelName:On,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Be(t.shape,n.shape);return{a:()=>{let i=r,l=kt(t.shape,o);return l.length>0&&(i=ge(i,l)),L(i,t.shape)},b:()=>{let i=r,l=kt(n.shape,o);return l.length>0&&(i=ge(i,l)),L(i,n.shape)}}}};var jM={kernelName:_o,saveAllInputs:!0,gradFunc:(r,e)=>{let t={};return e.forEach((n,o)=>{t[o]=()=>r.clone()}),t}};var UM={kernelName:ko,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>Ie(t)}}};var HM={kernelName:Ka,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>Ie(t)}}};var qM={kernelName:Ii,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>me(r,gt(pe(le(1),Me(oe(t,"float32")))))}}};var KM={kernelName:Ni,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=gt(ee(le(1),Me(oe(t,"float32"))));return me(r,n)}}}};var XM={kernelName:Ai,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Be(t.shape,n.shape);return{a:()=>{let i=ee(Me(t),Me(n)),l=P(r,me(n,i)),u=kt(t.shape,o);return u.length>0&&(l=ge(l,u)),L(l,t.shape)},b:()=>{let i=ee(Me(t),Me(n)),l=qe(P(r,me(t,i))),u=kt(n.shape,o);return u.length>0&&(l=ge(l,u)),L(l,n.shape)}}}};var YM={kernelName:Si,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>me(r,ee(Me(oe(t,"float32")),1))}}};var ZM={kernelName:Ti,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>me(r,pe(le(1),Me(oe(t,"float32"))))}}};function AQ(r,e,t,n,o,s){let a=k(r,"dy","avgPool3dGrad"),i=k(e,"input","avgPool3dGrad"),l=a,u=i,c=!1;i.rank===4&&(c=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),T(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),T(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),s!=null&&T(ot(o),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${s} but got pad ${o}.`);let p={dy:l,input:u},m={filterSize:t,strides:n,pad:o,dimRoundingMode:s},f=A.runKernel(xc,p,m);return c?L(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var JM=S({avgPool3dGrad_:AQ});var QM={kernelName:Xa,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:a,dimRoundingMode:i}=t;return{x:()=>JM(r,n,o,s,a,i)}}};function EQ(r,e,t,n,o){let s=k(r,"dy","avgPoolGrad"),a=k(e,"input","avgPoolGrad");T(a.rank===s.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`);let i=a,l=s,u=!1;a.rank===3&&(u=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),T(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),T(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let c={dy:l,input:i},p={filterSize:t,strides:n,pad:o},m=A.runKernel(gc,c,p);return u?L(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var eL=S({avgPoolGrad_:EQ});var tL={kernelName:vo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:a}=t;return{x:()=>eL(r,n,o,s,a)}}};var rL={kernelName:Co,inputsToSave:["a","b"],gradFunc:(r,e,t)=>{let[n,o]=e,{transposeA:s,transposeB:a}=t;return!s&&!a?{a:()=>ze(r,o,!1,!0),b:()=>ze(n,r,!0,!1)}:!s&&a?{a:()=>ze(r,o,!1,!1),b:()=>ze(r,n,!0,!1)}:s&&!a?{a:()=>ze(o,r,!1,!0),b:()=>ze(n,r,!1,!1)}:{a:()=>ze(o,r,!0,!0),b:()=>ze(r,n,!0,!0)}}};var nL={kernelName:Ya,gradFunc:(r,e,t)=>{let{blockShape:n,crops:o}=t;return{x:()=>_a(r,n,o)}}};var oL={kernelName:vS,gradFunc:(r,e,t)=>{let n=t,o=n.inputShape,s=n.shape,a=Array.from(s);for(let l=o.length-1;l>=0;l--)if(o[l]===s[l])a[l]=1;else if(o[l]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let i=[];for(let l=0;l<a.length;l++)a[l]>1&&i.push(l);return{x:()=>ge(r,i,!0)}}};var sL={kernelName:qn,gradFunc:r=>({x:()=>r.clone()})};var iL={kernelName:Io,gradFunc:r=>({x:()=>Ie(r)})};var aL={kernelName:Kn,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{clipValueMin:o,clipValueMax:s}=t;return{x:()=>Dt(yr(hn(n,o),Bn(n,s)),r,Ie(r))}}};var lL={kernelName:Za,inputsToSave:["x"],gradFunc:Ax.gradFunc};var uL={kernelName:Bs,saveAllInputs:!0,gradFunc:(r,e,t)=>{let n=e.map(l=>l.shape),{axis:o}=t,s=tr(o,e[0].shape)[0],a=n.map(l=>l[s]);return mr(r,a,s).map(l=>()=>l)}};var cL={kernelName:No,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{dilations:s,strides:a,pad:i,dataFormat:l}=t;return T(Ln(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>tp(n.shape,r,o,a,i,l),filter:()=>up(n,r,o.shape,a,i,l)}}};var pL={kernelName:So,inputsToSave:["dy","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{strides:s,pad:a,dataFormat:i,dimRoundingMode:l}=t;return{dy:()=>Jr(r,o,s,a,i,1,l),filter:()=>up(r,n,o.shape,s,a,i,l)}}};function DQ(r,e,t,n,o){let s=r;r.rank===4&&(s=L(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let a=e;a.rank===4&&(a=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),T(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),T(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),T(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),T(s.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${t[3]}.`),T(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);let i={x:s,dy:a},l={strides:n,pad:o,filterShape:t};return A.runKernel(_c,i,l)}var mL=S({conv3DBackpropFilter_:DQ});var fL={kernelName:Ja,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s}=t;T(Ln(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[a,i]=e;return{x:()=>dg(a.shape,r,i,o,s),filter:()=>mL(a,r,i.shape,o,s)}}};var dL={kernelName:To,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(qe(gu(oe(t,"float32"))),r)}}};var hL={kernelName:Ei,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(xu(oe(t,"float32")),r)}}};var gL={kernelName:Ao,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o,exclusive:s,reverse:a}=t;return{x:()=>{let i=s_([o],n.rank),l=su(r,o,s,!a);return i!=null&&(l=Ue(l,i)),l}}}};var xL={kernelName:Eo,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:a}=t,i=n==null?[1,1]:n;T(Ln(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[l,u]=e;return T(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),T(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),T(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),T(vr(o,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${i}'.`),a!=null&&T(ot(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),{x:()=>Ig(l.shape,r,u,o,s,n,a),filter:()=>Cg(l,r,u.shape,o,s,n,a)}}};var yL={kernelName:Qa,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,s={x:n,filter:o,dy:r},a={x:n,filter:o,dy:r};return{x:()=>A.runKernel(Tm,s,t),filter:()=>A.runKernel(Am,a,t)}}};var bL={kernelName:Ri,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e,n={dy:r,y:t};return{x:()=>A.runKernel(Tc,n)}}};var wL={kernelName:Fi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=P(Jt(qe(Me(t))),2/Math.sqrt(Math.PI));return{x:()=>P(r,n)}}};var _L={kernelName:$o,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,t)}}};var kL={kernelName:Vs,inputsToSave:["input"],gradFunc:(r,e)=>{let[t]=e;return{input:()=>L(r,t.shape)}}};var vL={kernelName:Pi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,Jt(t))}}};var CL={kernelName:Ro,gradFunc:r=>({x:()=>Ie(r)})};var IL={kernelName:Fo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Be(t.shape,n.shape);return{a:()=>{let i=me(r,oe(n,"float32")),l=kt(t.shape,o);return l.length>0?L(ge(i,l),t.shape):i},b:()=>{let i=P(r,oe(t,"float32")),l=kt(n.shape,o);l.length>0&&(i=L(ge(i,l),n.shape));let u=Me(n);return qe(me(i,oe(u,"float32")))}}}};var NL={kernelName:Oo,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,e,t)=>{let{varianceEpsilon:n}=t,[o,s,a,i]=e,l=i==null?le(1):i,u=kt(s.shape,o.shape),c=[];if(s.rank===1){for(let _=0;_<o.shape.length-1;++_)c.push(o.shape[_]);c.push(1)}let p=pe(o,s),m=P(r,l),f=du(ee(a,le(n))),d=P(P(P(f,f),f),le(-.5));return{x:()=>s.rank===1?L(P(P(r,zn(L(f,[1,1,1,s.shape[0]]),c)),l),o.shape):L(P(P(r,f),l),o.shape),mean:()=>{let _=P(P(f,le(-1)),m);return s.rank===1&&(_=ge(_,u)),L(_,s.shape)},variance:()=>{let _=P(P(d,p),m);return s.rank===1&&(_=ge(_,u)),L(_,s.shape)},scale:()=>{let _=P(p,f),I=P(r,_);return s.rank===1&&(I=ge(I,u)),L(I,s.shape)},offset:()=>{let _=r;return s.rank===1&&(_=ge(_,u)),L(_,s.shape)}}}};var AL={kernelName:Gs,inputsToSave:["x","indices"],gradFunc:(r,e,t)=>{let[n,o]=e,{axis:s}=t,a=tr(s,n.shape)[0];return{x:()=>{let l=n.shape,u=o.size,c=l.slice(0,a),p=c.length,m=l.slice(s,l.length).slice(1),f=m.length,d=SL(0,p),h=SL(p+1,p+1+f),g=TL([c,[u],m]),x=L(r,g),b=L(o,[u]),w=TL([[p],d,h]),_=Ue(x,w),I=yf(_,b,n.shape[a]),E=nf(w);return I=Ue(I,E),I},indices:()=>o}}};function SL(r,e){let t=[];for(let n=r;n<e;++n)t.push(n);return t}function TL(r){let e=[];for(let t=0;t<r.length;++t)for(let n=0;n<r[t].length;++n)e.push(r[t][n]);return e}var EL={kernelName:Po,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>Ie(t),b:()=>Ie(n)}}};var DL={kernelName:Xn,gradFunc:r=>({x:()=>oe(r,"float32")})};var $L={kernelName:Bi,gradFunc:r=>({x:()=>Ie(r)})};var RL={kernelName:Vi,gradFunc:r=>({x:()=>Ie(r)})};var FL={kernelName:Gi,gradFunc:r=>({x:()=>Ie(r)})};var OL={kernelName:Mo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{alpha:o}=t,s=nr(n,0);return{x:()=>Dt(s,r,P(r,o))}}};var PL={kernelName:Ui,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>me(r,ee(t,1))}}};var ML={kernelName:Lo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>me(r,oe(t,"float32"))}}};var LL={kernelName:CS,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t;return{logits:()=>{let s=!0,a=Jt(n);return pe(r,P(ge(r,o,s),a))}}}};function $Q(r,e,t,n=5,o=1,s=1,a=.5){let i={x:r,y:e,dy:t},l={depthRadius:n,bias:o,alpha:s,beta:a};return A.runKernel(Rc,i,l)}var zL=S({localResponseNormalizationBackprop_:$Q});var BL={kernelName:tl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{depthRadius:s,bias:a,alpha:i,beta:l}=t;return{x:()=>zL(n,o,r,s,a,i,l)}}};function Ex(r,e,t,n){return e.rank<t.rank&&(e=L(e,to(e.shape,n))),r.rank<t.rank&&(r=L(r,to(r.shape,n))),{x:()=>P(r,oe(Nn(t,e),r.dtype))}}var LC={kernelName:zo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{reductionIndices:o}=n,s=e[0],a=e[1],i=tr(o,s.shape),l=Ex(r,a,s,i);return{x:()=>l.x()}}};var VL={kernelName:Bo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>P(r,oe(hn(t,n),"float32")),b:()=>P(r,oe(au(t,n),"float32"))}}};function RQ(r,e,t,n,o,s,a){let i=k(r,"dy","maxPool3dGrad"),l=k(e,"input","maxPool3dGrad"),u=k(t,"output","maxPool3dGrad"),c=i,p=l,m=u,f=!1;l.rank===4&&(f=!0,c=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),p=L(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),m=L(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),T(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),T(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),T(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),a!=null&&T(ot(s),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let d={dy:c,input:p,output:m},h={filterSize:n,strides:o,pad:s,dimRoundingMode:a},g=A.runKernel(Oc,d,h);return f?L(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var GL=S({maxPool3dGrad_:RQ});var WL={kernelName:rl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:l}=t;return{x:()=>GL(r,n,o,s,a,i,l)}}};function FQ(r,e,t,n,o,s,a){let i=k(r,"dy","maxPoolGrad"),l=k(e,"input","maxPoolGrad"),u=k(t,"output","maxPoolGrad");T(l.rank===i.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`),T(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),T(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),a!=null&&T(ot(s),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let c={dy:i,input:l,output:u},p={filterSize:n,strides:o,pad:s,dimRoundingMode:a};return A.runKernel(Fc,c,p)}var jL=S({maxPoolGrad_:FQ});var UL={kernelName:Vo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:a,pad:i}=t;return{x:()=>jL(r,n,o,s,a,i)}}};var HL={kernelName:Go,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t,s=tr(o,n.shape),i=o_(n.shape,s)[1],l=nt(i);return{x:()=>{let c=n.shape.slice();s.forEach(f=>{c[f]=1});let p=L(r,c);return me(P(p,Qt(n.shape,"float32")),l)}}}};var qL={kernelName:Wo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{axis:o}=n,[s,a]=e,i=tr(o,s.shape),l=Ex(r,a,s,i);return{x:()=>l.x()}}};var KL={kernelName:jo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>P(r,oe(Bn(t,n),"float32")),b:()=>P(r,oe(nr(t,n),"float32"))}}};var XL={kernelName:Uo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(a=>a[0]);return{x:()=>Fe(r,s,n.shape)}}};var YL={kernelName:qi,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Be(t.shape,n.shape);return{a:()=>{let i=kt(t.shape,o);return i.length>0?L(ge(r,i),t.shape):r},b:()=>{let i=P(r,qe(bs(me(t,n)))),l=kt(n.shape,o);return l.length>0?L(ge(i,l),n.shape):i}}}};var ZL={kernelName:Ho,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Be(t.shape,n.shape);return{a:()=>{let i=P(r,oe(n,"float32")),l=kt(t.shape,o);return l.length>0?L(ge(i,l),t.shape):i},b:()=>{let i=P(r,oe(t,"float32")),l=kt(n.shape,o);return l.length>0?L(ge(i,l),n.shape):i}}}};var JL={kernelName:Ws,gradFunc:r=>({x:()=>qe(r)})};var QL={kernelName:qo,inputsToSave:["indices"],gradFunc:(r,e)=>{let t=e[0];return{indices:()=>ht(t.shape,"float32")}}};var ez={kernelName:js,gradFunc:r=>({x:()=>Ie(r)})};var tz={kernelName:Us,saveAllInputs:!0,gradFunc:(r,e,t)=>{let{axis:n}=t;return fr(r,n).map(s=>()=>s)}};var zC={kernelName:Ko,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(a=>a[0]);return{x:()=>Fe(r,s,n.shape)}}};var rz={kernelName:Xo,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,e)=>{let[t,n,o]=e,s=t,a=n,i=Be(s.shape,a.shape);return{a:()=>{let c=oe(a,"float32"),p=P(r,P(c,zr(s,pe(c,le(1))))),m=kt(s.shape,i);return m.length>0&&(p=ge(p,m)),L(p,s.shape)},b:()=>{let c=nr(s,0),p=Dt(c,cr(s),Ie(s)),m=P(r,P(o,p)),f=kt(a.shape,i);return f.length>0&&(m=ge(m,f)),L(m,a.shape)}}}};var nz={kernelName:Yo,inputsToSave:["x","alpha"],gradFunc:(r,e)=>{let[t,n]=e,o=nr(t,0);return{x:()=>Dt(o,r,P(r,n)),alpha:()=>{let s=Dt(o,Ie(r),P(r,t)),a=kt(n.shape,r.shape);return a.length>0&&(s=ge(s,a)),L(s,n.shape)}}}};var oz={kernelName:Do,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Be(t.shape,n.shape);return{a:()=>{let i=me(r,oe(n,"float32")),l=kt(t.shape,o);return l.length>0?L(ge(i,l),t.shape):i},b:()=>{let i=P(r,oe(t,"float32")),l=kt(n.shape,o);l.length>0&&(i=L(ge(i,l),n.shape));let u=Me(n);return qe(me(i,oe(u,"float32")))}}}};var sz={kernelName:Qi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>me(r,qe(Me(t)))}}};var iz={kernelName:Qo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=P(Bn(t,6),ks(t));return{x:()=>P(r,oe(n,"float32"))}}};var az={kernelName:Zo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,oe(ks(t),"float32"))}}};var lz={kernelName:Hs,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>L(r,t.shape)}}};var uz={kernelName:Jo,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>A.runKernel(Bc,o,t)}}};var cz={kernelName:ol,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>A.runKernel(zc,o,t)}}};var pz={kernelName:es,gradFunc:(r,e,t)=>{let{dims:n}=t,o=tr(n,r.shape);return{x:()=>qt(r,o)}}};var mz={kernelName:ts,gradFunc:r=>({x:()=>Ie(r)})};var fz={kernelName:rs,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>qe(me(r,P(zr(t,1.5),2)))}}};var dz={kernelName:qs,inputsToSave:["condition"],gradFunc:(r,e)=>{let[t]=e;return{condition:()=>oe(Ie(t),"float32"),t:()=>P(r,oe(t,r.dtype)),e:()=>P(r,oe(ba(t),r.dtype))}}};var hz={kernelName:ta,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=nr(t,le(0)),o=le(v_),s=le(C_),a=P(r,s),i=P(P(r,o),Jt(oe(t,"float32")));return Dt(n,a,i)}}}};var gz={kernelName:os,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,P(t,pe(le(1),t)))}}};var xz={kernelName:na,gradFunc:r=>({x:()=>Ie(r)})};var yz={kernelName:ns,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(ga(oe(t,"float32")),r)}}};var bz={kernelName:ra,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(ou(oe(t,"float32")),r)}}};var wz={kernelName:Ks,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{begin:o,size:s}=t,a=n.shape,[i,l]=$w(n,o,s),u=[];for(let c=0;c<r.rank;c++)u.push([i[c],a[c]-i[c]-l[c]]);return{x:()=>Lr(r,u)}}};var _z={kernelName:as,outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{dim:o}=t,s=!0,a=P(r,n);return{logits:()=>pe(a,P(ge(a,[o],s),n))}}};var kz={kernelName:oa,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,Er(t))}}};var BC={kernelName:sl,gradFunc:(r,e,t)=>{let{blockShape:n,paddings:o}=t;return{x:()=>da(r,n,o)}}};var VC={kernelName:Xs,gradFunc:(r,e,t)=>{let{axis:n}=t;return{x:()=>Qe(r,n)}}};var vz={kernelName:ss,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>me(r,P(gt(oe(t,"float32")),2))}}};var Cz={kernelName:il,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,P(oe(t,"float32"),2))}}};var Iz={kernelName:ls,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=le(2);return{a:()=>P(r,P(o,pe(t,n))),b:()=>P(r,P(o,pe(n,t)))}}};var Nz={kernelName:Yn,gradFunc:r=>({x:()=>Ie(r)})};var Sz={kernelName:us,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Be(t.shape,n.shape);return{a:()=>{let i=r,l=kt(t.shape,o);return l.length>0&&(i=ge(i,l)),L(i,t.shape)},b:()=>{let i=r,l=kt(n.shape,o);return l.length>0&&(i=ge(i,l)),L(qe(i),n.shape)}}}};var Tz={kernelName:is,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,o=n.shape.slice(),{axis:s}=t;tr(s,n.shape).forEach(u=>{o[u]=1});let i=L(r,o),l=P(i,Qt(n.shape,"float32"));return{x:()=>l}}};var Az={kernelName:cs,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>me(r,Me(ga(t)))}}};var Ez={kernelName:ps,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(pe(le(1),Me(t)),r)}}};var Dz={kernelName:Pn,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{reps:o}=t;return{x:()=>{let a=Ie(n);if(n.rank===1)for(let i=0;i<o[0];++i)a=ee(a,Fe(r,[i*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let i=0;i<o[0];++i)for(let l=0;l<o[1];++l)a=ee(a,Fe(r,[i*n.shape[0],l*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let i=0;i<o[0];++i)for(let l=0;l<o[1];++l)for(let u=0;u<o[2];++u)a=ee(a,Fe(r,[i*n.shape[0],l*n.shape[1],u*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let i=0;i<o[0];++i)for(let l=0;l<o[1];++l)for(let u=0;u<o[2];++u)for(let c=0;c<o[3];++c)a=ee(a,Fe(r,[i*n.shape[0],l*n.shape[1],u*n.shape[2],c*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return a}}}};var $z={kernelName:ms,gradFunc:(r,e,t)=>{let n=t,{perm:o}=n,s=nf(o);return{x:()=>Ue(r,s)}}};var Rz={kernelName:Ys,gradFunc:(r,e,t)=>{let n=t,{axis:o}=n;return{value:()=>Bt(r,o)}}};var Fz={kernelName:al,inputsToSave:["segmentIds"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>OQ(r,t)}}};function OQ(r,e){let t=en(e,Ie(e)),n=Qn(r,t),o=hn(e,le(0,"int32")),s=n.rank-o.rank;for(let i=0;i<s;++i)o=ur(o,i+1);o=yr(o,Qt(n.shape,"bool"));let a=Ie(n);return Dt(o,n,a)}var Oz={kernelName:Zs,gradFunc:r=>({x:()=>Ie(r)})};var PQ=[Ax,VM,GM,WM,jM,UM,HM,qM,KM,XM,YM,ZM,QM,tL,rL,nL,oL,sL,iL,aL,lL,uL,pL,cL,fL,dL,hL,gL,xL,yL,oz,bL,wL,_L,kL,vL,IL,CL,NL,AL,EL,DL,$L,RL,FL,OL,PL,ML,LL,BL,LC,LC,VL,WL,UL,HL,qL,KL,XL,YL,ZL,JL,QL,ez,tz,zC,zC,rz,nz,sz,iz,az,lz,uz,cz,pz,mz,fz,dz,hz,gz,xz,yz,bz,wz,_z,kz,BC,BC,VC,VC,vz,Iz,Cz,Nz,Sz,Tz,Az,Ez,Dz,$z,Rz,Fz,Oz];for(let r of PQ)IS(r);var Vz={};We(Vz,{maxNorm:()=>LQ,minMaxNorm:()=>VQ,nonNeg:()=>BQ,unitNorm:()=>zQ});var GC;function er(){return GC==null&&(GC=RT().epsilon()),GC}function rn(){return"channelsLast"}var En=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,En.prototype)}},Gr=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Gr.prototype)}},z=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,z.prototype)}},Se=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Se.prototype)}},Hf=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Hf.prototype)}};function po(r,e){if(Array.isArray(r)){let t=[];for(let n=0;n<e;n++)t=t.concat(r);return t}else{let t=new Array(e);return t.fill(r),t}}function Gn(r,e){if(!r)throw new Hf(e)}function WC(r,e){let t=0;for(let n of r)n===e&&t++;return t}function wr(r){return r.length===1?r[0]:r}function bt(r){return Array.isArray(r)?r:[r]}function mo(r){let t=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Fa(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}var fo={};function Fp(r){if(r==null)return null;let e={};return e.className=r.getClassName(),e.config=r.getConfig(),e}function jC(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(e=>jC(e));else{let e=Object.keys(r);for(let t of e){let n=r[t];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[t]=n.value:jC(n))}}}function ci(r,e={},t={},n="object",o=!1){if(typeof r=="string"){let s=r,a;if(s in t)a=t[s];else if(s in fo)a=fo[s];else if(a=e[s],a==null)throw new z(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let s=r;if(s.className==null||s.config==null)throw new z(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let a=s.className,i,l;if(a in t?[i,l]=t[a]:a in fo?[i,l]=fo.className:a in e&&([i,l]=e[a]),i==null)throw new z(`Unknown ${n}: ${a}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let f of Object.keys(fo))u[f]=fo[f];for(let f of Object.keys(t))u[f]=t[f];let c=s.config;c.customObjects=u;let p=Object.assign({},fo);for(let f of Object.keys(t))fo[f]=t[f];jC(s.config);let m=l(i,s.config,t,o);return fo=Object.assign({},p),m}else{let u=Object.assign({},fo);for(let p of Object.keys(t))fo[p]=t[p];let c=new i(s.config);return fo=Object.assign({},u),c}}}function MQ(r,e){return r<e?-1:r>e?1:0}function qf(r,e){return-1*MQ(r,e)}function ho(r){if(r==null)return r;let e=[];for(let t of r)e.indexOf(t)===-1&&e.push(t);return e}function Pz(r){if(r==null)throw new z(`Invalid value in obj: ${JSON.stringify(r)}`);for(let e in r)if(r.hasOwnProperty(e))return!1;return!0}function pi(r,e,t){if(t!=null&&r.indexOf(t)<0)throw new z(`${t} is not a valid ${e}.  Valid values are ${r} or null/undefined.`)}function Dx(r,e,t=0,n=Infinity){return Gn(t>=0),Gn(n>=t),Array.isArray(r)&&r.length>=t&&r.length<=n&&r.every(o=>typeof o===e)}function Ut(r,e){Array.isArray(r)?(y.assert(r.length>0,()=>`${e} is unexpectedly an empty array.`),r.forEach((t,n)=>Ut(t,`element ${n+1} of ${e}`))):y.assert(Number.isInteger(r)&&r>0,()=>`Expected ${e} to be a positive integer, but got ${Mz(r)}.`)}function Mz(r){return r===null?"null":Array.isArray(r)?"["+r.map(e=>Mz(e)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function Lz(r,e){let t=y.now(),n;return(...s)=>{let a=y.now();return a-t<e||(t=a,n=r(...s)),n}}function $x(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}function UC(r,e){return V(()=>gt(ge(P(r,r),e,!0)))}var Op=class extends J.Serializable{getConfig(){return{}}},Kf=class extends Op{constructor(e){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return V(()=>{let t=UC(e,this.axis),n=lr(t,0,this.maxValue);return P(e,me(n,ee(er(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Kf.className="MaxNorm";J.registerClass(Kf);var Xf=class extends Op{constructor(e){super();this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return V(()=>me(e,ee(er(),UC(e,this.axis))))}getConfig(){return{axis:this.axis}}};Xf.className="UnitNorm";J.registerClass(Xf);var Yf=class extends Op{apply(e){return Dr(e)}};Yf.className="NonNeg";J.registerClass(Yf);var Zf=class extends Op{constructor(e){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return V(()=>{let t=UC(e,this.axis),n=ee(P(this.rate,lr(t,this.minValue,this.maxValue)),P(1-this.rate,t));return P(e,me(n,ee(er(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Zf.className="MinMaxNorm";J.registerClass(Zf);var zz={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Pt(r){return Fp(r)}function Bz(r,e={}){return ci(r,J.SerializationMap.getMap().classNameMap,e,"constraint")}function Mt(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in zz?zz[r]:r,config:{}};return Bz(t)}else return r instanceof Op?r:Bz(r)}function LQ(r){return new Kf(r)}function zQ(r){return new Xf(r)}function BQ(){return new Yf}function VQ(r){return new Zf(r)}var l3={};We(l3,{constant:()=>XQ,glorotNormal:()=>ree,glorotUniform:()=>tee,heNormal:()=>nee,heUniform:()=>oee,identity:()=>QQ,leCunNormal:()=>see,leCunUniform:()=>iee,ones:()=>KQ,orthogonal:()=>aee,randomNormal:()=>ZQ,randomUniform:()=>YQ,truncatedNormal:()=>JQ,varianceScaling:()=>eee,zeros:()=>qQ});var Gz=["channelsFirst","channelsLast"],Wz=["nearest","bilinear"],jz=["valid","same","causal"],Uz=["max","avg"],Hz=["sum","mul","concat","ave"];var Pp=new Map;function Ft(r){pi(Gz,"DataFormat",r)}function qz(r){pi(Wz,"InterpolationFormat",r)}function nn(r){pi(jz,"PaddingMode",r)}function HC(r){pi(Uz,"PoolMode",r)}var Jf=[],Kz="/";function Ss(r,e){Jf.push(r);try{let t=e();return Jf.pop(),t}catch(t){throw Jf.pop(),t}}function GQ(){return Jf.length===0?"":Jf.join(Kz)+Kz}function Rx(r){if(!Xz(r))throw new Error("Not a valid tensor name: '"+r+"'");return GQ()+r}function Fx(r){if(!Xz(r))throw new Error("Not a valid tensor name: '"+r+"'");Pp.has(r)||Pp.set(r,0);let e=Pp.get(r);if(Pp.set(r,Pp.get(r)+1),e>0){let t=`${r}_${e}`;return Pp.set(t,1),t}else return r}var WQ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Xz(r){return!!r.match(WQ)}function Yz(r){return r===parseInt(r.toString(),10)}function go(r,e,t){e==null&&(e=0),t==null&&(t=r.length);let n=1;for(let o=e;o<t;++o)n*=r[o];return n}function Zz(r){return r=Array.isArray(r)?new Float32Array(r):r,Vt(r)}function ju(r){return ni(Zz(r)).dataSync()[0]}function Ts(r){return pr(Zz(r)).dataSync()[0]}function Wr(r,e){if(e<r)throw new z(`end (${e}) < begin (${r}) is forbidden.`);let t=[];for(let n=r;n<e;++n)t.push(n);return t}function Oa(r,e){return r.asType(e)}function Pa(r,e=-1){let t=r.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),r.reshape(t)}function Jz(r,e){return V(()=>{if(r.shape.length!==2)throw new z(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let t=Pa(r,1);return Ox(t,[1,e,1])})}function Qz(r){let e=[go(r.shape)];return r.reshape(e)}function e3(r){if(r.rank<=1)throw new z(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let e=[r.shape[0],go(r.shape,1)];return r.reshape(e)}function Ma(r,e,t){return V(()=>{switch(r.rank){case 1:return ff(r,e,t);case 2:return wg(r,[e,0],[t,r.shape[1]]);case 3:return df(r,[e,0,0],[t,r.shape[1],r.shape[2]]);case 4:return ip(r,[e,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Fe(r,[e,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Fe(r,[e,0,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function qC(r,e,t){return V(()=>{switch(r.rank){case 1:return ff(r,e,t);case 2:return wg(r,[0,e],[r.shape[0],t]);case 3:return df(r,[0,0,e],[r.shape[0],r.shape[1],t]);case 4:return ip(r,[0,0,0,e],[r.shape[0],r.shape[1],r.shape[2],t]);default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Qf(r,e,t,n){return V(()=>{switch(r.rank){case 1:return ff(r,e,t);case 2:switch(n){case 1:return Ma(r,e,t);case 2:return qC(r,e,t);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return Ma(r,e,t);case 2:return df(r,[0,e,0],[r.shape[0],t,r.shape[2]]);case 3:return qC(r,e,t);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return Ma(r,e,t);case 2:return ip(r,[0,e,0,0],[r.shape[0],t,r.shape[2],r.shape[3]]);case 3:return ip(r,[0,0,e,0],[r.shape[0],r.shape[1],t,r.shape[3]]);case 4:return qC(r,e,t);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Mp(r,e=-1){let t;return e<0&&(t=r[0].rank,t!==0?e=t:e=0),e===r[0].rank&&(e=-1),Qe(r,e)}function KC(r,e){switch(r.rank){case 1:return Uw([r,e]);case 2:return Hw([r,e],0);case 3:return qw([r,e],0);case 4:return Kw([r,e],0);default:throw new z(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function Ox(r,e){if(Array.isArray(e)||(e=[e]),r.rank!==e.length)throw new z(`The length of input n (${e.length}) does not match the number of dimensions in input x (${r.rank})`);return zn(r,e)}function Lp(r,e=0,t=1,n,o){return bg(r,e,t,n,o)}function xo(r,e,t,n){if(r.rank<2||e.rank<2)throw new Se(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${e.shape}`);if(e.rank>=3){let o=r.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(o!==s)throw new Se(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${e.shape}`)}if(r.rank===2&&e.rank===2){let o=!1,s=!1;return no.matMul({a:r,b:e,transposeA:o,transposeB:s,bias:n?XC(r.rank,n,rn()):null,activation:t})}else{let o=r.shape.slice(),s=o.pop();r=r.reshape([-1,s]);let a=e.shape.slice(),i=a.pop(),l=a.pop(),u=[...a,i],c=Array.from({length:e.rank},(d,h)=>h===0?e.rank-2:h<=e.rank-2?h-1:h);e=e.transpose(c).reshape([l,-1]);let p=[...o,...u],m=!1,f=!1;return no.matMul({a:r,b:e,transposeA:m,transposeB:f,bias:n?XC(r.rank,n,rn()):null,activation:t}).reshape(p)}}function Px(r,e,t){return V(()=>(Array.isArray(e)?e=Vt(e,"int32"):e=e.toInt(),Qn(r,e,t)))}function Uu(r){return P(r,r)}function XC(r,e,t){let n=e.shape;if(e.rank!==1&&e.rank!==r)throw new z(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${r}`);if(r===5){if(t==="channelsFirst")return n.length===1?e.reshape([1,n[0],1,1,1]):e.reshape([1,n[3],n[0],n[1],n[2]]);if(t==="channelsLast")return n.length===1?e.reshape([1,1,1,1,n[0]]):e.reshape([1].concat(n))}else if(r===4){if(t==="channelsFirst")return n.length===1?e.reshape([1,n[0],1,1]):e.reshape([1,n[2],n[0],n[1]]);if(t==="channelsLast")return n.length===1?e.reshape([1,1,1,n[0]]):e.reshape([1].concat(n))}else if(r===3){if(t==="channelsFirst")return n.length===1?e.reshape([1,n[0],1]):e.reshape([1,n[1],n[0]]);if(t==="channelsLast")return n.length===1?e.reshape([1,1,n[0]]):e.reshape([1].concat(n))}else if(r<3)return e;throw new z(`Unsupported input rank by biasAdd: ${e.rank}`)}function on(r,e,t){return V(()=>(t==null&&(t=rn()),Ft(t),r.add(XC(r.rank,e,t))))}function t3(r,e=1){if(e!==1)throw new Se(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return ys(r)}function r3(r){return V(()=>me(r,Nt(r).add(1)))}function Mx(r,e,t,n){return V(()=>n1(r,e,t,n))}function n3(r){return V(()=>{let e=ee(.5,P(.2,r));return lr(e,0,1)})}function Cl(r,e,t=!1){return t?r():e()}var o3=["fanIn","fanOut","fanAvg"],s3=["normal","uniform","truncatedNormal"];function jQ(r){pi(o3,"FanMode",r)}function UQ(r){pi(s3,"Distribution",r)}var yn=class extends J.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},ed=class extends yn{apply(e,t){return ht(e,t)}};ed.className="Zeros";J.registerClass(ed);var Hu=class extends yn{apply(e,t){return Qt(e,t)}};Hu.className="Ones";J.registerClass(Hu);var td=class extends yn{constructor(e){super();if(typeof e!="object")throw new z(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new z(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return V(()=>P(le(this.value),Qt(e,t)))}getConfig(){return{value:this.value}}};td.className="Constant";J.registerClass(td);var rd=class extends yn{constructor(e){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return _s(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};rd.className="RandomUniform";J.registerClass(rd);var nd=class extends yn{constructor(e){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Se(`randomNormal does not support dType ${t}.`);return Lp(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};nd.className="RandomNormal";J.registerClass(nd);var od=class extends yn{constructor(e){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Se(`truncatedNormal does not support dType ${t}.`);return wu(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};od.className="TruncatedNormal";J.registerClass(od);var sd=class extends yn{constructor(e){super();this.gain=e.gain!=null?e.gain:1}apply(e,t){return V(()=>{if(e.length!==2||e[0]!==e[1])throw new z("Identity matrix initializer can only be used for 2D square matrices.");return P(this.gain,rp(e[0]))})}getConfig(){return{gain:this.gain}}};sd.className="Identity";J.registerClass(sd);function HQ(r,e="channelsLast"){let t,n;if(Ft(e),r.length===2)t=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(e==="channelsFirst"){let o=go(r,2);t=r[1]*o,n=r[0]*o}else if(e==="channelsLast"){let o=go(r,0,r.length-2);t=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=go(r);t=Math.sqrt(o),n=Math.sqrt(o)}return[t,n]}var jr=class extends yn{constructor(e){super();if(e.scale<0)throw new z(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,jQ(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,UQ(this.distribution),this.seed=e.seed}apply(e,t){let n=HQ(e),o=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,o):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(o+s)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Se(`${this.getClassName()} does not support dType ${t}.`);return wu(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*a);return _s(e,-i,i,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};jr.className="VarianceScaling";J.registerClass(jr);var zp=class extends jr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return jr.className}};zp.className="GlorotUniform";J.registerClass(zp);var Bp=class extends jr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return jr.className}};Bp.className="GlorotNormal";J.registerClass(Bp);var Vp=class extends jr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return jr.className}};Vp.className="HeNormal";J.registerClass(Vp);var Gp=class extends jr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return jr.className}};Gp.className="HeUniform";J.registerClass(Gp);var Wp=class extends jr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return jr.className}};Wp.className="LeCunNormal";J.registerClass(Wp);var jp=class extends jr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return jr.className}};jp.className="LeCunNormal";J.registerClass(jp);var id=class extends yn{constructor(e){super();if(this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Se("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return V(()=>{if(e.length<2)throw new Se("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let n=e[0]>e[1]?[e[1],e[0]]:e,o=Lp(n,0,1,"float32"),s=O1.gramSchmidt(o);return e[0]>e[1]&&(s=s.transpose()),P(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};id.className="Orthogonal";J.registerClass(id);var i3={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function a3(r,e={}){return ci(r,J.SerializationMap.getMap().classNameMap,e,"initializer")}function vt(r){return Fp(r)}function pt(r){if(typeof r=="string"){let e=r in i3?i3[r]:r;if(e==="GlorotNormal")return new Bp;if(e==="GlorotUniform")return new zp;if(e==="HeNormal")return new Vp;if(e==="HeUniform")return new Gp;if(e==="LeCunNormal")return new Wp;if(e==="LeCunUniform")return new jp;{let t={};return t.className=e,t.config={},a3(t)}}else return r instanceof yn?r:a3(r)}function qQ(){return new ed}function KQ(){return new Hu}function XQ(r){return new td(r)}function YQ(r){return new rd(r)}function ZQ(r){return new nd(r)}function JQ(r){return new od(r)}function QQ(r){return new sd(r)}function eee(r){return new jr(r)}function tee(r){return new zp(r)}function ree(r){return new Bp(r)}function nee(r){return new Vp(r)}function oee(r){return new Gp(r)}function see(r){return new Wp(r)}function iee(r){return new jp(r)}function aee(r){return new id(r)}var z3={};We(z3,{Layer:()=>Le,RNN:()=>Dn,RNNCell:()=>Rl,activation:()=>Ete,add:()=>zte,alphaDropout:()=>kre,average:()=>Bte,averagePooling1d:()=>P0,averagePooling2d:()=>M0,averagePooling3d:()=>L0,avgPool1d:()=>Xte,avgPool2d:()=>Zte,avgPool3d:()=>Qte,avgPooling1d:()=>Yte,avgPooling2d:()=>Jte,avgPooling3d:()=>ere,batchNormalization:()=>Hte,bidirectional:()=>dre,concatenate:()=>Vte,conv1d:()=>_te,conv2d:()=>kte,conv2dTranspose:()=>vte,conv3d:()=>Cte,conv3dTranspose:()=>Ite,convLstm2d:()=>cre,convLstm2dCell:()=>pre,cropping2D:()=>Ste,dense:()=>Dte,depthwiseConv2d:()=>Ate,dot:()=>Ute,dropout:()=>$te,elu:()=>hte,embedding:()=>Lte,flatten:()=>Fte,gaussianDropout:()=>_re,gaussianNoise:()=>wre,globalAveragePooling1d:()=>tre,globalAveragePooling2d:()=>rre,globalMaxPool1d:()=>gre,globalMaxPool2d:()=>xre,globalMaxPooling1d:()=>B3,globalMaxPooling2d:()=>V3,gru:()=>ore,gruCell:()=>sre,input:()=>l0,inputLayer:()=>dte,layerNormalization:()=>qte,leakyReLU:()=>xte,lstm:()=>ire,lstmCell:()=>are,masking:()=>vre,maxPool1d:()=>yre,maxPool2d:()=>bre,maxPooling1d:()=>G3,maxPooling2d:()=>W3,maxPooling3d:()=>nre,maximum:()=>Gte,minimum:()=>Wte,multiply:()=>jte,permute:()=>Mte,prelu:()=>yte,reLU:()=>gte,repeatVector:()=>Ote,reshape:()=>Pte,rnn:()=>mre,separableConv2d:()=>Nte,simpleRNN:()=>lre,simpleRNNCell:()=>ure,softmax:()=>bte,spatialDropout1d:()=>Rte,stackedRNNCells:()=>fre,thresholdedReLU:()=>wte,timeDistributed:()=>hre,upSampling2d:()=>Tte,zeroPadding2d:()=>Kte});var lee=0;function Lx(){return lee++}var zx={};function Il(r=""){return r in zx||(zx[r]=0),zx[r]+=1,r+zx[r].toString()}function Bx(r){return Array.isArray(r)&&Array.isArray(r[0])}function Up(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Re(r){let e;if(Array.isArray(r)){if(r.length!==1)throw new z(`Expected Tensor length to be 1; got ${r.length}`);e=r[0]}else e=r;return e}function Xe(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new z(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function Hp(r){let e=0;for(let t of r)t.shape.length===0?e+=1:e+=t.shape.reduce((n,o)=>n*o);return e}var u3="Variable",Vx=class{constructor(e,t="float32",n=u3,o=!0,s=null){this.dtype=t==null?"float32":t,this.shape=e.shape,this.id=Lx(),n=n==null?u3:n,this.originalName=Rx(n),this.name=Fx(this.originalName),this.trainable_=o,this.constraint=s,this.val=__(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),uee(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function uee(r,e){if(r.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(e.shape))}function ad(r){return r.map(e=>e.read())}function qp(r){r.forEach(e=>{e[0].write(e[1])})}var Ct=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},sn=class{constructor(e,t,n,o,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=o,this.callArgs=s,this.outputTensorIndex=i,this.id=Lx(),a!=null&&(this.originalName=Rx(a),this.name=Fx(this.originalName)),this.rank=t.length}},cee=0,Nl=class{constructor(e,t){this.callArgs=t,this.id=cee++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},pee=0,Le=class extends J.Serializable{constructor(e={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=pee++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=mo(n)+"_"+Il(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let o=e.dtype;o==null&&(o=e.inputDType),o==null&&(o="float32"),this.dtype=o}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Gr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new z(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return wr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return wr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} is not connected, no input to return.`);return wr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return wr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=bt(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=bt(this.inputSpec);if(e.length!==t.length)throw new z(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let o=e[n],s=t[n];if(s==null)continue;let a=o.rank;if(s.ndim!=null&&a!==s.ndim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(s.maxNDim!=null&&a>s.maxNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(s.minNDim!=null&&a<s.minNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new z(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let i=o.shape;for(let l in s.axes){let u=Number(l),c=s.axes[l],p=u>=0?i[u]:i[i.length+u];if(c!=null&&[c,null].indexOf(p)===-1)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${i}.`)}}if(s.shape!=null)for(let i=0;i<s.shape.length;++i){let l=s.shape[i],u=o.shape[i];if(l!=null&&u!=null&&l!==u)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=bt(e),o=!0;for(let a of n)if(!(a instanceof sn)){o=!1;break}let s=!0;for(let a of n)if(a instanceof sn){s=!1;break}if(o===s)throw new z("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ss(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let i of bt(e))a.push(i.shape);this.build(wr(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t),i=bt(a),l=[];for(let u of i)n.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(a=wr(l),this.activityRegularizer!=null)throw new Se("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=mee(e),i=this.computeOutputShape(a),l,u=fee(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?l=i.map((c,p)=>new sn(u,c,this,bt(e),t,this.name,p)):l=new sn(u,i,this,bt(e),t,this.name),this.addInboundNode(e,l,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new Se("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&e[o]!=null&&e[o]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new En(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new En(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Gr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Hp(this.weights)}build(e){this.built=!0}getWeights(e=!1){return ad(e?this.trainableWeights:this.weights)}setWeights(e){V(()=>{let t=this.weights;if(t.length!==e.length)throw new z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],o=ad(t);for(let s=0;s<o.length;++s){let a=o[s],i=t[s],l=e[s];if(!y.arraysEqual(a.shape,l.shape))throw new z(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);n.push([i,l])}qp(n)})}addWeight(e,t,n,o,s,a,i){if(this._addedWeightNames.indexOf(e)!==-1)throw new z(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=pt("zeros"));let l=o.apply(t,n),u=new Vx(l,n,e,a,i);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(u.read())),a==null&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=bt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,o,s,a,i=null){let l=bt(e);t=bt(t),n=bt(n),o=bt(o),s=Up(s),a=Up(a);let u=[],c=[],p=[];for(let m of l)u.push(m.sourceLayer),c.push(m.nodeIndex),p.push(m.tensorIndex);new Nl({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:p,inputTensors:l,outputTensors:t,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:a},i);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount==0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function mee(r){r=bt(r);let e=[];for(let t of r)e.push(t.shape);return wr(e)}function fee(r){return"float32"}function YC(r,e,t){if((e==null||t!=null&&t>0)&&(e=r.sourceLayer,t=r.nodeIndex),e.inboundNodes.length===0)return[r];{let n=e.inboundNodes[t];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let a=n.inputTensors[s],i=n.inboundLayers[s],l=n.nodeIndices[s],u=YC(a,i,l);for(let c of u)o.indexOf(c)===-1&&o.push(c)}return o}}}var mi=class extends Le{constructor(e){super({dtype:e.dtype,name:e.name!=null?e.name:Il("input").toString()});if(e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let o=new sn(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new Nl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};mi.className="InputLayer";J.registerClass(mi);function Gx(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=r.batchShape;r.shape!=null&&e==null&&(e=[null].concat(r.shape));let t=r.dtype;return t==null&&(t="float32"),new mi({batchInputShape:e,name:r.name,dtype:t,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}async function fi(r){if(r==null)return;let e=[],t=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let a=s;e.push(a.data()),t.push(o),n.push(a)}}if(e.length>0){let o=await Promise.all(e);for(let s=0;s<o.length;++s)r[t[s]]=o[s][0];Ee(n)}}function Wx(r){if(r!=null)for(let e in r){let t=r[e];typeof t!="number"&&t.dispose()}}var c3;(function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"})(c3||(c3={}));var dee=125,Sl=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},ZC=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},p3=class extends Sl{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let o in t){let s=t[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let a;o in this.totals?a=this.totals[o]:this.totals[o]=0;let i=V(()=>ee(this.totals[o],P(s,n)));this.totals[o]=i,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:V(()=>{let o=P(me(1,this.seen),this.totals[n]);t[n]=o,this.totals[n].dispose(),Et(t[n])}))}},JC=class extends Sl{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let l=a[i];e.push(l.data()),t.push(s),n.push(i)}}let o=await Promise.all(e);for(let s=0;s<o.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=o[s][0]}},QC=class extends Sl{constructor(e,t){super();if(this.currentEpoch=0,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=dee),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");y.isNumber(this.yieldEvery)&&(this.maybeWait=Lz(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let o=[];this.yield!=null&&(await fi(n),o.push(this.yield(e,t,n))),o.push(wf()),await Promise.all(o)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await fi(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await fi(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(wf()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await fi(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await fi(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(wf()):y.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await fi(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await fi(e),await this.trainEnd(e))}};function jx(r,e){return r==null&&(r={}),r instanceof Sl?[r]:Array.isArray(r)&&r[0]instanceof Sl?r:bt(r).map(n=>new QC(n,e))}var bn=class{constructor(){}static registerCallbackConstructor(e,t){y.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),bn.checkForDuplicate(t),bn.constructors[e]==null&&(bn.constructors[e]=[]),bn.constructors[e].push(t)}static checkForDuplicate(e){for(let t in bn.constructors)bn.constructors[+t].forEach(o=>{if(o===e)throw new z("Duplicate callback constructor.")})}static clear(){bn.constructors={}}static createCallbacks(e){let t=[];for(let n in bn.constructors){let o=+n;e>=o&&t.push(...bn.constructors[o])}return t.map(n=>new n)}};bn.constructors={};function Ux(r,e,t,n,o,s,a,i,l){let u=new JC,c=[new p3,...bn.createCallbacks(e)];r!=null&&c.push(...r),c.push(u);let p=new ZC(c);return p.setParams({epochs:t,initialEpoch:n,samples:o,steps:s,batchSize:a,verbose:e,doValidation:i,metrics:l}),{callbackList:p,history:u}}function an(r,e={},t=!1){return ci(r,J.SerializationMap.getMap().classNameMap,e,"layer",t)}function ld(r,e){return V(()=>{r.dtype!=="float32"&&(r=r.asType("float32"));let t=ge(Uu(r),e,!0),n=xa(t.shape,er()),o=gt(en(t,n));return me(r,o)})}function di(r,e){return V(()=>dt(Uu(pe(e,r)),-1))}function Kp(r,e){return V(()=>dt(Nt(pe(e,r)),-1))}function Tl(r,e){return V(()=>{let t=pe(r,e),n=lr(Nt(r),er(),Number.MAX_VALUE),o=Nt(me(t,n));return P(100,dt(o,-1))})}function hee(r,e){return V(()=>{let t=lr(e,er(),Number.MAX_VALUE),n=cr(ee(1,t)),o=lr(r,er(),Number.MAX_VALUE),s=cr(ee(1,o));return dt(Uu(pe(n,s)),-1)})}function gee(r,e){return V(()=>{let t=en(0,pe(1,P(r,e)));return dt(Uu(t),-1)})}function xee(r,e){return V(()=>{let t=en(0,pe(1,P(r,e)));return dt(t,-1)})}function yee(r,e){return V(()=>{let t=ge(P(r,e),-1),n=pr(P(pe(1,r),e),-1);return en(0,ee(1,pe(n,t)))})}function bee(r,e){return V(()=>{let t=Math.log(2),n=pe(e,r),o=pe(ee(n,eo(P(-2,n))),t);return dt(o,-1)})}function qu(r,e,t=!1){return V(()=>{if(t)e=va(e);else{let n=ge(e,e.shape.length-1,!0);e=me(e,n)}return e=lr(e,er(),1-er()),qe(ge(P(r.toFloat(),cr(e)),e.shape.length-1))})}function Xp(r,e,t=!1){return V(()=>{let n=bs(Qz(r)).toInt();e=lr(e,er(),1-er());let o=e.shape,s=ds(n,o[o.length-1]).reshape(o);return qu(s,e,t)})}function wee(r,e){if(!y.arraysEqual(r.shape,e.shape))throw new z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(e.shape)}`);return V(()=>{let t=e.relu(),n=e.abs().neg();return t.sub(e.mul(r)).add(n.exp().log1p())})}function Yp(r,e){return V(()=>{let t;return t=lr(e,er(),1-er()),t=cr(me(t,pe(1,t))),dt(wee(r,t),-1)})}function _ee(r,e){return V(()=>{let t=lr(r,er(),1),n=lr(e,er(),1);return ge(P(r,cr(me(t,n))),-1)})}function kee(r,e){return V(()=>{let t=cr(ee(er(),e));return dt(pe(e,P(r,t)),-1)})}function ud(r,e){return V(()=>{let t=ld(r,-1),n=ld(e,-1),o=P(t,n);return qe(ge(o,-1))})}var cd={meanSquaredError:di,meanAbsoluteError:Kp,meanAbsolutePercentageError:Tl,meanSquaredLogarithmicError:hee,squaredHinge:gee,hinge:xee,categoricalHinge:yee,logcosh:bee,categoricalCrossentropy:qu,sparseCategoricalCrossentropy:Xp,binaryCrossentropy:Yp,kullbackLeiblerDivergence:_ee,poisson:kee,cosineProximity:ud};function Hx(r){if(typeof r=="string"){if(r in cd)return cd[r];let e=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new z(e)}else return r}function pd(r,e){return V(()=>{let t=P(.5,or(e)),n=Oa(nr(e,t),r.dtype);return dt(Nn(r,n),-1)})}function md(r,e){return V(()=>Oa(Nn(fl(r,-1),fl(e,-1)),"float32"))}function m3(r,e){return V(()=>yr(r.equal(1),e.equal(1)).sum().cast("float32"))}function vee(r,e){return V(()=>yr(r.equal(1),e.equal(0)).sum().cast("float32"))}function Cee(r,e){return V(()=>yr(r.equal(0),e.equal(1)).sum().cast("float32"))}function e0(r,e){return V(()=>{let t=m3(r,e),n=Cee(r,e),o=t.add(n);return Dt(nr(o,0),t.div(o),0).cast("float32")})}function f3(r,e){return V(()=>{let t=m3(r,e),n=vee(r,e),o=t.add(n);return Dt(nr(o,0),t.div(o),0).cast("float32")})}function qx(r,e){return Yp(r,e)}function Kx(r,e){return r.rank===e.rank&&(r=r.squeeze([r.rank-1])),e=e.argMax(-1),e.dtype!==r.dtype&&(e=e.asType(r.dtype)),Nn(r,e).asType("float32")}var Iee=di,Nee=di,See=Kp,Tee=Kp,Aee=Tl,Eee=Tl,fd=qu,Dee=ud,t0=Xp,Xx={binaryAccuracy:pd,categoricalAccuracy:md,precision:e0,categoricalCrossentropy:fd,sparseCategoricalCrossentropy:t0,mse:Iee,MSE:Nee,mae:See,MAE:Tee,mape:Aee,MAPE:Eee,cosine:Dee};function d3(r){if(typeof r=="string"&&r in Xx)return Xx[r];if(typeof r!="string"&&r!=null)return r;throw new z(`Unknown metric ${r}`)}function dd(r){if(Gn(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let e;for(let t of Object.keys(cd))if(cd[t]===r){e=t;break}if(e!==void 0)return e;for(let t of Object.keys(Xx))if(Xx[t]===r){e=t;break}return e!==void 0?e:r.name}}function h3(r){let e={Adagrad:()=>Iu.adagrad(.01),Adadelta:()=>Iu.adadelta(1,.95,er()),Adam:()=>Iu.adam(.001,.9,.999,er()),Adamax:()=>Iu.adamax(.002,.9,.999,er(),0),RMSProp:()=>Iu.rmsprop(.001,.9,0,er()),SGD:()=>Iu.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,r in e)return e[r]();throw new z(`Unknown Optimizer ${r}`)}var g3=1*1024*1024;function n0(r,e,t=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!r0(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){let n=JSON.stringify(r);n.length>g3&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${g3}.`)}}function r0(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let e=Object.keys(r);for(let t of e)if(typeof t!="string"||!r0(r[t]))return!1;return!0}else if(Array.isArray(r)){for(let e of r)if(!r0(e))return!1;return!0}else return!1;else{let e=typeof r;return e==="string"||e==="number"||e==="boolean"}}function x3(r,e,t,n=console.log){let o=Ree(r),s=["Layer (type)","Output shape","Param #"];o?(e=e||65,t=t||[.45,.85,1]):(e=e||98,t=t||[.33,.55,.67,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(e*c)));let a;if(!o){s.push("Receives inputs"),a=[];for(let c in r.nodesByDepth)a.push(...r.nodesByDepth[c])}n("_".repeat(e)),Yx(s,t,n),n("=".repeat(e));let i=r.layers;for(let c=0;c<i.length;++c)o?Fee(i[c],t,n):Oee(i[c],t,a,n),n((c===i.length-1?"=":"_").repeat(e));r.checkTrainableWeightsConsistency();let l=$ee(r),u=Hp(r.nonTrainableWeights);n(`Total params: ${l+u}`),n(`Trainable params: ${l}`),n(`Non-trainable params: ${u}`),n("_".repeat(e))}function $ee(r){let e;return r.collectedTrainableWeights!=null?e=Hp(r.collectedTrainableWeights):e=Hp(r.trainableWeights),e}function Ree(r){let e=!0,t=[],n=[];for(let o in r.nodesByDepth)t.push(r.nodesByDepth[o]);for(let o of t){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){e=!1;break}n.push(...o)}if(e)for(let o of r.layers){let s=!1;for(let a of o.inboundNodes)if(n.indexOf(a)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function Yx(r,e,t=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,e[o]),n+=" ".repeat(e[o]-n.length);t(n)}function Fee(r,e,t){let n;try{n=JSON.stringify(r.outputShape)}catch(i){n="multiple"}let o=r.name,s=r.getClassName(),a=[`${o} (${s})`,n,r.countParams().toString()];Yx(a,e,t)}function Oee(r,e,t,n){let o;try{o=JSON.stringify(r.outputShape)}catch(c){o="multiple"}let s=[];for(let c of r.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(c)===-1))for(let p=0;p<c.inboundLayers.length;++p){let m=c.inboundLayers[p].name,f=c.nodeIndices[p],d=c.tensorIndices[p];s.push(`${m}[${f}][${d}]`)}let a=r.name,i=r.getClassName(),l=s.length===0?"":s[0],u=[`${a} (${i})`,o,r.countParams().toString(),l];Yx(u,e,n);for(let c=1;c<s.length;++c)Yx(["","","",s[c]],e,n)}function y3(r,e,t){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&e===0&&typeof t=="string"}function Ku(r,e){if(r===null)return null;if(typeof r=="string")return Fa(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];y3(e,o,s)?t.push(s):t.push(Ku(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")t[n]=o;else{let s=Fa(n);t[s]=Ku(o,s)}}return t}}function Zx(r,e){if(r==null)return null;if(typeof r=="string")return mo(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];y3(e,o,s)?t.push(s):t.push(Zx(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n],s=mo(n);(n==="name"||n==="className")&&typeof o=="string"?t[s]=o:t[s]=Zx(o,n)}return t}}var hd="3.5.0";function Pee(r,e){if(r.dtype==null||r.dtype===e.dtype)return e;try{return oe(e,r.dtype)}catch(t){throw new z(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var As=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof As)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Pee(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new z(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof sn){if(this.id2Value[e.id]==null)throw new z(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new z(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof sn){if(this.id2Value[e.id]==null)throw new z(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new z(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Ee(this.id2Mask)}},o0={},b3={};function Xu(r,e,t,n){let o=t==null?!1:t.training,s=Array.isArray(r),a=s?r:[r],i=a.map(d=>d.name),l=[],u=e.names();for(let d of i)u.indexOf(d)!==-1?l.push(e.getValue(d)):l.push(null);n!=null&&(n.maxNumTensors=-Infinity,n.minNumTensors=Infinity);let c=i.join(",")+"|"+e.names().join(","),p,m;if(o0[c]==null){let d=Mee(a,e);p=d.sorted,m=d.recipientCounts,o0[c]=p,b3[c]=m}p=o0[c],m={},o||Object.assign(m,b3[c]);let f=new As(e);for(let d=0;d<p.length;++d){if(n!=null){let O=Lm().numTensors;O>n.maxNumTensors&&(n.maxNumTensors=O),O<n.minNumTensors&&(n.minNumTensors=O)}let h=p[d],g=h.sourceLayer;if(g instanceof mi)continue;let x=[],b=[],w=[],_=!1;for(let O of h.inputs){let M=f.getValue(O),G=f.getMask(O);x.push(M),b.push(G),G!=null&&(_=!0),o||(m[O.name]--,m[O.name]===0&&!e.hasKey(O)&&i.indexOf(O.name)===-1&&!M.isDisposed&&O.sourceLayer.stateful!==!0&&w.push(M))}_&&(t=t||{},t.mask=b[0]);let I=bt(g.apply(x,t)),E=null;g.supportsMasking&&(E=g.computeMask(x,b));let $=Lee(h),D=Array.isArray($)?$:[$];for(let O=0;O<D.length;++O){f.hasKey(D[O])||f.add(D[O],I[O],Array.isArray(E)?E[0]:E);let M=i.indexOf(D[O].name);M!==-1&&(l[M]=I[O])}o||Ee(w)}return f.disposeMasks(),s?l:l[0]}function Mee(r,e){y.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let t=[],n={};if(r.length===1){let o=w3(r[0],e);t=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:a,recipientMap:i}=w3(s,e);for(let l of a)o.has(l.name)||(t.push(l),o.add(l.name));for(let l in i)n[l]==null&&(n[l]=new Set),i[l].forEach(u=>n[l].add(u))}}return{sorted:t,recipientCounts:zee(n)}}function zee(r){let e={};for(let t in r)e[t]=r[t].size;return e}function w3(r,e){let t=new Set,n=[],o={};for(let i of e.names())t.add(i);let s=[],a=[];for(s.push(r);s.length>0;){let i=s[s.length-1];if(t.has(i.name)){s.pop();continue}let l=a[a.length-1]===s.length-1;if(i.inputs.length===0||l)s.pop(),n.push(i),t.add(i.name),l&&a.pop();else{a.push(s.length-1);for(let u of i.inputs)o[u.name]==null&&(o[u.name]=new Set),o[u.name].add(i.name),!t.has(u.name)&&s.push(u)}}return{sorted:n,recipientMap:o}}function Lee(r){let e;if(r.sourceLayer.inboundNodes.length===1)e=r.sourceLayer.output;else{let t=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){t=n;break}e=r.sourceLayer.getOutputAt(t)}return e}var Wn=class extends Le{constructor(e){super({});if(this.containerNodes=new Set,this.name=e.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=Il(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],ho(this.inputs).length!==this.inputs.length)throw new z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);ho(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let w=b.sourceLayer,_=b.nodeIndex,I=b.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(_),this.outputLayersTensorIndices.push(I)}for(let b of this.inputs){let w=b.sourceLayer,_=b.nodeIndex,I=b.tensorIndex;Gn(_===0,"input layer has >1 nodes"),Gn(I===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(_),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let w=this.inputLayers[b];if(!(w instanceof mi))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let t={},n={},o={},s={},a={},i=[],l=(b,w,_,I,E,$)=>{(I==null||E==null||$==null)&&(I=b.sourceLayer,E=b.nodeIndex,$=b.tensorIndex);let D=I.inboundNodes[E];if(_.indexOf(D)!==-1)throw new Gr(`The tensor ${b.name} at layer "${I.name}" is part of a cycle.`);if(w.indexOf(D)!==-1)return;this.containerNodes.add(Wn.nodeKey(I,E)),I.id in a||(a[I.id]=Object.keys(a).length),_.indexOf(D)===-1&&_.push(D);let O=D.inboundLayers.length;for(let M=0;M<O;M++){let G=D.inputTensors[M],j=D.inboundLayers[M],U=D.nodeIndices[M],H=D.tensorIndices[M];l(G,w,_,j,U,H)}for(w.push(D);_.indexOf(D)>=0;)_.splice(_.indexOf(D),1);i.push(D)},u=[],c=[];for(let b of this.outputs)l(b,u,c);let p=i.slice().reverse();for(let b of p){n[b.id]=b,b.id in t||(t[b.id]=0);let w=t[b.id],_=o[b.outboundLayer.id]==null?0:o[b.outboundLayer.id];w=Math.max(w,_),o[b.outboundLayer.id]=w,s[b.outboundLayer.id]=b.outboundLayer,t[b.id]=w;for(let I=0;I<b.inboundLayers.length;I++){let E=b.inboundLayers[I],$=b.nodeIndices[I],D=E.inboundNodes[$],O=t[D.id]==null?0:t[D.id];t[D.id]=Math.max(w+1,O),n[D.id]=D}}let m={};for(let b in t){let w=t[b];w in m||(m[w]=[]),m[w].push(n[b])}let f={};for(let b in o){let w=o[b];w in f||(f[w]=[]),f[w].push(s[b])}let d=Object.keys(f).map(b=>parseInt(b,10)).sort(qf);this.layers=[];for(let b of d){let w=f[b];w.sort((_,I)=>{let E=a[_.id],$=a[I.id];return E<$?-1:E>$?1:0});for(let _ of w)_ instanceof Wn&&this.internalContainerRefs.push(_),this.layers.push(_)}this.layersByDepth=f,d=Object.keys(m).map(b=>parseInt(b,10)).sort(qf);let h=this.inputs.slice(),g=[];for(let b of d)for(let w of m[b]){let _=w.outboundLayer;if(_!=null){for(let I of w.inputTensors)if(h.indexOf(I)===-1)throw new Gr(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${_.name}". The following previous layers were accessed without issue: ${g}`);for(let I of w.outputTensors)h.push(I);g.push(_.name)}}this.nodesByDepth=m;let x=this.layers.map(b=>b.name);for(let b of x){let w=x.filter(_=>_===b).length;if(w!==1)throw new Gr(`The name "${b}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new Nl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},o=0;for(let a of this.layers)for(let i of a.weights){if(n[i.originalName]!=null)throw new z(`Duplicate weight name: ${i.originalName}`);n[i.originalName]=i,o++}let s=[];for(let a in e){let i=a;if(n[a]==null){let l=a.split("/");i=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(n[i]!=null)s.push([n[i],e[a]]);else if(t)throw new z(`Provided weight data has no target variable: ${a}`);delete n[i]}if(t){let a=[];for(let i in n)a.push(i);if(a.length>0)throw new z(`${a.length} of ${o} weights are not set: ${a}`)}qp(s)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${hd}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=Zx(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return V(()=>{e=bt(e);let n=new As;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],e[o]);return Xu(this.outputs,n,t)})}computeMask(e,t){return V(()=>{e=bt(e);let n;return t==null?n=po(null,e.length):n=bt(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=Up(e);if(t.length!==this.inputLayers.length)throw new z(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let l=this.inputLayers[i],u=t[i],c=l.name+"_0_0";n[c]=u}let o=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(qf);if(o.length>1)for(let i of o){let l=this.nodesByDepth[i];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(c.id)!==-1)continue;let p=[];for(let h=0;h<u.inboundLayers.length;h++){let g=u.inboundLayers[h],x=u.nodeIndices[h],b=u.tensorIndices[h],w=`${g.name}_${x}_${b}`,_=n[w];p.push(_)}let m=c.computeOutputShape(wr(p)),f=Up(m),d=c.inboundNodes.indexOf(u);for(let h=0;h<f.length;h++){let g=`${c.name}_${d}_${h}`;n[g]=f[h]}}}let s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){let l=this.outputLayers[i],u=this.outputLayersNodeIndices[i],c=this.outputLayersTensorIndices[i],p=`${l.name}_${u}_${c}`;a.push(p)}for(let i=0;i<a.length;i++){let l=a[i];Gn(l in n),s.push(n[l])}return wr(s)}runInternalGraph(e,t){t==null&&(t=po(null,e.length));let n={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=e[l],p=t[l];n[u.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(qf);for(let l of o){let u=this.nodesByDepth[l];for(let c of u){let p=c.outboundLayer,m=c.inputTensors,f=c.outputTensors,d=new Array;for(let h of m)h.id in n&&d.push(n[h.id]);if(d.length===m.length){let h={},g,x,b,w;if(c.callArgs!=null&&(h=c.callArgs),d.length===1){let[_,I]=d[0];h.mask==null&&(h.mask=I),b=bt(p.call(_,h)),w=bt(p.computeMask(_,I)),g=[_],x=[I]}else g=d.map(_=>_[0]),x=d.map(_=>_[1]),h.mask==null&&(h.mask=x),b=bt(p.call(g,h)),w=bt(p.computeMask(g,x));if(p.activityRegularizer)throw new Se("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let _=0;_<f.length;++_){let I=f[_],E=b[_],$=w[_];n[I.id]=[E,$]}}}}let s=[],a=[],i=[];for(let l of this.outputs){Gn(l.id in n,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=n[l.id];i.push(u.shape),s.push(u),a.push(c)}return[s,a,i]}buildNodeConversionMap(e){let t={},n;for(let o of this.layers){n=o instanceof Wn?1:0;for(let s=0;s<o.inboundNodes.length;s++){let a=Wn.nodeKey(o,s);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new z(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new z("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new z(`No such layer: ${e}`)}calculateLosses(){return V(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let o=Wn.nodeKey(t,n);this.containerNodes.has(o)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let a of this.layers){let i=a.getClassName(),l=a.getConfig(),u=[];for(let p=0;p<a.inboundNodes.length;p++){let m=a.inboundNodes[p],f=Wn.nodeKey(a,p),d={};if(this.containerNodes.has(f)){if(m.callArgs)try{JSON.stringify(m.callArgs),d=m.callArgs}catch(h){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),d={}}if(m.inboundLayers.length>0){let h=[];for(let g=0;g<m.inboundLayers.length;g++){let x=m.inboundLayers[g],b=m.nodeIndices[g],w=m.tensorIndices[g],_=Wn.nodeKey(x,b),I=t[_];I==null&&(I=0),h.push([x.name,I,w,d])}u.push(h)}}}let c={};c.name=a.name,c.className=i,c.config=l,c.inboundNodes=u,n.push(c)}e.layers=n;let o=[];for(let a=0;a<this.inputLayers.length;a++){let i=this.inputLayers[a],l=this.inputLayersNodeIndices[a],u=Wn.nodeKey(i,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);let p=this.inputLayersTensorIndices[a];o.push([i.name,c,p])}e.inputLayers=o;let s=[];for(let a=0;a<this.outputLayers.length;a++){let i=this.outputLayers[a],l=this.outputLayersNodeIndices[a],u=Wn.nodeKey(i,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);let p=this.outputLayersTensorIndices[a];s.push([i.name,c,p])}return e.outputLayers=s,e}static fromConfig(e,t,n={},o=!1){let s={},a={};function i(g,x){g.name in a?a[g.name].push(x):a[g.name]=[x]}function l(g,x){let b=[],w;for(let _ of x){let I=_[0],E=_[1],$=_[2];if(w=_[3]==null?{}:_[3],!(I in s)){i(g,x);return}let D=s[I];if(D.inboundNodes.length<=E){i(g,x);return}let O=D.inboundNodes[E];b.push(O.outputTensors[$])}b.length>0&&g.apply(wr(b),w)}function u(g){let x=g.name,b=an(g,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(o),s[x]=b,g.inboundNodes.forEach(_=>{if(!(_ instanceof Array))throw new z(`Corrupted configuration, expected array for nodeData: ${_}`);i(b,_)})}let c=t.name,p=t.layers;for(let g of p)u(g);for(;!Pz(a);)for(let g of p){let x=s[g.name];if(x.name in a){let b=a[x.name];delete a[x.name];for(let w of b)l(x,w)}}let m=[],f=[],d=t.inputLayers;for(let g of d){let x=g[0],b=g[1],w=g[2];Gn(x in s);let I=s[x].inboundNodes[b].outputTensors;m.push(I[w])}let h=t.outputLayers;for(let g of h){let x=g[0],b=g[1],w=g[2];Gn(x in s);let I=s[x].inboundNodes[b].outputTensors;f.push(I[w])}return new e({inputs:m,outputs:f,name:c})}get stateful(){if(this._stateful)throw new z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){V(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function Bee(r,e,t){let n=e.length;if(r==null||Array.isArray(r)&&r.length===0)return e.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&e[0]in r?[r[e[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${t} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return e.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${t} must be either an array with ${n} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(r)}`)}function Jx(r,e){return Bee(r,e,"classWeight")}async function Qx(r,e,t,n){if(e!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){let o=V(()=>{if(r.shape.length===1)return r.clone();if(r.shape.length===2)if(r.shape[1]>1){let i=1;return r.argMax(i)}else{if(r.shape[1]===1)return r.reshape([r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());Ee(o);let a=[];return s.forEach(i=>{if(t[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(t[i])}),Vt(a,"float32")}else return null}function _3(r,e){return P(r,e)}var Vee=32;function v3(r,e){let t,n,o=e;t=o.xs,n=o.ys,y.assert(t!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);let s=k3("input",r.inputNames,t),a=k3("output",r.outputNames,n),i=s[0].shape[0];y.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),y.assert(a.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let l=0;l<s.length;l++)y.assert(s[l].shape[0]===i,()=>`Batch size mismatch: input ${r.inputNames[l]} has ${s[l].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);for(let l=0;l<a.length;l++)y.assert(a[l].shape[0]===i,()=>`Batch size mismatch: output ${r.outputNames[l]} has ${a[l].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);return{xs:s,ys:a}}function k3(r,e,t){if(t instanceof Pe)return[t];if(Array.isArray(t))return y.assert(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${r} keys ${e}.`),t;{let n=[];for(let o of e){if(t[o]==null)throw new z(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(t[o])}return n}}function Gee(r){if(r.length===3)throw new Se("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function I3(r,e,t){let n=t.batchesPerEpoch!=null;if(y.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),y.assert(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),y.assert(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),y.assert(!n||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),y.assert(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=t.validationData!=null,s,a;if(o)if(C3(t.validationData))y.assert(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{let g=Gee(t.validationData);s=g.xs,a=g.ys}let i=r.makeTrainFunction(),l=r.getDedupedMetricsNames(),u;o?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();let c=jx(t.callbacks,t.yieldEvery),p=t.verbose==null?1:t.verbose,{callbackList:m,history:f}=Ux(c,p,t.epochs,null,null,Wee(e,t),null,o,u);m.setModel(r),r.history=f,await m.onTrainBegin(),r.stopTraining_=!1;let d=t.initialEpoch==null?0:t.initialEpoch,h=await e.iterator();for(;d<t.epochs;){let g={};await m.onEpochBegin(d);let x=0,b=0;for(n||(h=await e.iterator());n?x<t.batchesPerEpoch:!0;){let w=await h.next();if(n&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){let{xs:_,ys:I}=v3(r,w.value),E={};E.batch=b,E.size=_[0].shape[0],await m.onBatchBegin(b,E);let $=[];if(t.classWeight!=null){let M=Jx(t.classWeight,r.outputNames);for(let G=0;G<M.length;++G)$.push(await Qx(I[G],null,M[G]))}let D=_.concat(I).concat($),O=i(D);Ee(D);for(let M=0;M<l.length;++M){let G=l[M],j=O[M];E[G]=j,Et(j)}await m.onBatchEnd(b,E),Wx(E),b++,x++}if(n?x>=t.batchesPerEpoch:w.done){if(o){let _;C3(t.validationData)?_=bt(await r.evaluateDataset(t.validationData,{batches:t.validationBatches})):_=bt(r.evaluate(s,a,{batchSize:t.validationBatchSize==null?Vee:t.validationBatchSize,verbose:0}));for(let I=0;I<r.metricsNames.length;++I)g[`val_${r.metricsNames[I]}`]=_[I]}break}if(r.stopTraining_)break}if(await m.onEpochEnd(d,g),d++,r.stopTraining_)break}return await m.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function Wee(r,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(r.size)&&(t=r.size),t}function C3(r){return typeof r.iterator=="function"}function jee(r){return typeof r.next=="function"}async function N3(r,e,t){t=t||{};let n=t.batches!=null,o=r.testFunction,s=[];if(t.verbose>0)throw new Se("Verbose mode is not implemented yet.");y.assert(!n||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);let a=jee(e)?e:await e.iterator(),i=0,l=0;for(;n?l<t.batches:!0;){let u=await a.next();if(s=V(()=>{if(u.value){let{xs:c,ys:p}=v3(r,u.value),m=c.concat(p),f=V(()=>o(m));if(Ee(m),l===0)for(let h=0;h<f.length;++h)s.push(le(0));let d=m[0].shape[0];for(let h=0;h<f.length;++h){let g=f[h],x=s[h];s[h]=V(()=>ee(s[h],P(d,g))),l>0&&Ee(x)}Ee(f),i+=d,++l}return s}),u.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let c=s[u];s[u]=me(s[u],i),Ee(c)}return wr(s)}function ey(r){y.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function Zp(r,e,t){return r==null?[null]:Array.isArray(r)?r.map(n=>Ma(n,e,t-e)):Ma(r,e,t-e)}function ty(r,e){return V(()=>r==null?null:Array.isArray(r)?r.map(t=>ty(t,e)):Px(r,e.dtype==="int32"?e:e.toInt()))}function ry(r,e){let t=[],n=0,o=null;for(;n<r;)o=n+e,o>=r&&(o=r),t.push([n,o]),n=o;return t}async function Uee(r,e,t,n,o,s,a,i,l,u,c,p,m,f,d){o==null&&(o=32),s==null&&(s=1),c==null&&(c=!0),m==null&&(m=0);let h=!1;if(l!=null&&u!=null&&(h=!0),d!=null&&(h=!0,f==null))throw new z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=r.checkNumSamples(t,o,f,"steps_per_epoch"),x;g!=null&&(x=Wr(0,g)),a==null&&(a=1);let{callbackList:b,history:w}=Ux(i,a,s,m,g,f,o,h,p);b.setModel(r),r.history=w,await b.onTrainBegin(),r.stopTraining_=!1;for(let _=m;_<s;++_){await b.onEpochBegin(_);let I={};if(f!=null)throw new Se("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Se("batch shuffling is not implemneted yet");c&&y.shuffle(x);let E=Vt(x),$=ry(g,o);for(let D=0;D<$.length;++D){let O={};if(await b.onBatchBegin(D,O),V(()=>{let M=$[D][0],G=$[D][1],j=Ma(E,M,G-M);O.batch=D,O.size=G-M;let U=ty(t,j),H=e(U);for(let q=0;q<n.length;++q){let X=n[q],ne=H[q];O[X]=ne,Et(ne)}if(D===$.length-1&&h){let q=r.testLoop(l,u,o);for(let X=0;X<n.length;++X){let ne=n[X],Y=q[X];Et(Y),I["val_"+ne]=Y}}}),await b.onBatchEnd(D,O),Wx(O),r.stopTraining_)break}E.dispose()}if(await b.onEpochEnd(_,I),r.stopTraining_)break}return await b.onTrainEnd(),await r.history.syncData(),r.history}async function S3(r,e,t,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let o,s,a,i,l,u,c;try{let p=n.batchSize==null?32:n.batchSize;ey(p);let m=!1,f=await r.standardizeUserData(e,t,n.sampleWeight,n.classWeight,m,p);o=f[0],s=f[1],c=f[2];let d=!1,h;if(n.validationData!=null&&n.validationData.length>0){if(d=!0,n.validationData.length===2)a=n.validationData[0],i=n.validationData[1];else throw n.validationData.length===3?new Se("validationData including sample weights is not supported yet."):new z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let $=!0,D=await r.standardizeUserData(a,i,null,null,$,p);l=D[0],u=D[1],h=l.concat(u)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){d=!0;let $=Math.floor(o[0].shape[0]*(1-n.validationSplit)),D=o[0].shape[0];l=Zp(o,$,D),o=Zp(o,0,$),u=Zp(s,$,D),s=Zp(s,0,$),h=l.concat(u)}else n.validationSteps!=null&&(d=!0);let g=o.concat(s).concat(c);r.checkTrainableWeightsConsistency();let x=r.makeTrainFunction(),b=r.getDedupedMetricsNames(),w,_;d?(r.makeTestFunction(),w=r.testFunction,_=b.slice().concat(b.map($=>"val_"+$))):(w=null,h=[],_=b.slice());let I=jx(n.callbacks,n.yieldEvery);return await Uee(r,x,g,b,p,n.epochs,n.verbose,I,w,h,n.shuffle,_,n.initialEpoch,null,null)}finally{r.isTraining=!1,Al(o,e),Al(s,t),Al(l,a),Al(u,i),c!=null&&Ee(c)}}function s0(r){let e=[];r instanceof Pe&&(r=[r]);for(let t=0;t<r.length;++t){let n=r[t];if(n.rank===1)e.push(Pa(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(n)}}return e}function Al(r,e){if(r==null)return;let t=[];if(e instanceof Pe)t.push(e.id);else if(Array.isArray(e))e.forEach(o=>t.push(o.id));else if(e!=null)for(let o in e){let s=e[o];t.push(s.id)}let n=[];if(r instanceof Pe)t.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{t.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];t.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function Hee(r){return r instanceof Pe}function i0(r){return Array.isArray(r)}function T3(r){return!Hee(r)&&!i0(r)}function A3(r,e,t,n=!0,o=""){if(e==null||e.length===0){if(r!=null){let a=!1;if(i0(r)&&r.length>0)a=!0;else if(T3(r)){for(let i in r)if(r.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new z(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return e.map(a=>null);let s;if(T3(r)){r=r,s=[];for(let a of e){if(r[a]==null)throw new z(`No data provided for "${a}". Need data for each key in: ${e}`);s.push(r[a])}}else if(i0(r)){if(r=r,r.length!==e.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,e.length>1)throw new z(`The model ${o} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=s0(s),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;let i=s[a];if(i.shape.length!==t[a].length)throw new z(`Error when checking ${o}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${i.shape}`);for(let l=0;l<t[a].length;++l){if(l===0&&!n)continue;let u=i.shape[l],c=t[a][l];if(c!=null&&c>=0&&u!==c)throw new z(`Error when checking ${o}: expected ${e[a]} to have shape [${t[a]}], but got array with shape [${i.shape}].`)}}return s}function qee(r,e,t){let n=ho(r.map(s=>s.shape[0]));n.sort();let o=ho(e.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!y.arraysEqual(n,o))throw new z(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function Kee(r,e,t){let n=[di,Yp,qu];for(let o=0;o<r.length;++o){let s=r[o],a=e[o],i=t[o];if(a!=null){if(a===qu&&s.shape[s.shape.length-1]===1)throw new z(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(a)!==-1){let l=s.shape.slice(1),u=i.slice(1);for(let c=0;c<l.length;++c){let p=l[c],m=u[c];if(m!=null&&p!==m)throw new z(`A target Tensor with shape ${s.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function E3(r,e,t,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==e.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(e.length>1)throw new z(`The model expects ${e.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;let i=s[a];if(i.shape.length!==t[a].length)throw new z(`Error when checking ${o}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let l=0;l<t[a].length;++l){if(l===0&&!n)continue;let u=i.shape[l],c=t[a][l];if(c!=null&&c!==u)throw new z(`Error when checking ${o}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function Xee(r,e){if(r==null||Array.isArray(r)&&r.length===0)return e.map(n=>[]);let t;if(typeof r=="string"||typeof r=="function")t=[r];else if(Array.isArray(r)||typeof r=="object")t=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(t))return e.map(n=>t);{let n=[];for(let o of e){let s=t.hasOwnProperty(o)?t[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var Yee="layers-model",jn=class extends Wn{constructor(e){super(e);this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");x3(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=h3(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Br))throw new z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new z(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(Hx(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(i=>Hx(i))}else{let a=Hx(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ss("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let o=Xee(e.metrics,this.outputNames),s=(a,i,l)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([l,a])};Ss("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=o[a];(u=>{let c="",p,m,f;for(let d of u){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===Yp?["accuracy","acc"].indexOf(d)!==-1?m=pd:["crossentropy","ce"].indexOf(d)!==-1&&(m=qx):this.lossFunctions[a]===Xp?["accuracy","acc"].indexOf(d)!==-1?m=Kx:["crossentropy","ce"].indexOf(d)!==-1&&(m=t0):["accuracy","acc"].indexOf(d)!==-1?m=md:["crossentropy","ce"].indexOf(d)!==-1&&(m=fd);let x;["accuracy","acc"].indexOf(d)!==-1?x="acc":["crossentropy","ce"].indexOf(d)!==-1&&(x="ce"),f=m,p=c+x}else f=d3(d),p=c+dd(d);let h;Ss(p,()=>{h=f}),s(a,p,h)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let o=n.batchSize==null?32:n.batchSize;ey(o);let s=!0,a=this.standardizeUserDataXY(e,t,s,o);try{let i=a[0].concat(a[1]);this.makeTestFunction();let l=this.testFunction,u=this.testLoop(l,i,o,n.verbose,n.steps);return wr(u)}finally{Al(a[0],e),Al(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),N3(this,e,t)}checkNumSamples(e,t,n,o="steps"){let s;if(n!=null){if(s=null,t!=null)throw new z(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new z(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new z("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),o=n?t:[t],s=this.retrieveSymbolicTensors(o),a=new As;if(e instanceof Pe&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new z(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],e[l])}else for(let l of this.inputs){let u=e[l.name];if(u==null)throw new z(`No value is provided for the model's input ${l.name}`);a.add(l,u)}let i=Xu(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){let t=po(null,e.length),n=e.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],a=s.map(i=>i.name);for(let i=0;i<e.length;++i){let l=a.indexOf(e[i]);if(l!==-1&&(t[i]=s[l],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw t.forEach((s,a)=>{s==null&&o.push(e[a])}),new z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return t}predictLoop(e,t=32,n=!1){return V(()=>{let o=this.checkNumSamples(e);if(n)throw new Se("Verbose predictLoop() is not implemented yet.");let s=ry(o,t),a=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)V(()=>{let u=s[i][0],c=s[i][1],p=Zp(e,u,c),m=[];if(Array.isArray(p))for(let d=0;d<p.length;++d)m.push({key:this.inputs[d],value:p[d]});else m.push({key:this.inputs[0],value:p});let f=new As(m);return Xu(this.outputs,f)}).forEach((u,c)=>a[c].push(u));return wr(a.map(i=>Qe(i,0)))})}predict(e,t={}){let n=s0(e);E3(n,this.inputNames,this.feedInputShapes,!1);try{let o=t.batchSize==null?32:t.batchSize;return ey(o),this.predictLoop(n,o)}finally{Al(n,e)}}predictOnBatch(e){E3(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,o){if(this.optimizer_==null)throw new Gr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===Xp?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(e=A3(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=A3(t,this.feedOutputNames,s,!1,"target"),qee(e,t,null),Kee(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&e[0].shape[0]%o!=0)throw new z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,o,s=!0,a){let[i,l]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let u=null;if(o!=null){let c=Jx(o,this.outputNames);u=[];for(let p=0;p<c.length;++p)u.push(await Qx(l[p],null,c[p]))}return[i,l,u]}testLoop(e,t,n,o=0,s){return V(()=>{let a=this.checkNumSamples(t,n,s,"steps"),i=[];if(o>0)throw new Se("Verbose mode is not implemented yet.");if(s!=null)throw new Se("steps mode in testLoop() is not implemented yet");{let l=ry(a,n),u=Vt(Wr(0,a));for(let c=0;c<l.length;++c){let p=l[c][0],m=l[c][1],f=Ma(u,p,m-p),d=ty(t,f),h=e(d);if(c===0)for(let g=0;g<h.length;++g)i.push(le(0));for(let g=0;g<h.length;++g){let x=h[g];i[g]=ee(i[g],P(m-p,x))}}for(let c=0;c<i.length;++c)i[c]=me(i[c],a)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let o=e[n],s=o;WC(e,o)>1&&(s+=`_${WC(e.slice(0,n),o)}`),t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let p=[];for(let h=0;h<this.inputs.length;++h)p.push({key:this.inputs[h],value:n[h]});let m=new As(p),f=Xu(this.outputs,m,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let x=this.lossFunctions[h](o[h],f[h]);s[h]!=null&&(x=_3(x,s[h]));let b=dt(x);t.push(b),h===0?d=x:d=ee(d,x)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=t[h];else{let x=this.metricsTensors[h][0],b=this.metricsTensors[h][1];g=dt(x(o[b],f[b]))}Et(g),a.push(g)}return d=dt(d),this.calculateLosses().forEach(h=>{d=ee(d,h)}),d},l=this.collectedTrainableWeights.map(p=>p.read()),u=!0;return[this.optimizer_.minimize(i,u,l)].concat(a)}}makeTestFunction(){this.testFunction=e=>V(()=>{let t=[],n,o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:o[u]});let i=new As(a),l=Xu(this.outputs,i);for(let u=0;u<this.lossFunctions.length;++u){let c=this.lossFunctions[u],p=dt(c(s[u],l[u]));u===0?n=p:n=ee(n,p),t.push(n)}for(let u=0;u<this.metricsTensors.length;++u){let c=this.metricsTensors[u][0],p=this.metricsTensors[u][1],m=dt(c(s[p],l[p]));t.push(m)}return t})}async fit(e,t,n={}){return S3(this,e,t,n)}async fitDataset(e,t){return I3(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),o=n[0],s=n[1],i=this.makeTrainFunction()(o.concat(s)),l=[];for(let u of i){let c=await u.data();l.push(c[0])}return Ee(i),wr(l)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<o.length;++a)n&&!o[a].trainable||t.push({name:o[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Lm().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Lm().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=mo(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>mo(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let o of t)if(typeof n[o]=="string")e[o]=mo(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[mo(dd(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>mo(dd(e)));{let e={};for(let t in this.metrics)e[t]=mo(dd(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=Ku(e.optimizer_config),n=an(t),o;if(typeof e.loss=="string")o=Fa(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>Fa(a));else if(e.loss!=null){o={};for(let a in e.loss)o[a]=Fa(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>Fa(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=Fa(e.metrics[a])}this.compile({loss:o,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let u=Ar.getSaveHandlers(e);if(u.length===0)throw new z(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new z(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Ar.encodeWeights(this.getNamedWeights(t)),o=!1,s=null,i={modelTopology:this.toJSON(s,o),format:Yee,generatedBy:`TensorFlow.js tfjs-layers v${hd}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();let u="optimizer",{data:c,specs:p}=await Ar.encodeWeights(await this.optimizer.getWeights(),u);n.specs.push(...p),n.data=Ar.concatenateArrayBuffers([n.data,c])}if(this.userDefinedMetadata!=null){let u=!0;n0(this.userDefinedMetadata,this.name,u),i.userDefinedMetadata=this.userDefinedMetadata}return i.weightData=n.data,i.weightSpecs=n.specs,e.save(i)}setUserDefinedMetadata(e){n0(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};jn.className="Model";J.registerClass(jn);var a0=class extends jn{};a0.className="Functional";J.registerClass(a0);async function D3(r,e){"modelTopology"in r||(r={modelTopology:r}),r=r;let t=r.modelTopology;t.model_config!=null&&(t=t.model_config);let n=Ku(t),o=an(n,e);if(r.weightsManifest!=null){let s=await Ar.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(i=>i.originalName)),a={};for(let i of o.weights)a[i.originalName]=s[i.originalName];o.loadWeights(a),Ee(s)}return o}async function $3(r,e){if(e==null&&(e={}),typeof r=="string"){let t=Ar.getLoadHandlers(r,e);if(t.length===0)t.push(Ar.browserHTTPRequest(r,e));else if(t.length>1)throw new z(`Found more than one (${t.length}) load handlers for URL '${r}'`);r=t[0]}return Zee(r,void 0,e)}async function Zee(r,e,t){if(t==null&&(t={}),r.load==null)throw new z("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=t.strict==null?!0:t.strict,a=n.weightData!=null&&n.weightSpecs!=null&&s,i=an(Ku(o),e,a),l=n.trainingConfig;if(l!=null&&i.loadTrainingConfig(l),n.userDefinedMetadata!=null&&i.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new z("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:c}=Jee(n.weightData,n.weightSpecs);i.loadWeights(u,s),i.optimizer!=null&&c.length>0&&await i.optimizer.setWeights(c),Ee(u),Ee(c.map(p=>p.tensor))}return i}function Jee(r,e){let t=Ar.decodeWeights(r,e),n={},o=[];return e.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:t[s.name]}):n[s.name]=t[s.name]}),{modelWeights:n,optimizerWeights:o}}var La=class extends jn{constructor(e){super({inputs:[],outputs:[]});if(e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Il("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new z(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof La||e instanceof jn,n;if(t){if(n=e,n.outputs.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=Gx({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=YC(this.outputs[0])}this.inboundNodes=[],new Nl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:po(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Xe(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new jn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},o=!1){let s,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new z("Legacy serialization format not supported yet.");s=t}else y.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;let i=new e(a);if(!(i instanceof La))throw new Se(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let l of s){let c=an(l,void 0,o);o&&c.setFastWeightInitDuringBuild(!0),i.add(c)}return i}set stopTraining(e){if(this.model==null)throw new z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};La.className="Sequential";J.registerClass(La);function Qee(r){return new jn(r)}function ete(r){return new La(r)}function tte(r,e){return e==null&&(e={}),$3(r,e)}function l0(r){return Gx(r)}function rte(r,e){bn.registerCallbackConstructor(r,e)}var ln=class extends J.Serializable{getConfig(){return{}}},u0=class extends ln{apply(e,t=1){return t3(e,t)}};u0.className="elu";J.registerClass(u0);var c0=class extends ln{apply(e){return hu(e)}};c0.className="selu";J.registerClass(c0);var p0=class extends ln{apply(e){return Dr(e)}};p0.className="relu";J.registerClass(p0);var m0=class extends ln{apply(e){return V(()=>ws(6,Dr(e)))}};m0.className="relu6";J.registerClass(m0);var f0=class extends ln{apply(e){return e}};f0.className="linear";J.registerClass(f0);var d0=class extends ln{apply(e){return Er(e)}};d0.className="sigmoid";J.registerClass(d0);var h0=class extends ln{apply(e){return n3(e)}};h0.className="hardSigmoid";J.registerClass(h0);var g0=class extends ln{apply(e){return eo(e)}};g0.className="softplus";J.registerClass(g0);var x0=class extends ln{apply(e){return r3(e)}};x0.className="softsign";J.registerClass(x0);var y0=class extends ln{apply(e){return gs(e)}};y0.className="tanh";J.registerClass(y0);var gd=class extends ln{apply(e,t=-1){return va(e,t)}};gd.className="softmax";J.registerClass(gd);var b0=class extends ln{apply(e,t=-1){return uu(e,t)}};b0.className="logSoftmax";J.registerClass(b0);var w0=class extends ln{apply(e,t=1){return V(()=>Er(e.mul(t)).mul(e))}};w0.className="swish";J.registerClass(w0);var _0=class extends ln{apply(e){return V(()=>P(e,gs(eo(e))))}};_0.className="mish";J.registerClass(_0);function Es(r){return r.getClassName()}function k0(r,e={}){return ci(r,J.SerializationMap.getMap().classNameMap,e,"activation")}function Ds(r){if(r==null){let e={};return e.className="linear",e.config={},k0(e)}if(typeof r=="string"){let e={};return e.className=r,e.config={},k0(e)}else return r instanceof ln?r:k0(r)}function v0(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var C0=class extends J.Serializable{},Yu=class extends C0{constructor(e){super();v0(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return V(()=>{let t=ht([1]);return this.hasL1&&(t=ee(t,ge(P(this.l1,Nt(e))))),this.hasL2&&(t=ee(t,ge(P(this.l2,Uu(e))))),t.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Yu.className="L1L2";J.registerClass(Yu);function R3(r){return v0(r),new Yu({l1:r!=null?r.l1:null,l2:0})}function F3(r){return v0(r),new Yu({l2:r!=null?r.l2:null,l1:0})}var O3={l1l2:"L1L2"};function it(r){return Fp(r)}function P3(r,e={}){return ci(r,J.SerializationMap.getMap().classNameMap,e,"regularizer")}function wt(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in O3?O3[r]:r,config:{}};return P3(t)}else return r instanceof C0?r:P3(r)}var xd=class extends Le{constructor(e){super(e==null?{}:e);this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Re(e);let n=Dr(e);return this.maxValue!=null&&(n=lr(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};xd.className="ReLU";J.registerClass(xd);var yd=class extends Le{constructor(e){super(e==null?{}:e);this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Re(e);return ya(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};yd.className="LeakyReLU";J.registerClass(yd);var bd=class extends Le{constructor(e){super(e==null?{}:e);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=pt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=wt(e.alphaRegularizer),this.alphaConstraint=Mt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new z(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Xe(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)t[o-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<e.length;++o)n[o]=e[o];this.inputSpec=[new Ct({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Re(e),ka(e,this.alpha.read())}getConfig(){let e={alphaInitializer:vt(this.alphaInitializer),alphaRegularizer:it(this.alphaRegularizer),alphaConstraint:Pt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};bd.className="PReLU";J.registerClass(bd);var wd=class extends Le{constructor(e){super(e==null?{}:e);if(this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Se(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Re(e);return ys(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};wd.className="ELU";J.registerClass(wd);var _d=class extends Le{constructor(e){super(e==null?{}:e);this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Re(e);return n.mul(Oa(n.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};_d.className="ThresholdedReLU";J.registerClass(_d);var kd=class extends Le{constructor(e){super(e==null?{}:e);this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new gd().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=Re(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};kd.className="Softmax";J.registerClass(kd);function El(r,e,t){if(typeof r=="number")return po(r,e);if(r.length!==e)throw new z(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${r.length} elements.`);for(let n=0;n<e;++n){let o=r[n];if(!Yz(o))throw new z(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function wn(r,e,t,n,o=1){if(r==null)return r;let s=e+(e-1)*(o-1),a;return t==="same"?a=r:a=r-s+1,Math.floor((a+n-1)/n)}function $s(r,e,t,n){if(r==null)return null;if(n==="valid")r=r*e+Ts([t-e,0]);else if(n==="same")r=r*e;else throw new z(`Unsupport padding mode: ${n}.`);return r}function vd(r,e){return V(()=>(Ft(e),e==="channelsFirst"?Ue(r,[0,2,3,1]):r))}function I0(r,e){return V(()=>(Ft(e),e==="channelsFirst"?Ue(r,[0,2,3,4,1]):r))}function nte(r,e,t,n=1,o="valid",s,a=1){return V(()=>{if(s==null&&(s=rn()),Ft(s),r.shape.length!==3)throw new z(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(e.shape.length!==3)throw new z(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new z(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(r=Ue(r,[0,2,1])),o==="causal")throw new Se("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=ru(r,e,n,o==="same"?"same":"valid","NWC",a);return t!=null&&(i=on(i,t)),i})}function M3(r,e,t,n=[1,1],o="valid",s,a,i=null){return V(()=>{if(s==null&&(s=rn()),Ft(s),r.rank!==3&&r.rank!==4)throw new z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(e.rank!==3&&e.rank!==4)throw new z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let l=vd(r,s);if(o==="causal")throw new Se("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=no.conv2d({x:l,filter:e,strides:n,pad:o==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:i}),s==="channelsFirst"&&(l=Ue(l,[0,3,1,2])),l})}function ote(r,e,t,n=[1,1,1],o="valid",s,a){return V(()=>{if(s==null&&(s=rn()),Ft(s),r.rank!==4&&r.rank!==5)throw new z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(e.rank!==4&&e.rank!==5)throw new z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let i=I0(r,s);if(o==="causal")throw new Se("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=Xm(i,e,n,o==="same"?"same":"valid","NDHWC",a),t!=null&&(i=on(i,t)),s==="channelsFirst"&&(i=Ue(i,[0,4,1,2,3])),i})}var Jp=class extends Le{constructor(e,t){super(t);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Jp.verifyArgs(t),this.rank=e,Ut(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Se(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=El(t.kernelSize,e,"kernelSize"),this.strides=El(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,nn(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ft(this.dataFormat),this.activation=Ds(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=pt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Mt(t.biasConstraint),this.biasRegularizer=wt(t.biasRegularizer),this.activityRegularizer=wt(t.activityRegularizer),this.dilationRate=El(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Gn("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Dx(e.kernelSize,"number",1,3))throw new z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Es(this.activation),useBias:this.useBias,biasInitializer:vt(this.biasInitializer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),biasConstraint:Pt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Zu=class extends Jp{constructor(e,t){super(e,t);this.kernel=null,Zu.verifyArgs(t),this.filters=t.filters,Ut(this.filters,"filters"),this.kernelInitializer=pt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Mt(t.kernelConstraint),this.kernelRegularizer=wt(t.kernelRegularizer)}build(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new z(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return V(()=>{e=Re(e);let n,o=this.bias==null?null:this.bias.read(),s=$x(this.activation.getClassName());if(s!=null&&this.rank===2)n=M3(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=nte(e,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=M3(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=ote(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Se("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=Xe(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let a=wn(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(a)}let o=[e[0]];return this.dataFormat==="channelsLast"?(o=o.concat(t),o.push(this.filters)):(o.push(this.filters),o=o.concat(t)),o}getConfig(){let e={filters:this.filters,kernelInitializer:vt(this.kernelInitializer),kernelRegularizer:it(this.kernelRegularizer),kernelConstraint:Pt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},Dl=class extends Zu{constructor(e){super(2,e);Dl.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Dx(e.kernelSize,"number",1,2))throw new z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};Dl.className="Conv2D";J.registerClass(Dl);var $l=class extends Zu{constructor(e){super(3,e);$l.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};$l.className="Conv3D";J.registerClass($l);var Cd=class extends Dl{constructor(e){super(e);if(this.inputSpec=[new Ct({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Xe(e),e.length!==4)throw new z("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ct({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return V(()=>{let n=Re(e);if(n.shape.length!==4)throw new z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let l=o[a],u=o[i],c=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],f=this.strides[1],d=$s(l,m,c,this.padding),h=$s(u,f,p,this.padding),g=[s,d,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Ue(n,[0,2,3,1]));let x=nu(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=Ue(x,[0,3,1,2])),this.bias!=null&&(x=on(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=Xe(e);let t=e.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let a=this.kernelSize[0],i=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[o]=$s(t[o],l,a,this.padding),t[s]=$s(t[s],u,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Cd.className="Conv2DTranspose";J.registerClass(Cd);var Id=class extends $l{constructor(e){super(e);if(this.inputSpec=[new Ct({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Xe(e),e.length!==5)throw new z("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ct({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return V(()=>{let n=Re(e);if(n.shape.length!==5)throw new z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],a,i,l;this.dataFormat==="channelsFirst"?(l=2,a=3,i=4):(l=1,a=2,i=3);let u=o[l],c=o[a],p=o[i],m=this.kernelSize[0],f=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],g=this.strides[1],x=this.strides[2],b=$s(u,h,m,this.padding),w=$s(c,g,f,this.padding),_=$s(p,x,d,this.padding),I=[s,b,w,_,this.filters];this.dataFormat!=="channelsLast"&&(n=Ue(n,[0,2,3,4,1]));let E=Xw(n,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=Ue(E,[0,4,1,2,3])),this.bias!==null&&(E=on(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(e){e=Xe(e);let t=e.slice(),n,o,s,a;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,a=4):(n=4,o=1,s=2,a=3);let i=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],p=this.strides[1],m=this.strides[2];return t[n]=this.filters,t[o]=$s(t[o],c,i,this.padding),t[s]=$s(t[s],p,l,this.padding),t[a]=$s(t[a],m,u,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Id.className="Conv3DTranspose";J.registerClass(Id);var N0=class extends Zu{constructor(e,t){super(e,t);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=pt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=wt(t.depthwiseRegularizer),this.depthwiseConstraint=Mt(t.depthwiseConstraint),this.pointwiseInitializer=pt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=wt(t.pointwiseRegularizer),this.pointwiseConstraint=Mt(t.pointwiseConstraint)}build(e){if(e=Xe(e),e.length<this.rank+2)throw new z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Ct({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return V(()=>{e=Re(e);let n;if(this.rank===1)throw new Se("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ue(e,[0,2,3,1])),n=pf(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=on(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Ue(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=vt(this.depthwiseInitializer),e.pointwiseInitializer=vt(this.pointwiseInitializer),e.depthwiseRegularizer=it(this.depthwiseRegularizer),e.pointwiseRegularizer=it(this.pointwiseRegularizer),e.depthwiseConstraint=Pt(this.depthwiseConstraint),e.pointwiseConstraint=Pt(this.pointwiseConstraint),e}};N0.className="SeparableConv";var Nd=class extends N0{constructor(e){super(2,e)}};Nd.className="SeparableConv2D";J.registerClass(Nd);var Ju=class extends Zu{constructor(e){super(1,e);Ju.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Dx(e.kernelSize,"number",1,1))throw new z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};Ju.className="Conv1D";J.registerClass(Ju);var Sd=class extends Le{constructor(e){super(e);typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return V(()=>{if(e=Re(e),this.dataFormat==="channelsLast"){let n=Qf(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Qf(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Qf(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Qf(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Sd.className="Cropping2D";J.registerClass(Sd);var Td=class extends Le{constructor(e){super(e);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ft(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,qz(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return V(()=>{let n=Re(e),o=n.shape;if(this.dataFormat==="channelsFirst"){n=Ue(n,[0,2,3,1]);let s=this.size[0]*o[2],a=this.size[1]*o[3],i=this.interpolation==="nearest"?n.resizeNearestNeighbor([s,a]):n.resizeBilinear([s,a]);return Ue(i,[0,3,1,2])}else{let s=this.size[0]*o[1],a=this.size[1]*o[2];return this.interpolation==="nearest"?n.resizeNearestNeighbor([s,a]):n.resizeBilinear([s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Td.className="UpSampling2D";J.registerClass(Td);function ste(r,e,t=[1,1],n="valid",o,s){return V(()=>{o==null&&(o=rn()),Ft(o);let a=vd(r,o);if(r.rank!==4)throw new z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(e.rank!==4)throw new z(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=xs(a,e,t,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(a=Ue(a,[0,3,1,2])),a})}var Ad=class extends Jp{constructor(e){super(2,e);this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=pt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Mt(e.depthwiseConstraint),this.depthwiseRegularizer=wt(e.depthwiseRegularizer)}build(e){if(e=Xe(e),e.length<4)throw new z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return V(()=>{e=Re(e);let n=ste(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=on(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=wn(t,this.kernelSize[0],this.padding,this.strides[0]),a=wn(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],o,s,a]:[e[0],s,a,o]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=vt(this.depthwiseInitializer),e.depthwiseRegularizer=it(this.depthwiseRegularizer),e.depthwiseConstraint=Pt(this.depthwiseRegularizer),e}};Ad.className="DepthwiseConv2D";J.registerClass(Ad);function S0(r,e,t,n){if(Array.isArray(r)){if(e!=null||t!=null)throw new z("When inputs is an array, neither initialState or constants should be provided");n!=null&&(t=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(e=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return e=o(e),t=o(t),{inputs:r,initialState:e,constants:t}}function T0(r,e,t,n=!1,o,s,a=!1,i=!1){return V(()=>{let l=e.shape.length;if(l<3)throw new z(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(Wr(2,l));if(e=Ue(e,u),s!=null)throw new Se("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=o.asType("bool").asType("float32"),o.rank===l-1&&(o=ur(o,-1)),o=Ue(o,u)),n&&(e=qt(e,0),o!=null&&(o=qt(o,0)));let c=[],p,m=t,f=e.shape[0],d=fr(e),h;o!=null&&(h=fr(o));for(let x=0;x<f;++x){let b=d[x],w=V(()=>r(b,m));if(o==null)p=w[0],m=w[1];else{let _=V(()=>{let I=h[x],E=or(I).sub(I),$=w[0].mul(I).add(m[0].mul(E)),D=m.map((O,M)=>w[1][M].mul(I).add(O.mul(E)));return{output:$,newStates:D}});p=_.output,m=_.newStates}i&&c.push(p)}let g;return i&&(g=Bt(c,1)),[p,g,m]})}var Dn=class extends Le{constructor(e){super(e);let t;if(e.cell==null)throw new z("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new Qp({cells:e.cell}):t=e.cell,t.stateSize==null)throw new z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ct({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Wr(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Bx(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],o;if(this.returnSequences?o=[e[0],e[1],n]:o=[e[0],n],this.returnState){let s=[];for(let a of t)s.push([e[0],a]);return[o].concat(s)}else return o}computeMask(e,t){return V(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){let t=null;if(this.numConstants!=null)throw new Se("Constants support is not implemented in RNN yet.");Bx(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new Ct({shape:[n,null,...o]});let s=[e[0]].concat(e.slice(2));if(t!=null)throw new Se("Constants support is not implemented in RNN yet.");this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!y.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new Ct({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){V(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ht([n,o])):this.states_=[ht([n,this.cell.stateSize])];else if(e==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ht([n,o])):this.states_[0]=ht([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let o=0;o<this.states_.length;++o){let s=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,i=[n,a];if(!y.arraysEqual(s.shape,i))throw new z(`State ${o} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Et(o.clone()))})}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=S0(e,n,o,this.numConstants);e=s.inputs,n=s.initialState,o=s.constants;let a=[],i=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(let u of n)this.stateSpec.push(new Ct({shape:u.shape}));i=i.concat(this.stateSpec)}if(o!=null&&(t.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof sn){let u=[e].concat(a),c=this.inputSpec.concat(i),p=this.inputSpec;this.inputSpec=c;let m=super.apply(u,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return V(()=>{let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;e=Re(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new z(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:o},u=T0((d,h)=>{let g=this.cell.call([d].concat(h),i);return[g[0],g.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=u[0],p=u[1],m=u[2];this.stateful&&this.resetStates(m,o);let f=this.returnSequences?p:c;return this.returnState?[f].concat(m):f})}getInitialState(e){return V(()=>{let t=ht(e.shape);return t=ge(t,[1,2]),t=Pa(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?Ox(t,[1,n]):t):this.cell.stateSize>1?[Ox(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===Dn.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){let o=t.cell,s=an(o,n);return new e(Object.assign(t,{cell:s}))}};Dn.className="RNN";J.registerClass(Dn);var Rl=class extends Le{},em=class extends Rl{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ut(this.units,"units"),this.activation=Ds(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Mt(e.kernelConstraint),this.recurrentConstraint=Mt(e.recurrentConstraint),this.biasConstraint=Mt(e.biasConstraint),this.dropout=ju([1,Ts([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ju([1,Ts([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return V(()=>{if(e=e,e.length!==2)throw new z(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let o=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=za({ones:()=>or(e),rate:this.dropout,training:o})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=za({ones:()=>or(n),rate:this.recurrentDropout,training:o}));let s,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?s=xo(P(e,a),this.kernel.read()):s=xo(e,this.kernel.read()),this.bias!=null&&(s=on(s,this.bias.read())),i!=null&&(n=P(n,i));let l=ee(s,xo(n,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Es(this.activation),useBias:this.useBias,kernelInitializer:vt(this.kernelInitializer),recurrentInitializer:vt(this.recurrentInitializer),biasInitializer:vt(this.biasInitializer),kernelRegularizer:it(this.kernelRegularizer),recurrentRegularizer:it(this.recurrentRegularizer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),kernelConstraint:Pt(this.kernelConstraint),recurrentConstraint:Pt(this.recurrentConstraint),biasConstraint:Pt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}};em.className="SimpleRNNCell";J.registerClass(em);var Ed=class extends Dn{constructor(e){e.cell=new em(e),super(e)}call(e,t){return V(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return new e(t)}};Ed.className="SimpleRNN";J.registerClass(Ed);var tm=class extends Rl{constructor(e){super(e);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new z("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ut(this.units,"units"),this.activation=Ds(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ds(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Mt(e.kernelConstraint),this.recurrentConstraint=Mt(e.recurrentConstraint),this.biasConstraint=Mt(e.biasConstraint),this.dropout=ju([1,Ts([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ju([1,Ts([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xe(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return V(()=>{if(e=e,e.length!==2)throw new z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=za({ones:()=>or(e),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=za({ones:()=>or(o),rate:this.recurrentDropout,training:n,count:3}));let s=this.dropoutMask,a=this.recurrentDropoutMask,i,l,u;0<this.dropout&&this.dropout<1&&(e=P(e,s[0]));let c=xo(e,this.kernel.read());this.useBias&&(c=on(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=P(o,a[0]));let p=this.recurrentKernel.read(),[m,f]=mr(p,[2*this.units,this.units],p.rank-1),d=xo(o,m),[h,g,x]=mr(c,3,c.rank-1),[b,w]=mr(d,2,d.rank-1);i=this.recurrentActivation.apply(ee(h,b)),l=this.recurrentActivation.apply(ee(g,w));let _=xo(P(l,o),f);u=this.activation.apply(ee(x,_));let I=ee(P(i,o),P(ee(1,qe(i)),u));return[I,I]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Es(this.activation),recurrentActivation:Es(this.recurrentActivation),useBias:this.useBias,kernelInitializer:vt(this.kernelInitializer),recurrentInitializer:vt(this.recurrentInitializer),biasInitializer:vt(this.biasInitializer),kernelRegularizer:it(this.kernelRegularizer),recurrentRegularizer:it(this.recurrentRegularizer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),kernelConstraint:Pt(this.kernelConstraint),recurrentConstraint:Pt(this.recurrentConstraint),biasConstraint:Pt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}};tm.className="GRUCell";J.registerClass(tm);var Dd=class extends Dn{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new tm(e),super(e)}call(e,t){return V(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Dd.className="GRU";J.registerClass(Dd);var Fl=class extends Rl{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ut(this.units,"units"),this.activation=Ds(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ds(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=pt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Mt(e.kernelConstraint),this.recurrentConstraint=Mt(e.recurrentConstraint),this.biasConstraint=Mt(e.biasConstraint),this.dropout=ju([1,Ts([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ju([1,Ts([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Xe(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,a=this.units;o=new(t=class extends yn{apply(l,u){let c=s.apply([a]),p=new Hu().apply([a]),m=s.apply([a*2]);return KC(KC(c,p),m)}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return V(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=za({ones:()=>or(e),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=za({ones:()=>or(o),rate:this.recurrentDropout,training:n,count:4}));let a=this.dropoutMask,i=this.recurrentDropoutMask,l,u,c,p;0<this.dropout&&this.dropout<1&&(e=P(e,a[0]));let m=xo(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=P(o,i[0])),m=ee(m,xo(o,this.recurrentKernel.read())),this.useBias&&(m=on(m,this.bias.read()));let[f,d,h,g]=mr(m,4,m.rank-1);l=this.recurrentActivation.apply(f),u=this.recurrentActivation.apply(d),c=ee(P(u,s),P(l,this.activation.apply(h))),p=this.recurrentActivation.apply(g);let x=P(p,this.activation.apply(c));return[x,x,c]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Es(this.activation),recurrentActivation:Es(this.recurrentActivation),useBias:this.useBias,kernelInitializer:vt(this.kernelInitializer),recurrentInitializer:vt(this.recurrentInitializer),biasInitializer:vt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:it(this.kernelRegularizer),recurrentRegularizer:it(this.recurrentRegularizer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),kernelConstraint:Pt(this.kernelConstraint),recurrentConstraint:Pt(this.recurrentConstraint),biasConstraint:Pt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}};Fl.className="LSTMCell";J.registerClass(Fl);var $d=class extends Dn{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Fl(e),super(e)}call(e,t){return V(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};$d.className="LSTM";J.registerClass($d);var Qp=class extends Rl{constructor(e){super(e);this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return V(()=>{e=e;let n=e.slice(1),o=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?o.push(n.splice(0,i.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],a;for(let i=0;i<this.cells.length;++i){let l=this.cells[i];n=o[i],i===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=l.call(a,t),s.push(a.slice(1))}n=[];for(let i of s.slice().reverse())n.push(...i);return[a[0]].concat(n)})}build(e){Bx(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,o)=>{Ss(`RNNCell_${o}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(t)};return Object.assign({},e,o)}static fromConfig(e,t,n={}){let o=[];for(let s of t.cells)o.push(an(s,n));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return ad(e)}setWeights(e){let t=[];for(let n of this.cells){let o=n.weights.length,s=e.splice(o);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}qp(t)}};Qp.className="StackedRNNCells";J.registerClass(Qp);function za(r){let{ones:e,rate:t,training:n=!1,count:o=1}=r,s=()=>Mx(e(),t),a=()=>Cl(s,e,n);return!o||o<=1?Et(a().clone()):Array(o).fill(void 0).map(a).map(l=>Et(l.clone()))}var ite=function(r,e){var t={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&e.indexOf(n)<0&&(t[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)e.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(t[n[o]]=r[n[o]]);return t};var A0=class extends Dn{constructor(e){if(e.unroll)throw new Se("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Se("It is not possible at the moment to stack convolutional cells.");super(e);this.inputSpec=[new Ct({ndim:5})]}call(e,t){return V(()=>{if(this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new z("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return V(()=>{let{stateSize:t}=this.cell,n=e.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],a=ht(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){V(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ht(s)):this.states_=[ht(s)];else if(e==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ht(s)):this.states_[0]=ht(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let i=0;i<this.states_.length;++i){let l=e[i],u=s;if(!y.arraysEqual(l.shape,u))throw new z(`State ${i} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[i]=l}}this.states_=this.states_.map(i=>Et(i.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:o,padding:s,strides:a,dilationRate:i}=this.cell,l=t==="channelsFirst",u=e[l?3:2],c=e[l?4:3],p=wn(u,o[0],s,a[0],i[0]),m=wn(c,o[1],s,a[1],i[1]);return[...e.slice(0,2),...l?[n,p,m]:[p,m,n]]}};A0.className="ConvRNN2D";var rm=class extends Fl{constructor(e){let{filters:t,kernelSize:n,strides:o,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign({},e,{units:t}));this.filters=t,Ut(this.filters,"filters"),this.kernelSize=El(n,2,"kernelSize"),this.kernelSize.forEach(l=>Ut(l,"kernelSize")),this.strides=El(o||1,2,"strides"),this.strides.forEach(l=>Ut(l,"strides")),this.padding=s||"valid",nn(this.padding),this.dataFormat=a||"channelsLast",Ft(this.dataFormat),this.dilationRate=El(i||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ut(l,"dilationRate"))}build(e){var t;e=Xe(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new z(`The channel dimension of the input should be defined. Found ${e[n]}`);let o=e[n],s=4,a=this.kernelSize.concat([o,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){let u=this.biasInitializer,c=this.filters;l=new(t=class extends yn{apply(m,f){let d=u.apply([c]),h=Qt([c]),g=u.apply([c*2]);return Mp([d,h,g])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return V(()=>{if(e.length!==3)throw new z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,o=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=za({ones:()=>or(o),rate:this.dropout,training:n,count:i}));let l=this.dropoutMask,u=(Q,ie,ce)=>!ie||!ie[ce]?Q:P(ie[ce],Q),c=u(o,l,0),p=u(o,l,1),m=u(o,l,2),f=u(o,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=za({ones:()=>or(s),rate:this.recurrentDropout,training:n,count:i}));let d=this.recurrentDropoutMask,h=u(s,d,0),g=u(s,d,1),x=u(s,d,2),b=u(s,d,3),w=3,[_,I,E,$]=mr(this.kernel.read(),i,w),[D,O,M,G]=this.useBias?mr(this.bias.read(),i):[null,null,null,null];c=this.inputConv(c,_,D,this.padding),p=this.inputConv(p,I,O,this.padding),m=this.inputConv(m,E,M,this.padding),f=this.inputConv(f,$,G,this.padding);let[j,U,H,q]=mr(this.recurrentKernel.read(),i,w);h=this.recurrentConv(h,j),g=this.recurrentConv(g,U),x=this.recurrentConv(x,H),b=this.recurrentConv(b,q);let X=this.recurrentActivation.apply(ee(c,h)),ne=this.recurrentActivation.apply(ee(p,g)),Y=ee(P(ne,a),P(X,this.activation.apply(ee(m,x)))),re=P(this.recurrentActivation.apply(ee(f,b)),this.activation.apply(Y));return[re,re,Y]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=ite(e,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,o)}inputConv(e,t,n,o){let s=Jr(e,t,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?on(s,n,this.dataFormat):s}recurrentConv(e,t){return Jr(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};rm.className="ConvLSTM2DCell";J.registerClass(rm);var Rd=class extends A0{constructor(e){let t=new rm(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}};Rd.className="ConvLSTM2D";J.registerClass(Rd);var nm=class extends Le{constructor(e){super(e);this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?t[o]:this.noiseShape[o]);return n}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e);if(0<this.rate&&this.rate<1){let o=t.training==null?!1:t.training,s=this.getNoiseShape(n);return Cl(()=>Mx(n,this.rate,s,this.seed),()=>n,o)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};nm.className="Dropout";J.registerClass(nm);var Fd=class extends nm{constructor(e){super(e);this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};Fd.className="SpatialDropout1D";J.registerClass(Fd);var Od=class extends Le{constructor(e){super(e);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ut(this.units,"units"),this.activation=Ds(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=pt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=pt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Mt(e.kernelConstraint),this.biasConstraint=Mt(e.biasConstraint),this.kernelRegularizer=wt(e.kernelRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.activityRegularizer=wt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Xe(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Xe(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e),o=$x(this.activation.getClassName()),s;return o!=null?s=xo(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=xo(n,this.kernel.read()),this.bias!=null&&(s=on(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:Es(this.activation),useBias:this.useBias,kernelInitializer:vt(this.kernelInitializer),biasInitializer:vt(this.biasInitializer),kernelRegularizer:it(this.kernelRegularizer),biasRegularizer:it(this.biasRegularizer),activityRegularizer:it(this.activityRegularizer),kernelConstraint:Pt(this.kernelConstraint),biasConstraint:Pt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};Od.className="Dense";J.registerClass(Od);var Pd=class extends Le{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Xe(e);for(let t of e.slice(1))if(t==null)throw new z(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],go(e,1)]}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=n.transpose(o)}return e3(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};Pd.className="Flatten";J.registerClass(Pd);var Md=class extends Le{constructor(e){super(e);this.supportsMasking=!0,this.activation=Ds(e.activation)}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e);return this.activation.apply(n)})}getConfig(){let e={activation:Es(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};Md.className="Activation";J.registerClass(Md);var Ld=class extends Le{constructor(e){super(e);this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return V(()=>(e=Re(e),Jz(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};Ld.className="RepeatVector";J.registerClass(Ld);var zd=class extends Le{constructor(e){super(e);this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",o=t.slice(),s=1,a=null;for(let l=0;l<o.length;++l){let u=o[l];if(this.isUnknown(u))if(a===null)a=l;else throw new z("Can only specifiy one unknown dimension.");else s*=u}let i=go(e);if(a!==null){if(s===0||i%s!=0)throw new z(n);o[a]=i/s}else if(i!==s)throw new z(n);return o}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return n.reshape(s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};zd.className="Reshape";J.registerClass(zd);var Bd=class extends Le{constructor(e){super(e);if(e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Wr(1,e.dims.length+1);if(!y.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ct({ndim:this.dims.length+1})]}computeOutputShape(e){e=Xe(e);let t=e.slice();return this.dims.forEach((n,o)=>{t[o+1]=e[n]}),t}call(e,t){return Ue(Re(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};Bd.className="Permute";J.registerClass(Bd);var Vd=class extends Le{constructor(e){super(e==null?{}:e);this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Re(e),o=-1;return ml(ro(n,this.maskValue),o)}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e),o=-1,s=!0,a=ml(ro(n,this.maskValue),o,s);return n.mul(a.asType(n.dtype))})}};Vd.className="Masking";J.registerClass(Vd);var Gd=class extends Le{constructor(e){super(e);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(bt(e.inputLength))}this.inputDim=e.inputDim,Ut(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ut(this.outputDim,"outputDim"),this.embeddingsInitializer=pt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=wt(e.embeddingsRegularizer),this.activityRegularizer=wt(e.activityRegularizer),this.embeddingsConstraint=Mt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return V(()=>this.maskZero?(e=Re(e),ro(e,Ie(e))):null)}computeOutputShape(e){if(e=Xe(e),this.inputLength==null)return[...e,this.outputDim];let t=bt(this.inputLength);if(t.length!==e.length-1)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let o=0;o<t.length;++o){let s=t[o],a=e[o+1];if(s!=null&&a!=null&&s!==a)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e);return n.dtype!=="int32"&&(n=Oa(n,"int32")),Px(this.embeddings.read(),n.as1D()).reshape(Xe(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:vt(this.embeddingsInitializer),embeddingsRegularizer:it(this.embeddingsRegularizer),activityRegularizer:it(this.activityRegularizer),embeddingsConstraint:Pt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};Gd.className="Embedding";J.registerClass(Gd);var Ol=class extends Le{constructor(e){super(e||{});this.supportsMasking=!0}mergeFunction(e){throw new Se}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let o=0;o<t.length;++o){let s=e[e.length-t.length+o],a=t[o];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new z("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Xe(e)]),e=e,e.length<2)throw new z(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=ho(t),t.length>1)throw new z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let o=e.map(s=>s.length);e.indexOf(null)===-1&&ho(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return V(()=>{if(e=e,this.reshapeRequired){let n=[],o=e.map(s=>s.rank);if(o.indexOf(null)===-1){let s=Ts(o);for(let a of e){let i=a.rank;for(let l=0;l<s-i;++l)a=Pa(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let l of e){let u=l.rank;if(u==null){let c=l.shape,p=c[0],m=c.slice(1).concat([p]),f=l.reshape([p].concat(go(c.slice(1))));f=Ue(f,[1,0]),f=f.reshape(m),n.push(f),s=!0}else if(u>1){let c=Wr(1,u).concat([0]);n.push(Ue(l,c)),s=!0}else n.push(l)}let a=this.mergeFunction(n),i=a.rank;if(s){if(i==null){let l=a.shape,u=l.length,c=l[u-1],p=[c].concat(l.slice(0,l.length-1));a=Ue(a.reshape([-1,c]),[1,0]).reshape(p)}else if(i>1){let l=[i-1].concat(Wr(0,i-1));a=Ue(a,l)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let o=1;o<e.length;++o){let s=e[o]==null?null:e[o].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let o of e)o!=null&&o[0]!==null&&n.push(o[0]);return n=ho(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return V(()=>{if(t==null)return null;if(!Array.isArray(t))throw new z("`mask` should be an Array");if(!Array.isArray(e))throw new z("`inputs` should be an Array");if(t.length!==e.length)throw new z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(o=>o==null))return null;t=t.map(o=>o==null?o:ur(o,0));let n=t[0];for(let o=1;o<t.length-1;++o)n=yr(n,t[o]);return n})}},Wd=class extends Ol{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ee(t,e[n]);return t})}};Wd.className="Add";J.registerClass(Wd);var jd=class extends Ol{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=P(t,e[n]);return t})}};jd.className="Multiply";J.registerClass(jd);var Ud=class extends Ol{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ee(t,e[n]);return P(1/e.length,t)})}};Ud.className="Average";J.registerClass(Ud);var Hd=class extends Ol{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=en(t,e[n]);return t})}};Hd.className="Maximum";J.registerClass(Hd);var qd=class extends Ol{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ws(t,e[n]);return t})}};qd.className="Minimum";J.registerClass(qd);var Kd=class extends Ol{constructor(e){super(e);this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new z("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let o of e)if(o!=null){t=!1;break}if(t)return;let n=[];for(let o=0;o<e.length;++o){let s=e[o].slice();s.splice(this.axis,1);let a=!1;for(let i of n)if(y.arraysEqual(i,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return V(()=>Mp(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new z("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new z("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new z("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new z(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return V(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let o=[];for(let a=0;a<e.length;++a)t[a]==null?o.push(or(e[a]).asType("bool")):t[a].rank<e[a].rank?o.push(ur(t[a],-1)):o.push(t[a]);let s=Qe(o,this.axis);return Ql(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};Kd.className="Concatenate";J.registerClass(Kd);function Xd(r,e){for(;r<0;)r+=e;return r}function ate(r,e,t){if(r.shape.length>3||e.shape.length>3)throw new Se("batchDot is not implemented for tensors of 4D or higher rank yet");if(y.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),y.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),r.dtype==="complex64"||e.dtype==="complex64")throw new Se("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=e.shape.length;t==null&&(t=[n-1,o-2]);let s=t;return V(()=>{let a;if(n>o){a=n-o;let l=[];for(let u=0;u<a;++u)l.push(1);e=e.reshape(e.shape.concat(l))}else if(o>n){a=o-n;let l=[];for(let u=0;u<a;++u)l.push(1);r=r.reshape(r.shape.concat(l))}else a=0;let i;if(r.shape.length===2&&e.shape.length===2)s[0]===s[1]?i=r.mul(e).sum(s[0]):i=r.transpose([1,0]).mul(e).sum(s[1]);else{let l=s[0]!==r.shape.length-1,u=s[1]===e.shape.length-1;i=r.matMul(e,l,u)}if(a>0){let l;n>o?l=n+o-3:l=n-1;let u=[];for(let c=l;c<l+a;++c)u.push(c);i=i.squeeze(u)}return i.shape.length===1&&(i=i.expandDims(1)),i})}var Yd=class extends Ol{constructor(e){super(e);this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){y.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Se("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);if(t[o[0]]!==n[o[1]])throw new z(`Dimension incompatibility: ${t[o[0]]} !== ${n[o[1]]}`)}mergeFunction(e){if(e.length!==2)throw new z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,a)=>Xd(s,e[a].shape.length)):o=[Xd(this.axes,t.shape.length),Xd(this.axes,n.shape.length)],this.normalize&&(t=ld(t,o[0]),n=ld(n,o[1])),ate(t,n,o)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Xd(this.axes,e.length),Xd(this.axes,t.length)],n}computeOutputShape(e){y.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Se("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);t.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};Yd.className="Dot";J.registerClass(Yd);var Zd=class extends Le{constructor(e){super(e);this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e);return Cl(()=>Lp(n.shape,0,this.stddev).add(n),()=>n,t.training||!1)})}};Zd.className="GaussianNoise";J.registerClass(Zd);var Jd=class extends Le{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return V(()=>{this.invokeCallHook(e,t);let n=Re(e);return this.rate>0&&this.rate<1?Cl(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return n.mul(Lp(n.shape,1,s))},()=>n,t.training||!1):n})}};Jd.className="GaussianDropout";J.registerClass(Jd);var Qd=class extends Le{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Re(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return V(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Cl(()=>{let s=Re(e),a=1.6732632423543772,i=1.0507009873554805,l=-a*i,u=hn(_s(n),this.rate);u=Oa(u,"float32");let c=((1-this.rate)*(1+this.rate*l**2))**-.5,p=-c*l*this.rate;return s.mul(u).add(u.add(-1).mul(l)).mul(c).add(p)},()=>Re(e),t.training||!1)}return e})}};Qd.className="AlphaDropout";J.registerClass(Qd);function eh(r,e,t,n,o,s=.001){let a;if(r.rank===2)a=Vw(r,e,t,n,o,s);else if(r.rank===3)a=Gw(r,e,t,n,o,s);else if(r.rank===4)a=Ww(r,e,t,n,o,s);else throw new Se(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return a}function lte(r,e,t,n,o=.001){return V(()=>{let s=np(r,n),a=s.mean,i=s.variance;return[eh(r,a,i,t,e,o),a,i]})}function ute(r,e,t,n,o=.001){return V(()=>{let s=np(r,n),a=s.mean,i=s.variance,l=[];for(let d of Wr(0,r.rank))n.indexOf(d)!==-1?l.push(1):l.push(r.shape[d]);let u=a.reshape(l),c=i.reshape(l),p=e==null?null:e.reshape(l),m=t==null?null:t.reshape(l);return[eh(r,u,c,m,p,o),a,i]})}function cte(r,e,t,n,o=.001){return y.arraysEqual(n.slice().sort(),Wr(0,r.rank-1))?lte(r,e,t,n,o):ute(r,e,t,n,o)}var th=class extends Le{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pt(e.betaInitializer||"zeros"),this.gammaInitializer=pt(e.gammaInitializer||"ones"),this.movingMeanInitializer=pt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=pt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Mt(e.betaConstraint),this.gammaConstraint=Mt(e.gammaConstraint),this.betaRegularizer=wt(e.betaRegularizer),this.gammaRegularizer=wt(e.gammaRegularizer)}build(e){e=Xe(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new z(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ct({ndim:e.length,axes:{[t]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return V(()=>{let n=t.training==null?!1:t.training,o=Re(e),s=o.shape,a=s.length,i=Wr(0,a),l=this.axis>=0?this.axis:this.axis+a;i.splice(l,1);let u=po(1,a);u[l]=s[l];let c=i.slice();c.sort();let p=!y.arraysEqual(c,Wr(0,a).slice(0,a-1)),m=()=>{if(p){let b=this.movingMean.read().reshape(u),w=this.movingVariance.read().reshape(u),_=this.center?this.beta.read().reshape(u):null,I=this.scale?this.gamma.read().reshape(u):null;return eh(o,b,w,_,I,this.epsilon)}else return eh(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return m();let[f,d,h]=cte(o,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(b,w,_)=>{V(()=>{let I=1-_,E=b.read(),$=E.sub(w).mul(I);b.write(E.sub($))})};return(()=>{g(this.movingMean,d,this.momentum),g(this.movingVariance,h,this.momentum)})(),f})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:vt(this.betaInitializer),gammaInitializer:vt(this.gammaInitializer),movingMeanInitializer:vt(this.movingMeanInitializer),movingVarianceInitializer:vt(this.movingVarianceInitializer),betaRegularizer:it(this.betaRegularizer),gammaRegularizer:it(this.gammaRegularizer),betaConstraint:Pt(this.betaConstraint),gammaConstraint:Pt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};th.className="BatchNormalization";J.registerClass(th);var rh=class extends Le{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=pt(e.betaInitializer||"zeros"),this.gammaInitializer=pt(e.gammaInitializer||"ones"),this.betaRegularizer=wt(e.betaRegularizer),this.gammaRegularizer=wt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Xe(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==ho(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(e,t){let n=Re(e),o=n.shape,s=o.length;return V(()=>{let a=!0,{mean:i,variance:l}=np(n,this.axis,a),u=po(1,s);for(let h of this.axis)u[h]=o[h];let c=h=>h!=null&&h.shape.length!==s&&this.axis!==[s-1]?h.reshape(u):h,p=c(this.gamma.read()),m=c(this.beta.read()),f=[],d=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(f.push(o[h]),d.push(1)):(f.push(1),d.push(o[h]));return i=i.tile(f),l=l.tile(f),p=p.tile(d),m=m.tile(d),eh(n,i,l,m,p,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:vt(this.betaInitializer),gammaInitializer:vt(this.gammaInitializer),betaRegularizer:it(this.betaRegularizer),gammaRegularizer:it(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};rh.className="LayerNormalization";J.registerClass(rh);function pte(r,e,t){return V(()=>{if(r.rank!==4)throw new z(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=rn()),t!=="channelsLast"&&t!=="channelsFirst")throw new z(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return t==="channelsFirst"?n=[[0,0],[0,0],e[0],e[1]]:n=[[0,0],e[0],e[1],[0,0]],Lr(r,n)})}var nh=class extends Le{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?rn():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Ct({ndim:4})]}computeOutputShape(e){e=Xe(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return V(()=>pte(Re(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};nh.className="ZeroPadding2D";J.registerClass(nh);function ny(r,e,t,n,o,s){return V(()=>{Ft(o),HC(s),nn(n),t==null&&(t=[1,1]),n==null&&(n="valid"),o==null&&(o=rn()),s==null&&(s="max"),r=vd(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=wa(r,e,t,i):a=fa(r,e,t,i),o==="channelsFirst"&&(a=Ue(a,[0,3,1,2])),a})}function L3(r,e,t,n,o,s){return V(()=>{Ft(o),HC(s),nn(n),t==null&&(t=[1,1,1]),n==null&&(n="valid"),o==null&&(o=rn()),s==null&&(s="max"),r=I0(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=sf(r,e,t,i):a=qm(r,e,t,i),o==="channelsFirst"&&(a=Ue(a,[0,4,1,2,3])),a})}var E0=class extends Le{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ut(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ut(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,nn(this.padding),this.inputSpec=[new Ct({ndim:3})]}computeOutputShape(e){e=Xe(e);let t=wn(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return V(()=>{this.invokeCallHook(e,t),e=Pa(Re(e),2);let n=this.poolingFunction(Re(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Sn(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},oh=class extends E0{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Ft(s),nn(o),ny(e,t,n,o,s,"max")}};oh.className="MaxPooling1D";J.registerClass(oh);var sh=class extends E0{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Ft(s),nn(o),ny(e,t,n,o,s,"avg")}};sh.className="AveragePooling1D";J.registerClass(sh);var D0=class extends Le{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ut(this.poolSize,"poolSize"),Ut(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ft(this.dataFormat),nn(this.padding),this.inputSpec=[new Ct({ndim:4})]}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=wn(t,this.poolSize[0],this.padding,this.strides[0]),n=wn(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return V(()=>(this.invokeCallHook(e,t),this.poolingFunction(Re(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},ih=class extends D0{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Ft(s),nn(o),ny(e,t,n,o,s,"max")}};ih.className="MaxPooling2D";J.registerClass(ih);var ah=class extends D0{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Ft(s),nn(o),ny(e,t,n,o,s,"avg")}};ah.className="AveragePooling2D";J.registerClass(ah);var $0=class extends Le{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ut(this.poolSize,"poolSize"),Ut(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ft(this.dataFormat),nn(this.padding),this.inputSpec=[new Ct({ndim:5})]}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=wn(t,this.poolSize[0],this.padding,this.strides[0]),n=wn(n,this.poolSize[1],this.padding,this.strides[1]),o=wn(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,o]:[e[0],t,n,o,e[4]]}call(e,t){return V(()=>(this.invokeCallHook(e,t),this.poolingFunction(Re(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},lh=class extends $0{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Ft(s),nn(o),L3(e,t,n,o,s,"max")}};lh.className="MaxPooling3D";J.registerClass(lh);var uh=class extends $0{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Ft(s),nn(o),L3(e,t,n,o,s,"avg")}};uh.className="AveragePooling3D";J.registerClass(uh);var R0=class extends Le{constructor(e){super(e);this.inputSpec=[new Ct({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Se}},ch=class extends R0{constructor(e){super(e||{})}call(e,t){return V(()=>{let n=Re(e);return dt(n,1)})}};ch.className="GlobalAveragePooling1D";J.registerClass(ch);var ph=class extends R0{constructor(e){super(e||{})}call(e,t){return V(()=>{let n=Re(e);return pr(n,1)})}};ph.className="GlobalMaxPooling1D";J.registerClass(ph);var F0=class extends Le{constructor(e){super(e);this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ft(this.dataFormat),this.inputSpec=[new Ct({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Se}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},mh=class extends F0{call(e,t){return V(()=>{let n=Re(e);return this.dataFormat==="channelsLast"?dt(n,[1,2]):dt(n,[2,3])})}};mh.className="GlobalAveragePooling2D";J.registerClass(mh);var fh=class extends F0{call(e,t){return V(()=>{let n=Re(e);return this.dataFormat==="channelsLast"?pr(n,[1,2]):pr(n,[2,3])})}};fh.className="GlobalMaxPooling2D";J.registerClass(fh);var O0=class extends Le{constructor(e){super(e);this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let o=t.layer,s=an(o,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},dh=class extends O0{constructor(e){super(e);this.supportsMasking=!0}build(e){if(e=Xe(e),e.length<3)throw new z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Xe(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),o=e[1];return[n[0],o].concat(n.slice(1))}call(e,t){return V(()=>(e=Re(e),T0((a,i)=>[Re(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};dh.className="TimeDistributed";J.registerClass(dh);function mte(r){pi(Hz,"BidirectionalMergeMode",r)}var fte="concat",hh=class extends O0{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=an(n),t.goBackwards=t.goBackwards!==!0;let o={};if(o.className=e.layer.getClassName(),o.config=t,this.backwardLayer=an(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?fte:e.mergeMode,mte(this.mergeMode),e.weights)throw new Se("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,o,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):wr(o)}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=S0(e,n,o,this.numConstants);if(e=s.inputs,n=s.initialState,o=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&o==null)return super.apply(e,t);let a=[],i=[];if(n!=null){let u=n.length;if(u%2>0)throw new z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let c=n.map(p=>new Ct({shape:p.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),i.push(...c)}if(o!=null)throw new Se("Support for constants in Bidirectional layers is not implemented yet.");let l=a[0]instanceof sn;for(let u of a)if(u instanceof sn!==l)throw new z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){let u=[e].concat(a),c=this.inputSpec.concat(i),p=this.inputSpec;this.inputSpec=c;let m=super.apply(u,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return V(()=>{let n=t.initialState,o,s;if(n==null)o=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let l=n.slice(0,n.length/2),u=n.slice(n.length/2);o=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let a;this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=qt(s,1));let i;return this.mergeMode==="concat"?i=Mp([o,s]):this.mergeMode==="sum"?i=ee(o,s):this.mergeMode==="ave"?i=P(.5,ee(o,s)):this.mergeMode==="mul"?i=P(o,s):this.mergeMode==null&&(i=[o,s]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ss(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ss(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=an(t.layer);if(delete t.layer,t.numConstants!=null)throw new Se("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=t;return o.layer=n,new e(o)}};hh.className="Bidirectional";J.registerClass(hh);function dte(r){return new mi(r)}function hte(r){return new wd(r)}function gte(r){return new xd(r)}function xte(r){return new yd(r)}function yte(r){return new bd(r)}function bte(r){return new kd(r)}function wte(r){return new _d(r)}function _te(r){return new Ju(r)}function kte(r){return new Dl(r)}function vte(r){return new Cd(r)}function Cte(r){return new $l(r)}function Ite(r){return new Id(r)}function Nte(r){return new Nd(r)}function Ste(r){return new Sd(r)}function Tte(r){return new Td(r)}function Ate(r){return new Ad(r)}function Ete(r){return new Md(r)}function Dte(r){return new Od(r)}function $te(r){return new nm(r)}function Rte(r){return new Fd(r)}function Fte(r){return new Pd(r)}function Ote(r){return new Ld(r)}function Pte(r){return new zd(r)}function Mte(r){return new Bd(r)}function Lte(r){return new Gd(r)}function zte(r){return new Wd(r)}function Bte(r){return new Ud(r)}function Vte(r){return new Kd(r)}function Gte(r){return new Hd(r)}function Wte(r){return new qd(r)}function jte(r){return new jd(r)}function Ute(r){return new Yd(r)}function Hte(r){return new th(r)}function qte(r){return new rh(r)}function Kte(r){return new nh(r)}function P0(r){return new sh(r)}function Xte(r){return P0(r)}function Yte(r){return P0(r)}function M0(r){return new ah(r)}function Zte(r){return M0(r)}function Jte(r){return M0(r)}function L0(r){return new uh(r)}function Qte(r){return L0(r)}function ere(r){return L0(r)}function tre(r){return new ch(r)}function rre(r){return new mh(r)}function B3(r){return new ph(r)}function V3(r){return new fh(r)}function G3(r){return new oh(r)}function W3(r){return new ih(r)}function nre(r){return new lh(r)}function ore(r){return new Dd(r)}function sre(r){return new tm(r)}function ire(r){return new $d(r)}function are(r){return new Fl(r)}function lre(r){return new Ed(r)}function ure(r){return new em(r)}function cre(r){return new Rd(r)}function pre(r){return new rm(r)}function mre(r){return new Dn(r)}function fre(r){return new Qp(r)}function dre(r){return new hh(r)}function hre(r){return new dh(r)}var gre=B3,xre=V3,yre=G3,bre=W3;function wre(r){return new Zd(r)}function _re(r){return new Jd(r)}function kre(r){return new Qd(r)}function vre(r){return new Vd(r)}var j3={};We(j3,{MAPE:()=>Fre,MSE:()=>Mre,binaryAccuracy:()=>Cre,binaryCrossentropy:()=>Ire,categoricalAccuracy:()=>Sre,categoricalCrossentropy:()=>Tre,cosineProximity:()=>Dre,mape:()=>Ore,meanAbsoluteError:()=>$re,meanAbsolutePercentageError:()=>Rre,meanSquaredError:()=>Pre,mse:()=>Lre,precision:()=>Are,recall:()=>Ere,sparseCategoricalAccuracy:()=>Nre});function Cre(r,e){return pd(r,e)}function Ire(r,e){return qx(r,e)}function Nre(r,e){return Kx(r,e)}function Sre(r,e){return md(r,e)}function Tre(r,e){return fd(r,e)}function Are(r,e){return e0(r,e)}function Ere(r,e){return f3(r,e)}function Dre(r,e){return ud(r,e)}function $re(r,e){return Kp(r,e)}function Rre(r,e){return Tl(r,e)}function Fre(r,e){return Tl(r,e)}function Ore(r,e){return Tl(r,e)}function Pre(r,e){return di(r,e)}function Mre(r,e){return di(r,e)}function Lre(r,e){return di(r,e)}var U3={};We(U3,{modelFromJSON:()=>D3});var H3={};We(H3,{l1:()=>Bre,l1l2:()=>zre,l2:()=>Vre});function zre(r){return new Yu(r)}function Bre(r){return R3(r)}function Vre(r){return F3(r)}var z0=class extends Sl{constructor(){super(...arguments);this.model=null}setModel(e){if(!(e instanceof jn))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function oy(r,e){return r<e}function q3(r,e){return r>e}var B0=class extends z0{constructor(e){super();if(e==null&&(e={}),e.restoreBestWeights)throw new Se("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=oy:this.mode==="max"?this.monitorFunc=q3:this.monitor.indexOf("acc")!==-1?this.monitorFunc=q3:this.monitorFunc=oy,this.monitorFunc===oy&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===oy?Infinity:-Infinity}async onEpochEnd(e,t){await fi(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function Gre(r){return new B0(r)}var Wre={earlyStopping:Gre};var yo;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(yo||(yo={}));var K3;(function(r){let e;(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(K3||(K3={}));var V0={};function jre(r,e){let t={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:e};V0[r]=t}function sy(r){return V0[r]}function Ure(r){delete V0[r]}function v(r,e,t,n,o){let s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){let i=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?i+1:s.inputIndexEnd;if(s.type==="tensor")return hr(e.inputNames[s.inputIndexStart],t,n,o);if(s.type==="tensors")return e.inputNames.slice(i,l).map(m=>hr(m,t,n,o));let u=hr(e.inputNames.slice(i)[0],t,n,o),c=u.dataSync();return s.type==="number"?c[0]:y.toNestedArray(u.shape,c)}let a=e.attrParams[r];return a&&a.value}function hr(r,e,t,n){let[o,s]=un(r);if(n!=null){let i=n.getHashTableHandleByName(o);if(i!=null)return i}let a=t.currentContextIds.find(i=>!!e[iy(o,i)]);return a!==void 0?e[iy(o,a)][s]:void 0}function X3(r,e,t){return e[iy(r,t.currentContextId)]}function Rs(r,e){let[t,n]=un(r);return[iy(t,e&&e.currentContextId),n]}function iy(r,e){return e?`${r}-${e}`:r}function un(r){let e=r.split(":");return e.length===1?[r,0]:[e[0],Number(e[e.length-1])]}function gh(r,e,t){let n=v("pad",r,e,t);if(n==="explicit"){n=v("explicitPaddings",r,e,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function Fs(r){return r.kept?r:Mn(r)}var G0={};We(G0,{json:()=>Hre});var Hre=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var W0={};We(W0,{json:()=>qre});var qre=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var j0={};We(j0,{json:()=>Kre});var Kre=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var U0={};We(U0,{json:()=>Xre});var Xre=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var H0={};We(H0,{json:()=>Yre});var Yre=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var q0={};We(q0,{json:()=>Zre});var Zre=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var K0={};We(K0,{json:()=>Jre});var Jre=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var X0={};We(X0,{json:()=>Qre});var Qre=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var Y0={};We(Y0,{json:()=>ene});var ene=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var Z0={};We(Z0,{json:()=>tne});var tne=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var J0={};We(J0,{json:()=>rne});var rne=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Q0={};We(Q0,{json:()=>nne});var nne=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var eI={};We(eI,{json:()=>one});var one=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var tI={};We(tI,{json:()=>sne});var sne=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var rI={};We(rI,{json:()=>ine});var ine=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var nI={};We(nI,{json:()=>ane});var ane=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var oI={};We(oI,{json:()=>lne});var lne=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];var ay=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[G0,W0,j0,U0,H0,q0,K0,J0,Z0,X0,Q0,eI,tI,rI,nI,oI,Y0],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(e,t={}){let n=e.node,o=[],s=[],a=[],i=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&a.push(h[g.name]),h),{}),l=[],u=[],c={},p={};t!=null&&(c=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let m=Object.keys(i);m.forEach(h=>{let g=i[h];g.inputNames.forEach(x=>{let[b]=Rs(x);g.inputs.push(i[b]),i[b].children.push(g)})}),Object.keys(p).length===0?m.forEach(h=>{let g=i[h];g.children.length===0&&u.push(g)}):Object.keys(p).forEach(h=>{let[g]=Rs(h),x=i[g];x!=null&&(x.signatureKey=p[h],u.push(x))}),Object.keys(c).length>0?Object.keys(c).forEach(h=>{let[g]=Rs(h),x=i[g];x&&(x.signatureKey=c[h],l.push(x))}):l=o;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let d={nodes:i,inputs:l,outputs:u,weights:s,placeholders:o,signature:t,functions:f};return a.length>0&&(d.initNodes=a),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=sy(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.substr(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((o,s)=>{let a=s.type,i;switch(s.type){case"string":i=ly(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ly(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=hy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=hy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=cy(e.attr,s.tfName,s.defaultValue||0),i===void 0&&!!s.tfDeprecatedName&&(i=cy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=dy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=dy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=uy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=uy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=xy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=xy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=fy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=fy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=gy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=gy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=py(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=py(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=my(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=my(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=Y3(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=Y3(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return o[s.name]={value:i,type:a},o},{})),n}mapFunction(e){let t=e.nodeDef,n=[],o=[],s={};t!=null&&(s=t.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&o.push(p[m.name]),p),{}));let a=[],i=[];e.signature.inputArg.forEach(p=>{let[m]=Rs(p.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:sI(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,a.push(f),s[m]=f}),Object.keys(s).forEach(p=>{let m=s[p];m.inputNames.forEach(f=>{let[d]=Rs(f);m.inputs.push(s[d]),s[d].children.push(m)})});let u=e.ret;e.signature.outputArg.forEach(p=>{let[m,f]=Rs(u[p.name]),d=s[m];d!=null&&(d.defaultOutput=f,i.push(d))});let c=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:o,placeholders:n,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function une(r){let e=W().global;if(typeof e.atob!="undefined")return e.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Z3(r,e){let t=Array.isArray(r)?String.fromCharCode.apply(null,r):une(r);return e?t:t.toLowerCase()}function ly(r,e,t,n=!1){let o=r[e];return o!=null?Z3(o.s,n):t}function uy(r,e,t){let n=r[e];return n?n.b:t}function cy(r,e,t){let n=r[e]||{},o=n.i!=null?n.i:n.f!=null?n.f:t;return typeof o=="number"?o:parseInt(o,10)}function sI(r){switch(typeof r=="string"&&(r=yo[r]),r){case yo.DT_FLOAT:return"float32";case yo.DT_INT32:case yo.DT_INT64:case yo.DT_INT8:case yo.DT_UINT8:return"int32";case yo.DT_BOOL:return"bool";case yo.DT_DOUBLE:return"float32";case yo.DT_STRING:return"string";default:return null}}function Y3(r,e,t){let n=r[e];return n&&n.func?n.func.name:t}function py(r,e,t){let n=r[e];return n&&n.type?sI(n.type):t}function my(r,e,t){let n=r[e];return n&&n.list&&n.list.type?n.list.type.map(o=>sI(o)):t}function J3(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function fy(r,e,t){let n=r[e];return n&&n.shape?J3(n.shape):t}function dy(r,e,t){let n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function hy(r,e,t,n=!1){let o=r[e];return o&&o.list&&o.list.s?o.list.s.map(s=>Z3(s,n)):t}function gy(r,e,t){let n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(o=>J3(o)):t}function xy(r,e,t){let n=r[e];return n&&n.list&&n.list.b?n.list.b:t}var iI=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(e){return hr(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return hr(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return cy(this.node.rawAttrs,e,t);if(n.s!=null)return ly(this.node.rawAttrs,e,t);if(n.b!=null)return uy(this.node.rawAttrs,e,t);if(n.shape!=null)return fy(this.node.rawAttrs,e,t);if(n.type!=null)return py(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return dy(this.node.rawAttrs,e,t);if(n.list.s!=null)return hy(this.node.rawAttrs,e,t);if(n.list.shape!=null)return gy(this.node.rawAttrs,e,t);if(n.list.b!=null)return xy(this.node.rawAttrs,e,t);if(n.list.type!=null)return my(this.node.rawAttrs,e,t)}return t}};var Q3=(r,e,t)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[ee(v("a",r,e,t),v("b",r,e,t))];case"AddN":return[Mw(v("tensors",r,e,t))];case"FloorMod":case"Mod":return[lf(v("a",r,e,t),v("b",r,e,t))];case"Mul":return[P(v("a",r,e,t),v("b",r,e,t))];case"RealDiv":case"Div":return[me(v("a",r,e,t),v("b",r,e,t))];case"DivNoNan":return[Jm(v("a",r,e,t),v("b",r,e,t))];case"FloorDiv":return[Jl(v("a",r,e,t),v("b",r,e,t))];case"Sub":return[pe(v("a",r,e,t),v("b",r,e,t))];case"Minimum":return[ws(v("a",r,e,t),v("b",r,e,t))];case"Maximum":return[en(v("a",r,e,t),v("b",r,e,t))];case"Pow":return[zr(v("a",r,e,t),v("b",r,e,t))];case"SquaredDifference":return[bu(v("a",r,e,t),v("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var eB=(r,e,t)=>{switch(r.op){case"Abs":case"ComplexAbs":return[Nt(v("x",r,e,t))];case"Acos":return[zm(v("x",r,e,t))];case"Acosh":return[Bm(v("x",r,e,t))];case"Asin":return[Gm(v("x",r,e,t))];case"Asinh":return[Wm(v("x",r,e,t))];case"Atan":return[jm(v("x",r,e,t))];case"Atan2":return[Um(v("x",r,e,t),v("y",r,e,t))];case"Atanh":return[Hm(v("x",r,e,t))];case"Ceil":return[Km(v("x",r,e,t))];case"Complex":return[In(v("real",r,e,t),v("imag",r,e,t))];case"Cos":return[ga(v("x",r,e,t))];case"Cosh":return[ou(v("x",r,e,t))];case"Elu":return[ys(v("x",r,e,t))];case"Erf":return[Qm(v("x",r,e,t))];case"Exp":return[Jt(v("x",r,e,t))];case"Expm1":return[ef(v("x",r,e,t))];case"Floor":return[bs(v("x",r,e,t))];case"Log":return[cr(v("x",r,e,t))];case"Log1p":return[lu(v("x",r,e,t))];case"Imag":return[iu(v("x",r,e,t))];case"Neg":return[qe(v("x",r,e,t))];case"Reciprocal":return[uf(v("x",r,e,t))];case"Real":return[dl(v("x",r,e,t))];case"Relu":return[Dr(v("x",r,e,t))];case"Round":return[cf(v("x",r,e,t))];case"Selu":return[hu(v("x",r,e,t))];case"Sigmoid":return[Er(v("x",r,e,t))];case"Sin":return[gu(v("x",r,e,t))];case"Sign":return[mf(v("x",r,e,t))];case"Sinh":return[xu(v("x",r,e,t))];case"Softplus":return[eo(v("x",r,e,t))];case"Sqrt":return[gt(v("x",r,e,t))];case"Square":return[Me(v("x",r,e,t))];case"Tanh":return[gs(v("x",r,e,t))];case"Tan":return[gf(v("x",r,e,t))];case"ClipByValue":return[lr(v("x",r,e,t),v("clipValueMin",r,e,t),v("clipValueMax",r,e,t))];case"Relu6":return[fu(v("x",r,e,t))];case"Rsqrt":return[du(hr(r.inputNames[0],e,t))];case"Prod":return[pu(v("x",r,e,t),v("axes",r,e,t))];case"LeakyRelu":return[ya(v("x",r,e,t),v("alpha",r,e,t))];case"Prelu":return[ka(v("x",r,e,t),v("alpha",r,e,t))];case"IsNan":return[tf(hr(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function $n(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){y.assert(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=e[n];y.assert(o<0||s<0||o===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function tB(r){return!(typeof r=="number"||r.some(e=>e<0))}function om(r,e,t){let n=yy(r,t),o=!tB(n);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&e.forEach(s=>{n=yy(s.shape,n)}),!tB(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function yy(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);let t=[];for(let n=0;n<r.length;++n){let o=r[n],s=e[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=o>=0?o:s}return t}var aI=class{constructor(e,t,n,o,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=le(0),Et(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),$n(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Et(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,o)=>this.write(n,t[o]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return Mr([],[0].concat(this.elementShape));let n=this.readMany(e);return $n(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Bt(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Mr([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let n=this.readMany(t);return $n(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Qe(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,fr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,o=e.map(l=>(n+=l,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];V(()=>{t=L(t,[1,n,s]);for(let l=0;l<e.length;++l){let u=l===0?0:o[l-1],c=[0,u,0],p=[1,e[l],s];a[l]=L(Fe(t,c,p),this.elementShape)}return a});let i=[];for(let l=0;l<e.length;l++)i[l]=l;this.writeMany(i,a)}};var Qu=class{constructor(e,t,n,o=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);$n(t,s.shape,"TensorList shape mismatch: "),Et(s)}),this.idTensor=le(0),this.maxNumElements=o,Et(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Qu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);$n(e,this.elementShape,"TensorList shape mismatch: ");let o=om(this.elementShape,this.tensors,e);return V(()=>{let s=this.tensors.map(a=>L(a,o));return Bt(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=om(this.elementShape,this.tensors,e),o=this.tensors.pop();return $n(o.shape,e,"TensorList shape mismatch: "),L(o,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if($n(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Et(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);$n(this.tensors[e].shape,t,"TensorList shape mismatch: ");let o=om(this.elementShape,this.tensors,t);return L(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);$n(this.elementShape,t.shape,"TensorList shape mismatch: "),Et(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);$n(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let o=om(this.elementShape,this.tensors,n);return e.length===0?Mr([],[0].concat(o)):V(()=>{let s=e.map(a=>L(this.tensors[a],o));return Bt(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);$n(this.elementShape,t,"TensorList shape mismatch: ");let n=om(this.elementShape,this.tensors,t);return this.size()===0?Mr([],[0].concat(n)):V(()=>{let o=this.tensors.map(s=>L(s,n));return Qe(o,0)})}};function rB(r,e,t){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);let o=r.shape.slice(1);$n(o,e,"TensorList shape mismatch: ");let s=fr(r);return new Qu(s,e,n)}function nB(r,e,t){return new Qu([],r,e,t)}function oB(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);let o=Math.max(...e);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new Qu([],t,r.dtype,n),a=fr(r,0);return e.forEach((i,l)=>{s.setItem(i,a[l])}),s}function sB(r,e,t){let n=0,o=e.map(c=>(n+=c,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),a=yy(s,t),i=n===0?0:r.size/n,l=V(()=>{let c=[];r=L(r,[1,n,i]);for(let p=0;p<e.length;++p){let m=p===0?0:o[p-1],f=[0,m,0],d=[1,e[p],i];c[p]=L(Fe(r,f,d),a)}return r.dispose(),c}),u=new Qu([],t,r.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var iB=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{let n=v("thenBranch",r,e,t),o=v("elseBranch",r,e,t),s=v("cond",r,e,t),a=v("args",r,e,t);return(await s.data())[0]?t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let n=v("body",r,e,t),o=v("cond",r,e,t),s=v("args",r,e,t),a=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),i=s.map(c=>c.id),l=await a[0].data();a.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;l[0];){let c=u;u=await t.functionMap[n].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);let p=u.map(f=>f.id);c.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let m=await t.functionMap[o].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await m[0].data(),m.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return u}case"LoopCond":{let n=v("pred",r,e,t);return[Fs(n)]}case"Switch":{let n=v("pred",r,e,t),o=v("data",r,e,t);return o.kept||(o=Fs(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>hr(o,e,t)!==void 0);if(n){let o=hr(n,e,t);return[Fs(o)]}return}case"Enter":{let n=v("frameName",r,e,t),o=v("tensor",r,e,t);return t.enterFrame(n),[Fs(o)]}case"Exit":{let n=v("tensor",r,e,t);return t.exitFrame(),[Fs(n)]}case"NextIteration":{let n=v("tensor",r,e,t);return t.nextIteration(),[Fs(n)]}case"TensorArrayV3":{let n=v("size",r,e,t),o=v("dtype",r,e,t),s=v("elementShape",r,e,t),a=v("dynamicSize",r,e,t),i=v("clearAfterRead",r,e,t),l=v("identicalElementShapes",r,e,t),u=v("name",r,e,t),c=new aI(u,o,n,s,l,a,i);return t.addTensorArray(c),[c.idTensor,le(1)]}case"TensorArrayWriteV3":{let n=v("tensorArrayId",r,e,t),o=v("index",r,e,t),s=v("tensor",r,e,t),a=t.getTensorArray(n.id);return a.write(o,s),[a.idTensor]}case"TensorArrayReadV3":{let n=v("tensorArrayId",r,e,t),o=v("index",r,e,t);return[t.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=v("tensorArrayId",r,e,t),o=v("indices",r,e,t),s=v("dtype",r,e,t);return[t.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=v("tensorArrayId",r,e,t),o=v("indices",r,e,t),s=v("tensor",r,e,t),a=t.getTensorArray(n.id);return a.scatter(o,s),[a.idTensor]}case"TensorArrayConcatV3":{let n=v("tensorArrayId",r,e,t),o=t.getTensorArray(n.id),s=v("dtype",r,e,t);return[o.concat(s)]}case"TensorArraySplitV3":{let n=v("tensorArrayId",r,e,t),o=v("tensor",r,e,t),s=v("lengths",r,e,t),a=t.getTensorArray(n.id);return a.split(s,o),[a.idTensor]}case"TensorArraySizeV3":{let n=v("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return[le(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=v("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=v("tensorListId",r,e,t),o=v("index",r,e,t),s=v("tensor",r,e,t),a=t.getTensorList(n.id);return a.setItem(o,s),[a.idTensor]}case"TensorListGetItem":{let n=v("tensorListId",r,e,t),o=v("index",r,e,t),s=v("elementShape",r,e,t),a=v("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(o,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{let n=v("indices",r,e,t),o=v("tensor",r,e,t),s=v("elementShape",r,e,t),a=v("numElements",r,e,t),i=oB(o,n,s,a);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=v("elementShape",r,e,t),o=v("elementDType",r,e,t),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let a=v(s,r,e,t),i=nB(n,o,a);return t.addTensorList(i),[i.idTensor]}case"TensorListGather":{let n=v("tensorListId",r,e,t),o=v("indices",r,e,t),s=v("elementShape",r,e,t),a=v("elementDType",r,e,t);return[t.getTensorList(n.id).gather(o,a,s)]}case"TensorListStack":{let n=v("tensorListId",r,e,t),o=v("elementShape",r,e,t),s=v("elementDType",r,e,t),a=v("numElements",r,e,t);return[t.getTensorList(n.id).stack(o,s,a)]}case"TensorListFromTensor":{let n=v("tensor",r,e,t),o=v("elementShape",r,e,t),s=v("elementDType",r,e,t),a=rB(n,o,s);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":{let n=v("tensorListId",r,e,t),o=t.getTensorList(n.id),s=v("dtype",r,e,t),a=v("elementShape",r,e,t);return[o.concat(s,a)]}case"TensorListPushBack":{let n=v("tensorListId",r,e,t),o=v("tensor",r,e,t),s=t.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=v("tensorListId",r,e,t),o=v("elementShape",r,e,t),s=v("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=v("tensor",r,e,t),o=v("elementShape",r,e,t),s=v("lengths",r,e,t),a=sB(n,s,o);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function aB(r,e,t){let[n,o]=v("fusedOps",r,e,t),s=n==="biasadd",a=o==="prelu",i=n==="fusedbatchnorm",l=v("numArgs",r,e,t);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=v("strides",r,e,t),c=gh(r,e,t),p=v("dataFormat",r,e,t).toUpperCase(),m=v("dilations",r,e,t),[f,d]=v("args",r,e,t),h=v("leakyreluAlpha",r,e,t);return{stride:u,pad:c,dataFormat:p,dilations:m,biasArg:f,preluArg:d,activationFunc:o,leakyreluAlpha:h}}var lB=(r,e,t)=>{switch(r.op){case"Conv1D":{let n=v("stride",r,e,t),o=v("pad",r,e,t),s=v("dataFormat",r,e,t).toUpperCase(),a=v("dilation",r,e,t);return[ru(v("x",r,e,t),v("filter",r,e,t),n,o,s,a)]}case"Conv2D":{let n=v("strides",r,e,t),o=gh(r,e,t),s=v("dataFormat",r,e,t).toUpperCase(),a=v("dilations",r,e,t);return[Jr(v("x",r,e,t),v("filter",r,e,t),[n[1],n[2]],o,s,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:n,pad:o,dataFormat:s,dilations:a,biasArg:i,preluArg:l,activationFunc:u,leakyreluAlpha:c}=aB(r,e,t);return[no.conv2d({x:v("x",r,e,t),filter:v("filter",r,e,t),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[a[1],a[2]],bias:i,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:o,dataFormat:s,dilations:a,biasArg:i,preluArg:l,activationFunc:u,leakyreluAlpha:c}=aB(r,e,t);return[no.depthwiseConv2d({x:v("x",r,e,t),filter:v("filter",r,e,t),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[a[1],a[2]],bias:i,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=v("outputShape",r,e,t),o=v("strides",r,e,t),s=gh(r,e,t);return[nu(v("x",r,e,t),v("filter",r,e,t),n,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=v("strides",r,e,t),o=gh(r,e,t),s=v("dilations",r,e,t),a=v("dataFormat",r,e,t).toUpperCase();return[xs(v("input",r,e,t),v("filter",r,e,t),[n[1],n[2]],o,a,[s[1],s[2]])]}case"Conv3D":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("dataFormat",r,e,t).toUpperCase(),a=v("dilations",r,e,t);return[Xm(v("x",r,e,t),v("filter",r,e,t),[n[1],n[2],n[3]],o,s,[a[1],a[2],a[3]])]}case"AvgPool":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t);return[fa(v("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPool":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t);return[wa(v("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPoolWithArgmax":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t),a=v("includeBatchInIndex",r,e,t),{result:i,indexes:l}=a_(v("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o,a);return[i,l]}case"AvgPool3D":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t);return[qm(v("x",r,e,t),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"MaxPool3D":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t);return[sf(v("x",r,e,t),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"Dilation2D":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("dilations",r,e,t),a=n[1],i=n[2],l=s[1],u=s[2];return[Zm(v("x",r,e,t),v("filter",r,e,t),[a,i],o,[l,u],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var uB=(r,e,t)=>{switch(r.op){case"Fill":{let n=v("shape",r,e,t),o=v("dtype",r,e,t),s=v("value",r,e,t);return[xa(n,s,o)]}case"LinSpace":{let n=v("start",r,e,t),o=v("stop",r,e,t),s=v("num",r,e,t);return[t_(n,o,s)]}case"Multinomial":{let n=v("logits",r,e,t),o=v("numSamples",r,e,t),s=v("seed",r,e,t);return[l_(n,o,s)]}case"OneHot":{let n=v("indices",r,e,t),o=v("depth",r,e,t),s=v("onValue",r,e,t),a=v("offValue",r,e,t);return[ds(n,o,s,a)]}case"Ones":return[Qt(v("shape",r,e,t),v("dtype",r,e,t))];case"OnesLike":return[or(v("x",r,e,t))];case"RandomUniform":return[_s(v("shape",r,e,t),v("minval",r,e,t),v("maxval",r,e,t),v("dtype",r,e,t))];case"Range":{let n=v("start",r,e,t),o=v("stop",r,e,t),s=v("step",r,e,t);return[sp(n,o,s,v("dtype",r,e,t))]}case"TruncatedNormal":{let n=v("shape",r,e,t),o=v("mean",r,e,t),s=v("stdDev",r,e,t),a=v("seed",r,e,t);return[wu(n,o,s,v("dtype",r,e,t),a)]}case"Zeros":return[ht(v("shape",r,e,t),v("dtype",r,e,t))];case"ZerosLike":return[Ie(v("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function lI(r,e,t){let n=v("boxes",r,e,t),o=v("scores",r,e,t),s=v("maxOutputSize",r,e,t),a=v("iouThreshold",r,e,t),i=v("scoreThreshold",r,e,t),l=v("softNmsSigma",r,e,t);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}}var cB=async(r,e,t)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}=lI(r,e,t),u=await ii.nonMaxSuppressionWithScoreAsync(n,o,s,a,i,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i}=lI(r,e,t),l=v("padToMaxOutputSize",r,e,t),u=await ii.nonMaxSuppressionPaddedAsync(n,o,s,a,i,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i}=lI(r,e,t);return[await ii.nonMaxSuppressionAsync(n,o,s,a,i)]}case"Where":{let n=oe(v("condition",r,e,t),"bool"),o=[await bf(n)];return n.dispose(),o}case"ListDiff":return w_(v("x",r,e,t),v("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var pB=(r,e,t)=>{switch(r.op){case"TopKV2":{let n=v("x",r,e,t),o=v("k",r,e,t),s=v("sorted",r,e,t),a=xf(n,o,s);return[a.values,a.indices]}case"Unique":{let n=v("x",r,e,t),o=ap(n);return[o.values,o.indices]}case"UniqueV2":{let n=v("x",r,e,t),o=v("axis",r,e,t),s=ap(n,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var mB=(r,e,t)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":let n=v("default",r,e,t);return[hr(r.name,e,t)||n];case"Placeholder":return[hr(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=v("x",r,e,t);return[Fs(u)]}case"IdentityN":return v("x",r,e,t).map(u=>Fs(u));case"Snapshot":let o=v("x",r,e,t);return[Fs(o)];case"Shape":return[Vt(v("x",r,e,t).shape,"int32")];case"ShapeN":return v("x",r,e,t).map(u=>Vt(u.shape));case"Size":return[le(v("x",r,e,t).size,"int32")];case"Rank":return[le(v("x",r,e,t).rank,"int32")];case"NoOp":return[le(1)];case"Print":let s=v("x",r,e,t),a=v("data",r,e,t),i=v("message",r,e,t),l=v("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var uI=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=le(0),this.tensorMap=new Map,Et(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return le(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),V(()=>{let o=fr(t),s=n.length,a=o.length;y.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let l=n[i],u=o[i];Et(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return V(()=>{let o=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,t);o.push(i)}return Bt(o)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};var fB=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=v("keyDType",r,e,t),s=v("valueDType",r,e,t),a=new uI(o,s);return n.addHashTable(r.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=v("tableHandle",r,e,t,n),s=v("keys",r,e,t),a=v("values",r,e,t);return[await n.getHashTableById(o.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{let o=v("tableHandle",r,e,t,n),s=v("keys",r,e,t),a=v("defaultValue",r,e,t);return[await n.getHashTableById(o.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=v("tableHandle",r,e,t,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var dB=(r,e,t)=>{switch(r.op){case"ResizeBilinear":{let n=v("images",r,e,t),o=v("size",r,e,t),s=v("alignCorners",r,e,t),a=v("halfPixelCenters",r,e,t);return[ii.resizeBilinear(n,[o[0],o[1]],s,a)]}case"ResizeNearestNeighbor":{let n=v("images",r,e,t),o=v("size",r,e,t),s=v("alignCorners",r,e,t),a=v("halfPixelCenters",r,e,t);return[ii.resizeNearestNeighbor(n,[o[0],o[1]],s,a)]}case"CropAndResize":{let n=v("image",r,e,t),o=v("boxes",r,e,t),s=v("boxInd",r,e,t),a=v("cropSize",r,e,t),i=v("method",r,e,t),l=v("extrapolationValue",r,e,t);return[ii.cropAndResize(n,o,s,a,i,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var hB=(r,e,t)=>{switch(r.op){case"Equal":return[Nn(v("a",r,e,t),v("b",r,e,t))];case"NotEqual":return[ro(v("a",r,e,t),v("b",r,e,t))];case"Greater":return[nr(v("a",r,e,t),v("b",r,e,t))];case"GreaterEqual":return[hn(v("a",r,e,t),v("b",r,e,t))];case"Less":return[au(v("a",r,e,t),v("b",r,e,t))];case"LessEqual":return[Bn(v("a",r,e,t),v("b",r,e,t))];case"LogicalAnd":return[yr(v("a",r,e,t),v("b",r,e,t))];case"LogicalNot":return[ba(v("a",r,e,t))];case"LogicalOr":return[cu(v("a",r,e,t),v("b",r,e,t))];case"Select":case"SelectV2":return[Dt(v("condition",r,e,t),v("a",r,e,t),v("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var gB=(r,e,t)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[ze(v("a",r,e,t),v("b",r,e,t),v("transposeA",r,e,t),v("transposeB",r,e,t))];case"Einsum":return[Jw(v("equation",r,e,t),...v("tensors",r,e,t))];case"Transpose":return[Ue(v("x",r,e,t),v("perm",r,e,t))];case"_FusedMatMul":let[n,o]=v("fusedOps",r,e,t),s=n==="biasadd",a=o==="prelu",i=v("numArgs",r,e,t),l=v("leakyreluAlpha",r,e,t);if(s){if(a&&i!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,c]=v("args",r,e,t);return[no.matMul({a:v("a",r,e,t),b:v("b",r,e,t),transposeA:v("transposeA",r,e,t),transposeB:v("transposeB",r,e,t),bias:u,activation:o,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var xB=(r,e,t)=>{switch(r.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Jn(v("x",r,e,t),v("mean",r,e,t),v("variance",r,e,t),v("offset",r,e,t),v("scale",r,e,t),v("epsilon",r,e,t))];case"FusedBatchNormV3":return[Jn(v("x",r,e,t),v("mean",r,e,t),v("variance",r,e,t),v("offset",r,e,t),v("scale",r,e,t),v("epsilon",r,e,t))];case"LRN":return[rf(v("x",r,e,t),v("radius",r,e,t),v("bias",r,e,t),v("alpha",r,e,t),v("beta",r,e,t))];case"Softmax":return[va(v("x",r,e,t))];case"LogSoftmax":return[uu(v("x",r,e,t))];case"SparseToDense":return[kg(v("sparseIndices",r,e,t),v("outputShape",r,e,t),v("sparseValues",r,e,t),v("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var yB=(r,e,t)=>{switch(r.op){case"Max":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[pr(v("x",r,e,t),a,i)]}case"Mean":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[dt(v("x",r,e,t),a,i)]}case"Min":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[ni(v("x",r,e,t),a,i)]}case"Sum":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[ge(v("x",r,e,t),a,i)]}case"All":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[Ql(v("x",r,e,t),a,i)]}case"Any":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[ml(v("x",r,e,t),a,i)]}case"ArgMax":{let a=v("axis",r,e,t);return[fl(v("x",r,e,t),a)]}case"ArgMin":{let a=v("axis",r,e,t);return[Vm(v("x",r,e,t),a)]}case"Prod":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[pu(v("x",r,e,t),a,i)]}case"Cumsum":{let a=v("axis",r,e,t),i=v("exclusive",r,e,t),l=v("reverse",r,e,t);return[su(v("x",r,e,t),a,i,l)]}case"Bincount":let n=v("x",r,e,t),o=v("weights",r,e,t),s=v("size",r,e,t);return[jw(n,o,s)];case"DenseBincount":{let a=v("x",r,e,t),i=v("weights",r,e,t),l=v("size",r,e,t),u=v("binaryOutput",r,e,t);return[Yw(a,i,l,u)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var bB=(r,e,t)=>{switch(r.op){case"ConcatV2":case"Concat":{let n=v("n",r,e,t),o=v("axis",r,e,t),s=v("tensors",r,e,t);return s=s.slice(0,n),[Qe(s,o)]}case"Gather":{let n=v("x",r,e,t),o=v("indices",r,e,t);return[Qn(n,oe(o,"int32"),0)]}case"GatherV2":{let n=v("axis",r,e,t),o=v("batchDims",r,e,t),s=v("x",r,e,t),a=v("indices",r,e,t);return[Qn(s,oe(a,"int32"),n,o)]}case"Reverse":{let n=v("dims",r,e,t),o=[];for(let a=0;a<n.length;a++)n[a]&&o.push(a);let s=v("x",r,e,t);return[qt(s,o)]}case"ReverseV2":{let n=v("axis",r,e,t),o=v("x",r,e,t);return[qt(o,n)]}case"Slice":{let n=v("begin",r,e,t),o=v("size",r,e,t);return[Fe(v("x",r,e,t),n,o)]}case"StridedSlice":{let n=v("begin",r,e,t),o=v("end",r,e,t),s=v("strides",r,e,t),a=v("beginMask",r,e,t),i=v("endMask",r,e,t),l=v("ellipsisMask",r,e,t),u=v("newAxisMask",r,e,t),c=v("shrinkAxisMask",r,e,t),p=v("x",r,e,t);return[hf(p,n,o,s,a,i,l,u,c)]}case"Pack":return V(()=>{let n=v("axis",r,e,t),o=v("tensors",r,e,t),s=o[0].shape,a=Sn(o[0]).shape,i=o.map(l=>{let u=y.arraysEqual(l.shape,s);if(!u&&!y.arraysEqual(Sn(l).shape,a))throw new Error("the input tensors shape does not match");return u?l:L(l,s)});return[Bt(i,n)]});case"Unpack":{let n=v("axis",r,e,t),o=v("tensor",r,e,t);return fr(o,n)}case"Tile":{let n=v("reps",r,e,t);return[zn(v("x",r,e,t),n)]}case"Split":case"SplitV":{let n=v("axis",r,e,t),o=v("numOrSizeSplits",r,e,t),s=v("x",r,e,t);return mr(s,o,n)}case"ScatterNd":{let n=v("indices",r,e,t),o=v("values",r,e,t),s=v("shape",r,e,t);return[QT(n,o,s)]}case"GatherNd":{let n=v("x",r,e,t),o=v("indices",r,e,t);return[t1(n,o)]}case"SparseToDense":{let n=v("sparseIndices",r,e,t),o=v("outputShape",r,e,t),s=v("sparseValues",r,e,t),a=v("defaultValue",r,e,t);return[kg(n,s,o,s.dtype===a.dtype?a:oe(a,s.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var wB=(r,e,t)=>{switch(r.op){case"SparseReshape":{let{outputIndices:n,outputShape:o}=P1.sparseReshape(v("inputIndices",r,e,t),v("inputShape",r,e,t),v("newShape",r,e,t));return[n,o]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var _B=(r,e,t)=>{switch(r.op){case"FFT":return[Ca(v("x",r,e,t))];case"IFFT":return[oi(v("x",r,e,t))];case"RFFT":return[Ia(v("x",r,e,t))];case"IRFFT":return[yu(v("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var kB=(r,e,t)=>{switch(r.op){case"Cast":return[oe(v("x",r,e,t),v("dtype",r,e,t))];case"ExpandDims":{let n=v("axis",r,e,t);return[ur(v("x",r,e,t),n)]}case"Squeeze":{let n=v("axis",r,e,t);return[Sn(v("x",r,e,t),n)]}case"Reshape":return[L(v("x",r,e,t),v("shape",r,e,t))];case"MirrorPad":return[af(v("x",r,e,t),v("padding",r,e,t),v("mode",r,e,t))];case"PadV2":case"Pad":return[Lr(v("x",r,e,t),v("padding",r,e,t),v("constantValue",r,e,t))];case"SpaceToBatchND":{let n=v("blockShape",r,e,t),o=v("paddings",r,e,t);return[_a(v("x",r,e,t),n,o)]}case"BatchToSpaceND":{let n=v("blockShape",r,e,t),o=v("crops",r,e,t);return[da(v("x",r,e,t),n,o)]}case"DepthToSpace":{let n=v("blockSize",r,e,t),o=v("dataFormat",r,e,t).toUpperCase();return[Ym(v("x",r,e,t),n,o)]}case"BroadcastTo":return[ha(v("x",r,e,t),v("shape",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function cI(r,e,t,n){let o=((s,a,i)=>{switch(s.category){case"arithmetic":return V(()=>Q3(s,a,i));case"basic_math":return V(()=>eB(s,a,i));case"control":return iB(s,a,i);case"convolution":return V(()=>lB(s,a,i));case"creation":return V(()=>uB(s,a,i));case"dynamic":return cB(s,a,i);case"evaluation":return V(()=>pB(s,a,i));case"image":return V(()=>dB(s,a,i));case"graph":return V(()=>mB(s,a,i));case"logical":return V(()=>hB(s,a,i));case"matrices":return V(()=>gB(s,a,i));case"normalization":return V(()=>xB(s,a,i));case"reduction":return V(()=>yB(s,a,i));case"slice_join":return V(()=>bB(s,a,i));case"sparse":return V(()=>wB(s,a,i));case"spectral":return V(()=>_B(s,a,i));case"transformation":return V(()=>kB(s,a,i));case"hash_table":return fB(s,a,i,n);case"custom":let l=sy(s.op);if(l&&l.customExecutor)return l.customExecutor(new iI(s,a,i));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return y.isPromise(o)?o.then(s=>[].concat(s)):[].concat(o)}var by=class{constructor(e={},t={},n={},o={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function mI(r,e,t,n){let o=new Set,s=[],a=null,i=null,l=new Set,u=Object.keys(r).map(m=>un(m)[0]),c=[];n!=null&&(c=n.map(m=>un(m.name)[0]));let p=[...e];for(;p.length>0;){let m=p.pop();if((pI(m)||cne(m)||pne(m))&&a==null&&(a=m,i=a.children.map(f=>f.name).filter(f=>o.has(f))),o.add(m.name),t[m.name]==null&&u.indexOf(m.name)===-1&&c.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),p.push(f))})}}return{inputs:r,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:a,syncInputs:i}}function vB(r,e,t){let{usedNodes:n,inputs:o}=t,s=[],a=Object.keys(o).map(c=>un(c)[0]).map(c=>r.nodes[c]),i=r.initNodes;a.forEach(c=>{n.has(c.name)&&s.push(c)}),r.weights.forEach(c=>{n.has(c.name)&&s.push(c)}),i!=null&&i.forEach(c=>{n.has(c.name)&&s.push(c)});let l=new Set,u=[];for(;s.length>0;){let c=s.pop();l.add(c.name),e[c.name]||u.push(c),c.children.forEach(p=>{!l.has(p.name)&&n.has(p.name)&&p.inputs.every(m=>l.has(m.name))&&s.push(p)})}return u}var mne=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],fne=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],dne=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function pI(r){return mne.indexOf(r.op)>=0}function cne(r){return fne.indexOf(r.op)>=0}function pne(r){return dne.indexOf(r.op)>=0}var sm=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new sm(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(e,t){let n=mI(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(o.length>0){let i=t.map(u=>u.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${l}]. Missing the following inputs: [${o}]`)}return vB(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let o=n.map(p=>this.graph.nodes[un(p)[0]]),s=t.map(p=>un(p)[0]),a=s.map(p=>this.graph.nodes[p]);a.length===0&&(a=this._outputs);let i=this.getCompilationKey(o,a),l=this.compiledMap.get(i);l==null&&(l=this.compile(e,a),this.compiledMap.set(i,l));let u={},c={};return V(()=>{let p=new by(this.weightMap,u,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(e).forEach(h=>{let[g,x]=un(h),b=[];b[x]=e[h],m[g]=b});let f=this.getFrozenTensorIds(m),d={};for(let h=0;h<l.length;h++){let g=l[h];if(!m[g.name]){let x=cI(g,m,p,this._resourceManager);if(y.isPromise(x))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=x,this.checkTensorForDisposal(g.name,g,m,p,f,s,d)}}return this.parent==null&&p.dispose(f),t.map(h=>hr(h,m,p))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(e,t,n,o,s,a,i){t.category==="control"||a.indexOf(e)!==-1||(n[e].forEach(l=>{l!=null&&(i[l.id]=(i[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){let u=X3(l.name,n,o);u!=null&&u.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){let p=i[c.id];p===1?(c.dispose(),delete i[c.id]):p!=null&&i[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,n=!1,o={},s={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));let a=new by(this.weightMap,o,s,this.functionExecutorMap),i=await this.executeWithControlFlow(e,a,t,n),l=t.map(m=>hr(m,i,a)),u=l.map(m=>m.id),c=Object.keys(e).map(m=>e[m].id),p=new Set([...u,...c,...this.weightIds]);return Object.keys(i).forEach(m=>{i[m].forEach(d=>{d&&!d.kept&&!d.isDisposed&&!p.has(d.id)&&d.dispose()})}),this.parent==null&&a.dispose(p),l}async executeFunctionAsync(e,t,n){let o=e.reduce((s,a,i)=>(s[this.inputs[i].name]=a,s),{});return this._executeAsync(o,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,o){let s=Object.keys(e),a=s.map(w=>this.graph.nodes[un(w)[0]]),i=n.map(w=>un(w)[0]),l=i.map(w=>this.graph.nodes[w]);l.length===0&&(l=this._outputs);let{usedNodes:u,missingInputs:c,dynamicNode:p,syncInputs:m}=mI(e,l,this.weightMap,this._initNodes),f=[...a,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:t.currentContext})),d=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{let[_,I]=un(w),E=[];E[I]=e[w],d[_]=E});let h={},g=this.getFrozenTensorIds(d),x={};for(;f.length>0;){let w=this.processStack(a,f,t,d,x,g,i,h,u);await Promise.all(w)}p==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter(w=>!pI(w)&&!hr(w.name,d,t)).map(w=>w.name);if(b.length>0){let w="";throw p!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${w}`)}return d}processStack(e,t,n,o,s,a,i,l,u){let c=[];for(;t.length>0;){let p=t.pop();n.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&v("isConstant",p.node,o,n)&&([m]=Rs(p.node.name,n)),o[p.node.name]==null){let f=cI(p.node,o,n,this._resourceManager);m||([m]=Rs(p.node.name,n));let d=n.currentContext;y.isPromise(f)?c.push(f.then(h=>(o[m]=h,n.currentContext=d,this.checkTensorForDisposal(m,p.node,o,n,a,i,l),this.processChildNodes(p.node,t,n,o,s,u),h))):(o[m]=f,this.checkTensorForDisposal(m,p.node,o,n,a,i,l),this.processChildNodes(p.node,t,n,o,s,u))}else this.processChildNodes(p.node,t,n,o,s,u)}return c}processChildNodes(e,t,n,o,s,a){e.children.forEach(i=>{let[l]=Rs(i.name,n);s[l]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(u=>!!hr(u,o,n))&&(s[l]=!0,t.push({contexts:n.currentContext,node:i})):i.inputNames.every(u=>!!hr(u,o,n))&&(s[l]=!0,t.push({contexts:n.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[o]=un(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,i=a.length===n.shape.length&&n.shape.every((l,u)=>a[u]===-1||a[u]===l);y.assert(i,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&y.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];t[o.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){let t=Object.keys(e).filter(n=>{let[o]=un(n);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{let[n]=un(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}};var fI=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}};var hne="?tfjs-format=file",gne="model.json",dI=class{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new fI}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Ar.browserHTTPRequest(e,this.loadOptions);else{let t=Ar.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(Ar.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let o=Ar.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new sm(ay.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=ay.Instance.transformGraph(e.modelInitializer);this.initializer=new sm(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){let n=Ar.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Pe)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,o)=>(t[n]=e[o],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function xne(r,e={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&r.load==null&&(r.endsWith("/")||(r=r+"/"),r=`${r}${gne}${hne}`);let t=new dI(r,e);return await t.load(),t}var yne="3.5.0";var AI={};We(AI,{CSVDataset:()=>_h,Dataset:()=>hi,FileDataSource:()=>Nh,TextLineDataset:()=>bh,URLDataSource:()=>Sh,array:()=>iV,csv:()=>gV,func:()=>xV,generator:()=>yV,microphone:()=>wV,version_data:()=>_V,webcam:()=>bV,zip:()=>aV});var sV=pc(_I());var jB=pc(_I());function zB(r,e){return _y(r,e)}function _y(r,e,t=new Map,n=new Set){if(r==null)return null;if(n.has(r))throw new Error("Circular references are not supported.");if(t.has(r))return t.get(r);let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(Pl(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let i=r[a],l=_y(i,e,t,n);s[a]=l}return n.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return t.set(r,o.value),o.value}function VB(r,e=kI){return BB(r,e)}function BB(r,e,t=new Set){let n=r[0];if(t.has(n))throw new Error("Circular references are not supported.");let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(Pl(n)){let s=Array.isArray(n)?[]:{};t.add(n);for(let a in n){let i=r.map(u=>u[a]),l=BB(i,e,t);s[a]=l}return t.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function kI(r){return r===null?null:Pl(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function ky(r,e){let t=new Map;_y(r,e,t);for(let o of Array.from(t.keys())){let s=t.get(o);if(y.isPromise(s)){let a=await s;t.set(o,a)}}return _y(r,e,t)}function Pl(r){return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof Pe))}function GB(r){return r==null||Ine(r)||Array.isArray(r)||typeof r=="object"&&r instanceof Pe||y.isTypedArray(r)}function Ine(r){return r===null||typeof r!="object"&&typeof r!="function"}function WB(r){return zB(r,Nne)}function Nne(r){return r instanceof Pe?{value:r.clone(),recurse:!1}:Pl(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var xh=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}};var im=class extends xh{constructor(){super(im.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let o=0;o<n;o++)t[o]=this.get(this.wrap(this.begin+o));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};im.INITIAL_CAPACITY=32;function vI(r){return new UB(r)}function yh(r){return new HB(r)}function qB(r,e){return new CI(r,e)}function XB(r,e=Ba.FAIL){return new KB(r,e)}var Xt=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new rV(this,e)}filter(e){return new eV(this,e)}map(e){return new tV(this,e)}mapAsync(e){return new II(this,e)}serialMapAsync(e){return new II(this,e).serial()}flatmap(e){return new nV(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new QB(this,e,t)}columnMajorBatch(e,t=!0,n=kI){return this.rowMajorBatch(e,t).map(s=>VB(s,n))}concatenate(e,t){return new CI(vI([this,e]),t)}take(e){return e<0||e==null?this:new JB(this,e)}skip(e){return e<0||e==null?this:new ZB(this,e)}prefetch(e){return new NI(this,e)}shuffle(e,t){return new oV(this,e,t)}serial(){return new YB(this)}},UB=class extends Xt{constructor(e){super();this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:WB(e),done:!1}}},HB=class extends Xt{constructor(e){super();this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},YB=class extends Xt{constructor(e){super();this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},ZB=class extends Xt{constructor(e,t){super();this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Ee(e.value)}return this.upstream.next()}},JB=class extends Xt{constructor(e,t){super();this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},QB=class extends Xt{constructor(e,t,n=!0){super();this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},eV=class extends Xt{constructor(e,t){super();this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ee(e.value)}}},tV=class extends Xt{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Zn.getTensorsInContainer(e.value),n=this.transform(e.value),o=Zn.getTensorsInContainer(n);for(let s of t)Zn.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},rV=class extends Xt{constructor(e,t){super();this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},II=class extends Xt{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Zn.getTensorsInContainer(e.value),n=await this.transform(e.value),o=Zn.getTensorsInContainer(n);for(let s of t)Zn.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},am=class extends Xt{constructor(){super();this.outputQueue=new im,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},nV=class extends am{constructor(e,t){super();this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Zn.getTensorsInContainer(e.value),n=this.transform(e.value),o=Zn.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)Zn.isTensorInList(s,o)||s.dispose();return!0}},CI=class extends Xt{constructor(e,t){super();this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},Ba;(function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"})(Ba||(Ba={}));var KB=class extends Xt{constructor(e,t=Ba.FAIL){super();this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function o(a){return a instanceof Xt?{value:a.next().then(l=>(t++,l.done&&n++,l.value)),recurse:!1}:{value:null,recurse:!0}}let s=await ky(this.iterators,o);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Ba.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Ba.SHORTEST:return{value:null,done:!0};case Ba.LONGEST:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},NI=class extends Xt{constructor(e,t){super();this.upstream=e,this.bufferSize=t,this.buffer=new xh(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},oV=class extends NI{constructor(e,t,n){super(e,t);this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=jB.alea(n||y.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}};var hi=class{constructor(){this.size=null}batch(e,t=!0){let n=this;y.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let o;return this.size===Infinity||this.size==null?o=this.size:t?o=Math.ceil(this.size/e):o=Math.floor(this.size/e),_n(async()=>(await n.iterator()).columnMajorBatch(e,t,Sne),o)}concatenate(e){let t=this,n;return this.size===Infinity||e.size===Infinity?n=Infinity:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,_n(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===Infinity?n=Infinity:n=null,_n(async()=>(await t.iterator()).filter(o=>V(()=>e(o))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return _n(async()=>(await t.iterator()).map(n=>V(()=>e(n))),this.size)}mapAsync(e){let t=this;return _n(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return _n(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=Infinity:n=null,_n(async()=>{let o=yh(async()=>({value:await t.iterator(),done:!1}));return qB(o.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,_n(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=sV.alea(t||y.now().toString());return _n(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await o.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,_n(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};hi.MAX_BUFFER_SIZE=1e4;function _n(r,e=null){return new class extends hi{constructor(){super(...arguments);this.size=e}async iterator(){return r()}}}function iV(r){return _n(async()=>vI(r),r.length)}function aV(r){if(!Pl(r))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(r))for(let t=0;t<r.length;t++)e=e==null?r[t].size:Math.min(e,r[t].size);else if(r instanceof Object)for(let t in r)e=e==null?r[t].size:Math.min(e,r[t].size);return _n(async()=>{let t=await ky(r,n=>{if(n instanceof hi)return{value:n.iterator(),recurse:!1};if(Pl(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return XB(t,Ba.SHORTEST)},e)}function Sne(r){if(r===null)return null;let e=r[0];return GB(e)?{value:Tne(r),recurse:!1}:{value:null,recurse:!0}}function Tne(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof Pe?Bt(r):Mr(r)}var bh=class extends hi{constructor(e){super();this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(o=>(o.endsWith("\r")&&(o=o.slice(0,-1)),o))}};var vy='"',wh=Symbol("out"),lV=Symbol("field"),Cy=Symbol("quote"),SI=Symbol("quoteafterquote"),uV=Symbol("quoteinquote"),_h=class extends hi{constructor(e,t){super();this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new bh(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(y.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&y.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((o,s)=>(o[s]=o[s]+1||1,o),{}),n=Object.keys(t).filter(o=>t[o]>1);if(y.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let o of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(o)===-1)throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");let n=t.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},o={};for(let s=0;s<this.fullColumnNames.length;s++){let a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){let l=t[s],u=null;if(l==="")if(i&&i.default!==void 0)u=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{let c=Number(l);if(isNaN(c))i&&i.dtype==="bool"?u=this.getBoolean(l):u=l;else if(!i||!i.dtype)u=c;else switch(i.dtype){case"float32":u=c;break;case"int32":u=Math.floor(c);break;case"bool":u=this.getBoolean(l);break;default:u=c}}i&&i.isLabel?o[a]=u:n[a]=u}}return Object.keys(o).length===0?n:{xs:n,ys:o}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],o=0,s=e.length,a=wh;for(let i=0;i<s;i++)switch(a){case wh:switch(e.charAt(i)){case vy:o=i+1,a=Cy;break;case this.delimiter:if(o=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=wh;break;default:a=lV,o=i;break}break;case lV:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(o,i)),a=wh,o=i+1;break;default:}break;case Cy:switch(e.charAt(i)){case vy:a=SI;break;default:}break;case SI:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(o,i-1)),a=wh,o=i+1;break;case vy:a=Cy;break;default:a=uV;break}break;case uV:switch(e.charAt(i)){case vy:a=Cy;break;default:}break;default:}if(a===SI?n.push(e.substring(o,s-1)):n.push(e.substring(o)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}};var kh=class extends Xt{constructor(e){super();this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(W().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");let t=new kh(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let o=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(o,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let o=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(o,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(o=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-Infinity&&o({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),o({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((o,s)=>n.set(o,s*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(y.sizeFromShape(t));return n.set(e,n.length-e.length),Mr(n,t)}};var vh=class extends Xt{constructor(e,t){super();if(this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Vt([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,o=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,a=(1-o)/2,i=s+n,l=o+a;this.cropBox=si([a,s,l,i],[1,4])}else this.cropBox=si([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(W().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new vh(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&y.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=ag.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return V(()=>{let t=ur(oe(e,"float32"),0),n;n=ii.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let o=n.shape;return L(n,o.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var Ch=class{};var Iy=class extends Xt{split(e){return new cV(this,e)}},cV=class extends Iy{constructor(e,t){super();this.upstream=e,this.impl=new pV(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},pV=class extends am{constructor(e,t){super();this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}};var TI=class extends Xt{decodeUTF8(){return new fV(this)}},fV=class extends Iy{constructor(e){super();this.upstream=e,this.impl=new dV(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},dV=class extends am{constructor(e){super();if(this.upstream=e,W().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=mV();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return W().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}};var Ih=class extends TI{constructor(e,t={}){super();this.file=e,this.options=t,y.assert(e instanceof Uint8Array||(W().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,n)=>{let o=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,o)));else{let s=new FileReader;s.onload=i=>{let l=s.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));t(l)},s.onabort=i=>n(new Error("Aborted")),s.onerror=i=>n(new Error(i.type));let a=this.file.slice(this.offset,o);s.readAsArrayBuffer(a)}this.offset=o}),done:!1}}};async function hV(r,e={}){let t,n;typeof r=="string"?t=r:(t=r.url,n=Ane(r));let o=await y.fetch(t,n);if(o.ok){let s=new Uint8Array(await o.arrayBuffer());return new Ih(s,e)}else throw new Error(o.statusText)}var Ane=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function Ny(r){return typeof r=="string"&&r.substr(0,7)==="file://"}var Nh=class extends Ch{constructor(e,t={}){super();this.input=e,this.options=t}async iterator(){if(Ny(this.input)&&W().get("IS_NODE")){let e=require("fs");this.input=e.readFileSync(this.input.substr(7))}return new Ih(this.input,this.options)}};var Sh=class extends Ch{constructor(e,t={}){super();this.url=e,this.fileOptions=t}async iterator(){return Ny(this.url)?new Nh(this.url,this.fileOptions).iterator():hV(this.url,this.fileOptions)}};function gV(r,e={}){return new _h(new Sh(r),e)}function xV(r){let e=yh(r);return _n(async()=>e)}function yV(r){return _n(async()=>{let e=await r();return yh(()=>e.next())})}async function bV(r,e){return vh.create(r,e)}async function wV(r){return kh.create(r)}var _V="3.5.0";var Ljt={tfjs:(bm==null?void 0:bm.version)||void 0,"tfjs-core":(wm==null?void 0:wm.version)||void 0,"tfjs-data":(_m==null?void 0:_m.version)||void 0,"tfjs-layers":(km==null?void 0:km.version)||void 0,"tfjs-converter":(vm==null?void 0:vm.version)||void 0,"tfjs-backend-cpu":U_||void 0,"tfjs-backend-webgl":rv||void 0,"tfjs-backend-wasm":MC||void 0};export{zs as Abs,_i as Acos,ki as Acosh,cp as AdadeltaOptimizer,pp as AdagradOptimizer,mp as AdamOptimizer,fp as AdamaxOptimizer,On as Add,_o as AddN,vi as All,Ci as Any,ko as ArgMax,Ka as ArgMin,Ii as Asin,Ni as Asinh,Si as Atan,Ai as Atan2,Ti as Atanh,vo as AvgPool,Xa as AvgPool3D,xc as AvgPool3DGrad,gc as AvgPoolGrad,Sx as BackendWasm,Co as BatchMatMul,Ya as BatchToSpaceND,yc as Bincount,vS as BroadcastTo,z0 as Callback,ZC as CallbackList,qn as Cast,Io as Ceil,Kn as ClipByValue,bc as Complex,Za as ComplexAbs,Bs as Concat,No as Conv2D,wc as Conv2DBackpropFilter,So as Conv2DBackpropInput,Ja as Conv3D,_c as Conv3DBackpropFilterV2,kc as Conv3DBackpropInputV2,To as Cos,Ei as Cosh,Di as CropAndResize,Ao as Cumsum,QC as CustomCallback,qa as DataStorage,vc as DenseBincount,$i as DepthToSpace,Eo as DepthwiseConv2dNative,Cc as DepthwiseConv2dNativeBackpropFilter,Ic as DepthwiseConv2dNativeBackpropInput,Nc as Diag,Qa as Dilation2D,Am as Dilation2DBackpropFilter,Tm as Dilation2DBackpropInput,tw as ENV,B0 as EarlyStopping,Sc as Einsum,Ri as Elu,Tc as EluGrad,Zh as Environment,Oi as Equal,Fi as Erf,$o as Exp,Vs as ExpandDims,Pi as Expm1,Ac as FFT,el as Fill,Mi as FlipLeftRight,Ro as Floor,Fo as FloorDiv,Em as FromPixels,Oo as FusedBatchNorm,Qs as FusedConv2D,ei as FusedDepthwiseConv2D,ax as GPGPUContext,Li as GatherNd,Gs as GatherV2,dI as GraphModel,zi as Greater,Po as GreaterEqual,JC as History,Ec as IFFT,Xn as Identity,Dc as Imag,Ct as InputSpec,Bi as IsFinite,Vi as IsInf,Gi as IsNan,Ps as KernelBackend,tl as LRN,Rc as LRNGrad,Vx as LayerVariable,jn as LayersModel,Mo as LeakyRelu,Wi as Less,ji as LessEqual,$c as LinSpace,Lo as Log,Ui as Log1p,CS as LogSoftmax,Hi as LogicalAnd,jl as LogicalNot,Ul as LogicalOr,Nu as MathBackendCPU,Ou as MathBackendWebGL,zo as Max,Vo as MaxPool,rl as MaxPool3D,Oc as MaxPool3DGrad,Fc as MaxPoolGrad,Pc as MaxPoolWithArgmax,Bo as Maximum,Go as Mean,Wo as Min,jo as Minimum,Uo as MirrorPad,qi as Mod,dp as MomentumOptimizer,Mc as Multinomial,Ho as Multiply,Ws as Neg,Xi as NonMaxSuppressionV3,Yi as NonMaxSuppressionV4,Zi as NonMaxSuppressionV5,Ki as NotEqual,LS as OP_SCOPE_SUFFIX,qo as OneHot,js as OnesLike,Br as Optimizer,Us as Pack,Ko as PadV2,Mne as Pool,Xo as Pow,Yo as Prelu,Ji as Prod,hp as RMSPropOptimizer,Dn as RNN,nl as Range,lw as Rank,Lc as Real,Do as RealDiv,Qi as Reciprocal,Gt as Reduction,Zo as Relu,Qo as Relu6,Hs as Reshape,Jo as ResizeBilinear,Bc as ResizeBilinearGrad,ol as ResizeNearestNeighbor,zc as ResizeNearestNeighborGrad,es as Reverse,aa as RotateWithOffset,ts as Round,rs as Rsqrt,hl as SGDOptimizer,ea as ScatterNd,qs as Select,ta as Selu,La as Sequential,os as Sigmoid,na as Sign,ns as Sin,ra as Sinh,Ks as Slice,as as Softmax,oa as Softplus,sl as SpaceToBatchND,Vc as SparseReshape,Gc as SparseToDense,Xs as SplitV,ss as Sqrt,il as Square,ls as SquaredDifference,Yn as Step,sa as StridedSlice,us as Sub,is as Sum,sn as SymbolicTensor,cs as Tan,ps as Tanh,Pe as Tensor,ut as TensorBuffer,Pn as Tile,ia as TopK,Wc as Transform,ms as Transpose,jc as Unique,Ys as Unpack,al as UnsortedSegmentSum,ul as Variable,Zs as ZerosLike,Js as _FusedMatMul,Nt as abs,zm as acos,Bm as acosh,ee as add,Mw as addN,Ql as all,ml as any,fl as argMax,Vm as argMin,Gm as asin,Wm as asinh,jm as atan,Um as atan2,Hm as atanh,fa as avgPool,qm as avgPool3d,RT as backend,C as backend_util,Ej as basicLSTMCell,Jn as batchNorm,Vw as batchNorm2d,Gw as batchNorm3d,Ww as batchNorm4d,da as batchToSpaceND,jw as bincount,aIe as booleanMaskAsync,ha as broadcastTo,ag as browser,Ce as buffer,Wre as callbacks,oe as cast,Km as ceil,lr as clipByValue,Mn as clone,In as complex,Qe as concat,Uw as concat1d,Hw as concat2d,qw as concat3d,Kw as concat4d,Vz as constraints,ru as conv1d,Jr as conv2d,nu as conv2dTranspose,Xm as conv3d,Xw as conv3dTranspose,Wne as copyRegisteredKernels,ga as cos,ou as cosh,vg as cosineWindow,su as cumsum,Qr as customGrad,AI as data,Yw as denseBincount,Pw as deprecationWarn,Ym as depthToSpace,xs as depthwiseConv2d,Ure as deregisterOp,Yl as device_util,o4 as diag,Zm as dilation2d,wae as disableDeprecationWarnings,Ee as dispose,_ae as disposeVariables,me as div,Jm as divNoNan,Zw as dot,n1 as dropout,Jw as einsum,ys as elu,bae as enableDebugMode,yae as enableProdMode,o1 as enclosingPowerOfTwo,hs as engine,W as env,Nn as equal,Qm as erf,Jt as exp,ur as expandDims,ef as expm1,rp as eye,Ca as fft,xa as fill,Sae as findBackend,Tae as findBackendFactory,bs as floor,Jl as floorDiv,BD as forceHalfFloat,no as fused,Qn as gather,t1 as gatherND,lg as gather_util,Iae as getBackend,sw as getGradient,$m as getKernel,Jh as getKernelsForBackend,j2 as gpgpu_util,F4 as grad,O4 as grads,nr as greater,hn as greaterEqual,oi as ifft,iu as imag,ii as image,xNe as inTopKAsync,l3 as initializers,l0 as input,Ar as io,yu as irfft,Qw as isFinite,e_ as isInf,tf as isNaN,Et as keep,Rr as kernel_impls,z3 as layers,ya as leakyRelu,au as less,Bn as lessEqual,O1 as linalg,t_ as linspace,xne as loadGraphModel,tte as loadLayersModel,rf as localResponseNormalization,cr as log,lu as log1p,r_ as logSigmoid,uu as logSoftmax,of as logSumExp,yr as logicalAnd,ba as logicalNot,cu as logicalOr,i_ as logicalXor,VFe as losses,ze as matMul,gT as math,pr as max,wa as maxPool,sf as maxPool3d,a_ as maxPoolWithArgmax,en as maximum,dt as mean,Lm as memory,nU as meshgrid,j3 as metrics,ni as min,ws as minimum,af as mirrorPad,lf as mod,Qee as model,U3 as models,np as moments,RIe as movingAverage,P as mul,pU as multiRNNCell,l_ as multinomial,qe as neg,wf as nextFrame,lp as norm,ro as notEqual,ds as oneHot,Qt as ones,or as onesLike,S as op,gU as outerProduct,Lr as pad,bU as pad1d,_U as pad2d,vU as pad3d,IU as pad4d,u_ as pool,zr as pow,ka as prelu,Nw as print,pu as prod,kae as profile,FU as rand,GU as randomGamma,bg as randomNormal,_s as randomUniform,sp as range,Cae as ready,dl as real,uf as reciprocal,Qc as registerBackend,rte as registerCallbackConstructor,IS as registerGradient,Hl as registerKernel,jre as registerOp,H3 as regularizers,Dr as relu,fu as relu6,Nae as removeBackend,L as reshape,qt as reverse,ZU as reverse1d,QU as reverse2d,tH as reverse3d,nH as reverse4d,Ia as rfft,cf as round,du as rsqrt,le as scalar,QT as scatterND,ug as scatter_util,hu as selu,pf as separableConv2d,ete as sequential,J as serialization,JW as setBackend,Aae as setPlatform,NQ as setWasmPath,SQ as setWasmPaths,ak as setWebGLContext,w_ as setdiff1dAsync,Wg as shared,Er as sigmoid,mf as sign,BFe as signal,gu as sin,xu as sinh,Fe as slice,ff as slice1d,wg as slice2d,df as slice3d,ip as slice4d,rr as slice_util,va as softmax,eo as softplus,_a as spaceToBatchND,P1 as sparse,kg as sparseToDense,zFe as spectral,mr as split,gt as sqrt,Me as square,bu as squaredDifference,Sn as squeeze,Bt as stack,ks as step,hf as stridedSlice,pe as sub,ge as sum,Kl as sumOutType,gf as tan,gs as tanh,Mr as tensor,Vt as tensor1d,si as tensor2d,Ew as tensor3d,AH as tensor4d,EH as tensor5d,DH as tensor6d,Zn as tensor_util,ET as test_util,V as tidy,zn as tile,vae as time,xf as topk,Iu as train,Ue as transpose,wu as truncatedNormal,ap as unique,Gne as unregisterGradient,Vne as unregisterKernel,yf as unsortedSegmentSum,fr as unstack,ar as upcastType,y as util,P4 as valueAndGrad,M4 as valueAndGrads,__ as variable,gg as variableGrads,Ljt as version,yne as version_converter,ZW as version_core,U_ as version_cpu,hd as version_layers,MC as version_wasm,rv as version_webgl,r7e as webgl,z2 as webgl_util,Dt as where,bf as whereAsync,ht as zeros,Ie as zerosLike};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** @license See the LICENSE file. */
//# sourceMappingURL=tfjs.esm.js.map
