{
  "version": 3,
  "sources": ["index.ts", "indexdb.ts"],
  "sourcesContent": ["/**\n * Human demo for browsers\n * @default Human Library\n * @summary <https://github.com/vladmandic/human>\n * @author <https://github.com/vladmandic>\n * @copyright <https://github.com/vladmandic>\n * @license MIT\n */\n\nimport { Human, TensorLike, FaceResult } from '../../dist/human.esm.js'; // equivalent of @vladmandic/Human\nimport * as indexDb from './indexdb'; // methods to deal with indexdb\n\nlet db: Array<indexDb.FaceRecord> = []; // face descriptor database stored in indexdb\nlet face: FaceResult; // face result from human.detect\nlet current: indexDb.FaceRecord; // currently matched db record\n\nconst humanConfig = { // user configuration for human, used to fine-tune behavior\n  modelBasePath: '../../models',\n  filter: { equalization: true }, // lets run with histogram equilizer\n  face: {\n    enabled: true,\n    detector: { rotation: true, return: true }, // return tensor is used to get detected face image\n    description: { enabled: true },\n    iris: { enabled: true }, // needed to determine gaze direction\n    emotion: { enabled: false }, // not needed\n    antispoof: { enabled: true }, // enable optional antispoof module\n    liveness: { enabled: true }, // enable optional liveness module\n  },\n  body: { enabled: false },\n  hand: { enabled: false },\n  object: { enabled: false },\n  gesture: { enabled: true }, // parses face and iris gestures\n};\n\nconst options = {\n  minConfidence: 0.6, // overal face confidence for box, face, gender, real, live\n  minSize: 224, // min input to face descriptor model before degradation\n  maxTime: 10000, // max time before giving up\n  blinkMin: 10, // minimum duration of a valid blink\n  blinkMax: 800, // maximum duration of a valid blink\n  threshold: 0.5, // minimum similarity\n};\n\nconst ok = { // must meet all rules\n  faceCount: false,\n  faceConfidence: false,\n  facingCenter: false,\n  blinkDetected: false,\n  faceSize: false,\n  antispoofCheck: false,\n  livenessCheck: false,\n  elapsedMs: 0, // total time while waiting for valid face\n};\nconst allOk = () => ok.faceCount && ok.faceSize && ok.blinkDetected && ok.facingCenter && ok.faceConfidence && ok.antispoofCheck && ok.livenessCheck;\n\nconst blink = { // internal timers for blink start/end/duration\n  start: 0,\n  end: 0,\n  time: 0,\n};\n\n// let db: Array<{ name: string, source: string, embedding: number[] }> = []; // holds loaded face descriptor database\nconst human = new Human(humanConfig); // create instance of human with overrides from user configuration\n\nhuman.env['perfadd'] = false; // is performance data showing instant or total values\nhuman.draw.options.font = 'small-caps 18px \"Lato\"'; // set font used to draw labels when using draw methods\nhuman.draw.options.lineHeight = 20;\n\nconst dom = { // grab instances of dom objects so we dont have to look them up later\n  video: document.getElementById('video') as HTMLVideoElement,\n  canvas: document.getElementById('canvas') as HTMLCanvasElement,\n  log: document.getElementById('log') as HTMLPreElement,\n  fps: document.getElementById('fps') as HTMLPreElement,\n  status: document.getElementById('status') as HTMLPreElement,\n  match: document.getElementById('match') as HTMLDivElement,\n  name: document.getElementById('name') as HTMLInputElement,\n  save: document.getElementById('save') as HTMLSpanElement,\n  delete: document.getElementById('delete') as HTMLSpanElement,\n  retry: document.getElementById('retry') as HTMLDivElement,\n  source: document.getElementById('source') as HTMLCanvasElement,\n};\nconst timestamp = { detect: 0, draw: 0 }; // holds information used to calculate performance and possible memory leaks\nconst fps = { detect: 0, draw: 0 }; // holds calculated fps information for both detect and screen refresh\nlet startTime = 0;\n\nconst log = (...msg) => { // helper method to output messages\n  dom.log.innerText += msg.join(' ') + '\\n';\n  // eslint-disable-next-line no-console\n  console.log(...msg);\n};\nconst printFPS = (msg) => dom.fps.innerText = msg; // print status element\nconst printStatus = (msg) => dom.status.innerText = 'status: ' + JSON.stringify(msg).replace(/\"|{|}/g, '').replace(/,/g, ' | '); // print status element\n\nasync function webCam() { // initialize webcam\n  printFPS('starting webcam...');\n  // @ts-ignore resizeMode is not yet defined in tslib\n  const cameraOptions: MediaStreamConstraints = { audio: false, video: { facingMode: 'user', resizeMode: 'none', width: { ideal: document.body.clientWidth } } };\n  const stream: MediaStream = await navigator.mediaDevices.getUserMedia(cameraOptions);\n  const ready = new Promise((resolve) => { dom.video.onloadeddata = () => resolve(true); });\n  dom.video.srcObject = stream;\n  dom.video.play();\n  await ready;\n  dom.canvas.width = dom.video.videoWidth;\n  dom.canvas.height = dom.video.videoHeight;\n  if (human.env.initial) log('video:', dom.video.videoWidth, dom.video.videoHeight, '|', stream.getVideoTracks()[0].label);\n  dom.canvas.onclick = () => { // pause when clicked on screen and resume on next click\n    if (dom.video.paused) dom.video.play();\n    else dom.video.pause();\n  };\n}\n\nasync function detectionLoop() { // main detection loop\n  if (!dom.video.paused) {\n    if (face && face.tensor) human.tf.dispose(face.tensor); // dispose previous tensor\n    await human.detect(dom.video); // actual detection; were not capturing output in a local variable as it can also be reached via human.result\n    const now = human.now();\n    fps.detect = 1000 / (now - timestamp.detect);\n    timestamp.detect = now;\n    requestAnimationFrame(detectionLoop); // start new frame immediately\n  }\n}\n\nasync function validationLoop(): Promise<FaceResult> { // main screen refresh loop\n  const interpolated = await human.next(human.result); // smoothen result using last-known results\n  await human.draw.canvas(dom.video, dom.canvas); // draw canvas to screen\n  await human.draw.all(dom.canvas, interpolated); // draw labels, boxes, lines, etc.\n  const now = human.now();\n  fps.draw = 1000 / (now - timestamp.draw);\n  timestamp.draw = now;\n  printFPS(`fps: ${fps.detect.toFixed(1).padStart(5, ' ')} detect | ${fps.draw.toFixed(1).padStart(5, ' ')} draw`); // write status\n  ok.faceCount = human.result.face.length === 1; // must be exactly detected face\n  if (ok.faceCount) { // skip the rest if no face\n    const gestures: string[] = Object.values(human.result.gesture).map((gesture) => gesture.gesture); // flatten all gestures\n    if (gestures.includes('blink left eye') || gestures.includes('blink right eye')) blink.start = human.now(); // blink starts when eyes get closed\n    if (blink.start > 0 && !gestures.includes('blink left eye') && !gestures.includes('blink right eye')) blink.end = human.now(); // if blink started how long until eyes are back open\n    ok.blinkDetected = ok.blinkDetected || (blink.end - blink.start > options.blinkMin && blink.end - blink.start < options.blinkMax);\n    if (ok.blinkDetected && blink.time === 0) blink.time = Math.trunc(blink.end - blink.start);\n    ok.facingCenter = gestures.includes('facing center') && gestures.includes('looking center'); // must face camera and look at camera\n    ok.faceConfidence = (human.result.face[0].boxScore || 0) > options.minConfidence && (human.result.face[0].faceScore || 0) > options.minConfidence && (human.result.face[0].genderScore || 0) > options.minConfidence;\n    ok.antispoofCheck = (human.result.face[0].real || 0) > options.minConfidence;\n    ok.livenessCheck = (human.result.face[0].live || 0) > options.minConfidence;\n    ok.faceSize = human.result.face[0].box[2] >= options.minSize && human.result.face[0].box[3] >= options.minSize;\n  }\n  printStatus(ok);\n  if (allOk()) { // all criteria met\n    dom.video.pause();\n    return human.result.face[0];\n  }\n  if (ok.elapsedMs > options.maxTime) { // give up\n    dom.video.pause();\n    return human.result.face[0];\n  } else { // run again\n    ok.elapsedMs = Math.trunc(human.now() - startTime);\n    return new Promise((resolve) => {\n      setTimeout(async () => {\n        const res = await validationLoop(); // run validation loop until conditions are met\n        if (res) resolve(human.result.face[0]); // recursive promise resolve\n      }, 30); // use to slow down refresh from max refresh rate to target of 30 fps\n    });\n  }\n}\n\nasync function saveRecords() {\n  if (dom.name.value.length > 0) {\n    const image = dom.canvas.getContext('2d')?.getImageData(0, 0, dom.canvas.width, dom.canvas.height) as ImageData;\n    const rec = { id: 0, name: dom.name.value, descriptor: face.embedding as number[], image };\n    await indexDb.save(rec);\n    log('saved face record:', rec.name);\n    db.push(rec);\n  } else {\n    log('invalid name');\n  }\n}\n\nasync function deleteRecord() {\n  if (current.id > 0) {\n    await indexDb.remove(current);\n  }\n}\n\nasync function detectFace() {\n  dom.canvas.getContext('2d')?.clearRect(0, 0, options.minSize, options.minSize);\n  if (!face || !face.tensor || !face.embedding) return 0;\n  human.tf.browser.toPixels(face.tensor as unknown as TensorLike, dom.canvas);\n  const descriptors = db.map((rec) => rec.descriptor);\n  const res = await human.match(face.embedding, descriptors);\n  if (res.index === -1) {\n    log('no matches');\n    dom.delete.style.display = 'none';\n    dom.source.style.display = 'none';\n  } else {\n    current = db[res.index];\n    log(`best match: ${current.name} | id: ${current.id} | similarity: ${Math.round(1000 * res.similarity) / 10}%`);\n    dom.delete.style.display = '';\n    dom.name.value = current.name;\n    dom.source.style.display = '';\n    dom.source.getContext('2d')?.putImageData(current.image, 0, 0);\n  }\n  return res.similarity > options.threshold;\n}\n\nasync function main() { // main entry point\n  ok.faceCount = false;\n  ok.faceConfidence = false;\n  ok.facingCenter = false;\n  ok.blinkDetected = false;\n  ok.faceSize = false;\n  ok.antispoofCheck = false;\n  ok.livenessCheck = false;\n  ok.elapsedMs = 0;\n  dom.match.style.display = 'none';\n  dom.retry.style.display = 'none';\n  document.body.style.background = 'black';\n  await webCam();\n  await detectionLoop(); // start detection loop\n  startTime = human.now();\n  face = await validationLoop(); // start validation loop\n  dom.fps.style.display = 'none';\n  dom.canvas.width = face?.tensor?.shape[1] || options.minSize;\n  dom.canvas.height = face?.tensor?.shape[0] || options.minSize;\n  dom.source.width = dom.canvas.width;\n  dom.source.height = dom.canvas.height;\n  dom.canvas.style.width = '';\n  dom.match.style.display = 'flex';\n  dom.retry.style.display = 'block';\n  if (!allOk()) {\n    log('did not find valid face');\n    return false;\n  } else {\n    // log('found valid face');\n    const res = await detectFace();\n    document.body.style.background = res ? 'darkgreen' : 'maroon';\n    return res;\n  }\n}\n\nasync function init() {\n  log('human version:', human.version, '| tfjs version:', human.tf.version_core);\n  log('options:', JSON.stringify(options).replace(/{|}|\"|\\[|\\]/g, '').replace(/,/g, ' '));\n  printFPS('loading...');\n  db = await indexDb.load(); // load face database from indexdb\n  log('loaded face records:', db.length);\n  await webCam(); // start webcam\n  await human.load(); // preload all models\n  printFPS('initializing...');\n  dom.retry.addEventListener('click', main);\n  dom.save.addEventListener('click', saveRecords);\n  dom.delete.addEventListener('click', deleteRecord);\n  await human.warmup(); // warmup function to initialize backend for future faster detection\n  await main();\n}\n\nwindow.onload = init;\n", "let db: IDBDatabase; // instance of indexdb\n\nconst database = 'human';\nconst table = 'person';\n\nexport type FaceRecord = { id: number, name: string, descriptor: number[], image: ImageData };\n\n// eslint-disable-next-line no-console\nconst log = (...msg) => console.log('indexdb', ...msg);\n\nexport async function open() {\n  if (db) return true;\n  return new Promise((resolve) => {\n    const request: IDBOpenDBRequest = indexedDB.open(database, 1);\n    request.onerror = (evt) => log('error:', evt);\n    request.onupgradeneeded = (evt: IDBVersionChangeEvent) => { // create if doesnt exist\n      log('create:', evt.target);\n      db = (evt.target as IDBOpenDBRequest).result;\n      db.createObjectStore(table, { keyPath: 'id', autoIncrement: true });\n    };\n    request.onsuccess = (evt) => { // open\n      db = (evt.target as IDBOpenDBRequest).result as IDBDatabase;\n      log('open:', db);\n      resolve(true);\n    };\n  });\n}\n\nexport async function load(): Promise<FaceRecord[]> {\n  const faceDB: Array<FaceRecord> = [];\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const cursor: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).openCursor(null, 'next');\n    cursor.onerror = (evt) => log('load error:', evt);\n    cursor.onsuccess = (evt) => {\n      if ((evt.target as IDBRequest).result) {\n        faceDB.push((evt.target as IDBRequest).result.value);\n        (evt.target as IDBRequest).result.continue();\n      } else {\n        resolve(faceDB);\n      }\n    };\n  });\n}\n\nexport async function save(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  const newRecord = { name: faceRecord.name, descriptor: faceRecord.descriptor, image: faceRecord.image }; // omit id as its autoincrement\n  db.transaction([table], 'readwrite').objectStore(table).put(newRecord);\n  log('save:', newRecord);\n}\n\nexport async function remove(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  db.transaction([table], 'readwrite').objectStore(table).delete(faceRecord.id); // delete based on id\n  log('delete:', faceRecord);\n}\n"],
  "mappings": "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",
  "names": []
}
